# InlineImporter
import os as _os
import sys as _sys
from functools import lru_cache as _lru_cache
from importlib.abc import ExecutionLoader, MetaPathFinder
from importlib.machinery import ModuleSpec


class InlineImporter(ExecutionLoader, MetaPathFinder):

    version = None
    inlined_modules = {}
    namespace_packages = False

    @classmethod
    def find_spec(cls, fullname, path=None, target=None):
        """Find a spec for a given module.
        
        Because we only deal with our inlined module, we don't have to care about path or target.
        The import machinery also takes care of fully resolving all names, so we just have to deal with the fullnames.
        """
        if fullname in cls.inlined_modules:
            # We have inlined this module, so return the spec
            ms = ModuleSpec(fullname,
                            cls,
                            origin=cls.get_filename(fullname),
                            is_package=cls.is_package(fullname))
            ms.has_location = True
            if cls.namespace_packages and ms.submodule_search_locations is not None:
                for p in _sys.path:
                    ms.submodule_search_locations.append(
                        _os.path.join(p, _os.path.dirname(ms.origin)))
            return ms

        return None

    @staticmethod
    def _call_with_frames_removed(f, *args, **kwds):
        """remove_importlib_frames in import.c will always remove sequences
        of importlib frames that end with a call to this function

        Use it instead of a normal call in places where including the importlib
        frames introduces unwanted noise into the traceback (e.g. when executing
        module code)
        """
        return f(*args, **kwds)

    @classmethod
    def create_module(cls, spec):
        """Create a module using the default machinery."""
        return None

    @classmethod
    def exec_module(cls, module):
        """Execute the module."""
        code = cls.get_code(module.__name__)
        if code is None:
            raise ImportError(
                "cannot load module {!r} when get_code() returns None".format(
                    module.__name__))
        cls._call_with_frames_removed(exec, code, module.__dict__)

    @classmethod
    @_lru_cache(maxsize=None)
    def get_filename(cls, fullname):
        """Returns the 

        Raises ImportError if the module cannot be found.
        """
        if fullname not in cls.inlined_modules:
            raise ImportError

        mod = cls.inlined_modules[fullname]
        origin = fullname
        if mod[0]:
            origin = ".".join([origin, "__init__"])
        origin = ".".join([origin.replace(".", "/"), "py"])

        return origin

    @classmethod
    @_lru_cache(maxsize=None)
    def is_package(cls, fullname):
        if fullname not in cls.inlined_modules:
            raise ImportError

        return cls.inlined_modules[fullname][0]

    @classmethod
    def get_source(cls, fullname):
        if fullname not in cls.inlined_modules:
            raise ImportError

        return cls.inlined_modules[fullname][1]

    @classmethod
    def get_code(cls, fullname):
        """Method to return the code object for fullname.

        Should return None if not applicable (e.g. built-in module).
        Raise ImportError if the module cannot be found.
        """
        source = cls.get_source(fullname)
        if source is None:
            return None
        try:
            path = cls.get_filename(fullname)
        except ImportError:
            return cls.source_to_code(source)
        else:
            return cls.source_to_code(source, path)


InlineImporter.version = '0.0.4'
InlineImporter.inlined_modules = {
    'lib.array2d':
    (False,
     "import itertools\n\n\nclass Array2dView:\n    def __init__(self, arr, i_indices, j_indices):\n        self.arr = arr\n        self.i_indices = i_indices\n        self.j_indices = j_indices\n    \n    def _get_view(self, i, j):\n        i = self.i_indices[i]\n        j = self.j_indices[j]\n        return Array2dView(self.arr, i, j)\n\n    def get_ind(self, i, j):\n        return self.i_indices[i]+self.j_indices[j]\n    \n    def __getitem__(self, index):\n        i, j = index\n        try:\n            return self.arr[self.get_ind(i,j)]\n        except TypeError:\n            return self._get_view(i, j)\n    \n    def __setitem__(self, index, value):\n        i, j = index\n        try:\n            self.arr[self.get_ind(i,j)] = value\n        except TypeError:\n            x = self._get_view(i, j)\n            for i in x.i_indices:\n                for j in x.j_indices:\n                    self.arr[i+j] = value\n    \n    def __iter__(self):\n        for i in self.i_indices:\n            for j in self.j_indices:\n                yield self.arr[i+j]\n    \n    def __reversed__(self):\n        for i in reversed(self.i_indices):\n            for j in reversed(self.j_indices):\n                yield self.arr[i+j]\n    \n    def __str__(self):\n        m = max(len(str(v)) for v in self)\n        res = ['']*len(self.i_indices)\n        row = ['']*(len(self.j_indices)+2)\n        for ri,i in enumerate(self.i_indices):\n            if ri == 0:\n                row[0] = '['\n            else:\n                row[0] = ' '\n            if ri == len(self.i_indices)-1:\n                row[-1] = ']\\n'\n            for rj,j in enumerate(self.j_indices):\n                row[rj+1] = f'{str(self.arr[i+j]):>{m+1}}'\n            res[ri] = ''.join(row)\n        return '\\n'.join(res)\n    \n    def copy(self):\n        return Array2d(len(self.i_indices), len(self.j_indices), list(self))\n\n\nclass Array2d:\n    def __init__(self, n, m, arr):\n        self.n = n\n        self.m = m\n        self.arr = arr\n    \n    @classmethod\n    def full(cls, n, m, fill_value):\n        return cls(n, m, [fill_value]*(n*m))\n    \n    @classmethod\n    def from_list(cls, lst):\n        return cls(len(lst),\n                   len(lst[0]),\n                   list(itertools.chain.from_iterable(lst)))\n    \n    def _get_view(self, i, j):\n        i = tuple(range(0, self.n*self.m, self.m))[i]\n        j = tuple(range(self.m))[j]\n        return Array2dView(self.arr, i, j)\n\n    def get_ind(self, i, j):\n        return i*self.m+j\n\n    def __getitem__(self, index):\n        try:\n            return self.arr[self.get_ind(*index)]\n        except TypeError:\n            return self._get_view(*index)\n    \n    def __setitem__(self, index, value):\n        try:\n            self.arr[self.get_ind(*index)] = value\n        except TypeError:\n            x = self._get_view(*index)\n            for i in x.i_indices:\n                for j in x.j_indices:\n                    self.arr[i+j] = value\n    \n    def __iter__(self):\n        return iter(self.arr)\n    \n    def __reversed__(self):\n        return reversed(self.arr)\n    \n    def __str__(self):\n        m = max(len(str(v)) for v in self)\n        res = ['']*self.n\n        row = ['']*(self.m+2)\n        for i in range(self.n):\n            if i == 0:\n                row[0] = '['\n            else:\n                row[0] = ' '\n            if i == self.n-1:\n                row[-1] = ']\\n'\n            for j in range(self.m):\n                row[j+1] = f'{str(self.arr[i*self.m+j]):>{m+1}}'\n            res[i] = ''.join(row)\n        return '\\n'.join(res)\n\n    def __eq__(self, other):\n        return self.arr == other.arr\n    \n    def copy(self):\n        return self.__init__(self.n, self.m, self.arr[:])\n\n    @property\n    def t(self):\n        arr = [self.arr[0]]*(len(self.arr))\n        x = 0\n        for i in range(self.n):\n            for j in range(self.m):\n                arr[j*self.n + i] = self.arr[x]\n                x += 1\n        return self.__init__(self.m, self.n, arr)\n\n\ndef get_matrix(zero, one):\n    class Matrix(Array2d):\n        def __add__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot add matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return self.__init__(self.n, self.m, [x+y for x, y in zip(self.arr, other.arr)])\n\n        def __iadd__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] += v\n\n        def __sub__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot subtract matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return self.__init__(self.n, self.m, [x-y for x, y in zip(self.arr, other.arr)])\n\n        def __isub__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] -= v\n\n        def __mul__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return self.__init__(self.n, self.m, [x*y for x, y in zip(self.arr, other.arr)])\n\n        def __imul__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] *= v\n\n        def __matmul__(self, other):\n            if self.m != other.n:\n                raise ValueError(f'Cannot dot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n\n            res = self.full(self.n, other.m, zero)\n\n            for i in range(self.n):\n                for j in range(other.m):\n                    c = zero\n                    for k in range(self.m):\n                        c += self[i, k]*other[k, j]\n                    res[i, j] = c\n            return res\n\n        def __imatmul__(self, other):\n            if self.m != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            if self is other or self.m != other.m:\n                return self @ other\n\n            row = [zero]*self.m\n            for i in range(self.n):\n                t = i*self.m\n                for j in range(self.m):\n                    row[j] = self.arr[j+t]\n                for j in range(other.m):\n                    c = zero\n                    for k in range(self.m):\n                        c += row[k]*other[k, j]\n                    self[i, j] = c\n            return self\n\n        def __pow__(self, power, modulo=None):\n            if self.n != self.m:\n                raise ValueError('pow is supported only for square matrix')\n            k = self.n\n            res = Matrix.full(k, k, zero)\n            for i in range(k):\n                res[i, i] = one\n\n            m = self\n            while power > 0:\n                if power & 1:\n                    res @= m\n                m @= m\n                power >>= 1\n            return res\n    return Matrix\n"
     ),
    'lib.array3d':
    (False,
     'class Array3d(list):\n    def __init__(self, n, m, p, arr):\n        list.__init__(self, arr)\n        self.n = n\n        self.m = m\n        self.p = p\n        self.mp = m*p\n\n    @classmethod\n    def full(cls, n, m, p, fill_value):\n        return cls(n, m, p, [fill_value] * (n * m * p))\n\n    def get_ind(self, i, j, k):\n        return i * self.mp + j * self.p + k\n\n    def __getitem__(self, index):\n        return list.__getitem__(self, self.get_ind(*index))\n\n    def __setitem__(self, index, value):\n        list.__setitem__(self, self.get_ind(*index), value)\n'
     ),
    'lib.benchmark':
    (False,
     '\nfrom time import perf_counter as timer\ndef simple_timeit(func, repeat=1000, warmup=100):\n    for i in range(warmup):\n        func(i)\n    start = timer()\n    for i in range(repeat):\n        func(i)\n    stop = timer()\n    return stop-start\n'
     ),
    'lib.data_structure':
    (False,
     'class DisjointSet:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n\n    def find(self, x):\n        stack = []\n        parent = self.parent\n        while parent[x] != x:\n            stack.append(x)\n            x = parent[x]\n        for y in stack:\n            parent[y] = x\n        return x\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n\n        if self.rank[xr] > self.rank[yr]:\n            self.parent[yr] = xr\n        elif self.rank[xr] < self.rank[yr]:\n            self.parent[xr] = yr\n        elif xr != yr:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n\n\nclass SegmentTree:\n    """\n    演算子は要素とセットでモノイドを形成するようなものでなければならない。\n    すなわち、結合律が成り立ち単位元が存在する必要がある。(ただし単位元は添加可能)\n    """\n\n    @classmethod\n    def all_identity(cls, operator, identity, size):\n        return cls(operator, identity, [identity] * (2 << (size - 1).bit_length()))\n\n    @classmethod\n    def from_initial_data(cls, operator, identity, data):\n        size = 1 << (len(data) - 1).bit_length()\n        temp = [identity] * (2 * size)\n        temp[size:size + len(data)] = data\n        data = temp\n\n        for i in reversed(range(size)):\n            data[i] = operator(data[2 * i], data[2 * i + 1])\n        return cls(operator, identity, data)\n\n    # これ使わずファクトリーメソッド使いましょうね\n    def __init__(self, operator, identity, data):\n        self.op = operator\n        self.id = identity\n        self.data = data\n        self.size = len(data) // 2\n\n    def _interval(self, a, b):\n        a += self.size\n        b += self.size\n        ra = self.id\n        rb = self.id\n\n        data = self.data\n        op = self.op\n        while a < b:\n            if a & 1:\n                ra = op(ra, data[a])\n                a += 1\n            if b & 1:\n                b -= 1\n                rb = op(data[b], rb)\n            a >>= 1\n            b >>= 1\n        return op(ra, rb)\n\n    def __getitem__(self, i):\n        if isinstance(i, slice):\n            return self._interval(\n                0 if i.start is None else i.start,\n                self.size if i.stop is None else i.stop)\n        elif isinstance(i, int):\n            return self.data[i + self.size]\n\n    def __setitem__(self, i, v):\n        i += self.size\n        data = self.data\n        op = self.op\n        while i:\n            data[i] = v\n            v = op(data[i ^ 1], v) if i & 1 else op(v, data[i ^ 1])\n            i >>= 1\n\n    def __iter__(self):\n        return iter(self.data[self.size:])\n\n\nclass LazySegmentTree:\n    """\n    op: 区間取得クエリでreduceする際に使う演算子\n    apply: 更新則の適用\n    comp: 更新則の合成\n    \n    range_query: reduce(op, (apply(x,m) for x,m in zip(X,M)))\n    \n    満たすべき性質:\n    \n    集合X (要素)\n    op[+]: X,X -> X\n    (X, op)はモノイド\n    \n    集合M (更新則)\n    comp[*]: M,M -> M\n    (M, compose)はモノイド\n    \n    apply[f(x,m,n)]: X,M,Z+ -> X\n    (Z+は区間長)\n    \n    f(x,e_M,n) = x\n    f(x,m*n,p) = f(f(x,m,p),n,p)\n    f(x,m,p)+f(y,m,q) = f(x+y,m,p+q)\n    \n    参考: https://algo-logic.info/segment-tree/#toc_id_3\n    """\n\n    @classmethod\n    def all_identity(cls, op, op_e, comp, comp_e, apply, size):\n        size = 1 << (size - 1).bit_length()\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            [op_e] * (2 * size),\n            [comp_e] * size\n        )\n\n    @classmethod\n    def from_initial_data(cls, op, op_e, comp, comp_e, apply, data):\n        size = 1 << (len(data) - 1).bit_length()\n        temp = [op_e] * (2 * size)\n        temp[size:size + len(data)] = data\n\n        for i in reversed(range(size)):\n            temp[i] = op(temp[2 * i], temp[2 * i + 1])\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            temp,\n            [comp_e] * size\n        )\n\n    # これ使わずファクトリーメソッド使いましょうね\n    def __init__(self, op, op_e, comp, comp_e, apply, data, lazy):\n        self.op = op\n        self.op_e = op_e\n        self.comp = comp\n        self.comp_e = comp_e\n        self.apply = apply\n        self.data = data\n        self.lazy = lazy\n        self.size = len(self.data) // 2\n        self.depth = self.size.bit_length() - 1\n        self._l_indices = [0] * self.depth\n        self._r_indices = [0] * self.depth\n\n    def _update_indices(self, i, l):\n        m = i // (i & -i)\n        i >>= 1\n        for k in range(self.depth):\n            l[k] = i if i < m else 0\n            i >>= 1\n\n    def _propagate_top_down(self):\n        data = self.data\n        lazy = self.lazy\n        apply = self.apply\n        comp = self.comp\n        comp_e = self.comp_e\n        k = self.size >> 1\n\n        for i, j in zip(reversed(self._l_indices), reversed(self._r_indices)):\n            if i > 0:\n                temp = lazy[i]\n                if temp != comp_e:\n                    lazy[i] = comp_e\n                    a = i << 1\n                    b = a | 1\n                    data[a] = apply(data[a], temp, k)\n                    data[b] = apply(data[b], temp, k)\n                    if k > 1:\n                        lazy[a] = comp(lazy[a], temp)\n                        lazy[b] = comp(lazy[b], temp)\n            if i < j:\n                temp = lazy[j]\n                if temp != comp_e:\n                    lazy[j] = comp_e\n                    a = j << 1\n                    b = a | 1\n                    data[a] = apply(data[a], temp, k)\n                    data[b] = apply(data[b], temp, k)\n                    if k > 1:\n                        lazy[a] = comp(lazy[a], temp)\n                        lazy[b] = comp(lazy[b], temp)\n            k >>= 1\n\n    def _propagate_bottom_up(self):\n        data = self.data\n        op = self.op\n        for i, j in zip(self._l_indices, self._r_indices):\n            if i < j:\n                data[j] = op(data[j << 1], data[j << 1 | 1])\n            if i > 0:\n                data[i] = op(data[i << 1], data[i << 1 | 1])\n\n    def update_interval(self, l, r, m):\n        lazy = self.lazy\n        data = self.data\n        comp = self.comp\n        apply = self.apply\n\n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n        k = 1\n        while l < r:\n            if l & 1:\n                data[l] = apply(data[l], m, k)\n                if k > 1:\n                    lazy[l] = comp(lazy[l], m)\n                l += 1\n            if r & 1:\n                r -= 1\n                data[r] = apply(data[r], m, k)\n                if k > 1:\n                    lazy[r] = comp(lazy[r], m)\n            l >>= 1\n            r >>= 1\n            k <<= 1\n        self._propagate_bottom_up()\n\n    def get_interval(self, l, r):\n        data = self.data\n        op = self.op\n\n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n\n        lx = self.op_e\n        rx = self.op_e\n        while l < r:\n            if l & 1:\n                lx = op(lx, data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                rx = op(data[r], rx)\n            l >>= 1\n            r >>= 1\n        return op(lx, rx)\n\n\nclass BinaryIndexedTree:\n    def __init__(self, size):\n        self.data = [0] * (size + 1)\n        self.msb = 1 << (size.bit_length() - 1)\n\n    def _add(self, i, w):\n        i += 1\n        while i < len(self.data):\n            self.data[i] += w\n            i += i & -i\n\n    def _get_sum(self, i):\n        res = 0\n        while i > 0:\n            res += self.data[i]\n            i -= i & -i\n        return res\n\n    def __getitem__(self, i):\n        """\n        [0,i)\n        """\n        if isinstance(i, slice):\n            a = self._get_sum(len(self.data) - 1 if i.stop is None else i.stop)\n            b = self._get_sum(0 if i.start is None else i.start)\n            return a - b\n        else:\n            return 0  # fake value\n\n    __setitem__ = _add\n\n    def bisect_left(self, v):\n        """\n        return smallest i s.t v <= sum[:i]\n        """\n        i = 0\n        k = self.msb\n        l = len(self.data)\n        while k > 0:\n            i += k\n            if i < l and self.data[i] < v:\n                v -= self.data[i]\n            else:\n                i -= k\n            k >>= 1\n        return i\n\n    def bisect_right(self, v):\n        """\n        return smallest i s.t v < sum[:i]\n        """\n        i = 0\n        k = self.msb\n        l = len(self.data)\n        while k > 0:\n            i += k\n            if i < l and self.data[i] <= v:\n                v -= self.data[i]\n            else:\n                i -= k\n            k >>= 1\n        return i\n\n    bisect = bisect_right\n'
     ),
    'lib.geometry':
    (False,
     "# 凸包ライブラリ。２点以下だとエラーでる\n# ConvexHull(points, qhull_options='QJ')\n"),
    'lib.graph':
    (False,
     'import itertools\nimport heapq as hq\nfrom random import randrange, shuffle\nfrom lib.misc import min2\nfrom lib.array2d import Array2d\n\nfrom typing import Union, Iterable, Any, Tuple, List\n\nINF = 2 ** 62\n\n\nclass BaseWeightedGraph:\n\n    def __init__(self, n_vertices):\n        self.n_vertices = n_vertices\n\n    def wadj(self, v):\n        """\n        Should return an iterator of vertices adjacent to v and edge weight\n        """\n        raise NotImplementedError\n\n    def adj(self, v):\n        """\n        Should return an iterator of vertices adjacent to v\n        """\n        return (u for u, w in self.wadj(v))\n\n    @property\n    def wedges(self):\n        """\n        Return an iterator of weighted edges (u,v,w)\n        """\n        return ((v, u, w) for v in range(self.n_vertices) for u, w in self.wadj(v))\n\n    def dist(self, s, t, inf=INF):\n        return dijkstra(self, s, t, inf)[t]\n\n    def warshall_floyd(self, inf=INF):\n        dist = Array2d.full(self.n_vertices, self.n_vertices, inf)\n        for u, v, w in self.wedges:\n            dist[u, v] = w\n        for i in range(self.n_vertices):\n            dist[i, i] = 0\n        for k in range(self.n_vertices):\n            for i in range(self.n_vertices):\n                for j in range(self.n_vertices):\n                    dist[i, j] = min2(dist[i, j], dist[i, k] + dist[k, j])\n        return dist\n\n\nclass WeightedGraph(BaseWeightedGraph):\n\n    def __init__(self, n_vertices, wedges, adj, weight, ind):\n        super().__init__(n_vertices)\n        self._adj = adj\n        self._weight = weight\n        self._ind = ind\n        self._wedges = wedges\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices, edges):\n        temp = [[] for _ in range(n_vertices)]\n        for u, v, w in edges:\n            temp[u].append((v, w))\n        adj = []\n        weight = []\n        ind = []\n        for u, l in enumerate(temp):\n            ind.append(len(adj))\n            for v, w in l:\n                adj.append(v)\n                weight.append(w)\n        ind.append(len(adj))\n        return cls(n_vertices, edges, adj, weight, ind)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices, edges):\n        temp = [[] for _ in range(n_vertices)]\n        for u, v, w in edges:\n            temp[u].append((v, w))\n            temp[v].append((u, w))\n        adj = []\n        weight = []\n        ind = []\n        for u, l in enumerate(temp):\n            ind.append(len(adj))\n            for v, w in l:\n                adj.append(v)\n                weight.append(w)\n        ind.append(len(adj))\n        return cls(n_vertices, edges, adj, weight, ind)\n\n    def wadj(self, v):\n        i, j = self._ind[v], self._ind[v + 1]\n        return zip(self._adj[i:j], self._weight[i:j])\n\n    @property\n    def wedges(self):\n        return self._wedges\n\n\nclass BaseGraph(BaseWeightedGraph):\n\n    def adj(self, v):\n        """\n        Should return an iterator of vertices adjacent to v\n        """\n        raise NotImplementedError\n\n    def wadj(self, v):\n        return ((u, 1) for u in self.adj(v))\n\n    def edges(self):\n        return ((v, u) for v in range(self.n_vertices) for u, w in self.adj(v))\n\n    def bfs(self, s, t=-1):\n        """\n        Returns a list of distance. If starts contains more than one vertex, returns the shortest distance from any of them\n        """\n        dist = [-1] * self.n_vertices\n\n        if isinstance(s, int):\n            q = [s]\n            dist[s] = 0\n        else:\n            q = list(s)\n            for v in q:\n                dist[v] = 0\n        for d in range(1, self.n_vertices):\n            nq = []\n            for v in q:\n                for u in self.adj(v):\n                    if dist[u] == -1:\n                        dist[u] = d\n                        nq.append(u)\n                    if u == t:\n                        return dist\n            q = nq\n        return dist\n\n    def dist(self, s, t, inf=INF):\n        return self.bfs(s, t)[t]\n\n\nclass Graph(BaseGraph):\n\n    def __init__(self, n_vertices, edges, adj, ind):\n        super().__init__(n_vertices)\n        self._adj = adj\n        self._ind = ind\n        self.edges = edges\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices, edges):\n        temp = [[] for _ in range(n_vertices)]\n        for u, v in edges:\n            temp[u].append(v)\n        adj = []\n        ind = []\n        for u, l in enumerate(temp):\n            ind.append(len(adj))\n            for v in l:\n                adj.append(v)\n        ind.append(len(adj))\n        return cls(n_vertices, edges, adj, ind)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices, edges):\n        temp = [[] for _ in range(n_vertices)]\n        for u, v in edges:\n            temp[u].append(v)\n            temp[v].append(u)\n        adj = []\n        ind = []\n        for u, l in enumerate(temp):\n            ind.append(len(adj))\n            for v in l:\n                adj.append(v)\n        ind.append(len(adj))\n        return cls(n_vertices, edges, adj, ind)\n\n    def adj(self, v):\n        return self._adj[self._ind[v]: self._ind[v + 1]]\n\n\nclass BaseRootedTree(BaseGraph):\n\n    def __init__(self, n_vertices, root_vertex=0):\n        super().__init__(n_vertices)\n        self.root = root_vertex\n\n    def parent(self, v):\n        raise NotImplementedError\n\n    def children(self, v):\n        raise NotImplementedError\n\n    def adj(self, v):\n        if self.root == v:\n            return self.children(v)\n        return itertools.chain(self.children(v), (self.parent(v),))\n\n    @property\n    def post_order(self):\n        """\n        bottom vertices first\n        """\n        return (~v for v in self.prepost_order if v < 0)\n\n    @property\n    def pre_order(self):\n        """\n        top vertices first\n        """\n        return (v for v in self.prepost_order if v >= 0)\n\n    @property\n    def prepost_order(self):\n        """\n        if v >= 0: it\'s pre-order entry\n        otherwise: it\'s post-order entry\n        """\n        try:\n            return self._prepost_order\n        except AttributeError:\n            order = [0] * (self.n_vertices * 2)\n            stack = [~self.root, self.root]\n            i = 0\n            for i in range(self.n_vertices * 2):\n                v = stack.pop()\n                order[i] = v\n                if v >= 0:\n                    for u in self.children(v):\n                        stack.append(~u)\n                        stack.append(u)\n            self._prepost_order = order\n            return order\n\n    @property\n    def prepost_indices(self, cache=False):\n        try:\n            return self._pre_ind, self._post_ind\n        except AttributeError:\n            pre_ind = [0] * self.n_vertices\n            post_ind = [0] * self.n_vertices\n            for i, t in enumerate(self.prepost_order):\n                if t >= 0:\n                    pre_ind[t] = i\n                else:\n                    post_ind[~t] = i\n            self._pre_ind = pre_ind\n            self._post_ind = post_ind\n            return pre_ind, post_ind\n\n    def depth(self, v):\n        try:\n            return self._depth[v]\n        except AttributeError:\n            depth = [0] * (self.n_vertices)\n            l = 0\n            for k in self.prepost_order:\n                if k >= 0:\n                    depth[k] = l\n                    l += 1\n                else:\n                    l -= 1\n            self._depth = depth\n            return depth[v]\n\n    @property\n    def height(self):\n        try:\n            return self._height\n        except AttributeError:\n            self._height = max(self.depth(v) for v in range(self.n_vertices)) + 1\n            return self._height\n\n    @property\n    def doubling(self):\n        try:\n            return self._dbl\n        except AttributeError:\n            d = self.height.bit_length()\n\n            dbl = Array2d.full(self.n_vertices, d, -1)\n            for v in self.pre_order:\n                u = self.parent(v)\n                dbl[v, 0] = u\n                for i in range(d - 1):\n                    u = dbl[u, i]\n                    if u < 0:\n                        break\n                    dbl[v, i + 1] = u\n            self._dbl = dbl\n            return dbl\n\n    def ancestor_of(self, v, k):\n        dbl = self.doubling\n        if k > self.depth(v):\n            return -1\n        i = 0\n        while k:\n            if k & 1:\n                v = dbl[v, i]\n            k //= 2\n            i += 1\n        return v\n\n    def lca(self, u, v):\n        lu, lv = self.depth(u), self.depth(v)\n        if lu > lv:\n            u = self.ancestor_of(u, lu - lv)\n        else:\n            v = self.ancestor_of(v, lv - lu)\n        if u == v:\n            return u\n\n        dbl = self.doubling\n        i = dbl.m - 1\n        while True:\n            while i >= 0 and dbl[u, i] == dbl[v, i]:\n                i -= 1\n            if i < 0:\n                return dbl[u, 0]\n            u, v = dbl[u, i], dbl[v, i]\n\n    def dist(self, u, v, inf=INF):\n        return self.depth(u) + self.depth(v) - 2 * self.depth(self.lca(u, v))\n\n    def solve_rerooting(self, merge, identity, finalize):\n        """\n        merge: (T,T) -> T, (T, merge)はモノイド\n        identity: 単位元\n        finalize: (T, V, V) -> T\n\n        以下の形で書けるdpは対応可能\n        dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u), u, v)\n        ただし(u,v)は辺\n        dp[u,v]: vを根とするuを含まないような部分木についての解\n        """\n\n        dp1 = [identity] * self.n_vertices\n        dp2 = [identity] * self.n_vertices\n\n        for v in self.post_order:\n            t = identity\n            for u in self.children(v):\n                dp2[u] = t\n                t = merge(t, finalize(dp1[u], v, u))\n            t = identity\n            for u in reversed(list(self.children(v))):\n                dp2[u] = merge(t, dp2[u])\n                t = merge(t, finalize(dp1[u], v, u))\n            dp1[v] = t\n        for v in self.pre_order:\n            if v == self.root:\n                continue\n            p = self.parent(v)\n            dp2[v] = finalize(merge(dp2[v], dp2[p]), v, p)\n            dp1[v] = merge(dp1[v], dp2[v])\n        return dp1\n\n\nclass RootedTree(BaseRootedTree):\n\n    @classmethod\n    def from_edges(cls, edges, root_vertex=0):\n        rt = cls(len(edges) + 1, root_vertex)\n        adj = [[] for _ in range(rt.n_vertices)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        rt._adj = adj\n        rt._edges = edges\n        return rt\n\n    @classmethod\n    def from_parent(cls, parent, root_vertex):\n        rt = cls(len(parent), root_vertex)\n        rt._parent = parent\n        return rt\n\n    @classmethod\n    def random(cls, n_vertices, root_vertex=0):\n        parent = [-1] * n_vertices\n        vertices = list(range(root_vertex)) + list(range(root_vertex + 1, n_vertices))\n        shuffle(vertices)\n        vertices.append(root_vertex)\n        for i, v in zip(reversed(range(n_vertices)), vertices[-2::-1]):\n            parent[v] = vertices[randrange(i, n_vertices)]\n        return cls.from_parent(parent, root_vertex)\n\n    def adj(self, v):\n        try:\n            return self._adj[v]\n        except AttributeError:\n            if v == self.root:\n                return self.children(v)\n            return itertools.chain(self.children(v), (self.parent(v),))\n\n    def parent(self, v):\n        try:\n            return self._parent[v]\n        except AttributeError:\n            parent = [0] * self.n_vertices\n            parent[self.root] = -1\n            stack = [self.root]\n            for _ in range(self.n_vertices):\n                k = stack.pop()\n                p = parent[k]\n                for u in self.adj(k):\n                    if u != p:\n                        parent[u] = k\n                        stack.append(u)\n            self._parent = parent\n            return parent[v]\n\n    def children(self, v):\n        try:\n            return self._children[v]\n        except AttributeError:\n            children = [[] for _ in range(self.n_vertices)]\n            for u in range(self.n_vertices):\n                p = self.parent(u)\n                if p >= 0:\n                    children[p].append(u)\n            self._children = children\n            return children[v]\n\n    @property\n    def edges(self):\n        try:\n            return self._edges\n        except AttributeError:\n            for v in range(self.n_vertices):\n                if v != self.root:\n                    yield (v, self.parent(v))\n\n\ndef scc(graph, rgraph):\n    n = graph.n_vertices\n    order = []\n    color = [0] * n\n    for v0 in range(n):\n        if color[v0]:\n            continue\n        color[v0] = -1\n        stack = [iter(graph.adj(v0))]\n        path = [v0]\n        while path:\n            for u in stack[-1]:\n                if color[u] == 0:\n                    color[u] = -1\n                    path.append(u)\n                    stack.append(iter(graph.adj(u)))\n                    break\n            else:\n                v = path.pop()\n                order.append(v)\n                stack.pop()\n\n    label = 0\n    for v0 in reversed(order):\n        if color[v0] >= 0:\n            continue\n        color[v0] = label\n        stack = [v0]\n        while stack:\n            v = stack.pop()\n            for u in rgraph.adj(v):\n                if color[u] < 0:\n                    color[u] = label\n                    stack.append(u)\n        label += 1\n    return label, color\n\n\ndef dijkstra(graph: BaseWeightedGraph, s: Union[int, Iterable[int]], t: Union[int, Iterable[int]] = -1,\n             inf: Any = 2 ** 62) -> Tuple[List[int], Any]:\n    """\n    Returns a list of distance. If starts contains more than one vertex, returns the shortest distance from any of them.\n    """\n    K = graph.n_vertices.bit_length()\n    MASK = (1 << K) - 1\n    dist = [inf] * graph.n_vertices\n\n    if isinstance(s, int):\n        q = [s]\n        dist[s] = 0\n    else:\n        q = list(s)\n        for v in q:\n            dist[v] = 0\n    if isinstance(t, int):\n        if t < 0:\n            t = []\n        else:\n            t = [t]\n    else:\n        t = set(t)\n\n    while q:\n        x = hq.heappop(q)\n        d, v = x >> K, x & MASK\n        if v in t:\n            return dist, d\n        if d > dist[v]:\n            continue\n        for u, w in graph.wadj(v):\n            if dist[u] > d + w:\n                dist[u] = d + w\n                hq.heappush(q, ((d + w) << K) | u)\n    return dist, None\n\n\ndef max_flow(graph: BaseWeightedGraph, s, t):\n    adj: List[List[int]] = [[] for _ in range(graph.n_vertices)]\n    weight: List[List[int]] = [[] for _ in range(graph.n_vertices)]\n    edge_id: List[List[int]] = [[] for _ in range(graph.n_vertices)]\n    for i, (u, v, w) in enumerate(graph.wedges):\n        if u != v:\n            adj[u].append(v)\n            weight[u].append(w)\n            edge_id[u].append(i)\n            adj[v].append(u)\n            weight[v].append(0)\n            edge_id[v].append(i)\n\n    rev = [0]*(i+1)\n    \n\ndef max_bipartite_matching(graph: BaseWeightedGraph):\n    pass'
     ),
    'lib.itertools':
    (False,
     '# それぞれの値values[i]が最大counts[i]回入ることを許す組み合わせ\ndef combinations_without_repetition(r, iterable=None, values=None, counts=None):\n\n  if iterable:\n    values, counts = zip(*Counter(iterable).items())\n\n  f = lambda i,c: chain.from_iterable(map(repeat, i, c))\n  n = len(counts)\n  indices = list(islice(f(count(),counts), r))\n  if len(indices) < r:\n    return\n  while True:\n    yield tuple(values[i] for i in indices)\n    for i,j in zip(reversed(range(r)), f(reversed(range(n)), reversed(counts))):\n      if indices[i] != j:\n        break\n    else:\n      return\n    j = indices[i]+1\n    for i,j in zip(range(i,r), f(count(j), counts[j:])):\n      indices[i] = j\n\n\n\n# それぞれの値values[i]がcounts[i]回入る順列\n# TODO\ndef permutations_without_repetition(r, iterable=None, values=None, counts=None):\n  from itertools import chain,repeat,islice,count\n  from collections import Counter\n\n  if iterable:\n    values, counts = zip(*Counter(iterable).items())\n\n  f = lambda i,c: chain.from_iterable(map(repeat, i, c))\n  n = len(counts)\n  indices = list(islice(f(count(),counts), r))\n  if len(indices) < r:\n    return\n  yield tuple(values[i] for i in indices)\n  while True:\n    for i,j in zip(reversed(range(r)), f(reversed(range(n)), reversed(counts))):\n      if indices[i] != j:\n        break\n    else:\n      return\n    j = indices[i]+1\n    for i,j in zip(range(i,r), f(count(j), counts[j:])):\n      indices[i] = j\n    yield tuple(values[i] for i in indices)'
     ),
    'lib.misc':
    (False,
     'from typing import List, Any, Callable, Sequence, Union, Tuple, TypeVar\n\nV = TypeVar(\'V\')\n\nimport sys\nfrom functools import reduce\nfrom itertools import accumulate\nfrom lib.data_structure import BinaryIndexedTree, DisjointSet\nimport bisect\n\n\ndef general_bisect(ng: int, ok: int, judge: Callable[[int], V]) -> int:\n    """\n    一般化した二分法。一般の単調関数の根をO(log L)で見つける。\n\n    :param ng: judge(ng)==Falseとなる値\n    :param ok: judge(ok)==Trueとなる値\n    :param judge: 真偽値を返す単調関数\n    :return: judge(x)==Trueが成り立つギリギリの値\n    """\n    while abs(ng - ok) > 1:\n        m = (ng + ok) // 2\n        if judge(m):\n            ok = m\n        else:\n            ng = m\n    return ok\n\n\ndef fibonacci_search(left: int, right: int, func: Union[Callable[[int], V], Sequence], inf: V = 2 ** 60) -> Tuple[\n    V, int]:\n    """\n    フィボナッチ探索法。極小値を一つだけ持つような関数の極小値をO(log L)で見つける。\n    探索は(left, right)の範囲で行われる。\n\n    :param left: 探索範囲の左端（含まない）\n    :param right: 探索範囲の右端（含まない）\n    :param func: 被最適化関数\n    :param inf: funcの上界\n    :return: (funcの極小値, 極小値を達成するfuncの引数)\n    """\n    try:\n        func = func.__getitem__\n    except AttributeError:\n        pass\n    f1, f2 = 1, 1\n    while f1 + f2 < right - left:\n        f1, f2 = f1 + f2, f1\n    l = left\n    m1 = func(l + f2)\n    m2 = func(l + f1)\n    while f1 > 2:\n        f1, f2 = f2, f1 - f2\n        if m1 > m2:\n            l += f1\n            m1 = m2\n            m2 = func(l + f1) if l + f1 < right else inf\n        else:\n            m2 = m1\n            m1 = func(l + f2)\n    if m1 < m2:\n        return m1, l + 1\n    else:\n        return m2, l + 2\n\n\ndef max2(x: V, y: V) -> V:\n    return x if x > y else y\n\n\ndef min2(x: V, y: V) -> V:\n    return x if x < y else y\n\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\n\n\ndef rerooting(rooted_tree, merge, identity, finalize):\n    """\n    merge: (T,T) -> T, (T, merge)はモノイド\n    identity: 単位元\n    finalize: (T, V, V) -> T\n\n    以下の形で書けるdpは対応可能\n    dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u), u, v)\n    ただし(u,v)は辺 u->v\n    """\n    N = rooted_tree.n_vertices\n    parent = rooted_tree.parent\n    children = rooted_tree.children\n    order = rooted_tree.dfs_order\n\n    # from leaf to parent\n    dp_down = [None] * N\n    for v in reversed(order):\n        dp_down[v] = finalize(reduce(merge,\n                                     (dp_down[c] for c in children[v]),\n                                     identity), parent[v], v)\n\n    # from parent to leaf\n    dp_up = [None] * N\n    dp_up[0] = identity\n    for v in order:\n        if len(children[v]) == 0:\n            continue\n        temp = (dp_up[v],) + tuple(dp_down[u] for u in children[v]) + (identity,)\n        left = accumulate(temp[:-2], merge)\n        right = tuple(accumulate(reversed(temp[2:]), merge))\n        for u, l, r in zip(children[v], left, reversed(right)):\n            dp_up[u] = finalize(merge(l, r), u, v)\n\n    res = [None] * N\n    for v, l in enumerate(children):\n        res[v] = reduce(merge,\n                        (dp_down[u] for u in children[v]),\n                        identity)\n        res[v] = merge(res[v], dp_up[v])\n    return res, dp_up, dp_down\n\n\ndef longest_increasing_sequence(l, inf):\n    dp = [inf] * len(l)\n    for i, v in enumerate(l):\n        dp[bisect.bisect(dp, v)] = i\n\n    m = next(n for n in reversed(range(len(l))) if dp[n] < inf) + 1\n    return m\n\n\ndef zeta(data, merge):\n    """\n    （この関数はdataを上書きします）\n    Mはモノイド\n    data: 2^n -> M\n    output: 2^n -> M\n    merge: M -> M\n \n    ouput[i] = sum(data[j] for j in range(2^n) if i|j == i)\n    """\n    n = len(data)\n    while i < n:\n        j = i\n        while j < n:\n            data[j] = merge(data[j], data[j & ~i])\n            j = (j + 1) | i\n        i <<= 1\n    return data\n\n\ndef check_bipartiteness(n_vertices, edges):\n    ds = DisjointSet(2 * n_vertices)\n\n    for a, b in edges:\n        ds.union(a, b + n_vertices)\n        ds.union(b, a + n_vertices)\n\n    next_color = 0\n    color = [-1] * (2 * n_vertices)\n    for v in range(n_vertices):\n        ra = ds.find(v)\n        rb = ds.find(v + n_vertices)\n        if ra == rb:\n            return None\n        if color[ra] < 0:\n            color[ra] = next_color\n            color[rb] = next_color + 1\n            next_color += 2\n        color[v] = color[ra]\n        color[v + n_vertices] = color[rb]\n    return color[:n_vertices]\n\n\ndef small_range_duplicate(a):\n    MASK = (1 << 32) - 1\n    n = len(a)\n    left = [i - 1 for i in range(n + 1)]\n    right = [i + 1 for i in range(n + 1)]\n\n    sorted_ind = sorted((~v << 32) | i for i, v in enumerate(a))\n    t = 0\n    vi = sorted_ind[t]\n    i = vi & MASK\n    v = ~(vi >> 32)\n    while t < n:\n        j = i\n        l = left[i]\n        pi = l\n        pv = v\n        while v == pv and left[i] == pi:\n            pi = i\n            t += 1\n            if t >= n:\n                break\n            vi = sorted_ind[t]\n            i = vi & MASK\n            v = ~(vi >> 32)\n        r = right[pi]\n        right[l] = r\n        while j <= pi:\n            nj = right[j]\n            left[j] = l\n            right[j] = r\n            j = nj\n        left[r] = l\n\n    return left, right\n\n\ndef small_range(a):\n    N = len(a)\n    MASK = (1 << 32) - 1\n    left = [i - 1 for i in range(N + 1)]\n    right = [i + 1 for i in range(N + 1)]\n    sorted_ind = sorted((~v << 32) | i for i, v in enumerate(a))\n    for v in sorted_ind:\n        i = v & MASK\n        left[right[-i]] = left[-i]\n        right[left[-i]] = right[-i]\n\n    return left, right\n\n\ndef popcnt32(n):\n    n = n - ((n >> 1) & 0x55555555)\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n    return ((((n + (n >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24) & 0xff\n\n\ndef popcnt64(n):\n    n = n - ((n >> 1) & 0x5555555555555555)\n    n = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333)\n    n = (n + (n >> 4)) & 0x0f0f0f0f0f0f0f0f\n    return ((((n + (n >> 32)) & 0xffffffff) * 0x01010101) >> 24) & 0xff\n\n\ndef popcnt(n):\n    if n < 1 << 32:\n        return popcnt32(n)\n    elif n < 1 << 64:\n        return popcnt64(n)\n    else:\n        return sum(c == \'1\' for c in bin(n))\n\n\ndef reverse_bits32(x):\n    x = ((x & 0x55555555) << 1) | ((x & 0xAAAAAAAA) >> 1)\n    x = ((x & 0x33333333) << 2) | ((x & 0xCCCCCCCC) >> 2)\n    x = ((x & 0x0F0F0F0F) << 4) | ((x & 0xF0F0F0F0) >> 4)\n    x = ((x & 0x00FF00FF) << 8) | ((x & 0xFF00FF00) >> 8)\n    return ((x & 0x0000FFFF) << 16) | ((x & 0xFFFF0000) >> 16)\n\n\ndef count_inversions(l: List[Any]) -> int:\n    """\n    転倒数を計算する。in-placeでソートもする。\n\n    :param l: リスト\n    :return: 転倒数\n    """\n    bit = BinaryIndexedTree(len(l))\n    res = 0\n    for i, v in enumerate(l):\n        bit[v] += 1\n        res += bit[v + 1:]\n    return res\n\n\nclass BinaryTrie:\n    class Node:\n        def __init__(self):\n            self.zero = None\n            self.one = None\n            self.cnt = 0\n\n    def __init__(self, bits):\n        self.root = self.Node()\n        self.bits = bits\n\n    def add(self, v):\n        n = self.root\n        n.cnt += 1\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                if not n.one:\n                    n.one = self.Node()\n                n = n.one\n            else:\n                if not n.zero:\n                    n.zero = self.Node()\n                n = n.zero\n            n.cnt += 1\n\n    def remove(self, v):\n        n = self.root\n        n.cnt -= 1\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                n = n.one\n            else:\n                n = n.zero\n            n.cnt -= 1\n\n    def find_argminxor(self, v):\n        n = self.root\n        r = 0\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                if n.one and n.one.cnt > 0:\n                    n = n.one\n                    r |= 1 << d\n                else:\n                    n = n.zero\n            else:\n                if n.zero and n.zero.cnt > 0:\n                    n = n.zero\n                else:\n                    n = n.one\n                    r |= 1 << d\n        return r\n\n    def __contains__(self, v):\n        n = self.root\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                n = n.one\n            else:\n                n = n.zero\n            if not n or n.cnt == 0:\n                return False\n        return True\n'
     ),
    'lib.modint':
    (False,
     "from importlib.util import find_spec, module_from_spec\n\nmodints = {}\n\n\ndef get_modint(mod):\n    try:\n        return modints[mod]\n    except KeyError:\n        spec = find_spec('lib._modint')\n        module = module_from_spec(spec)\n        module.__dict__['MOD'] = mod\n        spec.loader.exec_module(module)\n        modints[mod] = module.ModInt\n        return modints[mod]"
     ),
    'lib.number_theory':
    (False,
     'from collections import Counter, defaultdict\nfrom math import sqrt, ceil, gcd\nfrom itertools import count\nfrom typing import Tuple\n\n\ndef sign(x):\n    return int(x > 0) - int(x < 0)\n\n\ndef egcd(a: int, b: int) -> Tuple[int,int,int]:\n    """\n    拡張ユークリッド法\n\n    :param a: 係数\n    :param b: 係数\n    :return: (x, y, gcd(a,b)). x, yはax+by=gcd(a,b)を満たす\n    """\n    s,ps,r,pr = 0,1,b,a\n    while r != 0:\n        q = pr//r\n        pr,r = r,pr-q*r\n        ps,s = s,ps-q*s\n    t = (pr-ps*a)//b\n    if pr > 0:\n        return ps, t, pr\n    return -ps, -t, -pr\n\n\ndef modinv(x: int, mod: int) -> int:\n    """\n    Z/(mod Z)上でのxの逆元\n\n    :param x: 整数\n    :param mod: 整数\n    :return: x * y % mod = 1を満たすy\n    """\n    s,ps,r,pr = 0,1,mod,x\n    while r != 0:\n        pr, (q, r) = r, divmod(pr, r)\n        ps, s = s, ps-q*s\n    if pr == 1:\n        return ps if ps >= 0 else ps + mod\n    raise ValueError("base is not invertible for the given modulus")\n\n\ndef modpow(x, k, mod):\n    """\n    Z/(mod Z)上でのxのk乗\n\n    :param x: 整数\n    :param k: 整数\n    :param mod: 整数\n    :return: x ** k % mod\n    """\n    if k < 0:\n        x = modinv(x, mod)\n        k = -k\n    r = 1\n    while k != 0:\n        if k & 1:\n            r = (r*x)%mod\n        x = (x*x)%mod\n        k >>= 1\n    return r\n\n# 素因数分解\ndef prime_factors(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            yield i\n    if n > 1:\n        yield n\n\ndef int_product(iterable):\n    x = 1\n    for y in iterable:\n        x *= y\n    return x\n\n# 約数列挙（O(sqrt(n))かかる）\ndef divisors(n):\n    for i in range(1,ceil(sqrt(n))+1):\n        j, r = divmod(n, i)\n        if not r:\n            yield i\n            if i != j:\n                yield j\n\n# 素数生成器\ndef generate_primes():\n    D = defaultdict(list)\n\n    q = 2\n    for q in count(2):\n        if q in D:\n            for p in D[q]:\n                D[p+q].append(p)\n            del D[q]\n        else:\n            yield q\n            D[q*q].append(q)\n\n\ndef totient_factors(n):\n    def it():\n        prev = -1\n        for p in prime_factors(n):\n            if p == prev:\n                yield p\n            else:\n                prev = p\n                for q in prime_factors(p - 1):\n                    yield q\n    return it()\n\n\ndef primitive_root(mod, phi_factors=None):\n    if phi_factors is None:\n        phi_factors = tuple(totient_factors(mod))\n    phi = int_product(phi_factors)\n    primes = set(phi_factors)\n    for i in range(2, mod):\n        for p in primes:\n            if modpow(i, (phi // p), mod) == 1:\n                break\n        else:\n            return i\n    else:\n        raise ValueError(f\'There is no primitive root for modulo {mod}\')\n\n\ndef lcm(nums):\n    m = 1\n    for n in nums:\n        m *= n//gcd(m,n)\n    return m\n\n\ndef chinese_remainder_theorem(reminders, mods, mods_lcm=-1):\n    """\n    returns x and lcm(reminders) s.t.\n    all(x%m == r for r,m in zip(reminders,mods))\n    """\n    s = 0\n    if mods_lcm < 0:\n        mods_lcm = lcm(mods)\n    for m,r in zip(mods, reminders):\n        p = mods_lcm//m\n        s += r * p * pow(p, -1, m)\n        s %= mods_lcm\n    return s, mods_lcm\n\n\ndef factorials_with_inv(k, mod):\n    """\n    0! ... k! とそれらのmod逆元を求めて返す\n    PyPyだとpowが動かないので注意！！！\n    """\n    fac = [1]*(k+1)\n    inv = [1]*(k+1)\n    t = 1\n    for i in range(1,k+1):\n        t = (t*i) % mod\n        fac[i] = t\n    t = modinv(t, mod)\n    for i in reversed(range(1,k+1)):\n        inv[i] = t\n        t = (t*i) % mod\n    return fac, inv\n\ndef extended_lucas_theorem(mod):\n    """\n    Returns a function (n,m) -> C(n,m)%mod\n    """\n    factors = tuple((p, q, p**q) for p,q in Counter(prime_factors(mod)).items())\n    facs = [[0]*k for p,q,k in factors]\n    invs = [[0]*k for p,q,k in factors]\n    for (p,q,k),fac,inv in zip(factors,facs,invs):\n        t = 1\n        for n in range(k):\n            if n % p != 0:\n                t *= n\n                t %= k\n            fac[n] = t\n        t = modinv(t, k)\n        for n in reversed(range(k)):\n            inv[n] = t\n            if n % p != 0:\n                t *= n\n                t %= k\n    \n    def helper(n, m):\n        l = n - m\n        if l < 0:\n            return 0\n        def reminders():\n            for (p,q,k),fac,inv in zip(factors,facs,invs):\n                a,b,c,e0,eq,i,r = n,m,l,0,-2,1,1\n                while a > 0:\n                    r *= fac[a%k]*inv[b%k]*inv[c%k]\n                    r %= k\n                    a,b,c = a//p,b//p,c//p\n                    if i == q:\n                        eq = e0\n                    e0 += a-b-c\n                    i += 1\n                if eq >= 0:\n                    eq += e0\n                if e0 >= q:\n                    r = 0\n                else:\n                    r *= p**e0\n                    r %= k\n                    if not (p == 2 and q >= 3) and (eq%2 == 1):\n                        r = -r\n                yield r\n        return chinese_remainder_theorem(reminders(), (m for _,_,m in factors), mod)[0]\n    return helper\n\n\ndef lucas_theorem(m,n,mod,comb):\n    cnt = 1\n    while n > 0:\n        m,mr = divmod(m,mod)\n        n,nr = divmod(n,mod)\n        if mr < nr:\n            return 0\n        cnt *= comb[mr][nr]\n        cnt %= mod\n    return cnt\n\n# C(n,m) is even iff (~n&m)>0\n\ndef floor_linear_sum(n,m,a,b):\n    """\n    returns sum((a*i+b)//m for i in range(n))\n    """\n    if b < 0:\n        t = (-b-1)//m+1\n        b += m*t\n        res = -t*n\n    else:\n        res = 0\n    while True:\n        if a >= m:\n            res += (n-1)*n*(a//m)//2\n            a %= m\n        if b >= m:\n            res += n * (b//m)\n            b %= m\n\n        y_max = (a*n+b)//m\n        if y_max == 0:\n            return res\n        nx_max = b - y_max*m\n        res += (n + nx_max//a)*y_max\n        n,m,a,b = y_max, a, m, nx_max%a\n'
     ),
    'lib.transform':
    (False,
     "from cmath import rect, pi\nfrom lib.misc import reverse_bits32\nfrom lib.number_theory import totient_factors, primitive_root, modinv, modpow\n\n\ndef fft(a, inverse=False):\n    one = complex(1.0)\n    n = (len(a) - 1).bit_length()\n    m = 2 ** n\n    a += [complex(0.0)] * (m - len(a))\n    pows = [rect(1.0, (-pi if inverse else pi) / (2 ** (n - 1)))]\n    for _ in range(n-1):\n        pows.append(pows[-1] ** 2)\n    pows.reverse()\n\n    shift = 32 - n\n    for i in range(m):\n        j = reverse_bits32(i) >> shift\n        if i < j:\n            a[i], a[j] = a[j], a[i]\n\n    for i in range(m):\n        b = 1\n        for w1 in pows:\n            if not i & b:\n                break\n            i ^= b\n            w = one\n            while not i & b:\n                s = a[i]\n                t = a[i | b] * w\n                a[i] = s + t\n                a[i | b] = s - t\n                w *= w1\n                i += 1\n            i ^= b\n            b <<= 1\n    if inverse:\n        c = 1 / m\n        for i in range(m):\n            a[i] *= c\n    return a\n\n\ndef ntt(a, mod, inverse=False):\n    if type(a[0]) is not int:\n        for i,v in enumerate(a):\n            a[i] = int(v)\n    n = (len(a) - 1).bit_length()\n    d2 = 0\n    r = 1\n    phi_factors = tuple(totient_factors(mod))\n    for p in phi_factors:\n        if p == 2:\n            d2 += 1\n        else:\n            r *= p\n    if d2 < n:\n        raise ValueError(f'Given array is too long: modulo {modint.mod} only support array length up to {2 ** d2}')\n\n    pr = primitive_root(mod, phi_factors)\n    if inverse:\n        pr = modinv(pr, mod)\n    pows = [modpow(pr, r * 2 ** (d2 - n), mod)]\n    for _ in range(n - 1):\n        pows.append(pows[-1] ** 2 % mod)\n    pows = tuple(reversed(pows))\n\n    m = 2 ** n\n    a += [0] * (m - len(a))\n\n    shift = 32 - n\n    for i in range(m):\n        j = reverse_bits32(i) >> shift\n        if i < j:\n            a[i], a[j] = a[j], a[i]\n\n    for i in range(m):\n        b = 1\n        for w1 in pows:\n            if not i & b:\n                break\n            i ^= b\n            w = 1\n            while not i & b:\n                j = i | b\n                s = a[i] % mod\n                t = a[j] * w % mod\n                a[i] = s + t\n                a[j] = s - t\n                w = (w * w1) % mod\n                i += 1\n            i ^= b\n            b <<= 1\n\n    if inverse:\n        c = modinv(m, mod)\n        for i, v in enumerate(a):\n            a[i] = (v * c) % mod\n    return a"
     ),
    'lib._modint':
    (False,
     'from lib.number_theory import modinv, modpow\n\nclass ModInt(int):\n    mod = MOD\n\n    def __new__(cls, n, f=1):\n        return int.__new__(cls, n % MOD if f else n)\n\n    def __neg__(self):\n        return ModInt(MOD - int(self) if self != 0 else 0, 0)\n\n    def __add__(self, other):\n        x = int(self) + int(other)\n        return ModInt(x if x < MOD else x - MOD, 0)\n\n    def __sub__(self, other):\n        x = int(self) - int(other)\n        return ModInt(x if x >= 0 else x + MOD, 0)\n\n    def __rsub__(self, other):\n        x = int(other) - int(self)\n        return ModInt(x if x >= 0 else x + MOD, 0)\n\n    def __mul__(self, other):\n        return ModInt(int(self) * int(other))\n\n    def __matmul__(self, other):\n        return ModInt(reduce(int(self) * int(other)), 0)\n\n    def __truediv__(self, other):\n        return self * ModInt(other).inv\n\n    def __rtruediv__(self, other):\n        return self.inv * other\n\n    __radd__ = __add__\n    __rmul__ = __mul__\n    __rmatmul__ = __matmul__\n\n    def __pow__(self, other, **kwargs):\n        return modpow(int(self), int(other), MOD)\n\n    @property\n    def inv(self):\n        return ModInt(modinv(int(self), MOD), 0)'
     ),
    'lib': (True, ''),
}
_sys.meta_path.insert(2, InlineImporter)

# Entrypoint
from lib.graph import RootedTree

n, q = map(int, input().split())
edges = [
    tuple(map(lambda x: int(x) - 1,
              input().split())) for _ in range(n - 1)
]

rt = RootedTree.from_edges(edges)
for _ in range(q):
    c, d = map(int, input().split())
    print('Town' if rt.dist(c - 1, d - 1) % 2 == 0 else 'Road')
