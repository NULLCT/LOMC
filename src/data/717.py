#!/usr/bin/env python3
# from typing import *
import collections
import heapq
import queue


def solve_a(N, Q, a, b, c, d):
    G = collections.defaultdict(set)

    for aa, bb in zip(a, b):
        G[aa - 1].add(bb - 1)
        G[bb - 1].add(aa - 1)

    def dik(G, s):
        dist = [float('inf') for _ in range(N)]
        dist[s] = 0
        que = []
        heapq.heappush(que, (dist[s], s))

        while que:
            d, v = heapq.heappop(que)

            if d > dist[v]:
                continue

            for e in G[v]:
                if dist[e] > (dist[v] + 1):
                    dist[e] = dist[v] + 1
                    heapq.heappush(que, (dist[e], e))

        return dist

    dist_cache = {}

    ans = []
    for cc, dd in zip(c, d):
        if dd > cc:
            cc, dd = dd, cc
        if cc - 1 not in dist_cache:
            dist_cache[cc - 1] = dik(G, cc - 1)
        if dist_cache[cc - 1][dd - 1] % 2 == 0:
            ans.append('Town')
        else:
            ans.append('Road')

    return ans


# def solve(N: int, Q: int, a: List[int], b: List[int], c: List[int], d: List[int]) -> List[str]:
def solve_b(N, Q, a, b, c, d):
    dp = [[float('inf') for _ in range(N)] for _ in range(N)]

    for aa, bb in zip(a, b):
        dp[aa - 1][bb - 1] = 1
        dp[bb - 1][aa - 1] = 1

    for i in range(N):
        dp[i][i] = 0

    for k in range(N):
        for i in range(N):
            for j in range(N):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])

    ans = []
    for cc, dd in zip(c, d):
        if dp[cc - 1][dd - 1] % 2 == 0:
            ans.append("Town")
        else:
            ans.append("Road")

    return ans


def solve_c(N, Q, a, b, c, d):
    G = collections.defaultdict(set)

    for aa, bb in zip(a, b):
        G[aa - 1].add(bb - 1)
        G[bb - 1].add(aa - 1)

    def dik(G, s):
        dist = [float('inf') for _ in range(N)]
        dist[s] = 0
        que = []
        heapq.heappush(que, (dist[s], s))

        while que:
            d, v = heapq.heappop(que)

            if d > dist[v]:
                continue

            for e in G[v]:
                if dist[e] > (dist[v] + 1):
                    dist[e] = dist[v] + 1
                    heapq.heappush(que, (dist[e], e))

        return dist

    dist_cache = {}

    ans = []
    for cc, dd in zip(c, d):
        if dd > cc:
            cc, dd = dd, cc
        if cc - 1 not in dist_cache:
            dist_cache[cc - 1] = dik(G, cc - 1)
        if dist_cache[cc - 1][dd - 1] % 2 == 0:
            ans.append('Town')
        else:
            ans.append('Road')

    return ans


def solve_d(N, Q, a, b, c, d):
    G = collections.defaultdict(set)

    for aa, bb in zip(a, b):
        G[aa - 1].add(bb - 1)
        G[bb - 1].add(aa - 1)

    def dfs(G, s, g):
        dist = [-1 for _ in range(N)]
        dist[s] = 0

        que = queue.Queue()
        que.put(s)

        while not que.empty():
            v = que.get()

            for x in G[v]:
                if dist[x] != -1:
                    continue
                dist[x] = dist[v] + 1
                que.put(x)

                if x == g:
                    return dist[x]
        return dist

    for cc, dd in zip(c, d):
        k = dfs(G, cc - 1, dd - 1)
        if k % 2 == 0:
            print('Town')
        else:
            print('Road')


def solve_e(N, Q, a, b, c, d):
    G = collections.defaultdict(set)

    for aa, bb in zip(a, b):
        G[aa - 1].add(bb - 1)
        G[bb - 1].add(aa - 1)

    def dfs(G, s):
        dist = [-1 for _ in range(N)]
        dist[s] = 0

        que = queue.Queue()
        que.put(s)

        while not que.empty():
            v = que.get()

            for x in G[v]:
                if dist[x] != -1:
                    continue
                dist[x] = 1 if dist[v] == 0 else 0
                que.put(x)
        return dist

    dist = dfs(G, 0)

    for cc, dd in zip(c, d):
        if dist[cc - 1] == dist[dd - 1]:
            print('Town')
        else:
            print('Road')


# generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
def main():
    N, Q = map(int, input().split())
    a = [None for _ in range(N - 1)]
    b = [None for _ in range(N - 1)]
    c = [None for _ in range(Q)]
    d = [None for _ in range(Q)]
    for i in range(N - 1):
        a[i], b[i] = map(int, input().split())
    for i in range(Q):
        c[i], d[i] = map(int, input().split())
    e = solve_e(N, Q, a, b, c, d)


if __name__ == '__main__':
    main()
