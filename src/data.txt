from collections import deque

N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
Qn = [list(map(int, input().split())) for _ in range(Q)]

graph = [[] for _ in range(N + 1)]
for A, B in AB:
    graph[A].append(B)
    graph[B].append(A)


def BFS():
    q = deque()
    q.append(1)
    cost[1] = 0
    while q:
        p = q.popleft()
        if visit[p]:
            continue
        visit[p] = True
        for p2 in graph[p]:
            if visit[p2]:
                continue
            cost[p2] = cost[p] + 1
            q.append(p2)
    return


visit = [False] * (N + 1)
cost = [-1] * (N + 1)
BFS()

for C, D in Qn:
    if abs(cost[C] - cost[D]) % 2 == 1:
        print('Road')
    else:
        print('Town')
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]
cd = [list(map(int, input().split())) for _ in range(Q)]

from collections import defaultdict

adj = defaultdict(set)
for a, b in ab:
    adj[a - 1].add(b - 1)
    adj[b - 1].add(a - 1)

from collections import deque

INF = float('inf')


def bfs(start):
    todo = deque()
    todo.append((0, start))  # 初期探索場所をpush
    dists = [INF] * N

    while len(todo) > 0:
        dist, pos = todo.popleft()  # FIFOでpop
        if dists[pos] < INF:
            continue
        dists[pos] = dist

        # 次の位置を探索する
        for next_ in adj[pos]:
            todo.append((dist + 1, next_))
    return dists


dists = bfs(0)

for c, d in cd:
    ans = dists[c - 1] + dists[d - 1]
    print('Road' if ans % 2 == 1 else 'Town')
import sys
from collections import deque

N, Q = map(int, input().split())
visited = [False] * (N + 1)
connected = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, sys.stdin.readline().split())
    connected[a].append(b)
    connected[b].append(a)
distancefromone = [0] * (N + 1)
Que = deque([1])
count = 1
visited[1] = True
while Que:
    for _ in range(len(Que)):
        p = Que.popleft()
        for v in connected[p]:
            if visited[v] == False:
                distancefromone[v] = count
                visited[v] = True
                Que.append(v)
    count += 1
for _ in range(Q):
    c, d = map(int, sys.stdin.readline().split())
    distance = abs(distancefromone[c] - distancefromone[d])
    if distance % 2 == 0:
        print('Town')
    else:
        print('Road')
#!/usr/bin/env python3
import sys

input = sys.stdin.readline

n, q = map(int, input().split())
edge = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)


def dfs(p, v):
    st = [(p, v, 0)]
    visited = [-1] * n
    while st:
        p, v, oe = st.pop()
        visited[v] = oe
        oe = 1 - oe
        for nv in edge[v]:
            if nv == p:
                continue
            st.append((v, nv, oe))
    return visited


visited = dfs(-1, 0)
# print(visited)

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if visited[c] == visited[d]:
        print("Town")
    else:
        print("Road")
from collections import defaultdict

n, m = map(int, input().strip().split())
g = defaultdict(list)
for i in range(n - 1):
    x, y = map(int, input().strip().split())
    g[x - 1].append(y - 1)
    g[y - 1].append(x - 1)

color = [-1] * n
q = [0]
color[0] = 0
while q:
    t = q.pop(0)
    for i in g[t]:
        if color[i] == -1:
            color[i] = color[t] ^ 1
            q.append(i)

for i in range(m):
    x, y = map(int, input().strip().split())
    if color[x - 1] != color[y - 1]:
        print("Road")
    else:
        print("Town")
from collections import deque

N, Q = map(int, input().split())
edge = [[] for _ in range(N)]

color = [-1 for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)

q = deque()

color[0] = 0
q.append(0)

while len(q) > 0:
    node = q.popleft()
    for nx in edge[node]:
        if color[nx] < 0:
            color[nx] = (color[node] + 1) % 2
            q.append(nx)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if color[c] == color[d]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())
ab = [list(map(int, input().split())) for i in range(n - 1)]
cd = [list(map(int, input().split())) for i in range(q)]
import sys

sys.setrecursionlimit(10**7)
from collections import defaultdict, deque

roads = defaultdict(list)
for a, b in ab:
    roads[a - 1].append(b - 1)
    roads[b - 1].append(a - 1)

color = [-1] * n

queue = deque()
queue.append((0, 0))
while len(queue) > 0:
    (node, depth) = queue.pop()
    color[node] = depth
    for i in roads[node]:
        if color[i] >= 0:
            continue
        queue.append((i, depth + 1))

for c, d in cd:
    c, d = c - 1, d - 1
    print("Road" if (color[c] + color[d]) % 2 else "Town")
N, Q = map(int, input().split())
E = {n: [] for n in range(1, 1 + N)}
for i in range(1, N):
    a, b = map(int, input().split())
    E[a] += [b]
    E[b] += [a]  #only forwarding

D = {}  # id, even(i.e. 0) or odd(i.e. 1)
c = 1
for d in range(1, N + 1):
    P = [(c, 0)]
    while P:
        p, path = P.pop(0)  # BFS
        if p in D: continue
        D[p] = path
        for dest in E[p]:
            if dest not in D: P += [(dest, path + 1)]

for i in range(1, Q + 1):
    c, d = map(int, input().split())
    if D[c] % 2 == D[d] % 2: print('Town')
    else: print('Road')
from collections import deque

n, q = map(int, input().split())

g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1] += [b - 1]
    g[b - 1] += [a - 1]

visited = [-1] * n
deq = deque([0])
visited[0] = 0

while deq:
    v = deq.pop()
    for nv in g[v]:
        if visited[nv] != -1:
            continue
        visited[nv] = visited[v] ^ 1
        deq.appendleft(nv)

for _ in range(q):
    c, d = map(int, input().split())
    if visited[c - 1] == visited[d - 1]:
        print('Town')
    else:
        print('Road')import sys


class LCA:
    def __init__(self, n, e):
        self.n = n
        self.g = self._generate_adjacently_list(e)

        self.s = []
        self.f = [0] * n
        self.depth = [0] * n
        self.seen = [False] * n
        self._dfs(0, 0)

        self.INF = (self.n, None)

        self.m = 2 * self.n
        self.m0 = 2**(self.m - 1).bit_length()
        self.data = [self.INF] * (2 * self.m0)
        for i, v in enumerate(self.s):
            self.data[self.m0 - 1 + i] = (self.depth[v], i)
        for i in range(self.m0 - 2, -1, -1):
            self.data[i] = min(self.data[2 * i + 1], self.data[2 * i + 2])

    def _generate_adjacently_list(self, e):
        g = [[] for _ in range(self.n)]
        for a, b in e:
            g[a].append(b)
            g[b].append(a)
        return g

    def _dfs(self, v, d):
        self.f[v] = len(self.s)
        self.depth[v] = d
        self.s.append(v)
        self.seen[v] = True
        for w in self.g[v]:
            if not self.seen[w]:
                self._dfs(w, d + 1)
                self.s.append(v)

    def _query(self, a, b):
        yield self.INF
        a += self.m0
        b += self.m0
        while a < b:
            if b & 1:
                b -= 1
                yield self.data[b - 1]
            if a & 1:
                yield self.data[a - 1]
                a += 1
            a >>= 1
            b >>= 1

    def query(self, u, v):
        fu = self.f[u]
        fv = self.f[v]
        if fu > fv:
            fu, fv = fv, fu
        return self.s[min(self._query(fu, fv + 1))[1]]

    def get_dist(self, u, v):
        return self.depth[u] + self.depth[v] - 2 * self.depth[self.query(u, v)]

    def is_on_path(self, u, v, a):
        return self.get_dist(u, a) + self.get_dist(a, v) == self.get_dist(u, v)


if __name__ == '__main__':
    sys.setrecursionlimit(10**6)

    n, q = map(int, input().split())
    edges = [[int(i) - 1 for i in input().split()] for _ in range(n - 1)]

    lca = LCA(n, edges)

    ans = []
    for _ in range(q):
        c, d = map(lambda x: int(x) - 1, input().split())
        ans.append('Town' if lca.get_dist(c, d) % 2 == 0 else 'Road')

    print('\n'.join(ans))
#!/Users/amitani/Library/PyPy/pypy3.6-v7.3.0-osx64/bin/pypy3
import sys

input = sys.stdin.readline


# Generated by 2.2.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    N, Q = map(int, input().split())
    A = [0] * N
    B = [0] * N
    for i in range(N - 1):
        A[i], B[i] = map(int, input().split())
    C = [0] * Q
    D = [0] * Q
    for i in range(Q):
        C[i], D[i] = map(int, input().split())

    E = [[] for _ in range(N + 1)]
    E[0].append(1)
    for a, b in zip(A, B):
        E[a].append(b)
        E[b].append(a)

    depth = [-1] * (N + 1)  # -1: not processed
    to_visit = [(1, 0)]  # head, pre
    while to_visit:
        head, pre = to_visit.pop()
        #print(head, pre, c, d)
        depth[head] = depth[pre] + 1
        for b in E[head]:
            if b != pre:
                to_visit.append((b, head))
    for c, d in zip(C, D):
        if depth[c] % 2 == depth[d] % 2:
            print('Town')
        else:
            print('Road')

    pass


if __name__ == '__main__':
    main()
import collections

N, Q = map(int, input().split())
# ab=[list(map(int,input().split())) for _ in range(N-1)]

graph = [[] for _ in range(N + 1)]

for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (N + 1)
dist[0] = 0
dist[1] = 0

d = collections.deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

dist = dist[1:]

for i in range(Q):
    c, d = map(int, input().split())
    num = dist[d - 1] - dist[c - 1]
    print('Town' if num % 2 == 0 else 'Road')
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
from collections import defaultdict
import sys

sys.setrecursionlimit(10**9)

N, Q = map(int, input().split())

G = defaultdict(list)
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    G[a].append(b)
    G[b].append(a)

depth = [-1] * N
depth[0] = 0

q = [0]
while q:
    at = q.pop()
    for to in G[at]:
        if depth[to] != -1:
            continue
        depth[to] = depth[at] + 1
        q.append(to)

for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if depth[c] % 2 == depth[d] % 2:
        print("Town")
    else:
        print("Road")
n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

from collections import defaultdict

g = defaultdict(list)
for a, b in ab:
    g[a] += [b]
    g[b] += [a]


# Euler Tour
def dfs(u, d):
    # first visit
    vis = [-1] * (n + 1)
    # euler tour
    et = []
    que = [(u, d)]

    while len(que) > 0:
        u, d = que.pop()
        if u > 0:
            # 行きがけの処理
            vis[u] = len(et)
            et += [(u, d)]
            for v in g[u]:
                if vis[v] == -1:  # 未探索のみ
                    que += [(-v, d + 1)]  # 帰り
                    que += [(v, d + 1)]  # 行き
        else:
            # 帰りがけの処理
            et += [(u, d)]

    return vis, et


vis, et = dfs(1, 0)

t = [t for e, t in et]


def init_min(init_min_val):
    #set_val
    for i in range(n):
        seg_min[i + num_min - 1] = init_min_val[i]
    #built
    for i in range(num_min - 2, -1, -1):
        seg_min[i] = min(seg_min[2 * i + 1], seg_min[2 * i + 2])


def query_min(p, q):
    if q <= p:
        return ide_ele_min
    p += num_min - 1
    q += num_min - 2
    res = ide_ele_min
    while q - p > 1:
        if p & 1 == 0:
            res = min(res, seg_min[p])
        if q & 1 == 1:
            res = min(res, seg_min[q])
            q -= 1
        p = p // 2
        q = (q - 1) // 2
    if p == q:
        res = min(res, seg_min[p])
    else:
        res = min(min(res, seg_min[p]), seg_min[q])
    return res


n = len(t)
ide_ele_min = 10**5 + 1

#num_min:n以上の最小の2のべき乗
num_min = 2**(n - 1).bit_length()
seg_min = [ide_ele_min] * 2 * num_min

#init
init_min(t)

for c, d in cd:
    pc, pd = vis[c], vis[d]
    dc, dd = t[pc], t[pd]
    m = query_min(pc, pd)
    dist = dc + dd - 2 * m

    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
from heapq import heappush, heappop

N, Q = map(int, input().split())
path = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)

dist = [-1] * N
v = [0]
while v:
    idx = heappop(v)
    for i in path[idx]:
        if dist[i] != -1: continue
        dist[i] = dist[idx] + 1
        heappush(v, i)

for i in range(Q):
    c1, d1 = map(int, input().split())
    c1, d1 = c1 - 1, d1 - 1
    #print(c1,d1,dis[c1][d1])
    if abs(dist[c1] - dist[d1]) % 2:
        print('Road')
    else:
        print('Town')
import sys
from collections import deque

N, Q = map(int, input().split())
M = N - 1

g = {i: set() for i in range(1, N + 1)}
for _ in range(M):
    a, b = map(int, input().split())
    g[a].add(b)
    g[b].add(a)

dist = {i: sys.maxsize for i in range(1, N + 1)}
v = {i: False for i in range(1, N + 1)}

que = deque([1])
dist[1] = 0
while que:
    nd = que.popleft()
    v[nd] = True
    for ch in g[nd]:
        dist[ch] = min(dist[nd] + 1, dist[ch])
        if not v[ch]:
            que.append(ch)

for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[c] + dist[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
dist = [-1] * n
que = deque()
que.append(0)
dist[0] = 0
l = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    l[a - 1].append(b - 1)
    l[b - 1].append(a - 1)
while que:
    v = que.popleft()
    d = dist[v]
    for w in l[v]:
        if dist[w] > -1:
            continue
        dist[w] = d + 1
        que.append(w)
for _ in range(q):
    c, d = map(int, input().split())
    k = abs(dist[c - 1] - dist[d - 1])
    if k % 2 == 0:
        print('Town')
    else:
        print('Road')
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

q = queue.Queue()
color = [-1] * N
color[0] = 0
q.put(0)
while not q.empty():
    t = q.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            q.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
import sys, re
from math import ceil, floor, sqrt, pi, factorial, gcd
from copy import deepcopy
from collections import Counter, deque
from heapq import heapify, heappop, heappush
from itertools import accumulate, product, combinations, combinations_with_replacement
from bisect import bisect, bisect_left, bisect_right
from functools import reduce
from decimal import Decimal, getcontext


# input = sys.stdin.readline
def i_input():
    return int(input())


def i_map():
    return map(int, input().split())


def i_list():
    return list(i_map())


def i_row(N):
    return [i_input() for _ in range(N)]


def i_row_list(N):
    return [i_list() for _ in range(N)]


def s_input():
    return input()


def s_map():
    return input().split()


def s_list():
    return list(s_map())


def s_row(N):
    return [s_input for _ in range(N)]


def s_row_str(N):
    return [s_list() for _ in range(N)]


def s_row_list(N):
    return [list(s_input()) for _ in range(N)]


def lcm(a, b):
    return a * b // gcd(a, b)


sys.setrecursionlimit(10**6)
INF = float('inf')
MOD = 10**9 + 7
num_list = []
str_list = []

n, q = map(int, input().split())

inf = 10**6

road = [[] for i in range(n)]
dist = [inf for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)

C = []
D = []

for i in range(q):
    c, d = i_map()
    C.append(c - 1)
    D.append(d - 1)


def bfs():
    que = deque()
    que.append(0)
    dist[0] = 0

    while len(que) != 0:
        p = que.popleft()
        for i in road[p]:
            if dist[i] == inf:
                que.append(i)
                dist[i] = dist[p] + 1
    return


bfs()

for i in range(q):
    judge = (dist[C[i]] - dist[D[i]]) % 2
    if judge == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = list(map(int, input().strip().split()))
tree = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = list(map(int, input().strip().split()))
    a -= 1
    b -= 1
    tree[a] += [b]
    tree[b] += [a]

level = [-1] * N
root = 0
que = deque([root])
level[root] = 0
while que:
    node = que.popleft()
    for neighbor in tree[node]:
        if level[neighbor] == -1:
            que += [neighbor]
            level[neighbor] = level[node] + 1

Ans = ""
for _ in range(Q):
    c, d = list(map(int, input().strip().split()))
    c -= 1
    d -= 1
    if (level[c] - level[d]) % 2 == 0:
        Ans += "Town\n"
    else:
        Ans += "Road\n"
print(Ans)
# import numpy as np
import sys, math, heapq
from itertools import permutations, combinations, accumulate
from collections import defaultdict, Counter, deque
from math import factorial, gcd
from bisect import bisect_left, bisect_right

sys.setrecursionlimit(10**7)
MOD = 10**9 + 7
INF = float("inf")
input = lambda: sys.stdin.readline()[:-1]
pl = lambda x: print(*x, sep="\n")
ceil = lambda x, y: (x + y - 1) // y
trans = lambda l: list(map(list, zip(*l)))

N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]
cd = [list(map(int, input().split())) for _ in range(Q)]

edge = [[] for _ in range(N)]
color = [0] * N

for a, b in ab:
    a, b = a - 1, b - 1
    edge[a].append(b)
    edge[b].append(a)

stack = deque()
stack.append(0)
color[0] = 1
while stack:
    cindex = stack.pop()
    ccolor = color[cindex]
    # seen[cindex] = True
    ncolor = 1 - ccolor
    for nindex in edge[cindex]:
        if color[nindex] == 0:
            stack.append(nindex)
            color[nindex] = ncolor

for c, d in cd:
    c, d = c - 1, d - 1
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())

G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for n in G[t]:
        if color[n] == -1:
            if color[t] == 0:
                color[n] = 1
            else:
                color[n] = 0
            que.put(n)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**6)

n, m = map(int, input().split())
g = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

depth = [0] * (n + 1)


def dfs(cur, last=-1):
    for next in g[cur]:
        if next == last:
            continue
        depth[next] = depth[cur] + 1
        dfs(next, cur)


dfs(1)

for i in range(m):
    c, d = map(int, input().split())
    if (depth[c] - depth[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**8)
from typing import NamedTuple
from operator import itemgetter, attrgetter
from collections import defaultdict, deque, Counter
from itertools import combinations, combinations_with_replacement, permutations
import heapq
import bisect
import math


def main():
    N, Q = map(int, input().split())
    Edge = [[] for _ in range(N)]

    for _ in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        Edge[a].append(b)
        Edge[b].append(a)

    seen = [False] * N
    score = [-1] * N

    score[0] = 0
    stack = [0]

    while stack:
        v = stack.pop()
        seen[v] = True
        for u in Edge[v]:
            if seen[u]:
                continue
            score[u] = score[v] + 1
            stack.append(u)

    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        v = abs(score[c] - score[d])

        if v % 2 == 0:
            ans = "Town"
        else:
            ans = "Road"
        print(ans)


if __name__ == "__main__":
    main()
import sys

input = sys.stdin.readline
f = lambda: map(int, input().split())
n, Q = f()
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = f()
    g[a - 1] += [b - 1]
    g[b - 1] += [a - 1]
B = [-1] * n
B[0] = 0
q = [0]
while q:
    v = q.pop()
    b = B[v] ^ 1
    for c in g[v]:
        if B[c] < 0:
            B[c] = b
            q += [c]
ans = []
for _ in range(Q):
    c, d = f()
    ans += [['Town', 'Road'][B[c - 1] ^ B[d - 1]]]
print(*ans, sep='\n')
from collections import deque
import sys
from typing import Any, List, Tuple, Dict, Set, Callable

sys.setrecursionlimit(10**7)

N, Q = map(int, input().split())
E = [tuple([int(s) for s in input().split()]) for _ in range(N - 1)]
C = [tuple([int(s) for s in input().split()]) for _ in range(Q)]
'''
N = 10 ** 5
Q = 0
E = [(i, i + 1) for i in range(1, N)]
C = []
'''


def calc():
    d_path = {i: [] for i in range(N)}
    for a, b in E:
        d_path[a - 1].append(b - 1)
        d_path[b - 1].append(a - 1)
    # EulerTourを構築
    visit_order = []
    F = [-1] * N  # visit_orderで最初に出現した位置
    depth = [-1] * N
    parent = [-1] * N
    stk = deque([(0, 0)])
    while stk:
        v, d = stk.pop()
        if depth[v] == -1:
            F[v] = len(visit_order)
            depth[v] = d
            visit_order.append(v)
            has_next = False
            for w in d_path[v]:
                if depth[w] == -1:
                    stk.append((w, d + 1))
                    parent[w] = v
                    has_next = True
            if not has_next:
                stk.append((parent[v], d - 1))
        else:
            visit_order.append(v)
            visited_all = True
            for w in d_path[v]:
                if F[w] == -1:
                    visited_all = False
                    break
            if visited_all and parent[v] != -1:
                stk.append((parent[v], d - 1))
    # LCAの前計算

    class SegTree:
        def __init__(self, n: int, init) -> None:
            self.N: int = 1
            while self.N < n:
                self.N *= 2
            self.init: int = init
            self.data: List[int] = [init] * (self.N * 2 + 1)

        # i: 0-index
        def update(self, i: int, v) -> None:
            i += self.N - 1
            self.data[i] = v
            while i > 0:
                i = (i - 1) // 2
                self.data[i] = min(self.data[i * 2 + 1], self.data[i * 2 + 2])

        # a, b: 0-index
        # bを含めない
        def query(self, a: int, b: int):
            return self._query(a, b, 0, 0, self.N)

        def _query(self, a: int, b: int, k: int, l: int, r: int) -> int:
            if r <= a or b <= l:
                return self.init
            if a <= l and r <= b:
                return self.data[k]
            m: int = (l + r) // 2
            return min(self._query(a, b, k * 2 + 1, l, m),
                       self._query(a, b, k * 2 + 2, m, r))

    segtree = SegTree(2 * N, (N, None))
    for i in range(len(visit_order)):
        segtree.update(i, (depth[visit_order[i]], i))
    ans = []
    for c, d in C:
        vo_c = F[c - 1]
        vo_d = F[d - 1]
        if vo_c > vo_d:
            vo_c, vo_d = vo_d, vo_c
        dep, lca = segtree.query(vo_c, vo_d)
        # print(depth[c - 1], depth[d - 1], depth[lca])
        distance = depth[c - 1] + depth[d - 1] - \
            2 * depth[visit_order[lca - 1]]
        ans.append('Town' if distance % 2 == 0 else 'Road')
    return '\n'.join(ans)


print(calc())
from collections import deque

n, q = map(int, input().split())
path = [[] for i in range(n)]
query = []
for i in range(n - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)
for i in range(q):
    c, d = map(int, input().split())
    query.append([c, d])

que = deque()
que.append(0)
city = [-1] * n
city[0] = 0
while len(que) > 0:
    temp = que.pop()
    for i in path[temp]:
        if city[i] != -1:
            continue
        else:
            city[i] = 1 - city[temp]
            que.append(i)

for i in range(q):
    if city[query[i][0] - 1] == city[query[i][1] - 1]:
        print("Town")
    else:
        print("Road")
### ----------------
### ここから
### ----------------

import sys
import itertools
import heapq
from collections import deque
from collections import Counter


def resolve():
    readline = sys.stdin.readline
    #INF = float('inf')
    #NAN = float('nan')
    #N=int(readline())
    N, Q = map(int, readline().rstrip().split())
    Adj = [[] for i in range(N)]
    for i in range(N - 1):
        a, b = map(int, readline().rstrip().split())
        a -= 1
        b -= 1
        Adj[a].append(b)
        Adj[b].append(a)

    q = deque()
    q.appendleft(0)
    DONE = [False] * N
    DONE[0] = True
    D = [float("inf")] * N
    D[0] = 0
    while q:
        p = q.pop()
        for p2 in Adj[p]:
            if DONE[p2]:
                continue
            if (D[p] + 1) < D[p2]:
                D[p2] = D[p] + 1
                DONE[p2] = True
                q.appendleft(p2)

    for i in range(Q):
        c, d = map(int, readline().rstrip().split())
        c -= 1
        d -= 1
        if D[c] % 2 == D[d] % 2:
            print("Town")
        else:
            print("Road")

    #Arr=list(map(int, readline().rstrip().split()))
    #Arr=[list(map(int, readline().rstrip().split())) for _ in range(n)]
    #S=readline().rstrip()
    #print("Yes")
    #print("No")
    #q = deque()
    #c = Counter()

    return


if 'doTest' not in globals():
    resolve()
    sys.exit()

### ----------------
### ここまで
### ----------------
def inputlist():
    return list(map(int, input().split()))


def inputmap():
    return map(int, input().split())


def inputint():
    return int(input())


def inputstr():
    return str(input())


import sys
from collections import Counter
from collections import deque
import bisect
import itertools

sys.setrecursionlimit(10**6)

N, Q = inputmap()
graph = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = inputmap()
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

que = deque()
que.append((0, 0))
depth_list = [-1] * N
while len(que) > 0:
    node, depth = que.pop()
    depth_list[node] = depth
    for child in graph[node]:
        if depth_list[child] != -1:
            continue
        que.append((child, depth + 1))

for i in range(Q):
    c, d = inputmap()
    if (depth_list[c - 1] - depth_list[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
node = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    node[a].append(b)
    node[b].append(a)
# print(node)

CNT = [-1] * n
CNT[0] = 0
d = deque([0])
while d:
    x = d.popleft()
    for y in node[x]:
        if CNT[y] == -1:
            CNT[y] = 1 - CNT[x]
            d.append(y)

for i in range(q):
    c, d = map(int, input().split())
    print('Town' if CNT[c - 1] == CNT[d - 1] else 'Road')
#幅優先探索(グラフ)
import queue

N, Q = map(int, input().split())
dist = [-1 for i in range(N)]  #距離
que = queue.Queue()
nodes = [[] for i in range(N)]

#nodeの入力
for i in range(N - 1):
    a, b = map(int, input().split())
    nodes[a - 1].append(b - 1)
    nodes[b - 1].append(a - 1)

# 始点の設定
que.put(0)
dist[0] = 0

#キューが無くなるまでループ
while not que.empty():
    cur = que.get()

    for next_node in nodes[cur]:
        if dist[next_node] != -1: continue
        que.put(next_node)
        dist[next_node] = dist[cur] + 1

for i in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] + dist[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())

graph = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i in range(q):
    c, d = map(int, input().split())
    if (dist[c] - dist[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
from sys import stdin

input = stdin.readline

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    G[x].append(y)
    G[y].append(x)


def bfs(graph, start):
    from collections import deque
    seen = [False] * len(graph)
    todo = deque()
    color = [0] * len(graph)

    seen[start] = True
    todo.append(start)
    color[start] = 1

    while todo:
        v = todo.popleft()
        for w in graph[v]:
            if seen[w]: continue
            seen[w] = True
            todo.append(w)
            color[w] = color[v] * (-1)

    return color


color = bfs(G, 0)

for q in range(Q):
    c, d = map(lambda n: int(n) - 1, input().split())
    print("Town" if color[c] == color[d] else "Road")
def bfs(s: int) -> None:
    """
    :param s:
        start vertex.
    :variable vertices_num:
        number of vertices the graph has.
    :variable seen:
        memoitize each vertex is already seen or not.
            - initial value (-1)          : means "not seen yet".
            - updated value (zero or more): means "already seen" and its value is the vertex's depth from the root.
    :variable todo:
        vetices adjacent to the vertex in todo will be searched.
    :variable depth:
        the depth at that time.
    """

    # Data Structure for graph search
    vertices_num = len(a_graph)
    seen = [-1] * vertices_num
    seen[s] = 0
    todo = [s]
    depth = 0

    # Continue searching until "todo" becomes empty
    while todo:
        depth += 1
        todo_tmp = []
        # Pull out a vertex from the head of "todo"
        for i in todo:
            # Search all "not-seen" vertices adjacent to vertex-i
            for j in a_graph[i]:
                # Do nothing if vertex-j is already "seen"
                if seen[j] >= 0:
                    continue

                # Make vertex-j "seen", and append it into "todo_tmp"
                seen[j] = depth
                todo_tmp.append(j)

        todo = todo_tmp

    return seen


def create_graph(edge_num: int, edge_list: list) -> dict:
    """
    Create a graph expressed with adjacency list
    :dict_key    : int (a vertex)
    :dict_value  : set (consisted of vertices adjacent to key vertex)
    """
    a_graph = {i: set() for i in range(edge_num)}

    for a, b in edge_list:
        a_graph[a - 1].add(b - 1)  # All graphs always need this line
        a_graph[b - 1].add(a - 1)  # Only undirected graph needs this line

    return a_graph


N, Q = map(int, input().split())
LL1 = [list(map(int, input().split())) for _ in range(N - 1)]
LL2 = [list(map(int, input().split())) for _ in range(Q)]

a_graph = create_graph(N, LL1)
a_list = bfs(0)
for c, d in LL2:
    res = 'Town' if (a_list[c - 1] + a_list[d - 1]) % 2 == 0 else 'Road'
    print(res)
import heapq

N, Q = map(int, input().split())
hq = []
p = [[] for i in range(N)]
lcm = [[] for i in range(N)]
heapq.heapify(hq)
for i in range(N - 1):
    A, B = map(int, input().split())
    p[A - 1].append(B - 1)
    p[B - 1].append(A - 1)
visited = [False for i in range(N)]
score = [float('inf') for i in range(N)]
score[0] = 0
heapq.heappush(hq, [0, 0])
while hq:
    a, b = heapq.heappop(hq)
    if visited[b]:
        continue
    visited[b] = True
    for i in range(len(p[b])):
        if visited[p[b][i]]:
            continue
        d = score[b] + 1
        if d < score[p[b][i]]:
            score[p[b][i]] = d
            heapq.heappush(hq, [d, p[b][i]])
for i in range(Q):
    a, b = map(int, input().split())
    if abs(score[a - 1] - score[b - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
"""
街1からの最短距離が偶数か奇数かで考える.
すると偶数の街から奇数の街へまたは,奇数の街から偶数の街への移動のみとなる.
よってスタートする街が偶数か奇数かが異なっていれば同じ街で会うことはなく,
逆に同じであれば道路で会うことはない.
スタート地点が偶数か奇数かを調べるのみで判定可能なため計算量はO(1*q)=O(q)となる.
"""
from collections import deque

n, q = map(int, input().split())
abl = [list(map(int, input().split())) for _ in range(n - 1)]
cdl = [list(map(int, input().split())) for _ in range(q)]
graph = [[] for _ in range(n + 1)]  # graph[i]: iから繋がっている街一覧(graph[0]不使用)
for a, b in abl:
    graph[a].append(b)
    graph[b].append(a)
dist = [-1] * (n + 1)  # 街1からの距離が偶数か奇数かを記憶
dist[0] = 0  # 不使用
dist[1] = 0  # 街1は街1から0(偶数)
dq = deque([1])
while dq:
    v = dq.popleft()
    for i in graph[v]:
        if dist[i] == -1:
            dist[i] = 1 - dist[v]
            dq.append(i)
for c, d in cdl:
    if dist[c] == dist[d]:
        print('Town')
    else:
        print('Road')
from math import ceil, log2
import sys


def read():
    return sys.stdin.readline().rstrip()


def main():
    n, q = map(int, read().split())
    al = [[] for _ in range(n)]

    for _ in range(n - 1):
        a, b = [int(i) - 1 for i in read().split()]
        al[a].append(b)
        al[b].append(a)
    euler_tour = []
    depth = [0] * n
    todo = [(~0, 0), (0, 0)]
    seen = [False] * n
    while todo:
        v, d = todo.pop()
        if v >= 0:
            seen[v] = True
            depth[v] = d
            euler_tour.append((v, d))
            for u in al[v][::-1]:
                if not seen[u]:
                    todo.append((~u, d + 1))
                    todo.append((u, d + 1))
        else:
            euler_tour.append((~v, d))
    first_appear = [-1] * n
    for i, (v, _) in enumerate(euler_tour):
        if first_appear[v] < 0:
            first_appear[v] = i

    m = ceil(log2(2 * n))
    sparse_table = [[10**9] * m for _ in range(2 * n)]
    for i in range(2 * n):
        sparse_table[i][0] = euler_tour[i][1]
    for k in range(m - 1):
        for i in range(2 * n):
            sparse_table[i][k + 1] = sparse_table[i][k]
            if i + 2**k < 2 * n:
                sparse_table[i][k + 1] = min(sparse_table[i + 2**k][k],
                                             sparse_table[i][k + 1])

    for _ in range(q):
        c, d = [int(i) - 1 for i in read().split()]
        i, j = sorted([first_appear[c], first_appear[d]])
        k = int(log2(j - i))
        dlca = min(sparse_table[i][k], sparse_table[j - 2**k + 1][k])
        print(["Town", "Road"][(depth[c] + depth[d] - 2 * dlca) % 2])


if __name__ == '__main__':
    main()
# モジュールのインポート
import sys

sys.setrecursionlimit(10**6)

readline = sys.stdin.readline


def get_input() -> tuple:
    """
    標準入力を取得する.

    Returns:
        tuple: 標準入力
    """
    # 標準入力を取得
    N, Q = map(int, input().split())
    g = {i: [] for i in range(1, N + 1)}
    for _ in range(N - 1):
        a, b = map(int, readline().split())
        g[a].append(b)
        g[b].append(a)
    q = []
    for _ in range(Q):
        c, d = map(int, readline().split())
        q.append((c, d))

    return N, Q, g, q


def dfs(g: dict, city_depth: dict, depth: int, city: int) -> None:
    """
    街の深さを設定する.

    Args:
        g (dict): 道路
        city_depth (dict): 街の深さ(city_depth[i]: 街iの深さ)
        depth (int): 深さ
        city (int): 街
    """
    if city_depth[city] != -1:
        return
    city_depth[city] = depth
    for nbhd_city in g[city]:
        dfs(g, city_depth, depth + 1, nbhd_city)


def solve(N: int, Q: int, g: dict, q: list) -> None:
    """
    求解処理.

    Args:
        N (int): 街の数(2 <= N <= 10^5)
        Q (int): クエリの数(1 <= Q <= 10^5)
        g (dict): 道路(g[i]: 街iと結ばれている街のリスト)
        q (list): クエリ
    """
    # 求解処理
    city_depth = {i: -1 for i in range(1, N + 1)}
    dfs(g, city_depth, 0, 1)  # 街1をroot nodeとして各街の深さを設定
    for i in range(Q):
        c, d = q[i]
        if abs(city_depth[c] - city_depth[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    # 標準入力を取得
    N, Q, g, q = get_input()

    # 求解処理
    solve(N, Q, g, q)
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()

#幅優先探索+2部グラフ
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
graph = [[] for _ in range(n)]
cnt = []
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)
    cnt.append(a)
    cnt.append(b)

from collections import Counter, deque

cnter = Counter(cnt)
for key, value in cnter.items():
    if value == 1:
        break

dist = [0 for _ in range(n)]
dist[key] = 1
que = deque([key])

while que:
    v1 = que.popleft()
    for v2 in graph[v1]:
        if dist[v2] == 0:
            dist[v2] = dist[v1] * (-1)
            que.append(v2)
for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dist[c] == dist[d]:
        ans = 'Town'
    else:
        ans = 'Road'
    print(ans)
import heapq, math
from collections import defaultdict, deque
from os import getcwd
#from functools import cmp_to_key

import sys, os.path

sys.setrecursionlimit(10000000)

if (os.path.exists('C:/Users/Dhanush/Desktop/cp/input.txt')):
    sys.stdout = open('C:/Users/Dhanush/Desktop/cp/output.txt', 'w')
    sys.stdin = open('C:/Users/Dhanush/Desktop/cp/input.txt', 'r')

input = sys.stdin.readline


def dfs(cur, col):
    colour[cur] = col
    visit[cur] = 1
    for next in d[cur]:
        if (visit[next] == 0):
            dfs(next, 1 - col)


n, q = map(int, input().split())
d = defaultdict(list)
for i in range(n - 1):
    a, b = map(int, input().split())
    d[a].append(b)
    d[b].append(a)
visit = [0 for _ in range(n + 1)]
colour = [-1 for _ in range(n + 1)]
dfs(1, 0)
for i in range(q):
    a, b = map(int, input().split())
    if (colour[a] == colour[b]):
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())

G = [[] for i in range(n)]

for i in range(n - 1):
    ai, bi = map(int, input().split())
    ai -= 1
    bi -= 1
    G[ai].append(bi)
    G[bi].append(ai)

# coloring with bfs
import queue

que = queue.Queue()
que.put(0)
color = [-1 for i in range(n)]
color[0] = 0
while (not (que.empty())):
    par = que.get()
    for ch in G[par]:
        if color[ch] == -1:
            color[ch] = abs(color[par] - 1)
            que.put(ch)

# answer
for i in range(q):
    ci, di = map(int, input().split())
    ci -= 1
    di -= 1
    if (color[ci] != color[di]):
        print("Road")
    else:
        print("Town")
import sys

sys.setrecursionlimit(1000000)

N, Q = map(int, input().split())
G = []
for i in range(N):
    G.append([])
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

visited = [False] * N
eular_tour = []
first_appear = [0] * N
dist = [-1] * N
p = 0
d = 0


def dfs(dep, v, vpre):
    global p
    global d
    if not visited[v]:
        first_appear[v] = p
    visited[v] = True
    eular_tour.append([dep, v])
    dist[v] = d
    p += 1
    d += 1

    for j in G[v]:
        if not visited[j]:
            dfs(dep + 1, j, v)
    if dep > 0:
        eular_tour.append([dep - 1, vpre])
        p += 1
        d -= 1


dfs(0, 0, 0)

for i in range(Q):
    c, d = map(int, input().split())
    D = dist[c - 1] + dist[d - 1]
    if D % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque


def BFS(start):
    dist = [-1] * N
    dist[start] = 0
    que = deque([start])
    while que:
        fr = que.popleft()
        for to in edge[fr]:
            if dist[to] == -1:
                dist[to] = dist[fr] + 1
                que.append(to)

    return dist


N, Q = map(int, input().split())
N_list = list(range(N))
edge = [[] for _ in N_list]
for i in [0] * (N - 1):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)
arr = BFS(0)
ma = [''] * N
for i in range(N):
    if arr[i] % 2 == 0:
        ma[i] = 'R'
    else:
        ma[i] = 'B'

for i in range(Q):
    c, d = map(int, input().split())
    if ma[c - 1] == ma[d - 1]:
        print("Town")
    else:
        print("Road")
n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

from collections import defaultdict

g = defaultdict(list)
for a, b in ab:
    g[a] += [b]
    g[b] += [a]

# Euler Tour の構築


def dfs(u, d):
    F = [0] * (n + 1)
    ET = []
    que = [(1, u, d)]

    while len(que) > 0:
        s, u, d = que.pop()
        #print(s, u, d)
        if s == 1:
            F[u] = len(ET)
            ET += [d]
            for v in g[u]:
                if F[v] == 0:
                    que += [(0, v, d + 1)]
                    que += [(1, v, d + 1)]
        else:
            ET += [d]

    return F, ET


F, ET = dfs(1, 0)


def init_min(init_min_val):
    #set_val
    for i in range(n):
        seg_min[i + num_min - 1] = init_min_val[i]
    #built
    for i in range(num_min - 2, -1, -1):
        seg_min[i] = min(seg_min[2 * i + 1], seg_min[2 * i + 2])


def query_min(p, q):
    if q <= p:
        return ide_ele_min
    p += num_min - 1
    q += num_min - 2
    res = ide_ele_min
    while q - p > 1:
        if p & 1 == 0:
            res = min(res, seg_min[p])
        if q & 1 == 1:
            res = min(res, seg_min[q])
            q -= 1
        p = p // 2
        q = (q - 1) // 2
    if p == q:
        res = min(res, seg_min[p])
    else:
        res = min(min(res, seg_min[p]), seg_min[q])
    return res


n = len(ET)
ide_ele_min = 10**5 + 1

#num_min:n以上の最小の2のべき乗
num_min = 2**(n - 1).bit_length()
seg_min = [ide_ele_min] * 2 * num_min

#init
init_min(ET)

for c, d in cd:
    pc, pd = F[c], F[d]
    dc, dd = ET[pc], ET[pd]
    m = query_min(pc, pd)
    #print(c,d,pc,pd,dc,dd,m)
    dist = dc + dd - 2 * m
    #print(dist, sd[pc:pd+1])
    if dist % 2 == 0:
        print(  #dist, 
            "Town")
    else:
        print(  #dist, 
            "Road")
#!/usr/bin/env python3
from collections import deque


def wfs(num):
    q = deque([[num, 0]])
    while q:
        k, d = q.popleft()
        for i in G[k]:
            if depth[i] == -1:
                depth[i] = d + 1
                q.append([i, depth[i]])
    return


N, Q = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a] += [b]
    G[b] += [a]

depth = [-1] * N
depth[0] = 0

wfs(0)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    delta = abs(depth[c] - depth[d]) % 2

    if delta == 0:
        print("Town")
    else:
        print("Road")
import bisect
import collections
import copy
import functools
import heapq
import itertools
import math
import random
import re
import sys
import time
import string
from typing import List

sys.setrecursionlimit(99999)

n, q = map(int, input().split())
g = collections.defaultdict(list)
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

used = [0] * (n + 1)
depth = [0] * (n + 1)


def dfs(cur, dep):
    used[cur] = 1
    depth[cur] = dep
    for nc in g[cur]:
        if used[nc] == 0:
            dfs(nc, dep ^ 1)


dfs(1, 0)

for _ in range(q):
    m, n = map(int, input().split())
    if depth[m] != depth[n]:
        print("Road")
    else:
        print("Town")
# -*- coding: utf-8 -*-
"""
Created on Sat Jul 10 21:44:36 2021

@author: kazuk
"""

from sys import setrecursionlimit

setrecursionlimit(10**7)
n, q = map(int, input().split())
adj = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)

seen = [-1] * n


def dfs(v, t):
    seen[v] = t % 2
    t += 1
    for nextv in adj[v]:
        if seen[nextv] != -1:
            continue
        dfs(nextv, t)


dfs(0, 0)

for _ in range(q):
    c, d = map(int, input().split())
    if seen[c - 1] == seen[d - 1]:
        print("Town")
    else:
        print("Road")
class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


n, q = map(int, input().split())

g = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

lca = LCA(g)

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    dist = lca.depth[c] + lca.depth[d] - 2 * lca.depth[lca.get(c, d)]
    if dist % 2 == 0:
        ans = "Town"
    else:
        ans = "Road"
    print(ans)
import sys

INF = float('inf')
#10**20,2**63,float('inf')
MOD = 10**9 + 7
MOD2 = 998244353


#from collections import defaultdict
class LcaDoubling:
    """
    links[v] = { (u, w), (u, w), ... }  (u:隣接頂点, w:辺の重み)
    というグラフ情報から、ダブリングによるLCAを構築。
    任意の2頂点のLCAおよび距離を取得できるようにする
    """
    def __init__(self, n, links, root=0):
        self.depths = [-1] * n
        self.distances = [-1] * n
        prev_ancestors = self._init_dfs(n, links, root)
        self.ancestors = [prev_ancestors]
        max_depth = max(self.depths)
        d = 1
        while d < max_depth:
            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]
            self.ancestors.append(next_ancestors)
            d <<= 1
            prev_ancestors = next_ancestors

    def _init_dfs(self, n, links, root):
        q = [(root, -1, 0, 0)]
        direct_ancestors = [-1] * (n + 1
                                   )  # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1
        while q:
            v, p, dep, dist = q.pop()
            direct_ancestors[v] = p
            self.depths[v] = dep
            self.distances[v] = dist
            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)
        return direct_ancestors

    def get_lca(self, u, v):
        du, dv = self.depths[u], self.depths[v]
        if du > dv:
            u, v = v, u
            du, dv = dv, du
        tu = u
        tv = self.upstream(v, dv - du)
        if u == tv:
            return u
        for k in range(du.bit_length() - 1, -1, -1):
            mu = self.ancestors[k][tu]
            mv = self.ancestors[k][tv]
            if mu != mv:
                tu = mu
                tv = mv
        lca = self.ancestors[0][tu]
        assert lca == self.ancestors[0][tv]
        return lca

    def get_distance(self, u, v):
        lca = self.get_lca(u, v)
        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]

    def upstream(self, v, k):
        i = 0
        while k:
            if k & 1:
                v = self.ancestors[i][v]
            k >>= 1
            i += 1
        return v


def solve():
    def II():
        return int(sys.stdin.readline())

    def LI():
        return list(map(int, sys.stdin.readline().split()))

    def LC():
        return list(input())

    def IC():
        return [int(c) for c in input()]

    def MI():
        return map(int, sys.stdin.readline().split())

    N, Q = MI()
    Graph = [[] for _ in range(N)]
    for n in range(N - 1):
        X, Y = MI()
        X -= 1
        Y -= 1
        Graph[X].append((Y, 1))
        Graph[Y].append((X, 1))
    lca = LcaDoubling(N, Graph)
    for _ in range(Q):
        A, B = MI()
        A -= 1
        B -= 1
        if lca.get_distance(A, B) % 2 == 0:
            print("Town")
        else:
            print("Road")
    return


solve()
sys.setrecursionlimit(10**6)  #再帰関数ではコメントにしないこと！！
N, Q = map(int, input().split())

from collections import deque

que = deque()

#いけるとこリスト
connect = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    connect[a].append(b)
    connect[b].append(a)

#いったとこリスト
visited = [False] * (N + 1)

counter = [0] * (N + 1)

que.append(1)
visited[1] = True

while que:
    now = que.popleft()

    for to in connect[now]:
        if visited[to] == False:
            counter[to] = counter[now] + 1
            visited[to] = True
            que.append(to)
#訪問済みリストを初期化
visited = [False] * (N + 1)

for i in range(Q):
    a, b = map(int, input().split())
    if (counter[a] + counter[b]) % 2 == 0:

        print('Town')

    else:
        print('Road')
import sys
import math

sys.setrecursionlimit(10**5)

N, Q = map(int, input().split())
tmpA = [list(map(int, input().split())) for _ in range(N - 1)]
A = [a[0] for a in tmpA]
B = [a[1] for a in tmpA]
tmpB = [list(map(int, input().split())) for _ in range(Q)]
C = [b[0] for b in tmpB]
D = [b[1] for b in tmpB]

# N = 4
# Q = 1
# A = [1, 2, 2]
# B = [2, 3, 4]
# C = [1]
# D = [2]
"""変数初期化"""
route = []
dep = []
"""
A.append[-1]  # 最後の値の判別
B.append[-1]  # 最後の値の判別
"""
"""リスト系初期化"""
for _ in range(N):
    route.append([])
    dep.append(0)
"""ルートの初期化"""
for i in range(N - 1):
    route[A[i] - 1].append(B[i] - 1)
    route[B[i] - 1].append(A[i] - 1)


def dfs(x, last=-1):
    """深さ優先探索"""
    for i in route[x]:
        if (i == last):
            continue
        dep[i] = dep[x] + 1
        dfs(i, x)


dfs(0)

for i in range(Q):
    if ((dep[C[i] - 1] + dep[D[i] - 1]) % 2 == 0):
        print("Town")
    else:
        print("Road")
from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import dijkstra

n, q = [int(v) for v in input().split()]

edges_a = []
edges_b = []
for _ in range(n - 1):
    a, b = [int(v) for v in input().split()]
    edges_a.append(a - 1)
    edges_b.append(b - 1)
g = csr_matrix(([1] * (n - 1), (edges_a, edges_b)), shape=[n, n])

dist = [int(a + 1e-9) for a in dijkstra(csgraph=g, directed=False, indices=0)]

for _ in range(q):
    a, b = [int(v) for v in input().split()]
    if (dist[a - 1] + dist[b - 1]) % 2 == 0: print('Town')
    else: print('Road')
from collections import deque

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1 for i in range(N)]
dist[0] = 0

q = deque([])
q.append((0, 0))

while q:
    p, d = q.popleft()
    for g in G[p]:
        if dist[g] == -1:
            dist[g] = d + 1
            q.append((g, d + 1))
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())

G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
que.put(0)
color = [-1] * N
color[0] = 0
while not que.empty():
    # t = 親になるノード
    t = que.get()
    for i in G[t]:
        # color[i] == -1ならノードIは未探索
        if color[i] == -1:
            color[i] = 1 - color[t]
            # 親のノードとしてquwに追加する
            que.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    elif color[c - 1] != color[d - 1]:
        print("Road")
def resolve():
    from collections import deque
    # クエリ先読みっぽいな
    # 木構造なので最短経路しか無いはず。
    # 距離が偶数なら Town、そうで無いなら Road
    # アルゴリズム名がわからん
    # ダブリング
    N, Q = map(int, input().split(" "))
    EDGE = [set() for _ in range(N)]
    for _ in range(N - 1):
        a, b = [int(x) - 1 for x in input().split(" ")]
        EDGE[a].add(b)
        EDGE[b].add(a)

    k = N.bit_length()
    # データの構築
    D = [[0] * N for _ in range(k)]
    D[0][0] = -1
    nexts = deque()
    nexts.append(0)
    checked = [False] * N
    checked[0] = True
    while nexts:
        current = nexts.popleft()
        for n in EDGE[current]:
            if checked[n]: continue
            checked[n] = True
            D[0][n] = D[0][current] + 1
            nexts.append(n)

    # for i in range(k-1):
    #   for j in range(N):
    #     D[i+1][j]=D[i][D[i][j]]

    for i in range(Q):
        a, b = [int(x) - 1 for x in input().split(" ")]
        # a の深さを求める
        d_a = D[0][a]
        d_b = D[0][b]
        if abs(d_a - d_b) % 2:
            print("Road")
        else:
            print("Town")
        # d_a = 0
        # c = a
        # while c != 0:
        #   D[]


import sys
if sys.argv[-1] == './Main.py':
    resolve()
def dfs(cur, prev):
    global depth, parent
    depth[cur] = depth[prev] + 1
    parent[cur][0] = prev
    for next_ in tree[cur]:
        if next_ != prev:
            dfs(next_, cur)


def addEdge(u, v):
    global tree
    tree[u].append(v)
    tree[v].append(u)


def precompute(n):
    for i in range(1, level):
        for node in range(1, n + 1):
            if parent[node][i - 1] != -1:
                parent[node][i] = parent[parent[node][i - 1]][i - 1]


def lca(u, v):
    if depth[v] < depth[u]:
        u, v = v, u

    diff = depth[v] - depth[u]

    for i in range(level):
        if ((diff >> i) & 1):
            v = parent[v][i]

    if u == v:
        return u

    for i in range(level - 1, -1, -1):
        if (parent[u][i] != parent[v][i]):
            u = parent[u][i]
            v = parent[v][i]

    return parent[u][0]


import sys

sys.setrecursionlimit(200002)

MAXN = 200002
level = 8

tree = [[] for _ in range(MAXN)]
depth = [0 for _ in range(MAXN)]
parent = [[-1 for _ in range(level)] for _ in range(MAXN)]

n, q = map(int, input().split())
for _ in range(n - 1):
    a, b = map(int, input().split())
    addEdge(a, b)

depth[0] = 0
dfs(1, 0)

precompute(n)

for i in range(q):
    c, d = map(int, input().split())
    if (depth[c] + depth[d] - 2 * lca(c, d)) % 2 != 0:
        print("Road")
    else:
        print("Town")
#!python3.8
# -*- coding: utf-8 -*-
# abc209/d
import sys
import re
import math
from collections import *
from itertools import *
from decimal import *
from functools import *

from scipy.sparse import csgraph


def s2ss(s):
    return s.split()


def s2nn(s):
    return list(map(int, s2ss(s)))


def i2s():
    return sys.stdin.readline().rstrip()


def i2ss():
    return s2ss(i2s())


def i2n():
    return int(i2s())


def i2nn():
    return s2nn(i2s())


def debug(*arg):
    return print('DEBUG:', *arg) if sys.argv[1:] else None


import numpy as np
from scipy.sparse.csgraph import shortest_path, dijkstra
from scipy.sparse import csr_matrix

N, Q = i2nn()
n = 2 * (N - 1)
data = [1] * n
row = [None] * n
col = [None] * n
for i in range(0, n, 2):
    a, b = map(lambda x: x - 1, i2nn())
    row[i:i + 2] = [a, b]
    col[i:i + 2] = [b, a]
csr = csr_matrix((data, (row, col)), shape=(N, N), dtype=np.int32)
path = dijkstra(csr, directed=False, indices=0, unweighted=True)
#print(path)
#exit()
for i in range(Q):
    c, d = map(lambda x: x - 1, i2nn())
    x = path[c]
    y = path[d]
    if x % 2 != y % 2:
        print('Road')
    else:
        print('Town')
import sys

input = sys.stdin.readline
from heapq import heappush, heappop


def dijkstra(s, g):  # 始点・隣接グラフ
    INF = 10**18
    check = [False] * n
    dist = [INF] * n
    dist[s] = 0
    q = [(0, s)]  # 距離・ノード
    while q:
        node = heappop(q)[1]  # 今いる所までの距離・そのノード
        if check[node]: continue
        check[node] = True
        for i in g[node]:  # これから行く所までの距離・そのノード
            if check[i]: continue
            if dist[i] <= dist[node] + 1: continue
            dist[i] = dist[node] + 1
            heappush(q, [dist[i], i])
    return dist


n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

cnt = dijkstra(0, g)
for _ in range(q):
    c, d = map(int, input().split())
    if (cnt[c - 1] + cnt[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import collections
from collections import deque

n, q = map(int, input().split())
ab = [map(int, input().split()) for _ in range(n - 1)]
a, b = [list(i) for i in zip(*ab)]
cd = [map(int, input().split()) for _ in range(q)]
c, d = [list(i) for i in zip(*cd)]

g = collections.defaultdict(list)
for frm, to in zip(a, b):
    g[frm].append(to)
    g[to].append(frm)

queue = deque()
visited = [0 for _ in range(n + 1)]
distance = [0 for _ in range(n + 1)]
queue.append(1)
ansz = [1]
# ansz2 = []
before = 0
while len(queue) > 0:
    target = queue.popleft()
    if visited[target] == 1:
        continue
    visited[target] = 1
    for node in g[target]:
        if visited[node] == 1:
            continue
        distance[node] = distance[target] + 1
        # if distance[node] % 2 == 0:
        # ansz.append(node)
        # else:
        # ansz2.append(node)
        queue.append(node)

# print(distance)
for i in range(q):
    if (distance[c[i]] - distance[d[i]]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys, re
from math import ceil, floor, sqrt, pi, factorial, gcd
from copy import copy, deepcopy
from collections import Counter, deque, defaultdict
from heapq import heapify, heappop, heappush
from itertools import accumulate, product, combinations, combinations_with_replacement, permutations
from bisect import bisect, bisect_left, bisect_right
from functools import reduce
from decimal import Decimal, getcontext
from operator import itemgetter
#import numpy as np #pypyでは使用不可
input = sys.stdin.readline


def int_input():
    return int(input())


def int_map():
    return map(int, input().split())


def int_list():
    return list(int_map())


def int_row(N):
    return [int_input() for _ in range(N)]


def int_row_list(N):
    return [int_list() for _ in range(N)]


def str_input():
    return input()[:-1]


def str_map():
    return input().split()


def str_list():
    return list(str_map())


def str_row(N):
    return [str_input() for _ in range(N)]


def str_row_list(N):
    return [list(str_input()) for _ in range(N)]


def lcm(a, b):
    return a * b // gcd(a, b)


sys.setrecursionlimit(10**9)
INF = 1 << 60
MOD = 10**9 + 7
mod = 998244353


#メモリ消費を抑える時はグローバル空間に書く
def main():
    def dfs(g, v, p=-1, d=0):
        depth[v] = d
        for c in g[v]:
            if c == p:
                continue  #探索が親方向へ逆流するのを防ぐ
            dfs(g, c, v, d + 1)  #dを1増やして子頂点へ

        #帰りがけ時に、部分木のサイズを求める
        subtree_size[v] = 1  #自分自身
        for c in g[v]:
            if c == p:
                continue
            #子頂点を根とする部分木のサイズを加算する
            subtree_size[v] += subtree_size[c]

    n, q = int_map()  #頂点数(木なので辺数はn - 1で確定)
    g = [[] for _ in range(n)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        g[a].append(b)
        g[b].append(a)

    #探索
    root = 0
    depth = [0] * n
    subtree_size = [0] * n
    dfs(g, root)

    #結果
    lis = [] * n
    for v in range(n):
        lis.append(depth[v])

    for i in range(q):
        c, d = int_map()
        c -= 1
        d -= 1
        if (lis[c] - lis[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
import typing
import sys
import math
import collections
import bisect
import itertools
import heapq
import copy

# ===TEMPLATE==
# sys.setrecursionlimit(10**7+1)
# inf = float('inf')
inf = 10**20
mod = 10**9 + 7
# mod = 998244353


def ni():
    return int(sys.stdin.buffer.readline())


def ns():
    return map(int, sys.stdin.buffer.readline().split())


def na():
    return list(map(int, sys.stdin.buffer.readline().split()))


def na1():
    return list(map(lambda x: int(x) - 1, sys.stdin.buffer.readline().split()))


def nall():
    return list(map(int, sys.stdin.buffer.read().split()))


def flush():
    return sys.stdout.flush()


def nic():
    return int(sys.stdin.readline())


def nsc():
    return map(int, sys.stdin.readline().split())


def nac():
    return list(map(int, sys.stdin.readline().split()))


def na1c():
    return list(map(lambda x: int(x) - 1, sys.stdin.readline().split()))


# ===CODE===
def main():
    n, q = ns()
    e = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = na1()
        e[a].append(b)
        e[b].append(a)

    dist = [inf for _ in range(n)]
    dist[0] = 0
    que = collections.deque()
    que.append([0, 0])
    while que:
        idx, d = que.popleft()
        for nidx in e[idx]:
            if dist[nidx] == inf:
                dist[nidx] = d + 1
                que.append([nidx, d + 1])

    for _ in range(q):
        ci, di = na1()
        res = dist[ci] - dist[di]
        print("Town" if res % 2 == 0 else "Road")


if __name__ == '__main__':
    main()
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**6)


def main():
    n, q = map(int, input().split())
    g = [[] for i in range(n)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)
    dist = [-1] * n
    seen = [False] * n
    dist[0] = 0

    def dfs(i):
        if seen[i]: return
        seen[i] = True
        for j in g[i]:
            dist[j] = (dist[i] + 1) % 2
            dfs(j)

    dfs(0)
    for i in range(q):
        c, d = map(int, input().split())
        c, d = c - 1, d - 1
        if dist[c] == dist[d]:
            print('Town')
        else:
            print('Road')


main()
import sys

sys.setrecursionlimit(1000000)


def main():
    N, Q = [int(x) for x in input().split()]

    # 隣接リスト形式でグラフをつくる
    # 重み付きの場合は、[行き先, weight]をそれぞれの行に持たせれば良い。
    graph = [[] for i in range(N)]
    for i in range(N - 1):
        a, b = [int(x) for x in input().split()]
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)

    queries = []
    for i in range(Q):
        c, d = [int(x) for x in input().split()]
        queries.append([c - 1, d - 1])

    distances = [-1 for x in range(N)]
    distances[0] = 0
    dfs(graph, distances, 0)

    for query in queries:
        if (distances[query[0]] - distances[query[1]]) % 2 == 0:
            print("Town")
        else:
            print("Road")


def dfs(graph, distances, current_node):
    next_nodes = graph[current_node]
    for next_node in next_nodes:
        if distances[next_node] < 0:
            distances[next_node] = distances[current_node] + 1
            dfs(graph, distances, next_node)


if __name__ == "__main__":
    main()
n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

from collections import deque

P = [0] * n
used = [False] * n
dq = deque([0])
while dq:
    v = dq.popleft()
    if used[v]: continue
    used[v] = True
    for u in G[v]:
        P[u] = P[v] + 1
        dq.append(u)

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (P[c] + P[d]) % 2: print('Road')
    else: print('Town')
import sys

sys.setrecursionlimit(4100000)
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
color = [-1] * N


def dfs(x, par, now):
    color[x] = now
    for u in G[x]:
        if u != par and color[u] == -1:
            dfs(u, x, 1 - now)


dfs(0, -1, 0)
for _ in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())
adj = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)
c = [0] * q
d = [0] * q
for i in range(q):
    c[i], d[i] = map(int, input().split())
    c[i] -= 1
    d[i] -= 1

from collections import deque

dist = [-1] * n
que = deque([0])
dist[0] = 0
while que:
    v = que.popleft()
    e = dist[v]
    for w in adj[v]:
        if dist[w] > -1:
            continue
        dist[w] = e + 1
        que.append(w)

for i in range(q):
    ans = dist[c[i]] - dist[d[i]]
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = list(map(int, input().split()))

K = [[] for _ in range(N + 1)]
nums = [float("inf") for _ in range(N + 1)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    K[a].append(b)
    K[b].append(a)


def bfs(now, parent):
    que = deque()
    que.append((now, parent))

    while que:
        now, parent = que.popleft()
        for i in K[now]:
            if nums[i] == float("inf"):
                nums[i] = nums[now] + 1
                que.append((i, now))


nums[1] = 0
bfs(1, 0)

for _ in range(Q):
    c, d = map(int, input().split())
    cd = nums[c] - nums[d]
    if cd % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Query = map(int, input().split())

G = []
for _ in range(N):
    G.append([])
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1] * N

Q = deque()
Q.append(0)
dist[0] = 0

while len(Q) > 0:

    i = Q.popleft()

    for j in G[i]:
        if dist[j] == -1:
            dist[j] = dist[i] + 1
            Q.append(j)

for i in range(N):
    if dist[i] % 2 == 0:
        dist[i] = 1
    else:
        dist[i] = 2

for _ in range(Query):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dist[c] == dist[d]:
        print('Town')
    else:
        print('Road')
#!/usr/bin/env python3
# from typing import *
import collections
import heapq
import queue


def solve_a(N, Q, a, b, c, d):
    G = collections.defaultdict(set)

    for aa, bb in zip(a, b):
        G[aa - 1].add(bb - 1)
        G[bb - 1].add(aa - 1)

    def dik(G, s):
        dist = [float('inf') for _ in range(N)]
        dist[s] = 0
        que = []
        heapq.heappush(que, (dist[s], s))

        while que:
            d, v = heapq.heappop(que)

            if d > dist[v]:
                continue

            for e in G[v]:
                if dist[e] > (dist[v] + 1):
                    dist[e] = dist[v] + 1
                    heapq.heappush(que, (dist[e], e))

        return dist

    dist_cache = {}

    ans = []
    for cc, dd in zip(c, d):
        if dd > cc:
            cc, dd = dd, cc
        if cc - 1 not in dist_cache:
            dist_cache[cc - 1] = dik(G, cc - 1)
        if dist_cache[cc - 1][dd - 1] % 2 == 0:
            ans.append('Town')
        else:
            ans.append('Road')

    return ans


# def solve(N: int, Q: int, a: List[int], b: List[int], c: List[int], d: List[int]) -> List[str]:
def solve_b(N, Q, a, b, c, d):
    dp = [[float('inf') for _ in range(N)] for _ in range(N)]

    for aa, bb in zip(a, b):
        dp[aa - 1][bb - 1] = 1
        dp[bb - 1][aa - 1] = 1

    for i in range(N):
        dp[i][i] = 0

    for k in range(N):
        for i in range(N):
            for j in range(N):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])

    ans = []
    for cc, dd in zip(c, d):
        if dp[cc - 1][dd - 1] % 2 == 0:
            ans.append("Town")
        else:
            ans.append("Road")

    return ans


def solve_c(N, Q, a, b, c, d):
    G = collections.defaultdict(set)

    for aa, bb in zip(a, b):
        G[aa - 1].add(bb - 1)
        G[bb - 1].add(aa - 1)

    def dik(G, s):
        dist = [float('inf') for _ in range(N)]
        dist[s] = 0
        que = []
        heapq.heappush(que, (dist[s], s))

        while que:
            d, v = heapq.heappop(que)

            if d > dist[v]:
                continue

            for e in G[v]:
                if dist[e] > (dist[v] + 1):
                    dist[e] = dist[v] + 1
                    heapq.heappush(que, (dist[e], e))

        return dist

    dist_cache = {}

    ans = []
    for cc, dd in zip(c, d):
        if dd > cc:
            cc, dd = dd, cc
        if cc - 1 not in dist_cache:
            dist_cache[cc - 1] = dik(G, cc - 1)
        if dist_cache[cc - 1][dd - 1] % 2 == 0:
            ans.append('Town')
        else:
            ans.append('Road')

    return ans


def solve_d(N, Q, a, b, c, d):
    G = collections.defaultdict(set)

    for aa, bb in zip(a, b):
        G[aa - 1].add(bb - 1)
        G[bb - 1].add(aa - 1)

    def dfs(G, s, g):
        dist = [-1 for _ in range(N)]
        dist[s] = 0

        que = queue.Queue()
        que.put(s)

        while not que.empty():
            v = que.get()

            for x in G[v]:
                if dist[x] != -1:
                    continue
                dist[x] = dist[v] + 1
                que.put(x)

                if x == g:
                    return dist[x]
        return dist

    for cc, dd in zip(c, d):
        k = dfs(G, cc - 1, dd - 1)
        if k % 2 == 0:
            print('Town')
        else:
            print('Road')


def solve_e(N, Q, a, b, c, d):
    G = collections.defaultdict(set)

    for aa, bb in zip(a, b):
        G[aa - 1].add(bb - 1)
        G[bb - 1].add(aa - 1)

    def dfs(G, s):
        dist = [-1 for _ in range(N)]
        dist[s] = 0

        que = queue.Queue()
        que.put(s)

        while not que.empty():
            v = que.get()

            for x in G[v]:
                if dist[x] != -1:
                    continue
                dist[x] = 1 if dist[v] == 0 else 0
                que.put(x)
        return dist

    dist = dfs(G, 0)

    for cc, dd in zip(c, d):
        if dist[cc - 1] == dist[dd - 1]:
            print('Town')
        else:
            print('Road')


# generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
def main():
    N, Q = map(int, input().split())
    a = [None for _ in range(N - 1)]
    b = [None for _ in range(N - 1)]
    c = [None for _ in range(Q)]
    d = [None for _ in range(Q)]
    for i in range(N - 1):
        a[i], b[i] = map(int, input().split())
    for i in range(Q):
        c[i], d[i] = map(int, input().split())
    e = solve_e(N, Q, a, b, c, d)


if __name__ == '__main__':
    main()
import queue
import sys

input = sys.stdin.readline

N, Q = map(int, input().split())
r = [[] for _ in range(N)]
que = queue.Queue()
for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    r[a].append(b)
    r[b].append(a)
dep = [-1] * N
dep[0] = 0
que.put(0)
while not que.empty():
    id = que.get()
    for i in r[id]:
        if dep[i] == -1:
            dep[i] = dep[id] + 1
            que.put(i)
col = ['Town', 'Road']
for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print(col[(dep[c] - dep[d]) % 2])
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())

R = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    R[a].append(b)
    R[b].append(a)

bw = [None] * (n + 1)


def func(_bw, _r, a, b):
    _bw[b] = not _bw[a]

    for e in _r[b]:
        if e == a:
            continue
        func(_bw, _r, b, e)


bw[1] = True
for b in R[1]:
    func(bw, R, 1, b)

for _ in range(q):
    c, d = map(int, input().split())

    if bw[c] == bw[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())

R = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    R[a].append(b)
    R[b].append(a)

D = [-1] * N
D[0] = 0
queue = deque([0])
while queue:
    nxt = queue.popleft()
    for i in R[nxt]:
        if D[i] == -1:
            queue.append(i)
            D[i] = D[nxt] + 1

for _ in range(Q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if b > a:
        a, b = b, a
    if (D[a] - D[b]) % 2 == 0:
        print("Town")
    else:
        print("Road")
def dfs(cur, prev):
    global depth, parent
    depth[cur] = depth[prev] + 1
    parent[cur][0] = prev
    for next_ in tree[cur]:
        if next_ != prev:
            dfs(next_, cur)


def addEdge(u, v):
    global tree
    tree[u].append(v)
    tree[v].append(u)


def precompute(n):
    for i in range(1, level):
        for node in range(1, n + 1):
            if parent[node][i - 1] != -1:
                parent[node][i] = parent[parent[node][i - 1]][i - 1]


def lca(u, v):
    if depth[v] < depth[u]:
        u, v = v, u

    diff = depth[v] - depth[u]

    for i in range(level):
        if ((diff >> i) & 1):
            v = parent[v][i]

    if u == v:
        return u

    for i in range(level - 1, -1, -1):
        if (parent[u][i] != parent[v][i]):
            u = parent[u][i]
            v = parent[v][i]

    return parent[u][0]


import sys

sys.setrecursionlimit(200002)

MAXN = 200002
level = 2

tree = [[] for _ in range(MAXN)]
depth = [0 for _ in range(MAXN)]
parent = [[-1 for _ in range(level)] for _ in range(MAXN)]

n, q = map(int, input().split())
for _ in range(n - 1):
    a, b = map(int, input().split())
    addEdge(a, b)

depth[0] = 0
dfs(1, 0)

precompute(n)

for i in range(q):
    c, d = map(int, input().split())
    if (depth[c] + depth[d] - 2 * lca(c, d)) % 2 != 0:
        print("Road")
    else:
        print("Town")
import sys
from collections import deque

sys.setrecursionlimit(10**7)


def I():
    return int(sys.stdin.readline().rstrip())


def MI():
    return map(int, sys.stdin.readline().rstrip().split())


def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def LI2():
    return list(map(int, sys.stdin.readline().rstrip()))


def S():
    return sys.stdin.readline().rstrip()


def LS():
    return list(sys.stdin.readline().rstrip().split())


def LS2():
    return list(sys.stdin.readline().rstrip())


N, Q = MI()
Graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = MI()
    a -= 1
    b -= 1
    Graph[a].append(b)
    Graph[b].append(a)

dist = [-1] * N
deq = deque([0])
dist[0] = 0
while deq:
    i = deq.pop()
    for j in Graph[i]:
        if dist[j] == -1:
            dist[j] = 1 ^ dist[i]
            deq.append(j)

for _ in range(Q):
    c, d = MI()
    c -= 1
    d -= 1
    if dist[c] == dist[d]:
        print('Town')
    else:
        print('Road')
import queue

N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
dist = [100000000 for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

que = queue.Queue()
que.put((0, 0))
while not que.empty():
    p, c = que.get()
    if dist[p] == 100000000:
        dist[p] = c
        for e in graph[p]:
            que.put((e, c + 1))

for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
g = [[] for _ in range(n + 1)]
A = [0] * (n + 1)
for _ in range(n - 1):
    a, b = [int(x) for x in input().split()]
    g[a].append(b)
    g[b].append(a)
    A[a] += 1
    A[b] += 1

x = A.index(1)
D = []


def bfs(u):
    queue = deque([u])
    d = [None] * (n + 1)  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


ans = bfs(x)
for i in range(q):
    c, d = map(int, input().split())
    val = ans[c] - ans[d]
    if val % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue


def main():
    N, Q = map(int, input().split())
    town = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        town[a - 1].append(b - 1)
        town[b - 1].append(a - 1)

    que = queue.Queue()
    que.put(0)
    # print(que.get())
    color = [-1] * N
    color[0] = 0
    while not que.empty():
        t = que.get()
        for i in town[t]:
            if color[i] == -1:
                color[i] = 1 - color[t]
                que.put(i)

    for _ in range(Q):
        c, d = map(int, input().split())
        if color[c - 1] == color[d - 1]:
            print('Town')
        else:
            print("Road")


if __name__ == '__main__':
    main()
from heapq import heappush, heappop

INF = 10**9
A, B = map(int, input().split())
adj = [[] for _ in range(A)]
q = []
for i in range(A - 1):
    l, m = map(int, input().split())
    adj[l - 1].append((m - 1, 1))
    adj[m - 1].append((l - 1, 1))
for i in range(B):
    q.append(list(map(int, input().split())))


def dijkstra(s, n):  # (始点, ノード数)
    dist = [INF] * n
    hq = [(0, s)]  # (distance, node)
    dist[s] = 0
    seen = [False] * n  # ノードが確定済みかどうか
    while hq:
        v = heappop(hq)[1]  # ノードを pop する
        seen[v] = True
        for to, cost in adj[v]:  # ノード v に隣接しているノードに対して
            if seen[to] == False and dist[v] + cost < dist[to]:
                dist[to] = dist[v] + cost
                heappush(hq, (dist[to], to))
    return dist


d = dijkstra(0, A)
for i in range(B):
    dif = d[q[i][1] - 1] - d[q[i][0] - 1]
    if dif % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

inf = 10**24


def BFS(s):
    cost = [inf] * n
    cost[s] = 0
    q = deque([s])
    while q:
        x = q.popleft()
        for y in g[x]:
            if cost[y] == inf:
                cost[y] = cost[x] + 1
                q.append(y)
    return cost


cost = BFS(0)
for _ in range(q):
    c, d = map(int, input().split())
    if (cost[c - 1] + cost[d - 1]) % 2:
        print('Road')
    else:
        print('Town')
import sys
from collections import defaultdict, deque


def main(f):
    global children, parity
    mod = 10**9 + 7
    N, Q = list(map(int, f.readline().split()))
    children = [[] for _ in range(N + 1)]
    parity = [None] * (N + 1)
    for i in range(1, N):
        a, b = list(map(int, f.readline().split()))
        children[a].append(b)
        children[b].append(a)

    q = deque()
    parity[1] = 1
    q.append((1, -1))
    while q:
        i, parent = q.popleft()
        for j in children[i]:
            if j == parent:
                continue
            parity[j] = -parity[i]
            q.append((j, i))

    for i in range(1, Q + 1):
        c, d = list(map(int, f.readline().split()))
        if parity[c] == parity[d]:
            print('Town')
        else:
            print('Road')


main(sys.stdin)
from collections import deque

n, q = map(int, input().split())

G = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int,
               input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1] * n
que = deque()

dist[0] = 0
que.append(0)

while que:
    v = que.popleft()

    for nv in G[v]:
        if dist[nv] != -1: continue

        dist[nv] = dist[v] + 1
        que.append(nv)

for i in range(q):
    c, d = map(int, input().split())
    t = abs(dist[c - 1] - dist[d - 1])
    if t % 2 == 1:
        print("Road")
    else:
        print("Town")
import sys


def main():
    input = sys.stdin.readline
    N, Q = map(int, input().split())
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        G[a].append(b)
        G[b].append(a)
    dist = [-1] * N
    stk = [0]
    dist[0] = 0
    while stk:
        v = stk.pop()
        for nv in G[v]:
            if dist[nv] >= 0: continue
            dist[nv] = dist[v] + 1
            stk.append(nv)
    for _ in range(Q):
        c, d = map(int, input().split())
        c, d = c - 1, d - 1
        if dist[c] & 1 != dist[d] & 1:
            print('Road')
        else:
            print('Town')


if __name__ == '__main__':
    main()
import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from collections import Counter
from collections import defaultdict as dd
from collections import deque

# sys.setrecursionlimit(100000000)

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))
stdmap = lambda: map(int, stdstr().split())
stdarr = lambda: list(map(int, stdstr().split()))

mod = 1000000007


def BFS(node, graph):
    global n
    visited = [False] * (n + 1)

    distance = [0] * (n + 1)

    q = deque([node])

    while (q):
        curr = q.popleft()
        visited[curr] = True

        for i in graph[curr]:
            if (not visited[i]):
                distance[i] = distance[curr] + 1
                q.append(i)

    return distance


n, q = stdmap()

graph = dd(list)

for i in range(n - 1):
    a, b = stdmap()

    graph[a].append(b)
    graph[b].append(a)

dx = BFS(1, graph)

for _ in range(q):
    c, d = stdmap()

    diff = abs(dx[c] - dx[d])

    if (diff % 2 == 0):
        print("Town")
    else:
        print("Road")
import collections


def BSF(G, s):
    N = len(G)
    dist = [-1] * N
    que = collections.deque()

    dist[s] = 0
    que.append(s)

    while que:
        v = que.popleft()

        for i in G[v]:
            if dist[i] != -1:
                continue
            dist[i] = dist[v] + 1
            que.append(i)

    return dist


N, Q = map(int, input().split())

AB = [list(map(int, input().split())) for _ in range(N - 1)]

G = []
for i in range(N):
    G.append(set())

for i in range(N - 1):
    G[AB[i][0] - 1].add(AB[i][1] - 1)
    G[AB[i][1] - 1].add(AB[i][0] - 1)

dist1 = BSF(G, 0)
M = max(dist1)
Mi = dist1.index(M)
dist2 = BSF(G, Mi)

for _ in range(Q):
    c, d = map(int, input().split())
    if (dist2[c - 1] + dist2[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from heapq import heappush, heappop
import sys  # 入力高速化

input = sys.stdin.readline


def dijkstra(s, graph):  # (始点, グラフのリスト)
    INF = 10**18
    dist = [INF] * n  # INF で初期化
    check = [False] * n  # Bool
    dist[s] = 0
    q = [(0, s)]  # （距離・ノード）
    while q:
        v = heappop(q)[1]  # 今いるノード
        if check[v]: continue  # すでに行っていたらcontinue
        check[v] = True  # 訪問済み
        for i, j in graph[v]:  # 先のノード・距離
            if check[i] != False: continue
            if dist[i] <= dist[v] + j: continue
            dist[i] = dist[v] + j
            heappush(q, (dist[i], i))  # 必ず[0]が距離になるように（優先度付きキュー）
    return dist


n, Q = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append((b - 1, 1))
    g[b - 1].append((a - 1, 1))

num_a = dijkstra(0, g)
#print("スタートから",num_a)
ma = max(num_a)
for i in range(n):
    if ma == num_a[i]:
        ind = i
        break

num_b = dijkstra(ind, g)
#print("最大から", num_b, ind)

for _ in range(Q):
    c, d = map(int, input().split())
    if num_a[c - 1] < num_a[d - 1]:
        x = num_a[d - 1]
        y = num_a[c - 1]
    else:
        x = num_a[c - 1]
        y = num_a[d - 1]
    #print(i,x,y)
    if abs(y - x) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**7)

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines


def main():
    N, Q = map(int, input().split())
    AB = [list(map(int, input().split())) for _ in range(N - 1)]
    CD = [list(map(int, input().split())) for _ in range(Q)]

    PATH = [[] for _ in range(N + 1)]
    for a, b in AB:
        PATH[a].append(b)
        PATH[b].append(a)

    POS = [True] * (N + 1)
    q = [(1, True, -1)]
    while q:
        u, t, parent = q.pop()
        for v in PATH[u]:
            if v == parent:
                continue

            POS[v] = not (t)
            q.append((v, not (t), u))

    # print(POS)

    ans = []
    for c, d in CD:
        if POS[c] == POS[d]:
            ans.append("Town")
        else:
            ans.append("Road")

    print("\n".join(ans))

    return


if __name__ == "__main__":
    main()
from collections import deque

N, Q = map(int, input().split())
# ab[i]にはiから一歩でいける点が入ります。
ab = [set() for _ in range(N)]
c = []
d = []
for i in range(N - 1):
    holda, holdb = map(lambda x: int(x) - 1, input().split())
    ab[holda].add(holdb)
    ab[holdb].add(holda)
for i in range(Q):
    holdc, holdd = map(lambda x: int(x) - 1, input().split())
    c.append(holdc)
    d.append(holdd)

# 判定するのは町で出会うか道路で出会うかのみです。
# もちろん高橋くんから青木くんへ向かうのと青木くんから高橋くんへ向かのは同じルートを通るので、考えるのはc[i],d[i]の最短距離の間にある町の数が偶数か奇数かということだけです。
# 点1から幅優先探索して全部の点への距離を求めます。そして、任意の二点の距離は点1からの距離の差で与えることができます。

queue = deque([0])
# 発見されたかされてないかを管理します。
seen = N * [False]
seen[0] = True
# dist[i]には0からiまでの最短距離が入ります。
dist = N * [-1]
depth = 0
dist[0] = 0

# 幅優先探索
while len(queue) > 0:
    # まずqueueからひとつpop()します
    now = queue.pop()
    # nowから一歩で行ける点を探索します。
    for nextp in ab[now]:
        if not seen[nextp]:
            queue.appendleft(nextp)
            # queueに追加したら発見済みです。
            seen[nextp] = True
            # このループはすべて同じ深さです。深さはnowの深さ+1で与えます。
            dist[nextp] = dist[now] + 1

# クエリに答えます。
for i in range(Q):
    if abs(dist[c[i]] - dist[d[i]]) % 2 == 1:
        print("Road")
    else:
        print("Town")
import collections, sys

sys.setrecursionlimit(10**8)

N, Q = map(int, input().split())
graph = [[] for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

dist = [-1] * N

q = collections.deque([0])

while q:
    v = q.popleft()
    for n_v in graph[v]:
        if dist[n_v] != -1: continue
        dist[n_v] = dist[v] + 1
        q.append(n_v)

# dist[0] = 0

# def DFS(v):
# 	for n_v in graph[v]:
# 		if dist[n_v] != -1: continue
# 		dist[n_v] = dist[v] + 1
# 		DFS(n_v)

# DFS(0)

for _ in range(Q):
    c, d = map(int, input().split())
    if dist[c - 1] + dist[d - 1] & 1:
        print('Road')
    else:
        print('Town')
#D
from collections import deque


def bfs(x):
    e[x] = 0
    v = deque([x])

    while v:
        y = v.pop()
        for z in L[y]:
            if e[z] == -1:
                e[z] = e[y] + 1
                v.append(z)


###############################################

N, Q = map(int, input().split())
a = [0] * (N - 1)
b = [0] * (N - 1)
L = [[] for _ in range(N)]

for i in range(N - 1):
    a[i], b[i] = map(int, input().split())
    a[i] -= 1
    b[i] -= 1
    L[a[i]].append(b[i])
    L[b[i]].append(a[i])

e = [-1] * N  #距離・訪問
bfs(0)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    dist = abs(e[c] - e[d])
    if dist % 2 == 0:
        ans = "Town"
    else:
        ans = "Road"
    print(ans)
import queue

num = [int(s) for s in input().split()]

N = num[0]
Q = num[1]

route = [[] for i in range(N)]

for i in range(N - 1):
    temp = [int(s) for s in input().split()]
    route[temp[0] - 1].append(temp[1] - 1)
    route[temp[1] - 1].append(temp[0] - 1)

que = queue.Queue()

color = [-1] * N

color[0] = 0

que.put(0)

while not que.empty():
    t = que.get()
    for i in route[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
def main():
    import sys
    input = sys.stdin.readline
    sys.setrecursionlimit(10**7)
    from collections import Counter, deque, defaultdict
    from itertools import combinations, permutations, accumulate, groupby, product
    from bisect import bisect_left, bisect_right
    from heapq import heapify, heappop, heappush
    from math import floor, ceil, pi, factorial, gcd, sqrt

    def I():
        return int(input())

    def MI():
        return map(int, input().split())

    def LI():
        return list(map(int, input().split()))

    def SI():
        return input().rstrip()

    inf = 10**17
    mod = 10**9 + 7
    #mod =998244353
    n, q = MI()
    adj = [[] for i in range(n)]
    for i in range(n - 1):
        a, b = MI()
        a -= 1
        b -= 1
        adj[a].append(b)
        adj[b].append(a)
    dist = [0] * n
    Q = deque([0])
    visited = [0] * n
    visited[0] = 1
    while Q:
        x = Q.popleft()
        for nex in adj[x]:
            if visited[nex]:
                continue
            dist[nex] = dist[x] + 1
            Q.append(nex)
            visited[nex] = 1
    #print(dist)
    for i in range(q):
        c, d = MI()
        c -= 1
        d -= 1
        if (dist[c] - dist[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
import sys
from pprint import pprint
from typing import List
from collections import deque
import itertools
from bisect import bisect

input = sys.stdin.readline
sys.setrecursionlimit = 10**6

MOD = 10**9 + 7


def d():
    N, Q = map(int, input().split())
    paths = [[] for _ in range(N)]

    for _ in range(N - 1):
        a, b = map(int, input().split())
        paths[a - 1].append(b - 1)
        paths[b - 1].append(a - 1)

    # pprint(paths)

    dist = []
    for _ in range(N):
        dist.append(-1)

    deq = deque()

    deq.append(0)

    dist[0] = 0

    while deq:
        i = deq.popleft()
        for j in paths[i]:
            if dist[j] == -1:
                dist[j] = dist[i] + 1
                deq.append(j)

    # pprint(dist)

    def inspect(c, d):
        c -= 1
        d -= 1
        if dist[c] % 2 == dist[d] % 2:
            return 'Town'
        else:
            return 'Road'

    ans = []
    for _ in range(Q):
        c, d = map(int, input().split())
        ans.append(inspect(c, d))

    for i in ans:
        print(i)

    return


if __name__ == '__main__':
    d()
from collections import deque


def bfs(graph, N):
    parities = [None] * N
    parities[0] = 0
    que = deque([0])
    while que:
        node = que.popleft()
        p = parities[node] ^ 1
        for n in graph[node]:
            if parities[n] is None:
                parities[n] = p
                que.append(n)
    return parities


N, _, *R = map(int, open(0).read().split())
M = 2 * (N - 1)
R = [r - 1 for r in R]
E = R[:M]
Q = R[M:]
graph = [[] for _ in range(N)]
for a, b in zip(E[::2], E[1::2]):
    graph[a].append(b)
    graph[b].append(a)
parities = bfs(graph, N)
for a, b in zip(Q[::2], Q[1::2]):
    print("TRoowand"[parities[a] ^ parities[b]::2])
N, Q = map(int, input().split())


class DSU:
    def __init__(self, N: int) -> None:
        self.par = list(range(N))
        self.sz = [1] * N

    def find(self, x: int) -> int:
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]

    def unite(self, x: int, y: int) -> bool:
        x, y = self.find(x), self.find(y)
        if x == y:
            return False
        if self.sz[x] < self.sz[y]:
            x, y = y, x
        self.par[y] = x
        self.sz[x] += self.sz[y]
        return True


dsu = DSU(N * 2)

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    dsu.unite(a, b + N)
    dsu.unite(b, a + N)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dsu.find(c) == dsu.find(d):
        print("Town")
    else:
        print("Road")
#再起のlimitを上げる
import sys

sys.setrecursionlimit(4100000)

n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for i in range(n - 1)]
cd = [list(map(int, input().split())) for i in range(q)]

N = n
g = [[] for _ in range(n)]
for a, b in ab:
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)
visitted = [-1 for _ in range(n)]
start = 0
kyori = 0
#bfs
from collections import deque

q = deque([(start, kyori)])
while q:
    t, k = q.popleft()
    if visitted[t] == -1:
        visitted[t] = k
        for renketsu in g[t]:
            q.append((renketsu, k + 1))

# def dfs_g(cur_node,kyori,prenode=None):
#     visitted[cur_node]=kyori
#     g_renketsu = g[cur_node]
#     for c_c in g_renketsu:
#         if c_c==prenode:
#             continue
#         dfs_g(c_c,kyori+1,cur_node)
# dfs_g(start,0)

for c, d in cd:
    if abs(visitted[c - 1] - visitted[d - 1]) % 2 != 0:
        print("Road")
    else:
        print("Town")
from collections import deque


def bfs(edges, N):
    inf = float("inf")
    waiting = deque()
    done = [0] * N
    done[0] = 2
    dist = [inf] * N
    dist[0] = 0
    for n in edges[0]:
        done[n] = 1
        waiting.append(n)
        dist[n] = 1
    while (len(waiting)):
        cur_node = waiting.popleft()
        if (done[cur_node] != 2):
            done[cur_node] = 2
            for n in edges[cur_node]:
                if (done[n] != 2):
                    done[n] = 1
                    dist[n] = dist[cur_node] + 1
                    waiting.append(n)
    return dist


N, Q = map(int, input().split())
e_list = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    e_list[a - 1].append(b - 1)
    e_list[b - 1].append(a - 1)

dist = bfs(e_list, N)

for i in range(Q):
    c, d = map(int, input().split())
    if (abs(dist[c - 1] - dist[d - 1]) % 2 == 0):
        print("Town")
    else:
        print("Road")
from collections import deque


def bfs(dist):
    queue = deque()
    queue.append(0)
    while queue:
        v1 = queue.popleft()
        for v2 in adj[v1]:
            if dist[v2] != -1:
                continue
            dist[v2] = dist[v1] + 1
            queue.append(v2)


N, Q = map(int, input().split())
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    adj[a].append(b)
    adj[b].append(a)

dist = [-1] * N
dist[0] = 0

ans = bfs(dist)

# print(dist)

for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    dis = abs(dist[c] - dist[d])
    if dis % 2:
        print("Road")
    else:
        print("Town")
from collections import deque

N, Q = map(int, input().split())
link = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    link[a].append(b)
    link[b].append(a)

dist = [-1] * N
dist[0] = 0
query = deque()
query.append(0)
while query:
    pos = query.popleft()
    for nxt in link[pos]:

        if dist[nxt] == -1:

            #            print(f"{pos=}")
            #            print(f"{nxt=}")

            dist[nxt] = dist[pos] + 1
            query.append(nxt)

#print(dist)

for i in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if abs(dist[d] - dist[c]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

n, qq = map(int, input().split())

g = [[] * 2 for i in range(n)]

for i in range(n - 1):
    ai, bi = map(int, input().split())
    g[ai - 1].append(bi - 1)
    g[bi - 1].append(ai - 1)

seen = [False] * n
q = []

d = [0] * n

v = 0
q.append(v)
seen[v] = True
while q:
    next_v = q.pop()
    for v2 in g[next_v]:
        if seen[v2]:
            continue
        q.append(v2)
        seen[v2] = True
        d[v2] = d[next_v] + 1

for i in range(qq):
    ci, di = map(int, input().split())
    ci -= 1
    di -= 1
    if (d[ci] + d[di]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from sys import setrecursionlimit

setrecursionlimit(10**6)


def dfs(pos, pre):
    for i in G[pos]:
        if i == pre:
            continue
        dist[i] = dist[pos] ^ 1
        dfs(i, pos)


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)
dist = [0] * N
dfs(0, 0)
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dist[c] == dist[d]:
        print('Town')
    else:
        print('Road')
from collections import deque
import sys


def bfs(T, n, D):
    D[1] = 0
    q = deque([1])
    while q:
        c = q.popleft()
        for i in T[c]:
            if D[i] == n:
                D[i] = D[c] + 1
                q.append(i)


def main():
    input = sys.stdin.readline
    n, q = map(int, input().split())
    T = [[] for i in range(n + 1)]
    D = [n] * (n + 1)
    for i in range(1, n):
        a, b = map(int, input().split())
        T[a].append(b)
        T[b].append(a)
    bfs(T, n, D)
    for _ in range(q):
        c, d = map(int, input().split())
        if (D[c] + D[d]) % 2 == 1:
            print('Road')
        else:
            print('Town')


main()
import sys

sys.setrecursionlimit(4100000)
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
color = [-1] * N


def dfs(x, par, now):
    color[x] = now
    for u in G[x]:
        if u != par and color[u] == -1:
            dfs(u, x, 1 - now)


dfs(0, -1, 0)
for _ in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(10**5)
n, q = map(int, input().split())
graph = [[] for i in range(n)]

#木であることに注意
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

depth = [-1 for i in range(n)]
visited = [False for i in range(n)]
visited[0] = True

#0からの深さをdepth配列に記録。０番目の要素をhukasa0で記録
depth[0] = 0


def dfs(i):
    a = graph[i]
    for j in a:
        #print(j)
        if not (visited[j]):
            depth[j] = depth[i] + 1
            visited[j] = True
            dfs(j)
        else:
            continue


dfs(0)
for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    if abs(depth[c] - depth[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
N, Q = map(int, input().split())
AB = [tuple(map(int, input().split())) for i in range(N - 1)]
CD = [tuple(map(int, input().split())) for i in range(Q)]

es = [[] for _ in range(N)]
for a, b in AB:
    a, b = a - 1, b - 1
    es[a].append(b)
    es[b].append(a)

depth = [0] * N
visited = [0] * N
visited[0] = 1
stack = [0]
while stack:
    v = stack.pop()
    for to in es[v]:
        if visited[to]: continue
        visited[to] = 1
        depth[to] = depth[v] + 1
        stack.append(to)

ans = []
for c, d in CD:
    c, d = c - 1, d - 1
    x = depth[c] + depth[d]
    ans.append('Road' if x % 2 else 'Town')
print(*ans, sep='\n')
from collections import deque

N, Q = map(int, input().split())

tree = [[] for _ in range(N)]
ans = []

for _ in range(N - 1):
    a, b = map(int, input().split())
    tree[a - 1].append(b - 1)
    tree[b - 1].append(a - 1)


def bfs(u):
    queue = deque([u])
    d = [None] * (N)
    d[u] = 0
    while queue:
        v = queue.popleft()
        for i in tree[v]:
            if d[i] is not None:
                continue
            d[i] = d[v] + 1
            queue.append(i)
    return d


dis = bfs(0)

for _ in range(Q):
    c, d = map(int, input().split())
    if (dis[c - 1] + dis[d - 1]) % 2 == 0:
        ans.append("Town")
    else:
        ans.append("Road")

print(*ans, sep="\n")
from collections import deque

INF = 1 << 60
MOD = 10**9 + 7

N, Q = map(int, input().split())

# 無向グラフ
to = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    to[a].append(b)
    to[b].append(a)

# 全頂点の深さを格納する配列
dep_list = [0] * N

# 全頂点の深さを幅優先探索で求める
q = deque([])
parent = -1
dep = 1
q.append((0, dep, parent))

while len(q) > 0:
    v, dep, parent = q.popleft()
    for vv in to[v]:
        if vv == parent: continue
        dep_list[vv] = dep
        q.append((vv, dep + 1, v))

# それぞれのクエリにおいて c と d の経路の偶奇を求める
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    parity = dep_list[c] + dep_list[d]
    print("Town" if parity % 2 == 0 else "Road")
import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, copy, functools
import time, random

sys.setrecursionlimit(10**6)

inf = 10**20
eps = 1.0 / 10**10
mod = 10**9 + 7
mod2 = 998244353
dd = [(-1, 0), (0, 1), (1, 0), (0, -1)]
ddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]
df = collections.defaultdict


def LI():
    return list(map(int, sys.stdin.readline().split()))


def LI_():
    return [int(x) - 1 for x in sys.stdin.readline().split()]


def LS():
    return sys.stdin.readline().split()


def I():
    return int(sys.stdin.readline())


def F():
    return float(sys.stdin.readline())


def S():
    return input()


def pf(s):
    return print(s, flush=True)


def pe(s):
    return print(str(s), file=sys.stderr)


def JA(a, sep):
    return sep.join(map(str, a))


def JAA(a, s, t):
    return s.join(t.join(map(str, b)) for b in a)


def main():
    n, q = LI()
    ab = [LI_() for _ in range(n - 1)]
    cd = [LI_() for _ in range(q)]

    e = df(set)
    for a, b in ab:
        e[a].add(b)
        e[b].add(a)

    def search(s):
        d = collections.defaultdict(lambda: inf)
        d[s] = 0
        q = []
        heapq.heappush(q, (0, s))
        v = collections.defaultdict(bool)
        while len(q):
            k, u = heapq.heappop(q)
            if v[u]:
                continue
            v[u] = True

            for uv in e[u]:
                if v[uv]:
                    continue
                vd = k + 1
                if d[uv] > vd:
                    d[uv] = vd
                    heapq.heappush(q, (vd, uv))

        return d

    s = search(0)
    rr = []
    for c, d in cd:
        t = s[c] + s[d]
        if t % 2 == 1:
            rr.append("Road")
        else:
            rr.append("Town")

    return JA(rr, "\n")


# start = time.time()
print(main())
# pe(time.time() - start)
from collections import deque


def main():
    [N, Q] = [int(x) for x in input().split()]

    # グラフの初期化
    graph = [[] for _ in range(N + 1)]
    for _ in range(N - 1):
        [a, b] = [int(x) for x in input().split()]
        graph[a].append(b)
        graph[b].append(a)

    # 深さを記録するリスト
    depth_vec = [-1 for _ in range(N + 1)]

    # 1を根とする根付き木を作り、各頂点の深さを記録する
    queue = deque()
    queue.append((1, 0))
    while len(queue) > 0:
        (node, depth) = queue.pop()
        depth_vec[node] = depth
        for child in graph[node]:
            if depth_vec[child] >= 0:
                continue
            queue.append((child, depth + 1))

    # クエリに解答する
    for query in range(Q):
        [c, d] = [int(x) for x in input().split()]
        if (depth_vec[c] + depth_vec[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
#!/usr/bin/env python3

from sys import setrecursionlimit, stdin
from typing import Iterable

INF: int = 2**62
MOD: int = 10**9 + 7

setrecursionlimit(10**6)


def inputs(type_=int):
    ins = input().split(' ')
    ins = [x for x in ins if x != '']

    if isinstance(type_, Iterable):
        return [t(x) for t, x in zip(type_, ins)]
    else:
        return list(map(type_, ins))


def input_(type_=int):
    a, = inputs(type_)
    return a


inputi = input_


def inputstr():
    return input_(str)


# b/aの切り上げ
def ceil(b, a):
    return (a + b - 1) // a


def answer(res) -> None:
    print(res)
    exit()


def compute():
    return


class UnionFind:
    """
    Ref: https://qiita.com/tefuxu/items/e9f99b6eefc3a7f76cc9
    ・自身が子のとき, 親ノード番号を格納する。自身が根のとき, ノード数を負の数で格納する
    ・負の数のときは自身が根であり, その絶対値がその木のノード数を表す
    """
    def __init__(self, n):
        # 親ノードを-1に初期化する
        self.parents = [-1] * n

    # 根を返す
    def find_root(self, x: int) -> int:
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find_root(self.parents[x])
            return self.parents[x]

    # 同じ要素かどうか
    def are_same(self, x: int, y: int) -> bool:
        return self.find_root(x) == self.find_root(y)

    # xとyの木を併合する
    def union(self, x: int, y: int) -> None:
        # x,yの根をX,Yとする
        root_x = self.find_root(x)
        root_y = self.find_root(y)

        # 根が同じなら結合済み
        if root_x == root_y:
            return

        # ノード数が多い方をXとする
        if self.parents[root_x] > self.parents[root_y]:
            root_x, root_y = root_y, root_x

        # XにYのノード数を足す
        self.parents[root_x] += self.parents[root_y]
        # Yの根を X(>0) とする
        self.parents[root_y] = root_x

    # 木のサイズ
    def size(self, x: int) -> int:
        return self.parents[self.find_root(x)] * -1


def main():
    n, q = inputs()
    from collections import defaultdict
    path = defaultdict(set)

    # print(n)
    for _ in range(n - 1):
        a, b = inputs()
        a -= 1
        b -= 1
        path[a].add(b)
        path[b].add(a)

    uf = UnionFind(n)
    for i in range(n):
        for j in path[i]:
            for k in path[j]:
                if k in path[i]:
                    continue
                else:
                    uf.union(i, k)

    # print(q)
    for _ in range(q):
        c, d = inputs()
        c -= 1
        d -= 1
        if uf.find_root(c) == uf.find_root(d):
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
import math
import itertools
from decimal import Decimal
from functools import reduce
import collections
import bisect
import queue


def main():
    # n = int(input())
    # a,b = input().split()
    n, q = map(int, input().split())
    # c = list(map(int, input().split()))
    # b = list(map(int, input().split()))
    # s_ = input()
    # c = [list(input()) for _ in range(h)]
    # m = int(input())
    # d = [list(map(int, input().split())) for _ in range(n)]
    # l = [int(input()) for _ in range(n)]
    # c = [input() for _ in range(h)]
    # mod = 10**9+7
    path = [[] for _ in range(n)]

    ab = [list(map(int, input().split())) for _ in range(n - 1)]
    cd = [list(map(int, input().split())) for _ in range(q)]

    for a, b in ab:
        path[a - 1].append(b - 1)
        path[b - 1].append(a - 1)

    que = queue.Queue()
    color = [-1] * n
    color[0] = 0
    que.put(0)
    while not que.empty():
        t = que.get()
        for i in path[t]:
            if color[i] == -1:
                color[i] = 1 - color[t]
                que.put(i)

    for c, d in cd:
        if color[c - 1] == color[d - 1]:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
from collections import deque

N, Q = map(int, input().split())
a = [None] * N
b = [None] * N
# g = [[False for _ in range(N)] for _ in range(N)]
g = [[] for _ in range(N)]

for n in range(N - 1):
    a[n], b[n] = map(int, input().split())
    g[a[n] - 1].append(b[n] - 1)
    g[b[n] - 1].append(a[n] - 1)


def bfs(s):
    dist = [None] * N
    que = deque([s])
    dist[s] = 0
    while que:
        v = que.popleft()
        d = dist[v]
        for w in g[v]:
            if dist[w] is not None:
                continue
            dist[w] = d + 1
            que.append(w)
    return dist.index(d), dist


_, dist = bfs(0)

for q in range(Q):
    c, d = map(int, input().split())
    print('Road' if (dist[c - 1] + dist[d - 1]) % 2 == 1 else 'Town')
n, q = map(int, input().split())
road = [list(map(int, input().split())) for i in range(n - 1)]
queries = [list(map(int, input().split())) for i in range(q)]
edges = [[] for i in range(n + 1)]
for i in road:
    edges[i[0]].append(i[1])
    edges[i[1]].append(i[0])
stack = [1]
inf = 10**5
d = [-1 for i in range(n + 1)]
d[1] = 0
while len(stack) > 0:
    s = stack.pop()
    for i in edges[s]:
        if d[i] == -1:
            d[i] = d[s] + 1
            stack.append(i)

for i in queries:
    if abs(d[i[0]] - d[i[1]]) % 2 == 1:
        print('Road')
    else:
        print('Town')
class Inputs():
    def inInt():  # 入力行（数値1つ）を整数型にして返す
        return int(input())

    def inInts():  # 入力行をスペース区切りで整数型のリスト化して返す
        return [int(n) for n in input().split()]

    def inIntN(n):  # n行1整数の入力から整数型のリストを作成して返す
        return [int(input()) for _ in range(n)]

    def inIntsN(n):  # n行の入力をスペース区切りで整数型の2次元リストにして返す
        return [list(map(int, input().split())) for _ in range(n)]

    def inChars():  # 入力した文字列を1文字ずつに分解してリスト化して返す
        return list(input())

    def inCharsN(n):  # n行の文字列入力を1文字ずつに分解して2次元リストにして返す
        return [list(input()) for _ in range(n)]

    def inStr():  # 入力行を文字列として格納して返す
        return input()

    def inStrs():  # 入力行をスペース区切りでリスト化して返す
        return input().split()

    def inStrsN(n):  # n行の入力をスペース区切りで文字列型の2次元リストにして返す
        return [input().split() for _ in range(n)]

    def getInitListDim1(val, n):  # 長さnのリストをvalで初期化して返す
        return [val] * (n)

    def getInitListDim2(val, n, m):  # n * mの2次元リストをvalで初期化して返す
        return [[val for _ in range(m)] for _ in range(n)]

    def getInitListDim3(val, n, m, k):  # n * m * kの3次元リストをvalで初期化して返す
        return [[[val for _ in range(k)] for _ in range(m)] for _ in range(n)]


class Outputs():
    def outputs_yes_no(bool):  # AtCoder用のYes/Noの出力用関数
        print('Yes') if bool else print('No')


class UFT:
    def __init__(self, n):
        self.uft = [-1] * (n + 1)

    def find(self, x):
        if self.uft[x] < 0:
            return x
        else:
            self.uft[x] = self.find(self.uft[x])  # 経路圧縮
            return self.uft[x]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x == y:
            pass
        else:
            if self.uft[x] > self.uft[y]:
                x, y = y, x
            self.uft[x] += self.uft[y]
            self.uft[y] = x
        return self.uft

    def size(self, x):
        return -self.uft[self.find(x)]


class BIT:
    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n + 1)
        self.ele = [0] * (n + 1)

    def sum(self, i):
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s

    def add(self, i, x):
        self.ele[i] += x
        while i <= self.size:
            self.tree[i] += x
            i += i & -i

    def get(self, i, j=None):
        if j is None:
            return self.ele[i]
        return self.sum(j) - self.sum(i)


class SegmentTree:
    pass


class Graph:
    INF = 10**9

    def __init__(self, n: int, e: list):
        self.num_nodes = n
        self.num_edges = len(e)
        self.edges = [[] for _ in range(n)]
        for t in e:
            self.edges[t[0] - 1].append(t[1] - 1)
            self.edges[t[1] - 1].append(t[0] - 1)

    def dijkstra(self, s):
        from heapq import heappush, heappop
        dist = [self.INF] * self.num_nodes
        hq = [(0, s)]
        dist[s] = 0
        seen = [False] * self.num_nodes
        while hq:
            v = heappop(hq)[1]
            seen[v] = True
            for to in self.edges[v]:
                if seen[to] is False and dist[v] + 1 < dist[to]:
                    dist[to] = dist[v] + 1
                    heappush(hq, (dist[to], to))
        return dist


class GraphCustomized(Graph):  # 3-coloring @ ABC199D
    import sys
    sys.setrecursionlimit(10**6)

    def __init__(self, n: int, e: list):
        super(GraphCustomized, self).__init__(n, e)
        self.num_components = 0
        self.nodes_components = []
        self.idx_components = [0] * n
        self.set_components()
        self.color = [0] * n

    def reset_color(self):
        self.color = [0] * self.num_nodes

    def dfs_set_component(self, current: int):
        self.idx_components[current] = self.num_components
        self.nodes_components[self.num_components - 1].append(current)
        for cand in self.edges[current]:
            if self.idx_components[cand] > 0:
                continue
            self.dfs_set_component(cand)

    def set_components(self):
        for i in range(self.num_nodes):
            if self.idx_components[i] > 0:
                continue
            self.num_components += 1
            self.nodes_components.append([])
            self.dfs_set_component(i)

    # i:idx of component, j: idx in component
    def dfs_count(self, i, j):
        if j == len(self.nodes_components[i]):
            return 1
        count = 0
        current_node = self.nodes_components[i][j]
        cand = {1, 2, 3}
        for k in self.edges[current_node]:
            cand.discard(self.color[k])
        for c in cand:
            self.color[current_node] = c
            count += self.dfs_count(i, j + 1)
            self.color[current_node] = 0
        return count

    def get_num_3coloring(self):
        if self.num_edges == 0:
            return 3**self.num_nodes
        elif self.num_edges == self.num_nodes * (self.num_nodes + 1) // 2:
            return 0
        else:
            counter = 1
            for i in range(self.num_components):
                self.reset_color()
                counter *= self.dfs_count(i, 0)
            return counter


class Tree(Graph):
    import sys
    sys.setrecursionlimit(10**6)

    def __init__(self, n: int, e: list):
        super(Tree, self).__init__(n, e)

    def dfs(self, current: int, prev: int):
        for cand in self.edges[current]:
            if cand == prev:
                continue
            #  Here, process will be written
            self.dfs(cand, current)

    def bfs(self):
        pass


class TreeCustomized(Tree):  # ABC198E
    import sys
    sys.setrecursionlimit(10**6)

    def __init__(self, n: int, e: list, c: list):
        super(TreeCustomized, self).__init__(n, e)
        self.values = c
        self.state = {c[0]}
        self.ans = [1]

    def dfs(self, current: int, prev: int):
        for cand in self.edges[current]:
            if cand == prev:
                continue
            c = self.values[cand]
            if c in self.state:
                self.dfs(cand, current)
            else:
                self.state.add(c)
                self.ans.append(cand + 1)
                self.dfs(cand, current)
                self.state.remove(c)


class LoopBitBruteForce:  # ABC_197_C
    def __init__(self):
        self.n = Inputs.inInt()
        self.a = Inputs.inInts()

    def solve(self):
        ans = 2**31
        for mask in range(1 << (self.n - 1)):
            val_xor = 0
            tmp = self.a[0]
            for i in range(1, self.n):
                if mask & 1 << (i - 1):
                    val_xor ^= tmp
                    tmp = 0
                tmp |= self.a[i]
            val_xor ^= tmp
            ans = min(ans, val_xor)
        return ans


def solve():
    # 入力
    N, Q = Inputs.inInts()
    ab = Inputs.inIntsN(N - 1)
    cd = Inputs.inIntsN(Q)
    # 求解
    g = Graph(N, ab)
    dist = g.dijkstra(0)
    ans = []
    for i in range(Q):
        d1 = dist[cd[i][0] - 1]
        d2 = dist[cd[i][1] - 1]
        if abs(d1 - d2) % 2 == 0:
            ans.append('Town')
        else:
            ans.append('Road')
    # 回答
    for a in ans:
        print(a)


if __name__ == "__main__":
    solve()
n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

from collections import defaultdict

g = defaultdict(list)
for a, b in ab:
    g[a] += [b]
    g[b] += [a]


# Euler Tour
def dfs(u, d):
    # first visit
    vis = [-1] * (n + 1)
    # euler tour
    et = []
    stack = [(u, d)]

    while len(stack):
        u, d = stack.pop()
        if u > 0:
            # 行きがけの処理
            vis[u] = len(et)
            et += [(u, d)]
            for v in g[u]:
                if vis[v] == -1:  # 未探索のみ
                    stack.append((-v, d + 1))  # 帰り
                    stack.append((v, d + 1))  # 行き
        else:
            # 帰りがけの処理
            et += [(u, d)]

    return vis, et


vis, et = dfs(1, 0)

t = [t for e, t in et]


def init_min(init_min_val):
    #set_val
    for i in range(n):
        seg_min[i + num_min - 1] = init_min_val[i]
    #built
    for i in range(num_min - 2, -1, -1):
        seg_min[i] = min(seg_min[2 * i + 1], seg_min[2 * i + 2])


def query_min(p, q):
    if q <= p:
        return ide_ele_min
    p += num_min - 1
    q += num_min - 2
    res = ide_ele_min
    while q - p > 1:
        if p & 1 == 0:
            res = min(res, seg_min[p])
        if q & 1 == 1:
            res = min(res, seg_min[q])
            q -= 1
        p = p // 2
        q = (q - 1) // 2
    if p == q:
        res = min(res, seg_min[p])
    else:
        res = min(min(res, seg_min[p]), seg_min[q])
    return res


n = len(t)
ide_ele_min = 10**5 + 1

#num_min:n以上の最小の2のべき乗
num_min = 2**(n - 1).bit_length()
seg_min = [ide_ele_min] * 2 * num_min

#init
init_min(t)

for c, d in cd:
    pc, pd = vis[c], vis[d]
    dc, dd = t[pc], t[pd]
    m = query_min(pc, pd)
    dist = dc + dd - 2 * m

    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
from array import array
from collections import deque


def shortest_path_bfs(es: "隣接リスト", start: "始点"):
    V = len(es)
    d = [2] * V  # 頂点startからの最短距離
    que = deque()
    que.append(start)
    d[start] = 0
    while que:
        v = que.popleft()
        for e in es[v]:
            if d[e] == 2:
                d[e] = 1 - d[v]
                que.append(e)

    return d


n, q = map(int, input().split())
es = [array("i") for _ in range(n)]
for i in range(n - 1):
    start, end = map(int, input().split())
    start -= 1
    end -= 1
    es[start].append(end)
    es[end].append(start)

dist = shortest_path_bfs(es, 0)

res = [""] * q
for i in range(q):
    c, d = map(int, input().split())
    k = dist[c - 1] - dist[d - 1]
    res[i] = "Road" if k % 2 else "Town"

print(*res, sep="\n")
import sys

sys.setrecursionlimit(100000000)

n, q = map(int, input().split())
# inf = float('inf')
# dist = [[inf for _ in range(n+1)] for _ in range(n+1)]
evenorodd = [-1] * (n + 1)
evenorodd[1] = 0
edge = [[] for _ in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    edge[a].append(b)
    edge[b].append(a)
done = [0] * (n + 1)


def near_check(n, num):
    # 隣あっているやつを確認していく
    tmp = (num + 1) % 2
    if done[n] == 1:
        return
    done[n] = 1
    for i in edge[n]:
        if evenorodd[i] == -1:
            evenorodd[i] = tmp
            near_check(i, tmp)


near_check(1, 0)

#print(evenorodd)

for i in range(q):
    c, d = map(int, input().split())
    if evenorodd[c] == evenorodd[d]:
        print("Town")
    else:
        print("Road")
#problem4
from collections import deque
from collections import defaultdict

N, Q = list(map(int, input().split()))
G = defaultdict(set)

color = [0 for i in range(N + 1)]

for _ in range(N - 1):
    A, B = map(int, input().split())
    G[A].add(B)
    G[B].add(A)

color[1] = 1
que = deque([1])  #始点を追加
bipartite = True

while len(que):
    p = que.popleft()  #直近で追加したグラフの頂点を取得
    for q in list(G[p]):  #結合しているグラフの頂点を参照
        if color[q] == 0:  #塗られていないなら別の色で塗る
            color[q] = -color[p]
            que.append(q)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
inputs = input().split()
inputs = list(map(int, inputs))
N = inputs[0]
Q = inputs[1]

roads = [[] for _ in range(N)]
for road_idx in range(N - 1):
    inputs = input().split()
    inputs = list(map(int, inputs))
    roads[inputs[0] - 1].append(inputs[1] - 1)
    roads[inputs[1] - 1].append(inputs[0] - 1)

flags = [False for _ in range(N)]
flags[0] = True
distances = [-1 for _ in range(N)]
distances[0] = 0
queue = [0]
while len(queue) > 0:
    current = queue.pop(0)
    for neighbor in roads[current]:
        if not flags[neighbor]:
            distances[neighbor] = distances[current] + 1
            queue.append(neighbor)
            flags[neighbor] = True

for _ in range(Q):
    inputs = input().split()
    inputs = list(map(int, inputs))
    s = inputs[0] - 1
    g = inputs[1] - 1
    distance = distances[s] + distances[g]
    if distance % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys
from itertools import islice
from typing import NamedTuple
from heapq import heappop, heappush

INF = 1 << 60


def _dijkstra1(N, S, graph):
    queue = []
    dist = [INF] * N
    dist[S] = 0
    queue.append((dist[S], S))

    while queue:
        min_dist, min_v = heappop(queue)
        if min_dist > dist[min_v]:
            continue

        for e in graph[min_v]:
            c = dist[min_v] + 1
            if dist[e] > c:
                dist[e] = c
                heappush(queue, (c, e))

    return dist


def solve(in_):
    N, Q = map(int, next(in_).split())
    graph = [[] for _ in range(N)]
    _edges = tuple(map(int, line.split()) for line in islice(in_, N - 1))
    for a, b in _edges:
        a -= 1
        b -= 1
        graph[a].append(b)
        graph[b].append(a)
    queries = tuple(map(int, line.split()) for line in islice(in_, Q))
    ans = []
    _dist = _dijkstra1(N, 0, graph)
    for c, d in queries:
        c -= 1
        d -= 1
        dist = abs(_dist[c] - _dist[d])
        if dist % 2:
            ans.append('Road')
        else:
            ans.append('Town')
    return ans


def main():
    answer = solve(sys.stdin.buffer)
    print('\n'.join(answer))


if __name__ == '__main__':
    main()
# /usr/bin/python3
# -*- coding: utf-8 -*-
from bisect import bisect_left, bisect_right
from queue import Queue
from queue import LifoQueue as Stack
from math import sqrt, floor, ceil, log2, log10, pi, sin, cos, atan
from fractions import gcd
from itertools import permutations, combinations
from collections import Counter
from operator import itemgetter
from functools import cmp_to_key, reduce
from bisect import bisect_left

# INF=1001001001
# INF = 100010001000100010001
INF = float('INF')
__MOD__ = (10**9) + 7
yn = 'YNeos'
judge = False
cnt = 0
ans = None


def lcm(a, b):
    return (a * b) // gcd(a, b)


def intinput():
    return int(input())


def mulinputs():
    return map(int, input().split())


def lineinputs(func=intinput):
    datas = []
    while True:
        try:
            datas.append(func())
        except EOFError:
            break
    return datas


def bindex(a, x):
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    return None


class UnionFind:
    def __init__(self, n):
        self.r = [-1] * (n + 1)

    def root(self, x):
        if self.r[x] < 0:
            return x
        self.r[x] = self.root(self.r[x])
        return self.r[x]

    def unite(self, x, y):
        x = self.root(x)
        y = self.root(y)
        if x == y:
            return False
        if self.r[x] > self.r[y]:
            x, y = y, x
        self.r[x] += self.r[y]
        self.r[y] = x
        return True

    def size(self, x):
        return -1 * self.r[self.root(x)]


class ModInt():
    def __init__(self, x):
        self.__x = (x % __MOD__)

    def __add__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((self.__x + other.__x) % __MOD__))
        elif type(other) == ModInt:
            return self.__class__((self.__x + other.__x) % __MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __radd__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((other.__x + self.__x) % __MOD__))
        elif type(other) == ModInt:
            return self.__class__((other.__x + self.__x) % __MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __sub__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((self.__x - other.__x) % __MOD__))
        elif type(other) == ModInt:
            return self.__class__((self.__x - other.__x) % __MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __rsub__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((other.__x - self.__x) % __MOD__))
        elif type(other) == ModInt:
            return self.__class__((other.__x - self.__x) % __MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __mul__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((self.__x * other.__x) % __MOD__))
        elif type(other) == ModInt:
            return self.__class__((self.__x * other.__x) % __MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __rmul__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((other.__x * self.__x) % __MOD__))
        elif type(other) == ModInt:
            return self.__class__((other.__x * self.__x) % __MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __truediv__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((self.__x * other.__modinv()) % __MOD__))
        elif type(other) == ModInt:
            return self.__class__((self.__x * other.__modinv()) % __MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __rtruediv__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((other.__x * self.__modinv()) % __MOD__))
        elif type(other) == ModInt:
            return self.__class__((other.__x * self.__modinv()) % __MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __pow__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__(pow(self.__x, other.__x, __MOD__)))
        elif type(other) == ModInt:
            return self.__class__(pow(self.__x, other.__x, __MOD__))
        else:
            raise Exception("Not Int or Not ModInt")

    def __rpow__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__(pow(other.__x, self.__x, __MOD__)))
        elif type(other) == ModInt:
            return self.__class__(pow(other.__x, self.__x, __MOD__))
        else:
            raise Exception("Not Int or Not ModInt")

    def __modinv(self, m=__MOD__):
        a = self.__x
        if a == 0:
            raise ZeroDivisionError()
        if gcd(a, m) != 1:
            raise Exception("%sの逆数は求まりません。" % a)
        b, u, v = m, 1, 0
        while b != 0:
            t = a // b
            a -= t * b
            a, b = b, a
            u -= t * v
            u, v = v, u
        u %= m
        if u < 0:
            u += m
        return u

    def __int__(self):
        return self.__x

    def __str__(self):
        return str(self.__x)


if __name__ == '__main__':
    N, Q = mulinputs()
    paths_list = []
    for _ in range(N):
        paths_list.append(set())

    for _ in range(N - 1):
        a, b = mulinputs()
        paths_list[a - 1].add(b - 1)
        paths_list[b - 1].add(a - 1)

    indatas = []
    for _ in range(Q):
        c, d = mulinputs()
        indatas.append((c - 1, d - 1))

    s, e = 0, N - 1
    q = Queue()
    q.put(s)

    count = []
    for _ in range(N):
        count.append(-1)
    count[s] = 0

    while not q.empty():
        v = q.get()
        for path in paths_list[v]:
            if count[path] < 0:
                count[path] = 1 - count[v]
                q.put(path)

    for s, e in indatas:
        if (count[e] - count[s]) % 2 == 0:
            print('Town')
        else:
            print('Road')
    exit()

#     for s, e in indatas:
#         q = Queue()
#         q.put(s)
#         count = []
#         for _ in range(N):
#             count.append(0)
#         count[s] = 1
#         visited = set()
#         visited.add(s)
#         while not q.empty():
#             v = q.get()
#             if e in paths_list[v]:
#                 count[e] = count[v] + 1
#                 break
#             for path in paths_list[v]:
#                 if path in visited:
#                     continue
#                 count[path] = count[v] + 1
#                 q.put(path)
#                 visited.add(path)
#
#         if count[e] % 2 == 1:
#             print(f"Town")
#         else:
#             print(f"Road")
import heapq
from collections import defaultdict


def dijkstra(start, N, branches):
    """
    :param start:
    :param N: The number of nodes
    :param branches: dictionary, branches[src_node] = [(next_node, cost)]
    :return:
    """
    distance_heap = [(float('inf'), i) for i in range(N)]
    distance_heap[start] = (0, start)
    heapq.heapify(distance_heap)

    ways = {}

    dv = [-1] * N
    heap_is_empty = False
    most_close_node_id = most_close_node_distance = -1
    while True:
        while True:
            if len(distance_heap) == 0:
                heap_is_empty = True
                break
            most_close_node_distance, most_close_node_id = heapq.heappop(
                distance_heap)
            if dv[most_close_node_id] < 0:
                break
        if heap_is_empty:
            break

        dv[most_close_node_id] = most_close_node_distance
        # update heap (just add new distances)
        for branch in branches[most_close_node_id]:
            next_node, cost = branch
            # skip already processed nodes
            if dv[next_node] >= 0:
                continue
            distance = cost + most_close_node_distance
            heapq.heappush(distance_heap, (distance, next_node))

    return dv


def resolve():
    N, Q = [int(v) for v in input().split()]

    branches = defaultdict(list)
    for _ in range(N - 1):
        a, b = [int(v) - 1 for v in input().split()]
        branches[a].append((b, 1))
        branches[b].append((a, 1))

    dv = dijkstra(0, N, branches)
    for _ in range(Q):
        c, d = [int(v) - 1 for v in input().split()]
        if (dv[c] + dv[d]) % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    resolve()
from collections import deque

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

color = [-1] * N
color[0] = 0
q = deque()
q.append(0)

while len(q):
    t = q.popleft()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            q.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())
l = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    l[a].append(b)
    l[b].append(a)

que = [0]
dist = [None] * n
dist[0] = 0

for v in que:
    for vv in l[v]:
        if dist[vv] is None:
            dist[vv] = dist[v] + 1
            que.append(vv)

for _ in range(q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
def Is():
    return input()


def Iss():
    return input().split()


def Ii():
    return int(input())


def Iis():
    return map(int, input().split())


def Iil():
    return list(map(int, input().split()))


def Ixy(N):
    return [list(map(int, input().split())) for l in range(N)]


def Ixyind(N):
    xy = [map(int, input().split()) for _ in range(N)]
    return [list(i) for i in zip(*xy)]


def Imixind(N):
    list = []
    for i in range(N):
        a, b = input().split()
        list.append([int(a), b])
    return list


#####################################################################
import sys

sys.setrecursionlimit(100000)
# N = Ii()
# S = Is()
N, Q = Iis()
# l = Iil()
# X,Y = Ixyind(N)
# XY = Ixy(N)


class Node:
    def __init__(self):
        self.parents = []
        self.children = []
        self.depth = None


def cal_depth(node_id, d=0):
    Tree[node_id].depth = d
    for child in Tree[node_id].children:
        if Tree[child].depth == None:
            cal_depth(child, d + 1)
    for parent in Tree[node_id].parents:
        if Tree[parent].depth == None:
            cal_depth(parent, d - 1)


Tree = [Node() for _ in range(N)]

for i in range(N - 1):
    #id, 子供の数k, c_0~c_k
    tree_info = list(map(int, input().split()))
    node_id = tree_info[0] - 1
    k = 1

    if k > 0:
        children = tree_info[1] - 1
        Tree[node_id].children.append(children)
        Tree[node_id].type = "internal node"
    else:
        Tree[node_id].type = "leaf"

    for child in Tree[node_id].children:
        Tree[child].parents.append(node_id)

#search_root
root_id = [i for i, t in enumerate(Tree) if t.parents == []][0]
Tree[root_id].type = "root"
cal_depth(root_id)

# answer_output
# for i, t in enumerate(Tree):
#     print("node {}: parents = {}, depth = {}, {}".format(i, t.parents, t.depth, t.children))
for _ in range(Q):
    c, d = Iis()
    c -= 1
    d -= 1
    if Tree[c].depth % 2 == Tree[d].depth % 2:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**9)


def dfs(v: int, _dep=0, parent=-1):
    dep_list[v] = _dep
    for vv in to[v]:
        # 親に戻るルートの場合はスキップ（無限再帰を防ぐ）
        if vv == parent: continue
        dfs(vv, _dep + 1, v)


N, Q = map(int, input().split())

# 隣接リスト
to = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    to[a].append(b)
    to[b].append(a)

# 全頂点の深さを格納する配列
dep_list = [0] * N

# 全頂点の深さを深さ優先探索で求める
dfs(0)

# それぞれのクエリにおいて c と d の経路の偶奇を求める
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    parity = dep_list[c] + dep_list[d]
    print("Town" if parity % 2 == 0 else "Road")
from collections import deque

n, q = map(int, input().split())  # 頂点数と辺数

# グラフ入力受け取り (ここでは無向グラフを想定)
graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * n  # 全頂点を -1 (未訪問) に初期化
pos = deque()  # キュー

# 初期条件 (頂点 0 を始点とする)
dist[0] = 0
pos.append(0)

# 幅優先探索 (キューが空になるまで探索を行う)
while len(pos) > 0:
    v = pos.popleft()  # キューから先頭の頂点を取り出す
    for nv in graph[v]:
        # 既に訪問済みの頂点は探索しない
        if dist[nv] != -1:
            continue
        # 新たな頂点 nv について距離情報を更新してキューに追加する
        dist[nv] = dist[v] + 1
        pos.append(nv)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import heapq, math
from collections import defaultdict, deque
from os import getcwd
#from functools import cmp_to_key

import sys, os.path

sys.setrecursionlimit(10000000)

if (os.path.exists('C:/Users/Dhanush/Desktop/cp/input.txt')):
    sys.stdout = open('C:/Users/Dhanush/Desktop/cp/output.txt', 'w')
    sys.stdin = open('C:/Users/Dhanush/Desktop/cp/input.txt', 'r')

input = sys.stdin.readline


def dfs(cur, col):
    colour[cur] = col
    visit[cur] = 1
    for next in d[cur]:
        if (visit[next] == 0):
            dfs(next, 1 - col)


n, q = map(int, input().split())
d = defaultdict(list)
for i in range(n - 1):
    a, b = map(int, input().split())
    d[a].append(b)
    d[b].append(a)
visit = [0 for _ in range(n + 1)]
colour = [-1 for _ in range(n + 1)]
dfs(1, 0)
for i in range(q):
    a, b = map(int, input().split())
    if (colour[a] == colour[b]):
        print('Town')
    else:
        print('Road')
"""
解説見た
めっちゃ惜しいところまで行ってた
考察結果(計算量の推定，dfs使う，偶奇判定)は全部正解

肝は各nodeと隣り合うnodeを区別して(0, 1を割り振る)同じ番号かどうか(つまり偶奇判定は惜しかった)
で各クエリにO(1)で解答できる

くっっっっっそおしいやんけ
"""

from collections import deque
import sys

input = sys.stdin.readline

n, q = map(int, input().split())
Graph = [list() for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    Graph[a].append(b)
    Graph[b].append(a)


def bfs(start_pos: int) -> list:
    marked = [1 if idx == start_pos else 0 for idx in range(n)]
    nexts = deque([start_pos])
    while nexts:
        now = nexts.popleft()
        for now_pos in Graph[now]:
            if marked[now_pos] == 0:
                marked[now_pos] = -marked[now]
                nexts.append(now_pos)
    return marked


Marked: list = bfs(0)
ans = ["" for _ in range(q)]
for query in range(q):
    c, d = map(int, input().split())
    if Marked[c - 1] == Marked[d - 1]:
        ans[query] = "Town"
    else:
        ans[query] = "Road"

for a in ans:
    print(a)
N, Q = map(int, input().split())
path = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)

dist = [-1] * N
v = [0]
while v:
    tmp = []
    for i in v:
        for j in path[i]:
            if dist[j] == -1:
                dist[j] = dist[i] + 1
                tmp.append(j)
    v = tmp

for i in range(Q):
    c1, d1 = map(int, input().split())
    c1, d1 = c1 - 1, d1 - 1
    if abs(dist[c1] - dist[d1]) % 2:
        print('Road')
    else:
        print('Town')
# -*- coding: utf-8 -*-
import sys

sys.setrecursionlimit(10**6)


def input():
    return sys.stdin.readline().strip()


import math
import collections
from collections import deque, Counter, defaultdict
from bisect import bisect_left, bisect
from copy import deepcopy
import itertools
from heapq import heappush, heappop, heapify
import statistics

INF = 10**20
mod = 10**9 + 7
from decimal import Decimal
import string
# import numpy as np
# alp = list(string.ascii_letters[0:26])
# map(int,input().split())


def dijkstra(start, n):  # (始点, ノード数)
    dist = [-1] * n
    hq = [(0, start)]  # (distance, node)
    dist[start] = 0
    seen = [False] * n  # ノードが確定済みかどうか
    while hq:
        v = heappop(hq)[1]  # ノードを pop する
        seen[v] = True
        for to, cost in adj[v]:  # ノード v に隣接しているノードに対して
            if (seen[to] == False
                    and dist[v] + cost < dist[to]) or (seen[to] == False
                                                       and dist[to] == -1):
                dist[to] = dist[v] + cost
                heappush(hq, (dist[to], to))
    return dist


# ノード数, エッジ数, 始点ノード, 終点ノード
# n,m,x,y = map(int, input().split())
n, q = map(int, input().split())
m = n - 1

# adj[s]: ノード s に隣接する(ノード, 重み)をリストで持つ
adj = [[] for _ in range(n)]
for i in range(m):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    adj[a].append((b, 1))
    adj[b].append((a, 1))

dis_k = dijkstra(0, n)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    print("Town" if (dis_k[c] + dis_k[d]) % 2 == 0 else "Road")
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    G[x].append(y)
    G[y].append(x)

color = [0 for _ in range(N)]


def dfs(graph, v):
    global color
    for w in graph[v]:
        if color[w] == 0:
            color[w] = color[v] * -1
            dfs(graph, w)


import sys

sys.setrecursionlimit(10**7)
color[0] = 1
dfs(G, 0)

for q in range(Q):
    c, d = map(lambda n: int(n) - 1, input().split())
    print("Town" if color[c] == color[d] else "Road")
import queue


def main():
    N, Q = [int(x) for x in input().split()]

    graph = [[] for i in range(N)]
    for i in range(N - 1):
        a, b = [int(x) for x in input().split()]
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)

    queries = []
    for i in range(Q):
        c, d = [int(x) for x in input().split()]
        queries.append([c - 1, d - 1])

    distances = bfs(graph, 0)

    for query in queries:
        if (distances[query[0]] - distances[query[1]]) % 2 == 0:
            print("Town")
        else:
            print("Road")


def bfs(graph, first_node):
    que = queue.Queue()
    que.put(first_node)
    distances = [-1 for x in range(len(graph))]
    distances[first_node] = 0

    while not que.empty():
        current_node = que.get()
        current_distance = distances[current_node]

        for next_node in graph[current_node]:
            if distances[next_node] < 0:
                que.put(next_node)
                distances[next_node] = current_distance + 1

    return distances


if __name__ == "__main__":
    main()
from collections import deque

n, q = map(int, input().split())  # 頂点数と辺数

# グラフ入力受け取り (ここでは無向グラフを想定)
graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * n  # 全頂点を -1 (未訪問) に初期化
pos = deque()  # キュー

# 初期条件 (頂点 0 を始点とする)
dist[0] = 0
pos.append(0)

# 幅優先探索 (キューが空になるまで探索を行う)
while len(pos) > 0:
    v = pos.popleft()  # キューから先頭の頂点を取り出す
    for nv in graph[v]:
        # 既に訪問済みの頂点は探索しない
        if dist[nv] != -1:
            continue
        # 新たな頂点 nv について距離情報を更新してキューに追加する
        dist[nv] = dist[v] + 1
        pos.append(nv)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dist[c] % 2 == dist[d] % 2:
        print("Town")
    else:
        print("Road")from collections import deque


def graph(n):
    res = [[] for _ in range(n)]
    return res


n, q = map(int, input().split())

g = graph(n + 1)
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

Q = deque()
check = set()

Q.append(1)
check.add(1)
cnt = 1
A = [0] * (n + 1)
while cnt:
    now = Q.popleft()
    cnt -= 1
    for i in range(len(g[now])):
        x = g[now][i]
        if x in check:
            continue
        Q.append(x)
        cnt += 1
        check.add(x)
        A[x] = A[now] ^ 1

while q:
    x, y = map(int, input().split())
    print('Road' if A[x] ^ A[y] else 'Town')
    q -= 1
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
import math
import bisect
import random
from itertools import permutations, accumulate, combinations, product
import sys
import string
from bisect import bisect_left, bisect_right
from math import factorial, ceil, floor
from operator import mul
from functools import reduce

sys.setrecursionlimit(2147483647)
INF = 10**13


def LI():
    return list(map(int, sys.stdin.buffer.readline().split()))


def I():
    return int(sys.stdin.buffer.readline())


def LS():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()


def S():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8')


def IR(n):
    return [I() for i in range(n)]


def LIR(n):
    return [LI() for i in range(n)]


def SR(n):
    return [S() for i in range(n)]


def LSR(n):
    return [LS() for i in range(n)]


def SRL(n):
    return [list(S()) for i in range(n)]


def MSRL(n):
    return [[int(j) for j in list(S())] for i in range(n)]


mod = 1000000007


class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(int, input().split())
    G[x - 1] += [y - 1]
    G[y - 1] += [x - 1]
lca = LCA(G)
for _ in range(Q):
    a, b = map(int, input().split())
    if (lca.depth[a - 1] + lca.depth[b - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
import heapq

input = sys.stdin.readline


def dijkstra(V, e_list):
    inf = float('inf')
    done = [False] * V
    dist = [inf] * V
    dist[0] = 0
    node_heap = []
    heapq.heappush(node_heap, [dist[0], 0])
    while node_heap:
        tmp = heapq.heappop(node_heap)
        cur_node = tmp[1]
        if not done[cur_node]:
            for e in e_list[cur_node]:
                if dist[e[0]] > dist[cur_node] + e[1]:
                    dist[e[0]] = dist[cur_node] + e[1]
                    heapq.heappush(node_heap, [dist[e[0]], e[0]])
        done[cur_node] = True
    return dist


n, q = map(int, input().split())
l_adj = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    l_adj[a - 1].append([b - 1, 1])
    l_adj[b - 1].append([a - 1, 1])

dist = dijkstra(n, l_adj)

l_cd = []
for _ in range(q):
    c, d = map(int, input().split())
    l_cd.append([c - 1, d - 1])

for cd in l_cd:
    c = cd[0]
    d = cd[1]
    dist_c = dist[c]
    dist_d = dist[d]
    if abs(dist_c - dist_d) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque
from collections import defaultdict as ddict


def main():
    N, Q = map(int, input().split())

    way = ddict(list)
    for _ in range(N - 1):
        a, b = map(int, input().split())
        way[a].append(b)
        way[b].append(a)

# print(way)
    ansdic = {1: 0}
    mita = {1: 1}

    que = deque([1])
    fukasa = 0

    while que:
        #print(que, fukasa)
        q = que.popleft()
        fukasa += 1
        if q in ansdic:
            fukasa = ansdic[q] + 1
        tmp = deque([])
        for town in way[q]:
            if town in mita:
                continue
            mita[town] = 1
            que.append(town)
            ansdic[town] = fukasa

        #   print(ansdic)

    inlis = []
    for _ in range(Q):
        c, d = map(int, input().split())
        inlis.append([c, d])

    for i in range(Q):
        c, d = inlis[i]
        cpo = ansdic[c]
        dpo = ansdic[d]
        #print(c,d,cpo,dpo)
        if abs(dpo - cpo) % 2 == 1:
            print('Road')
        else:
            print('Town')

if __name__ == "__main__":
    main()
import bisect, collections, copy, heapq, itertools, math, string, sys, queue, time, random

input = lambda: sys.stdin.readline().rstrip()


def I():
    return input()


def IS():
    return input().split()


def II():
    return int(input())


def IIS():
    return map(int, input().split())


def LIIS():
    return list(map(int, input().split()))


def Base_n_to_10(X, n):
    out = 0
    for i in range(1, len(str(X)) + 1):
        out += int(X[-i]) * (n**(i - 1))
    return out  #int out


def Base_10_to_n(X, n):
    if (X // n):
        return Base_10_to_n(X // n, n) + str(X % n)
    return str(X % n)


INF = 10**18
MOD = 10**9 + 7
sys.setrecursionlimit(10**8)
##############################################################################
n, Q = IIS()
path = [[] for i in range(n)]
for i in range(n - 1):
    a, b = IIS()
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)
used = [False for i in range(n)]
val = [0 for i in range(n)]
used[0] = True
q = collections.deque()
q.append((0, 0))
while len(q):
    v, c = q.popleft()
    for i in path[v]:
        if used[i]: continue
        used[v] = True
        val[i] = c + 1
        q.append((i, c + 1))
for i in range(Q):
    c, d = IIS()
    if (val[d - 1] - val[c - 1]) % 2:
        print("Road")
    else:
        print("Town")
from collections import deque

N, Q = map(int, input().split())
adjacencies = {vertex: [] for vertex in range(1, N + 1)}
for _ in range(N - 1):
    a, b = map(int, input().split())
    adjacencies[a].append(b)
    adjacencies[b].append(a)
root = 1
distance = {root: 0}
queue = deque([root])
while queue:
    vertex = queue.popleft()
    for adj_vertex in adjacencies[vertex]:
        if adj_vertex not in distance:
            distance[adj_vertex] = distance[vertex] + 1
            queue.append(adj_vertex)
ans_list = []
for _ in range(Q):
    c, d = map(int, input().split())
    if abs(distance[c] - distance[d]) % 2 == 0:
        ans_list.append('Town')
    else:
        ans_list.append('Road')
for a in ans_list:
    print(a)
from itertools import accumulate
from collections import deque
from heapq import heappush, heappop
from inspect import currentframe


def LI():
    return list(map(int, input().split()))


def II():
    return int(input())


def chkprint(*args):
    names = {id(v): k for k, v in currentframe().f_back.f_locals.items()}
    print(', '.join(
        names.get(id(arg), '???') + ' = ' + repr(arg) for arg in args))


N, Q = LI()
F = [[] for i in range(N + 1)]
#print("F",F)

for _ in range(N - 1):
    a, b = LI()
    F[a].append(b)
    F[b].append(a)
#print("F",F)
#print("a",a,"b",b)
# aから始める

DD = [0 for i in range(N + 1)]

root = a
A = [False for i in range(N + 1)]
A[a] = True
DQ = deque([[a, 0]])

while DQ:
    v, cost = DQ.pop()
    DD[v] = cost
    for nv in F[v]:
        if A[nv] == False:
            A[nv] = True
            DQ.append([nv, cost + 1])
#print("DD",DD)
for _ in range(Q):
    c, d = LI()
    if abs(DD[c] - DD[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
import sys

sys.setrecursionlimit(10**7)
input = sys.stdin.readline
n, q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]
ki = [[] for _ in range(n)]
for a, b in ab:
    a, b = a - 1, b - 1
    ki[a].append(b)
    ki[b].append(a)

# n: 頂点数
# ki: 木
# Euler Tour の構築
S = []  # Euler Tour
F = [0] * n  # F[v]:vにはじめて訪れるステップ
depth = [0] * n  # 0を根としたときの深さ


def dfs(v, pare, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in ki[v]:
        if w == pare: continue
        dfs(w, v, d + 1)
        S.append(v)


dfs(0, -1, 0)
ary = [[depth[v], v] for v in range(n)]

# Sをセグメント木に乗せる
# u,vのLCAを求める:S[F[u]:F[v]+1]のなかでdepthが最小の頂点を探せば良い
# F[u]:uに初めてたどるつくステップ
# S[F[u]:F[v]+1]:はじめてuにたどり着いてつぎにvにたどるつくまでに訪れる頂点
# 存在しない範囲は深さが他よりも大きくなるようにする
INF = (n, None)
# LCAを計算するクエリの前計算
M = 2 * n
M0 = 2**(M - 1).bit_length()  # M以上で最小の2のべき乗
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


# LCAの計算 (外から呼び出す関数)
def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for c, d in cd:
    c, d = c - 1, d - 1
    lca = query(c, d)
    tmp = depth[c] + depth[d] - depth[lca] * 2
    if tmp % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())  # 頂点数と辺数

# グラフ入力受け取り (ここでは無向グラフを想定)
graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * n  # 全頂点を -1 (未訪問) に初期化
pos = deque()  # キュー

# 初期条件 (頂点 0 を始点とする)
dist[0] = 0
pos.append(0)

# 幅優先探索 (キューが空になるまで探索を行う)
while len(pos) > 0:
    v = pos.popleft()  # キューから先頭の頂点を取り出す
    for nv in graph[v]:
        # 既に訪問済みの頂点は探索しない
        if dist[nv] != -1:
            continue
        # 新たな頂点 nv について距離情報を更新してキューに追加する
        dist[nv] = dist[v] + 1
        pos.append(nv)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    d = abs(dist[c] - dist[d])
    if d % 2 == 0:
        print("Town")
    else:
        print("Road")
from os import environ
import sys
import math
from queue import Queue
if environ.get("hardik"):
    sys.stdin = open('../input.txt', 'r')
    sys.stdout = open('../output.txt', 'w')
sys.setrecursionlimit(10**5)
input = sys.stdin.readline
print = sys.stdout.write
mod = (10**9) + 7


def I():
    return input()


def II():
    return int(input())


def MI():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


def P(z=''):
    print(str(z) + '\n')


def LP(z=[]):
    for i in z:
        print(str(i) + ' ')
    print('\n')


def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)


def sieve(n):
    isPrimes = [True for i in range(n + 1)]
    isPrimes[0], isPrimes[1] = False, False
    p = 2
    while p * p <= n:
        if isPrimes[p] == True:
            for j in range(p * p, n, p):
                isPrimes[j] = False
        p += 1


n, queries = MI()
mat = [[] for x in range(n)]
for i in range(n - 1):
    a, b = MI()
    mat[a - 1].append(b - 1)
    mat[b - 1].append(a - 1)
colors = [None for _ in range(n)]
isVisited = [0 for _ in range(n)]
colors[0] = 0
q = Queue()
q.put(0)
while not q.empty():
    node = q.get()
    for i in mat[node]:
        if colors[i] == None:
            colors[i] = 1 - colors[node]
            q.put(i)
for i in range(queries):
    a, b = MI()
    a -= 1
    b -= 1
    if colors[a] == colors[b]:
        P("Town")
    else:
        P("Road")
import sys
#from numba import jit
#import collections
#import math
#sys.setrecursionlimit(200000)

input_methods = ['clipboard', 'file', 'key']
using_method = 0
input_method = input_methods[using_method]

tin = lambda: map(int, input().split())
lin = lambda: list(tin())
MOD = 1000000007
INF = 10**12

#+++++
#for copy from lib

#+++++


def main():
    #n = int(input())
    n, q = tin()
    #s=input()
    #al=lin()
    path = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = tin()
        path[a - 1].append(b - 1)
        path[b - 1].append(a - 1)
    dist = [-1] * n
    dist[0] = 0
    pp = []
    for np in path[0]:
        pp.append(np)
        dist[np] = 1

    while len(pp) > 0:
        np = pp[-1]
        pp.pop()
        for nnp in path[np]:
            if dist[nnp] != -1:
                continue
            dist[nnp] = dist[np] + 1
            pp.append(nnp)

    for _ in range(q):
        a, b = tin()
        a, b = a - 1, b - 1
        dd = dist[a] + dist[b]
        if dd % 2 == 0:
            print('Town')
        else:
            print('Road')


#+++++
isTest = False


def pa(*vl):
    if not isTest:
        return
    #for v in vl:
    print(vl)


def input_clipboard():
    import clipboard
    input_text = clipboard.get()
    input_l = input_text.splitlines()
    for l in input_l:
        yield l


if __name__ == "__main__":
    if sys.platform == 'ios':
        if input_method == input_methods[0]:
            ic = input_clipboard()
            input = lambda: ic.__next__()
        elif input_method == input_methods[1]:
            sys.stdin = open('inputFile.txt')
        else:
            pass
        isTest = True
    else:
        pass
        #input = sys.stdin.readline

    ret = main()
    if ret is not None:
        print(ret)
import sys

sys.setrecursionlimit(10**7)
N, Q = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    G[a].append(b)
    G[b].append(a)

# Euler Tour Technique
S = []
FS = [0] * N
depth = [0] * N


def dfs(v, p, d):
    depth[v] = d
    FS[v] = len(S)
    S.append(v)
    for w in G[v]:
        if w == p:
            continue
        dfs(w, v, d + 1)
        S.append(v)


dfs(0, -1, 0)

# Sparse Table
L = len(S)
lg = [0] * (L + 1)
for i in range(2, L + 1):
    lg[i] = lg[i >> 1] + 1
st = [None] * (lg[L] + 1)
st0 = st[0] = S
b = 1
for i in range(lg[L]):
    st0 = st[i + 1] = [
        p if depth[p] <= depth[q] else q for p, q in zip(st0, st0[b:])
    ]
    b <<= 1


# LCA O(1)
def query(u, v):
    x = FS[u]
    y = FS[v]
    if x > y:
        x, y = y, x
    l = lg[y - x + 1]
    px = st[l][x]
    py = st[l][y - (1 << l) + 1]
    return px if depth[px] <= depth[py] else py


q = [list(map(int, input().split())) for _ in range(Q)]

for x, y in q:
    x, y = x - 1, y - 1
    z = query(x, y)
    if (depth[x] - depth[z]) % 2 == (depth[y] - depth[z]) % 2:
        print("Town")
    else:
        print("Road")
n, q = (int(x) for x in input().split())
orders = [0 for _ in range(n)]
orders[0] = 1
path = [[] for _ in range(n)]
#print(path)
for i in range(n - 1):
    a, b = (int(x) for x in input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)

from collections import deque

d = deque()
d.append(0)
orders[0] = 1
while d:
    tmp = d.popleft()
    for i in path[tmp]:
        if orders[i] != 0:
            continue
        d.append(i)
        orders[i] = orders[tmp] + 1

ans = []
for i in range(q):
    c, d = (int(x) for x in input().split())
    if orders[c - 1] == orders[d - 1]:
        if (c - 1) in path[d - 1]:
            ans.append("Road")
            continue
    tmp = orders[c - 1] - orders[d - 1]
    if tmp % 2 == 0:
        #print("Town")
        ans.append("Town")
    elif tmp % 2 != 0:
        #print("Road")
        ans.append("Road")
for i in ans:
    print(i)
import heapq
import sys
import math
# import numpy as np
from heapq import heappush, heappop
import inspect
import itertools
import bisect
from collections import deque
from collections import Counter
from collections import defaultdict
from decimal import Decimal

sys.setrecursionlimit(10**7)
MOD1 = 10**9 + 7
MOD2 = 998244353
MOD = MOD2
INF = float('inf')
DYDX = [(1, 0), (0, 1), (-1, 0), (0, -1)]
input = sys.stdin.readline


def ii():
    return int(input())


def si():
    return str(input()[:-1])


def li():
    return list(input())


def mi():
    return map(int, input().split())


def lmi():
    return list(map(int, input().split()))


def folmi(n):
    return [list(map(int, input().split())) for _ in range(n)]


def foli(n):
    return [list(input()[:-1]) for _ in range(n)]


def foi(n):
    return [input()[:-1] for _ in range(n)]


def foii(n):
    return [int(input()[:-1]) for _ in range(n)]


def lcm(a, b):
    return a // math.gcd(a, b) * b


def cnt_digits(a):
    return len(str(a))


###############################################################################

###############################################################################


def p(x):
    print(x)


def pmat(mat):
    for i in mat:
        print(i)


def dmat(mat):
    for i in mat:
        print(i, file=sys.stderr)


def dd(a, b=None, c=None, d=None):
    frame = inspect.currentframe()
    stack = inspect.getouterframes(frame)
    varnames = stack[1].code_context[0].split('(')[1].split(')')[0].split(",")
    outputs = []
    for i in range(len(varnames)):
        outputs.append("|")
        outputs.append(varnames[i])
        outputs.append("=")
        if i == 0:
            outputs.append(a)
        elif i == 1:
            outputs.append(b)
        elif i == 2:
            outputs.append(c)
        elif i == 3:
            outputs.append(d)
        if i == len(varnames) - 1:
            outputs.append("|")
    print(*outputs, file=sys.stderr)


def pow(x, n, mod):
    ans = 1
    while n > 0:
        if n % 2 != 0:
            ans *= x % mod
        x = x * x % mod
        n = n // 2
    return ans


def nck(n, r, mod):
    x, y = 1, 1
    for i in range(r):
        x = x * (n - i) % mod
        y = y * (i + 1) % mod
    return x * pow(y, mod - 2, mod) % mod


def make_divisors(n):
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]


def primes(x):
    if x < 2:
        return []
    primes = [i for i in range(x)]
    primes[1] = 0
    for prime in primes:
        if prime > math.sqrt(x):
            break
        if prime == 0:
            continue
        for non_prime in range(2 * prime, x, prime):
            primes[non_prime] = 0
    return [prime for prime in primes if prime != 0]


def prime_numbers(n):
    if n < 2:
        return []
    m = (n + 1) // 2
    p = [1] * m
    for i in range(1, int((n**0.5 - 1) / 2) + 1):
        if p[i]:
            p[2 * i * (i + 1):: 2 * i + 1] = [0] * \
                (((m - 1) - 2 * i * (i + 1)) // (2 * i + 1) + 1)
    return {2} | {2 * i + 1 for i in range(1, m) if p[i]}


def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a


def is_prime(x):
    if x < 2:
        return False
    if x == 2 or x == 3 or x == 5:
        return True
    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:
        return False
    prime = 7
    step = 4
    while prime <= math.sqrt(x):
        if x % prime == 0:
            return False
        prime += step
        step = 6 - step
    return True


def prime_factorize_count(n):
    return Counter(prime_factorize(n))


class dsu:
    __slots__ = ["n", "parent_or_size"]

    def __init__(self, n):
        self.n = n
        self.parent_or_size = [-1] * n

    def merge(self, a, b):
        x = self.leader(a)
        y = self.leader(b)
        if x == y:
            return x
        if self.parent_or_size[y] < self.parent_or_size[x]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self.parent_or_size[y] = x
        return x

    def same(self, a, b):
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        path = []
        while self.parent_or_size[a] >= 0:
            path.append(a)
            a = self.parent_or_size[a]
        for child in path:
            self.parent_or_size[child] = a
        return a

    def size(self, a):
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        result = [[] for _ in range(self.n)]
        for i in range(self.n):
            result[self.leader(i)].append(i)
        return [g for g in result if g]


# def dijkstra(s, n):
#     dist = [INF] * (n + 1)
#     hq = [(0, s)]
#     dist[s] = 0
#     seen = [False] * (n + 1)
#     while hq:
#         v = heappop(hq)[1]
#         seen[v] = True
#         for to, cost in a[v]:
#             if seen[to] == False and dist[v] + cost < dist[to]:
#                 dist[to] = dist[v] + cost
#                 heappush(hq, (dist[to], to))
#     return dist

# nck modp
# MAX = 200010
# MOD = MOD1
# fac = [0] * MAX
# finv = [0] * MAX
# inv = [0] * MAX

# def cominit():
#     for i in range(2):
#         fac[i] = 1
#         finv[i] = 1
#     inv[1] = 1
#     for i in range(2, MAX):
#         fac[i] = fac[i - 1] * i % MOD
#         inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
#         finv[i] = finv[i - 1] * inv[i] % MOD

# def com(n, k):
#     return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD


class ModInt:
    def __init__(self, x):
        self.x = x % MOD

    def __str__(self):
        return str(self.x)

    __repr__ = __str__

    def __add__(self, other):
        return (ModInt(self.x + other.x)
                if isinstance(other, ModInt) else ModInt(self.x + other))

    def __sub__(self, other):
        return (ModInt(self.x - other.x)
                if isinstance(other, ModInt) else ModInt(self.x - other))

    def __mul__(self, other):
        return (ModInt(self.x * other.x)
                if isinstance(other, ModInt) else ModInt(self.x * other))

    def __truediv__(self, other):
        return (ModInt(self.x * pow(other.x, MOD - 2, MOD)) if isinstance(
            other, ModInt) else ModInt(self.x * pow(other, MOD - 2, MOD)))

    def __pow__(self, other):
        return (ModInt(pow(self.x, other.x, MOD)) if isinstance(other, ModInt)
                else ModInt(pow(self.x, other, MOD)))

    __radd__ = __add__

    def __rsub__(self, other):
        return (ModInt(other.x - self.x)
                if isinstance(other, ModInt) else ModInt(other - self.x))

    __rmul__ = __mul__

    def __rtruediv__(self, other):
        return (ModInt(other.x * pow(self.x, MOD - 2, MOD)) if isinstance(
            other, ModInt) else ModInt(other * pow(self.x, MOD - 2, MOD)))

    def __rpow__(self, other):
        return (ModInt(pow(other.x, self.x, MOD)) if isinstance(other, ModInt)
                else ModInt(pow(other, self.x, MOD)))


###############################################################################
#
###############################################################################
n, q = mi()
edge = [[] for _ in range(n)]
dep = [0] * n

for i in range(n - 1):
    a, b = mi()
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)


def dfs(x, last=-1):
    for to in edge[x]:
        if to == last:
            continue
        dep[to] = dep[x] + 1
        dfs(to, x)


dfs(0)

for _ in range(q):
    c, d = mi()
    c -= 1
    d -= 1
    if dep[c] & 1 == dep[d] & 1:
        p("Town")
    else:
        p("Road")
from collections import deque

n, q = map(int, input().split())
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a = a - 1
    b = b - 1
    g[a].append(b)
    g[b].append(a)
dpt = list(-1 for i in range(n))
que = deque([0])
dpt[0] = 0
while que:
    u = que.popleft()
    for v in g[u]:
        if (dpt[v] == -1):
            dpt[v] = dpt[u] + 1
            que.append(v)
while q > 0:
    q = q - 1
    c, d = map(int, input().split())
    c = c - 1
    d = d - 1
    if (dpt[c] + dpt[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
class LCA:
    """
    オイラーツアーとRMQでLCAを求める
    n: 木の頂点数
    edge: 辺のリストのリスト
    root: 根（デフォルト0）

    計算量
    初期化: O(N)
    クエリ: O(logN)
    定数倍が重い
    """
    class SegmentTree:
        def __init__(self, op, e, n, array=None):
            self.e = e
            self.op = op
            self.n = n
            self.log = (self.n - 1).bit_length()
            self.size = 1 << self.log
            self.d = [e] * (2 * self.size)

            if array:
                for i in range(self.n):
                    self.d[self.size + i] = array[i]
                for i in reversed(range(1, self.size)):
                    self.__update(i)

        def set(self, p, x):
            """
            a[p] に x を代入する
            """
            p += self.size
            self.d[p] = x
            for i in range(1, self.log + 1):
                self.__update(p >> i)

        def get(self, p):
            """
            a[p]を返す
            """
            return self.d[p + self.size]

        def prod(self, l, r):
            """
            [l, r) の総積を返す
            """
            op = self.op

            sml = self.e
            smr = self.e

            l += self.size
            r += self.size

            while l < r:
                if l & 1:
                    sml = op(sml, self.d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = op(self.d[r], smr)
                l >>= 1
                r >>= 1
            return op(sml, smr)

        def all_prod(self):
            """
            [0, n) の総積を返す
            """
            return self.d[1]

        def max_right(self, l, f):
            if l == self.n:
                return self.n
            op = self.op
            size = self.size
            l += size
            sm = self.e

            while True:
                while not (l & 1):
                    l >>= 1
                if not f(op(sm, self.d[l])):
                    while l < size:
                        l <<= 1
                        if f(op(sm, self.d[l])):
                            sm = op(sm, self.d[l])
                            l += 1
                    return l - size
                sm = op(sm, self.d[l])
                l += 1
                if (l & -l) == l:
                    break
            return self.n

        def min_left(self, r, f):
            if r == 0:
                return 0
            op = self.op
            size = self.size
            r += self.size
            sm = self.e

            while True:
                r -= 1
                while r and r & 1:
                    r >>= 1
                if not f(op(self.d[r], sm)):
                    while r < size:
                        r = 2 * r + 1
                        if f(op(self.d[r], sm)):
                            sm = op(self.d[r], sm)
                            r -= 1
                    return r + 1 - size
                sm = op(self.d[r], sm)
                if (r & -r) == r:
                    break
            return 0

        def __update(self, k):
            self.d[k] = self.op(self.d[k << 1], self.d[k << 1 | 1])

    def __init__(self, n, edge, root=0):
        self.n = n
        self.root = root
        self.edge = edge
        self.et = []
        self.id = [-1] * self.n
        self.depth = []
        self._init_euler_tour()
        self.depth.append(float("inf"))  # indexを取得するRMQの単位元用

        def f(x, y):
            return x if self.depth[x] < self.depth[y] else y

        self.seg = self.SegmentTree(f, 2 * n - 1, 2 * n,
                                    [i for i in range(2 * n)])

    def _init_euler_tour(self):
        seen = [False] * self.n
        stack_v = [self.root]
        stack_d = [0]

        while stack_v:
            u = stack_v.pop()
            d = stack_d.pop()
            if u >= 0:
                seen[u] = True
                self.et.append(u)
                self.depth.append(d)

                for v in self.edge[u][::-1]:
                    if seen[v]:
                        continue
                    stack_v.append(~u)
                    stack_v.append(v)
                    stack_d.append(d)
                    stack_d.append(d + 1)
            else:
                self.et.append(~u)
                self.depth.append(d)

        for i, u in enumerate(self.et):
            if self.id[u] == -1:
                self.id[u] = i

    def get_lca(self, u, v):
        x, y = min(self.id[u], self.id[v]), max(self.id[u], self.id[v])
        return self.et[self.seg.prod(x, y + 1)]


def main():
    import sys
    read = sys.stdin.read
    readline = sys.stdin.readline
    INF = float('INF')
    # INF = (1 << 62) - (1 << 31)
    MOD = 10**9 + 7
    sys.setrecursionlimit(10**5)
    N, Q = map(int, readline().split())
    edge = [[] for _ in range(N)]

    for _ in range(N - 1):
        a, b = (x - 1 for x in map(int, readline().split()))
        edge[a].append(b)
        edge[b].append(a)

    lca = LCA(N, edge)

    for _ in range(Q):
        c, d = (x - 1 for x in map(int, readline().split()))
        p = lca.get_lca(c, d)
        dist = lca.id[c] + lca.id[d] - 2 * lca.id[p]
        print('Town' if dist % 2 == 0 else 'Road')


if __name__ == '__main__':
    main()
N, Q = map(int, input().split())
L = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    L[a].append(b)
    L[b].append(a)

dp = [-1 for _ in range(N)]
dp[0] = 0
que = [0]
bl = [1, 0]

for i in que:
    for j in L[i]:
        if dp[j] == -1:
            que.append(j)
            dp[j] = bl[dp[i]]

for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print('Town' if dp[c] == dp[d] else 'Road')
#
import sys, math

sys.setrecursionlimit(10**8)


def readline():
    return sys.stdin.buffer.readline()


def read():
    return sys.stdin.buffer.read()


def decode(s):
    return s.decode()


mod = 10**9 + 7
INF = 1 << 50


def get_dist(to):
    dists = [-1] * len(to)

    def dfs(c):
        nval = dists[c] + 1
        for nc in to[c]:
            if dists[nc] == -1:
                dists[nc] = nval
                dfs(nc)

    dists[1] = 0
    dfs(1)
    return dists


def main():
    N, Q = map(int, readline().split())
    to = [[] for _ in range(N + 1)]
    for _ in range(N - 1):
        a, b = map(int, readline().split())
        to[a].append(b)
        to[b].append(a)
    D = get_dist(to)
    for _ in range(Q):
        c, d = map(int, readline().split())
        d = abs(D[c] - D[d])
        if not d % 2:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
import sys

sys.setrecursionlimit(10**6)

N, Q = map(int, input().split())
g = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

cnt = [0] * N


def f(cur, par, i):
    cnt[cur] = i
    for chi in g[cur]:
        if chi != par:
            f(chi, cur, i + 1)


f(0, -1, 0)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    tmp = (cnt[d] - cnt[c]) % 2
    if tmp:
        print('Road')
    else:
        print('Town')
import sys

input = sys.stdin.readline

N, Q = [int(x) for x in input().split()]  # nは頂点の数、mは辺の数
g = [[] for _ in range(N)]  # 隣接リスト

for _ in range(N - 1):
    a, b = [int(x) for x in input().split()]
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * N  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


A = bfs(0)
for _ in range(Q):
    c, d = [int(x) for x in input().split()]
    num = A[c - 1] - A[d - 1]
    if num % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = list(map(int, input().split()))

g = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = list(map(lambda x: int(x) - 1, input().split()))
    g[a].append(b)
    g[b].append(a)

from collections import deque


def bfs(v):
    q = deque()
    q.append(v)
    d = [-1] * n
    d[v] = 0
    while q:
        v = q.popleft()
        for u in g[v]:
            if d[u] != -1: continue
            d[u] = d[v] + 1
            q.append(u)
    return d


a = bfs(0)

for i in range(q):
    c, d = list(map(lambda x: int(x) - 1, input().split()))

    if (a[c] - a[d]) % 2:
        print('Road')
    else:
        print('Town')
from collections import deque


def bfs(v):
    ## キューを作成
    que = deque()
    ## 深さ記録用のリストを作成
    depth_log = [None for _ in range(N + 1)]
    ## 初期値として、1つ目のノードの接続先ノードをQueに入れる
    current_depth = 0
    depth_log[0] = 0  # 使用しない0番目の値も0にしておく
    depth_log[v] = 0
    for node in graph[v]:
        depth_log[node] = current_depth + 1
        que.append(node)

    # que がなくなるまで以下を繰り返し
    while que:
        node = que.popleft()
        for _ in graph[node]:
            current_depth = depth_log[node] + 1
            if depth_log[_] == None:
                depth_log[_] = current_depth
                que.append(_)
    return depth_log


## 入力
N, Q = [int(i) for i in input().split()]

graph = [[] for _ in range(N + 1)]

graph[0].append(0)

for _ in range(N - 1):
    a, b = [int(i) for i in input().split()]
    graph[a].append(b)
    graph[b].append(a)

bfs_graph = bfs(1)

for q in range(Q):
    c, d = [int(i) for i in input().split()]
    if (bfs_graph[c] - bfs_graph[d]) % 2 == 1:
        print('Road')
    else:
        print('Town')
from collections import deque

n, q = map(int, input().split())

graph = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i in range(q):
    c, d = map(int, input().split())
    s = dist[c] + dist[d]
    if s % 2 == 1:
        print('Road')
    else:
        print('Town')
import sys
from collections import defaultdict, deque

sys.setrecursionlimit(10**7)
input = sys.stdin.readline
import array as ar

N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for i in range(N - 1)]
CD = [list(map(int, input().split())) for i in range(Q)]

g = defaultdict(list)
for a, b in AB:
    g[a].append(b)
    g[b].append(a)

depth = [0] * (N + 1)
parent = [1] * (N + 1)
visited = [False] * (N + 1)
dq = deque([1])
while dq:
    v = dq.popleft()
    visited[v] = True
    for nv in g[v]:
        if visited[nv]:
            continue
        depth[nv] = depth[v] + 1
        parent[nv] = v
        dq.append(nv)

anc = [ar.array('I', list(range(N + 1))), ar.array('I', parent)]
for i in range(15):
    temp = ar.array('I', [1] * (N + 1))
    for v in range(1, N + 1):
        temp[v] = anc[-1][anc[-1][v]]
    anc.append(temp)

for c, d in CD:
    tc, td = c, d
    while tc != td:
        for i in range(len(anc) - 1, -1, -1):
            if anc[i][tc] != anc[i][td]:
                tc = anc[i][tc]
                td = anc[i][td]
        if parent[tc] == parent[td]:
            break
    a = parent[tc]
    d = depth[c] + depth[d] - 2 * depth[a]
    if d % 2 == 0:
        print('Town')
    else:
        print('Road')
import math
from collections import deque, Counter
from itertools import product, combinations, permutations

n, q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

g = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = ab[i][0], ab[i][1]
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

dist = [-1] * n
godeq = deque()
root = 0

dist[root] = 0
godeq.append(root)

while (godeq):
    v = godeq.popleft()
    for next in g[v]:
        if dist[next] != -1:
            continue
        else:
            dist[next] = dist[v] + 1
            godeq.append(next)

for qu in cd:
    if (dist[qu[1] - 1] - dist[qu[0] - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
Roads = []
Ables = [[] for i in range(N)]  #i番目のlistはi番目の街から行ける場所のリスト
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    Ables[a].append(b)
    Ables[b].append(a)

nows = {0}
count = 1
odd = set()
even = set()
done = set()
even.add(0)
while True:
    goto = set()
    for now in nows:
        done.add(now)
        for to in Ables[now]:
            goto.add(to)
    nows = goto - done
    for now in nows:
        if count % 2 == 0:
            even.add(now)
        else:
            odd.add(now)
    count += 1
    if len(nows) == 0:
        break


def PrintAns(c, d):
    if (c in odd and d in odd) or (c in even and d in even):
        print("Town")
    else:
        print("Road")


for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    PrintAns(c, d)
# coding: utf-8
# Your code here!
import sys

sys.setrecursionlimit(1000000)
from collections import deque

n, q = map(int, input().split())
g = [[] for i in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)
dist = [-1 for i in range(n)]
que = deque()
que.append((0, 0))
while que:
    v, d = que.pop()
    if dist[v] >= 0:
        continue
    dist[v] = d
    for vv in g[v]:
        que.append((vv, d + 1))
for _ in range(q):
    c, d = map(int, input().split())
    if (dist[c - 1] + dist[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque
import sys

input = sys.stdin.readline

n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

visited = [-1] * n
temp = deque([0])
visited[0] = 0

while temp:
    p = temp.popleft()
    for pp in g[p]:
        if visited[pp] != -1: continue
        visited[pp] = visited[p] + 1
        temp.append(pp)

for i in range(q):
    c, d = map(int, input().split())
    if visited[c - 1] % 2 == visited[d - 1] % 2: print('Town')
    else: print('Road')
def abc209d():
    from collections import deque
    n, Q = map(int, input().split())
    g = [list() for _ in range(n)]
    for _ in range(n - 1):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        g[a].append(b)
        g[b].append(a)
    c = [-1] * n
    q = deque([0])
    c[0] = 0
    while len(q) > 0:
        node = q.popleft()
        for nxt in g[node]:
            if c[nxt] != -1: continue
            c[nxt] = 1 - c[node]
            q.append(nxt)
    ans = []
    for _ in range(Q):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        if c[a] == c[b]:
            ans.append("Town")
        else:
            ans.append("Road")
    for item in ans:
        print(item)


abc209d()
from collections import deque


class Node:
    def __init__(self, index):
        self.index = index
        self.nears = []
        self.dis = 0
        self.visited = 0


N, Q = map(int, input().split())
maps = [list(map(int, input().split())) for _ in range(N - 1)]
queries = [list(map(int, input().split())) for _ in range(Q)]

nodes = []
for i in range(N + 1):
    nodes.append(Node(i))

for map in maps:
    a, b = map
    nodes[a].nears.append(b)
    nodes[b].nears.append(a)

queue = deque()
queue.append(nodes[1])
nodes[1].visited = 1

while queue:
    node = queue.popleft()
    nears = node.nears
    for near in nears:
        if nodes[near].visited == 0:
            queue.append(nodes[near])
            nodes[near].visited = 1
            nodes[near].dis = node.dis + 1

for query in queries:
    _c, _d = query
    c = nodes[_c].dis
    d = nodes[_d].dis
    if (c - d) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
from pprint import pprint


def do():
    n, qnum = map(int, input().split())

    numv = n

    rootnode = 0

    parentlist = [None] * numv
    distlist = [-1] * numv

    e = [[] for _ in range(numv)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        e[a].append(b)
        e[b].append(a)

    dt = []
    for i in range(63):
        l = [-1] * numv
        dt.append(l)

    # calc depth and parent node
    from collections import deque
    q = deque([])
    q.append([rootnode, -1, 0])
    while len(q) != 0:
        node, parent, d = q.popleft()
        parentlist[node] = parent
        distlist[node] = d
        for nextnode in e[node]:
            if parentlist[nextnode] is not None:  # visited
                continue
            q.append([nextnode, node, d + 1])

    # doubling calc
    for i in range(numv):
        dt[0][i] = parentlist[i]
    for i in range(1, 63):
        for curnode in range(numv):
            p1 = dt[i - 1][curnode]
            p2 = dt[i - 1][p1] if p1 != -1 else -1
            dt[i][curnode] = p2

    def ancestor(node, n):
        i = 0
        cur = node
        while n != 0:
            x = 2**i
            if (n & x) != 0:  # this bit is 1
                n ^= x  # this bit is off
                cur = dt[i][cur]
            i += 1
        return cur

    def lca(nodeu, nodev):
        if nodeu == nodev:
            return nodeu
        tu = nodeu
        tv = nodev
        for k in range(60, -1, -1):
            mu = ancestor(tu, 2**k)
            mv = ancestor(tv, 2**k)
            if mu != mv:
                tu = mu
                tv = mv
        assert ancestor(tu, 1) == ancestor(tv, 1)
        return ancestor(tu, 1)

    for i in range(qnum):
        u, ov = map(int, input().split())
        u -= 1
        ov -= 1
        v = ov
        #print("q", u, v)
        # u < v
        if distlist[u] > distlist[v]:
            u, v = v, u
        d = distlist[v] - distlist[u]
        anc = ancestor(v, d)
        if anc == v:  # v が共通
            pass  # d is orig
        else:
            d = distlist[v] - distlist[anc]
            d += distlist[u] - distlist[anc]
        if (d % 2) == 0:
            print("Town")
        else:
            print("Road")


do()
import collections
import sys

sys.setrecursionlimit(10**6)


def main():
    n, q = map(int, input().split())
    ab = [tuple(map(int, input().split())) for _ in range(n - 1)]
    cd = [tuple(map(int, input().split())) for _ in range(q)]

    G = {}
    col = collections.Counter()

    #1. Input
    for a, b in ab:
        if a not in G.keys():
            G[a] = [b]
        else:
            G[a].append(b)
        if b not in G.keys():
            G[b] = [a]
        else:
            G[b].append(a)

    for a, b in ab:
        G[a].append(b)
        G[b].append(a)

    def dfs(pos, cur):
        col[pos] = cur
        for i in G[pos]:
            if (col[i] >= 1):
                continue
            dfs(i, 3 - cur)

#2. Graph Coloring

    dfs(1, 1)

    for c, d in cd:
        if col[c] == col[d]:
            print('Town')
        else:
            print('Road')

    return 0

if __name__ == '__main__':
    main()
from collections import deque


def bfs(u, g):
    queue = deque([u])
    d = [None] * n  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


n, q = map(int, input().split())
edge = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)
INF = 1001001001

dist = bfs(0, edge)
#print(dist)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
from collections import deque
#from collections import defaultdict as dfd
from sys import stderr

printn = lambda x: print(x, end='')
inn = lambda: int(input())
inl = lambda: list(map(int, input().split()))
inm = lambda: map(int, input().split())
ins = lambda: input().strip()
DBG = True  # and False
BIG = 10**18
R = 10**9 + 7  # 998244353


def ddprint(*args, **kwargs):
    if DBG:
        print(*args, file=stderr, **kwargs)


n, r = inm()
dst = [{} for i in range(n + 1)]
for i in range(n - 1):
    a, b = inm()
    dst[a][b] = dst[b][a] = 1
di = [R] * (n + 1)
q = deque([1])
di[1] = 0
while len(q) > 0:
    x = q.popleft()
    dd = di[x]
    for u in dst[x]:
        if di[u] == R:
            di[u] = dd + 1
            q.append(u)
for i in range(r):
    c, d = inm()
    print('Town' if (di[c] - di[d]) % 2 == 0 else 'Road')
import sys

sys.setrecursionlimit(10**7)


def dfs(depth, depths, node, parent, g):
    depths[node] = depth
    depth += 1
    for nex in g[node]:
        if nex == parent:
            continue
        dfs(depth, depths, nex, node, g)


n, q = map(int, input().split())
g = [[] for _ in range(n)]
depths = [0] * n
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

dfs(0, depths, 0, 0, g)
for _ in range(q):
    c, d = map(int, input().split())
    if abs(depths[c - 1] - depths[d - 1]) & 1:
        print('Road')
    else:
        print('Town')
import sys

sys.setrecursionlimit(1000000)
n, q = map(int, input().split())
graph = [set([]) for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].add(b - 1)
    graph[b - 1].add(a - 1)


def dfs(i):
    if temp[i]:
        return
    temp[i] = True
    if i in odd:
        for j in graph[i]:
            even.add(j)
            dfs(j)
    else:
        for j in graph[i]:
            odd.add(j)
            dfs(j)


temp = [False] * n
odd = set([])
even = set([])
odd.add(0)
dfs(0)
ans = []
for i in range(q):
    c, d = map(int, input().split())
    if (c - 1 in odd and d - 1 in odd) or (c - 1 in even and d - 1 in even):
        ans.append("Town")
    else:
        ans.append("Road")
for i in ans:
    print(i)
n, q = map(int, input().split())
ab = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    ab[a - 1].append(b - 1)
    ab[b - 1].append(a - 1)

inf = 10**15
from collections import deque

que = deque()
visited = [0] * n
dist = [inf] * n
que.append(0)
visited[0] = 1
dist[0] = 0

while que:
    x = que.popleft()
    for i in ab[x]:
        if dist[i] > dist[x] + 1 and visited[i] == 0:
            dist[i] = dist[x] + 1
            visited[i] = 1
            que.append(i)
#print(dist)
for i in range(q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque


def BFS(start, tree):
    search = deque()
    search.append(start)
    visited = {start[0]}  # リストでやるとおそい
    #kyori = {}
    while len(search) > 0:
        # print(search)
        node, depth = search.popleft()
        depth_list[node] = depth
        # print(node,depth)
        # if node in visited:
        #  continue
        for i in tree[node]:
            if i not in visited:
                search.append([i, depth + 1])
                visited.add(i)


n, q = map(int, input().split())

edges = [list() for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    edges[a].append(b)
    edges[b].append(a)
depth_list = [0] * n
BFS((0, 0), edges)
#print(depth_list)

for k in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if (depth_list[c] - depth_list[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
G = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
color = [False] * n
dist = [-1] * n
#町xからの距離の偶奇を記録する
dist[0] = 0
d = deque()
d.append(0)
while d:
    v = d.popleft()
    for i in G[v]:
        if dist[i] != -1:
            continue
        dist[i] = (dist[v] + 1) % 2
        d.append(i)
for i in range(q):
    c, d = map(int, input().split())
    if dist[c - 1] == dist[d - 1]:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())

a, b = [0] * (N - 1), [0] * (N - 1)
for i in range(N - 1):
    a[i], b[i] = map(int, input().split())

c, d = [0] * Q, [0] * Q
for i in range(Q):
    c[i], d[i] = map(int, input().split())

graph = [[] for _ in range(N)]
for i in range(N - 1):
    graph[a[i] - 1].append(b[i] - 1)
    graph[b[i] - 1].append(a[i] - 1)

dist = [-1 for _ in range(N)]
dist[0] = 0

que = deque()
que.append(0)

while que:
    current_node = que.popleft()
    for near_node in graph[current_node]:
        if dist[near_node] != -1:
            continue
        dist[near_node] = dist[current_node] + 1
        que.append(near_node)

for i in range(Q):
    if (dist[c[i] - 1] + dist[d[i] - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())

pic = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    x, y = map(int, input().split())
    pic[x].append(y)
    pic[y].append(x)


def BFS(x):

    visited = [None] * (n + 1)  #注_'None'を演算に使用するとエラーが返る
    visited[x] = 0  #頂点'x'から頂点'x'までの距離は'0'なので問題なし

    queue = deque([])  #探索候補の器、初期化
    queue.append(x)  #スタート位置('X')のみ追加しとく

    while queue:
        tmp = queue.popleft()  #探索候補を'popleft'
        for i in pic[tmp]:  #探索候補の隣接頂点を探索
            if visited[i] != None:  #訪問済の場合
                continue  #何もしない
            else:  #未訪問('None')の場合
                #visited[i]に'x'からの距離を一つ手前(visited[tmp])'+1'として記録
                visited[i] = visited[tmp] + 1
                queue.append(i)  #現在地を探索候補に'append'
    return visited  # visited[0]はダミーなので[1]以降をリストで出力


MAP = BFS(1)
for i in range(q):
    c, d = map(int, input().split())
    tmp = MAP[c] + MAP[d]
    if tmp % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque


def bfs(graph, N):
    parities = [None] * N
    parities[0] = 0
    que = deque([0])
    while que:
        node = que.popleft()
        p = parities[node] ^ 1
        for n in graph[node]:
            if parities[n] is None:
                parities[n] = p
                que.append(n)
    return parities


N, _, *R = map(int, open(0).read().split())
M = 2 * (N - 1)
R = [r - 1 for r in R]
E = R[:M]
Q = R[M:]
graph = [[] for _ in range(N)]
for a, b in zip(E[::2], E[1::2]):
    graph[a].append(b)
    graph[b].append(a)
parities = bfs(graph, N)
for a, b in zip(Q[::2], Q[1::2]):
    print("TRoowand"[parities[a] ^ parities[b]::2])
from collections import deque


class Node:
    def __init__(self):
        self.color = None
        self.paths = []


n, q = map(int, input().split())
g = [Node() for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].paths.append(b)
    g[b].paths.append(a)

queue = deque()
g[0].color = 1
queue.appendleft(g[0])
while queue:
    node = queue.pop()
    for to_node in node.paths:
        if g[to_node].color is None:
            g[to_node].color = 1 if node.color == 0 else 0
            queue.appendleft(g[to_node])

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if g[c].color == g[d].color:
        print('Town')
    else:
        print('Road')
from collections import defaultdict
from math import ceil, log2

n, q = map(int, input().strip().split())
tree = defaultdict(list)
for i in range(n - 1):
    u, v = map(int, input().strip().split())
    tree[u].append(v)
    tree[v].append(u)

level = dict()
visited = defaultdict(bool)

LEVEL = ceil(log2(n)) + 1
sparse = [[-1 for __ in range(LEVEL)] for ___ in range(n + 1)]


def dfs(u):
    st = [(u, 0)]
    while len(st):
        u, k = st.pop()
        visited[u] = True
        level[u] = k
        for v in tree[u]:
            if not visited[v]:
                st.append((v, k + 1))
                sparse[v][0] = u


dfs(1)

for i in range(1, LEVEL):
    for node in range(1, n + 1):
        if sparse[node][i - 1] != -1:
            sparse[node][i] = sparse[sparse[node][i - 1]][i - 1]


def lca(u, v):
    if level[v] < level[u]:
        u, v = v, u
    diff = level[v] - level[u]
    for i in range(LEVEL):
        if (diff >> i) & 1:
            v = sparse[v][i]
    if u == v:
        return u
    for i in reversed(range(LEVEL)):
        if sparse[u][i] != sparse[v][i] and sparse[u][i] != -1:
            u = sparse[u][i]
            v = sparse[v][i]
    return sparse[u][0]


for __ in range(q):
    u, v = map(int, input().strip().split())
    x = lca(u, v)
    dist = abs(level[x] - level[u]) + abs(level[x] - level[v])
    if dist & 1:
        print("Road")
    else:
        print("Town")
import bisect, collections, copy, heapq, itertools, math, string, sys, queue, time, random

input = lambda: sys.stdin.readline().rstrip()
sys.setrecursionlimit(10**7)


def I():
    return input()


def IS():
    return input().split()


def II():
    return int(input())


def IIS():
    return map(int, input().split())


def LIIS():
    return list(map(int, input().split()))


def Base_n_to_10(X, n):
    out = 0
    for i in range(1, len(str(X)) + 1):
        out += int(X[-i]) * (n**(i - 1))
    return out  #int out


def Base_10_to_n(X, n):
    if (X // n):
        return Base_10_to_n(X // n, n) + str(X % n)
    return str(X % n)


INF = 10**18
MOD = 10**9 + 7
sys.setrecursionlimit(10**8)
##############################################################################
n, q = IIS()
path = [[] for i in range(n)]
for i in range(n - 1):
    a, b = IIS()
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)
used = [False for i in range(n)]
st = set()
li = [0 for i in range(n)]


def EulerTour(n, X, i0):
    done = [0] * n
    Q = [~i0, i0]  # 根をスタックに追加
    ET = []
    while Q:
        i = Q.pop()
        if i >= 0:  # 行きがけの処理
            done[i] = 1
            ET.append(i)
            for a in X[i][::-1]:
                if done[a]: continue
                Q.append(~a)  # 帰りがけの処理をスタックに追加
                Q.append(a)  # 行きがけの処理をスタックに追加

        else:  # 帰りがけの処理
            ET.append(~i)

    return ET


li2 = [-1 for i in range(n)]
li3 = [0 for i in range(n)]
li = EulerTour(n, path, 0)
for i in range(n * 2):
    if li2[li[i]] == -1:
        li2[li[i]] = i
    else:
        li3[li[i]] = i
for i in range(q):
    c, d = IIS()
    if min(abs(li3[c - 1] - li2[d - 1]), abs(li2[c - 1] - li3[d - 1])) % 2:
        print("Town")
    else:
        print("Road")
N, X = map(int, input().split())

import sys

sys.setrecursionlimit(1000000)
G = []
for i in range(N):
    G.append([])

for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

from collections import deque

visited = [False] * N

Q = deque()
Q.append(0)
visited[0] = True
dis = [0] * N

while len(Q) > 0:
    i = Q.popleft()
    for j in G[i]:
        if not visited[j]:
            visited[j] = True
            dis[j] = dis[i] + 1
            Q.append(j)

for i in range(X):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    tmp = dis[c] + dis[d]
    if tmp % 2 == 1:
        print('Road')
    else:
        print('Town')
import sys
from collections import deque, defaultdict, Counter
from copy import deepcopy
from bisect import bisect_left, bisect_right, insort_left, insort_right
from heapq import heapify, heappop, heappush
from itertools import product, permutations, combinations, combinations_with_replacement, accumulate
from functools import reduce
from math import gcd, sin, cos, tan, asin, acos, atan, degrees, radians, ceil, floor, log, sqrt, ceil, floor, pi, hypot
from string import ascii_lowercase
from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN

sys.setrecursionlimit(1000000)
INF = 10**18
MOD = 10**9 + 7
# MOD = 998244353
yes = "Yes"
no = "No"
from random import randint


def II():
    return int(input())


def SI():
    return str(input())


def MI():
    return map(int, input().split())


def MS():
    return map(str, input().split())


def LI():
    return list(map(int, input().split()))


def SLI():
    return sorted(list(map(int, input().split())))


N, Q = map(int, input().split())
L = [[] for i in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    L[a].append(b)
    L[b].append(a)
P = [0] * (N + 1)
T = [0] * (N + 1)


def dfs(p, cnt):
    P[p] = cnt
    T[p] = 1
    for l in L[p]:
        if T[l] == 0:
            dfs(l, cnt + 1)


dfs(1, 0)
for i in range(Q):
    a, b = map(int, input().split())
    if (P[a] + P[b]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
E = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

dist = [0] * N
d = deque()
d.append(0)
while d:
    v = d.popleft()
    for i in E[v]:
        if dist[i] != 0: continue
        dist[i] = dist[v] + 1
        d.append(i)

for _ in range(Q):
    c, d = map(int, input().split())

    even = bool(dist[c - 1] % 2) ^ bool(dist[d - 1] % 2)
    print('Road' if even else 'Town')
import queue

n, q = map(int, input().split())
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * n
color[0] = 0
que.put(0)
#キューからデータがなくなるまで取り出しを行う
while not que.empty():
    t = que.get()
    for i in g[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print('Town')
    else:
        print('Road')
from collections import defaultdict

adj = defaultdict(list)
N, Q = map(int, input().split())

for i in range(N - 1):
    a, b = map(int, input().split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)

root = 0

stack = [root]
depth = [0 for _ in range(N)]
depth[0] = 0
visited = [0 for _ in range(N)]
visited[root] = 1

while (stack):
    v = stack.pop()

    for w in adj[v]:
        if visited[w] == 0:
            depth[w] = depth[v] + 1
            stack.append(w)
            visited[w] = 1

for i in range(Q):
    c, d = map(int, input().split())
    depth_c = depth[c - 1]
    depth_d = depth[d - 1]

    if (depth_c + depth_d) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**8)
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

dones = [-1] * N


def dfs(now, num, pre):
    dones[now] = num

    num += 1
    num %= 2

    for nex in G[now]:
        if nex == pre:
            continue

        dfs(nex, num, now)


dfs(0, 0, -1)

for i in range(Q):
    c, d = map(int, input().split())
    if dones[c - 1] == dones[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, r = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)
d = [-1] * n
q = deque([0])
while q:
    x = q.popleft()
    for i in g[x]:
        if d[i] == -1:
            d[i] = 1 - d[x]
            q.append(i)

for i in range(r):
    c, e = map(int, input().split())
    if d[c - 1] == d[e - 1]:
        print("Town")
    else:
        print("Road")
'''                      __      __        __                  __    __        __  __       
                      /  |    /  |      /  |                /  |  /  |     /   |/| |      
  _______   ______   _$$ |_   $$ |____  $$ |____    ______  $$/   _$$ |_    $$/ |$$ |   __ 
 /       | /       / $$   |  $$         $$        /         /  | / $$   |   /  |$$ |  /  |
/$$$$$$$/ /$$$$$$  |$$$$$$/   $$$$$$$  |$$$$$$$  |/$$$$$$  |$$ | $$$$$$/   $$  |$$ |_/$$/ 
$$        $$    $$ |  $$ | __ $$ |  $$ |$$ |  $$ |$$ |  $$/ $$ |  $$ | __  $$  |$$   $$<  
 $$$$$$  |$$$$$$$$/   $$ |/  |$$ |  $$ |$$ |  $$ |$$ |      $$ |  $$ |/  | $$  |$$$$$$  \
/     $$/ $$       |  $$  $$/ $$ |  $$ |$$ |  $$ |$$ |      $$ |  $$  $$/  $$  |$$ | $$  |
$$$$$$$/   $$$$$$$/    $$$$/  $$/   $$/ $$/   $$/ $$/       $$/    $$$$/   $$/ |$$/   $$/ 
                                                                                        
'''

import sys
from os import path
import bisect
if (path.exists('input.txt')):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output1.txt', 'w')
from heapq import heappop, heappush, heapify
from math import ceil, log
from collections import defaultdict, deque

maxi = sys.maxsize
mini = -maxi
from math import gcd

n, qu = map(int, input().split())
d = defaultdict(list)
for i in range(n - 1):
    x, y = map(int, input().split())
    d[x].append(y)
    d[y].append(x)
v = [0 for i in range(n + 1)]
maxi = int(log(n, 2))
dis = [0 for i in range(n + 1)]
q = deque()
q.append(1)
LCA = [[-1 for i in range(maxi + 1)] for j in range(n + 1)]
while q:
    a = q.popleft()
    v[a] = 1
    for i in d[a]:
        if not v[i]:
            v[i] = 1
            LCA[i][0] = a
            q.append(i)
            dis[i] = dis[a] + 1
for j in range(1, maxi + 1):
    for i in range(1, n + 1):
        if LCA[i][j - 1] != -1:
            p = LCA[i][j - 1]
            LCA[i][j] = LCA[p][j - 1]


def solve(a, b):
    for i in range(maxi, -1, -1):
        if LCA[a][i] != -1 and LCA[a][i] != LCA[b][i]:
            a = LCA[a][i]
            b = LCA[b][i]
    return LCA[a][0]


ans = []
Q = [list(map(int, input().split())) for i in range(qu)]


def EQUAL(a, b):
    x, y = dis[a], dis[b]
    z = abs(x - y)
    if z == 0:
        return a, b
    if x > y:
        while z:
            p = int(log(z, 2))
            a = LCA[a][p]
            z -= (1 << p)
    else:
        while z:
            p = int(log(z, 2))
            b = LCA[b][p]
            z -= (1 << p)

    return a, b


for i in Q:
    a, b = i
    x, y = EQUAL(a, b)
    if x == y:
        vp = dis[a] + dis[b] - (2 * dis[y])
        if vp % 2:
            ans.append('Road')
        else:
            ans.append('Town')
        continue
    z = solve(x, y)
    vp = dis[a] + dis[b] - (2 * dis[z])
    if vp % 2:
        ans.append('Road')
    else:
        ans.append('Town')
for i in ans:
    print(i)
import sys

input = sys.stdin.readline


def main():
    def is_bipartite(graph):
        n = len(graph)
        color = [-1] * n

        for start in range(n):
            if color[start] == -1:
                color[start] = 0
                stack = [start]

                while stack:
                    parent = stack.pop()

                    for child in graph[parent]:
                        if color[child] == -1:
                            color[child] = 1 - color[parent]
                            stack.append(child)
                        elif color[parent] == color[child]:
                            return False, color

        return color

    n, q = map(int, input().split())

    g = [[] for _ in range(n)]

    for _ in range(n - 1):
        a, b = map(int, input().split())
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)

    c = is_bipartite(g)

    for _ in range(q):
        a, b = map(int, input().split())
        if c[a - 1] == c[b - 1]:
            print("Town")
        else:
            print("Road")


main()
from collections import deque

INF = 1 << 60
MOD = 10**9 + 7

N, Q = map(int, input().split())

# 無向グラフ
to = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    to[a].append(b)
    to[b].append(a)

# 全頂点の深さを格納する配列
dep_list = [0] * N

# 全頂点の深さを深さ優先探索で求める
q = deque([])
parent = -1
dep = 1
q.append((0, dep, parent))

while len(q) > 0:
    v, dep, parent = q.popleft()
    for vv in to[v]:
        if vv == parent: continue
        dep_list[vv] = dep
        q.append((vv, dep + 1, v))

# それぞれのクエリにおいて c と d の経路の偶奇を求める
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    parity = dep_list[c] + dep_list[d]
    print("Town" if parity % 2 == 0 else "Road")
import math

n, q = map(int, input().split())

# [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
ab = [[] for i in range(n + 1)]

for i in range(0, n - 1):
    a_t, b_t = map(int, input().split())
    ab[a_t].append(b_t)
    ab[b_t].append(a_t)

import queue

que = queue.Queue()
color = [-1] * (n + 1)
color[1] = 0

que.put(1)

# すべてにカラーをつける
# 二部グラフ
# すべての道に到達できる前提だから、これですべてに色をつけられる
while not que.empty():
    t = que.get()
    for i in ab[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(0, q):
    c_t, d_t = map(int, input().split())
    if color[c_t] == color[d_t]:
        print("Town")
    else:
        print("Road")
from collections import UserDict, deque

N, Q = map(int, input().split())
edges = {k: [] for k in range(N)}

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)

color = [-1] * N
done = [False] * N
queue = deque([(0, 0)])

while queue:
    u, c = queue.popleft()

    if done[u]:
        continue

    done[u] = True
    color[u] = c

    for v in edges[u]:
        queue.append((v, 1 - c))

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (color[c] + color[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, P = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)
dist = [-1] * N
Q = deque()
Q.append(0)
dist[0] = 0
while Q:
    now = Q.popleft()
    for to in G[now]:
        if dist[to] == -1:
            dist[to] = dist[now] + 1
            Q.append(to)

for _ in range(P):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    L = dist[c] + dist[d]
    if L % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
G = [[] for _ in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)

dist = [-1] * (n + 1)
dist[1] = 0
que = deque()
que.append(1)
while que:
    v = que.popleft()
    for i in G[v]:
        if dist[i] > -1:
            continue
        dist[i] = dist[v] + 1
        que.append(i)
for j in range(q):
    c, d = map(int, input().split())
    if dist[c] % 2 == 0 and dist[d] % 2 == 0 or dist[c] % 2 == 1 and dist[
            d] % 2 == 1:
        print('Town')
    else:
        print('Road')
# 深さで塗り分けする→偶奇判定が答え
from collections import deque

n, Q = map(int, input().split())
adj = [[] for i in range(n + 1)]
for i in range(1, n):
    a, b = map(int, input().split())
    adj[a].append(b)
    adj[b].append(a)

# paint
q = deque([(a, 1)])
color = [-1] * (n + 1)

while q:
    c, paint = q.popleft()
    for i in adj[c]:
        if color[i] != -1:
            continue
        else:
            color[i] = paint
            q.append((i, (paint + 1) % 2))

for i in range(Q):
    c, d = map(int, input().split())
    if color[c] != color[d]:
        print('Road')
    else:
        print('Town')
from collections import deque


class Node:
    def __init__(self, index):
        self.color = None
        self.nears = []
        self.safe = -1


n, q = map(int, input().split())
nodes = [Node(i) for i in range(n + 1)]
for j in range(n - 1):
    a, b = map(int, input().split())
    nodes[a].nears.append(b)
    nodes[b].nears.append(a)

de = deque()
de.append(nodes[1])
nodes[1].safe = 1
nodes[1].color = "red"
u = 0
while de:
    for k in range(len(de)):
        s = de.popleft()
        nears = s.nears
        for near in nears:
            if nodes[near].safe == -1:
                nodes[near].safe = 1
                de.append(nodes[near])
                if u % 2 == 0:
                    nodes[near].color = "blue"
                else:
                    nodes[near].color = "red"
    u += 1
for m in range(q):
    c, d = map(int, input().split())
    if nodes[c].color == nodes[d].color:
        print("Town")
    else:
        print("Road")
import sys, bisect, collections, copy, heapq, itertools, math, string
# import numpy as np
from functools import lru_cache


def I():
    return int(sys.stdin.readline().rstrip())


def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def S():
    return sys.stdin.readline().rstrip()


def LS():
    return list(sys.stdin.readline().rstrip().split())


sys.setrecursionlimit(10**6)


def main():
    N, Q = LI()
    G = [[] for _ in range(N)]

    for _ in range(N - 1):
        a, b = LI()
        a -= 1
        b -= 1
        G[a].append(b)
        G[b].append(a)

    start = 0
    candidate = [start]
    distance = [0] * N
    done = [False] * N
    while candidate:
        p = candidate.pop()
        done[p] = True
        for next_p in G[p]:
            if done[next_p]:
                continue
            distance[next_p] = distance[p] + 1
            candidate.append(next_p)

    # print(distance)
    for _ in range(Q):
        start, goal = LI()
        start -= 1
        goal -= 1
        if abs(distance[start] - distance[goal]) % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
n, q = [int(_) for _ in input().split()]
lis = [[] for i in range(n)]
import sys

sys.setrecursionlimit(10**5 + 10)

for i in range(n - 1):
    a, b = [int(_) - 1 for _ in input().split()]
    lis[a].append(b)
    lis[b].append(a)

g = [-1 for i in range(n)]
g[0] = 1


def set(x):
    for i in lis[x]:
        if g[i] == -1:
            g[i] = (g[x] % 2) + 1
            set(i)
    return


set(0)

for i in range(q):
    c, d = [int(_) - 1 for _ in input().split()]
    if g[c] == g[d]:
        print("Town")
    else:
        print("Road")n, q = map(int, input().split())

node = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    node[a - 1].append(b)
    node[b - 1].append(a)

town = [2] * n
town[0] = 0
node_bool = [True] * n
node_bool[0] = False

from collections import deque

d = deque()
for j in node[0]:
    d.append(j)
    node_bool[j - 1] = False
    town[j - 1] = 1

while d:
    v = d.popleft()
    for j in node[v - 1]:
        if node_bool[j - 1]:
            node_bool[j - 1] = False
            d.append(j)
            if town[v - 1] == 1:
                town[j - 1] = 0
            elif town[v - 1] == 0:
                town[j - 1] = 1

cd = [list(map(int, input().split())) for _ in range(q)]

for i in range(q):
    if town[cd[i][0] - 1] == town[cd[i][1] - 1]:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())

edges = [[] for _ in range(n)]

for a, b in (map(int, input().split()) for _ in range(n - 1)):
    a, b = a - 1, b - 1
    edges[a].append(b)
    edges[b].append(a)

flags = [False for _ in range(n)]
marked = [False for _ in range(n)]


def mark(i, flag):
    if marked[i]:
        return
    else:
        flags[i] = flag
        marked[i] = True
        for next in edges[i]:
            mark(next, not flag)


mark(0, False)
for c, d in (map(int, input().split()) for _ in range(q)):
    c, d = c - 1, d - 1
    if flags[c] == flags[d]:
        print("Town", flush=False)
    else:
        print("Road", flush=False)
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]
cd = [list(map(int, input().split())) for _ in range(Q)]

G = [[] for _ in range(N)]
for a, b in ab:
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1 for _ in range(N)]
dist[0] = 0

from collections import deque

Qu = deque()
Qu.append(0)

while len(Qu) > 0:
    i = Qu.popleft()

    for j in G[i]:
        if dist[j] == -1:
            dist[j] = dist[i] + 1
            Qu.append(j)
for c, d in cd:
    c -= 1
    d -= 1
    diff = dist[c] - dist[d]
    if diff % 2 != 0:
        print('Road')
    else:
        print('Town')
from collections import deque

N, Q = map(int, input().split())

G = []
for _ in range(N):
    G.append([])

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = []
for _ in range(N):
    dist.append(-1)

que = deque()

que.append(0)
dist[0] = 0

while len(que) > 0:
    i = que.popleft()
    for j in G[i]:
        if dist[j] == -1:
            dist[j] = dist[i] + 1
            que.append(j)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    check = dist[c] - dist[d]
    if check % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
mich = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    mich[a - 1].append(b - 1)
    mich[b - 1].append(a - 1)
from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * N
    d[u] = 0
    while queue:
        v = queue.popleft()
        for i in mich[v]:
            if d[i] == None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


kyo = bfs(0)
for i in range(Q):
    c, e = map(int, input().split())
    a = kyo[c - 1]
    b = kyo[e - 1]
    if (a - b) % 2 == 1:
        print("Road")
    else:
        print("Town")
N, Q = map(int, input().split())
path = [[] * N for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)
par = [True] * N
stack = [0]
checked = [False] * N
while len(stack) > 0:
    node = stack.pop(-1)
    if checked[node]:
        continue
    checked[node] = True
    for i in path[node]:
        if checked[i]:
            continue
        par[i] = not par[node]
        stack.append(i)

inp = []
for _ in range(Q):
    c, d = map(int, input().split())
    cf = par[c - 1]
    df = par[d - 1]
    if cf == df:
        print("Town")
    else:
        print("Road")
# coding: utf-8
import sys
import math
import io
from collections import Counter
from collections import deque


def i_input():
    return int(input())


def i_map():
    return map(int, input().split())


def i_list():
    return list(i_map())


def main():
    sys.setrecursionlimit(10**6)
    n, q = i_map()
    global R
    R = [[] for _ in range(n + 1)]
    global color
    color = [0 for _ in range(n + 1)]
    color[1] = 1

    for _ in range(n - 1):
        a, b = i_map()
        R[a].append(b)
        R[b].append(a)

    #dfs(1)

    que = deque()
    que.append(1)
    while que:
        t = que.pop()
        for r in R[t]:
            if color[r] == 0:
                color[r] = color[t] * -1
                que.append(r)

    for i in range(q):
        c, d = i_map()
        if color[c] == color[d]:
            print("Town")
        else:
            print("Road")


def dfs(s):
    for r in R[s]:
        if color[r] == 0:
            color[r] = color[s] * -1
            dfs(r)


if __name__ == '__main__':
    _INPUT = '''\
2 1
1 2
1 2


    '''
    if sys.platform == 'win32':
        sys.stdin = io.StringIO(_INPUT)

    main()
import queue

N, Q = [int(x) for x in input().split()]

graph = [[] for i in range(N)]
for i in range(N - 1):
    a, b = [int(x) for x in input().split()]
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

queries = []
for i in range(Q):
    c, d = [int(x) for x in input().split()]
    queries.append([c - 1, d - 1])

que = queue.Queue()
que.put(0)
distances = [-1 for x in range(N)]  # 0: ラベルなし, 1: even, -1: odd
distances[0] = 0

while not que.empty():
    current_node = que.get()
    current_distance = distances[current_node]

    for next_node in graph[current_node]:
        if distances[next_node] < 0:
            que.put(next_node)
            distances[next_node] = current_distance + 1

for query in queries:
    if (distances[query[0]] - distances[query[1]]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
colors = [None] * n
e_list = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    e_list[a - 1].append(b - 1)
    e_list[b - 1].append(a - 1)
waiting = deque()
waiting.append(0)
colors[0] = 1
while waiting:
    u = waiting.popleft()
    for v in e_list[u]:
        if not colors[v]:
            colors[v] = 3 - colors[u]
            waiting.append(v)
for _ in range(q):
    c, d = map(int, input().split())
    if colors[c - 1] == colors[d - 1]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()

serch = [-1] * N
serch[0] = 0
que.put(0)

while not que.empty():
    t = que.get()
    for i in G[t]:
        if serch[i] == -1:
            serch[i] = 1 - serch[t]
            que.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if serch[c - 1] == serch[d - 1]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**6)

N, Q = map(int, input().split())
a = []
b = []
c = []
d = []
town = [[] for _ in range(N)]  # 隣接リスト

for i in range(N - 1):
    a_tmp, b_tmp = map(int, input().split())
    a.append(a_tmp)
    b.append(b_tmp)

for i in range(N - 1):
    town[a[i] - 1].append(b[i] - 1)
    town[b[i] - 1].append(a[i] - 1)

dep = [-1] * N


def dfs(v, _dep=0, p=-1):
    dep[v] = _dep
    for u in town[v]:
        if u != p:
            dfs(u, _dep + 1, v)


dfs(0)
col = [i % 2 for i in dep]

for _ in range(Q):
    c, d = map(int, input().split())
    if col[c - 1] == col[d - 1]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())

e = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    e[a].append(b)
    e[b].append(a)

import sys

sys.setrecursionlimit(100000000)
d = [-1] * n
d[0] = 0


def dfs(v):
    for u in e[v]:
        if d[u] >= 0:
            continue
        d[u] = d[v] + 1
        dfs(u)


dfs(0)

for _ in range(q):
    c, dd = map(int, input().split())
    c -= 1
    dd -= 1
    if (d[c] - d[dd]) % 2:
        print("Road")
    else:
        print("Town")
N, Q = map(int, input().split())

edge = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)

color = [-1] * N

qu = [(0, 0)]

while qu:
    i, c = qu.pop()
    if color[i] == -1:
        color[i] = c
        for nxt in edge[i]:
            qu.append((nxt, 1 if c == 0 else 0))

for q in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print('Town')
    else:
        print('Road')
from queue import Queue

N, Q = map(int, input().split())
edges = [list(map(int, input().split())) for _ in range(N - 1)]
queries = [list(map(int, input().split())) for _ in range(Q)]

edges_from = dict.fromkeys([i for i in range(1, N + 1)])

for vertex in edges_from.keys():
    edges_from[vertex] = []

for edge in edges:
    a = edge[0]
    b = edge[1]

    edges_from[a].append(b)
    edges_from[b].append(a)

vertex_waitlist = Queue()
visited = [-1 for _ in range(N + 1)]  # -1 = not visited, 0 = even, 1 = odd

vertex_waitlist.put(1)
visited[1] = 0

while not vertex_waitlist.empty():
    vertex = vertex_waitlist.get()

    for next_vertex in edges_from[vertex]:
        if visited[next_vertex] != -1:
            continue

        vertex_waitlist.put(next_vertex)
        visited[next_vertex] = (visited[vertex] +
                                1) % 2  # flip between 0 and 1

for query in queries:
    c = query[0]
    d = query[1]

    if visited[c] == visited[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
path = [[] for i in range(n)]
query = []
for i in range(n - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)
for i in range(q):
    c, d = map(int, input().split())
    query.append([c, d])

que = deque()
que.append(0)
city = [-1] * n
city[0] = 0
while len(que) > 0:
    temp = que.pop()
    for i in path[temp]:
        if city[i] != -1:
            continue
        else:
            city[i] = 1 - city[temp]
            que.append(i)

for i in range(q):
    if city[query[i][0] - 1] == city[query[i][1] - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque


# 二部グラフの色を出力する関数
def bfs(N, G, s):
    color = [-1] * N  # 黒は1,白は0,未探索は-1
    q = deque()
    color[s] = 1
    q.appendleft(s)
    while q:
        v = q[-1]
        q.pop()
        for x in G[v]:
            if color[x] != -1: continue  # 探索済
            # color[v]が1ならcolor[x]は0,color[v]が0ならcolor[x]は1
            color[x] = 1 - color[v]
            q.appendleft(x)
    return color


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

Query = []
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    Query.append([c, d])

color = bfs(N, G, 0)
# print(color)

for q in Query:
    # 同じ色なら距離は偶数、ちがう色なら距離は奇数
    if color[q[0]] == color[q[1]]:
        print('Town')
    else:
        print('Road')
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)


def main():
    n, q = map(int, input().split())
    g = [[] for i in range(n)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)
    dist = [-1] * n
    seen = [False] * n
    dist[0] = False

    def dfs(x, last=-1):
        for to in g[x]:
            if to == last:
                continue
            dist[to] = not (dist[x])
            dfs(to, x)

    dfs(0)
    for i in range(q):
        c, d = map(int, input().split())
        c, d = c - 1, d - 1
        if dist[c] != dist[d]:
            print('Road')
        else:
            print('Town')


main()
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)
que = queue.Queue()
color = [-1] * (N + 1)
color[1] = 0
que.put(1)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for t in range(Q):
    a, b = map(int, input().split())
    if color[a] == color[b]:
        print("Town")
    else:
        print("Road")
#n = int(input())
n, q = map(int, input().split())
#c = list(map(int, input().split()))
#l = [list(map(int, input().split())) for l in range(n)]
import sys

input = sys.stdin.readline

#n, m = map(int, input().split()) # nは頂点の数、mは辺の数
g = [[] for _ in range(n)]  # 隣接リスト

for _ in range(n - 1):
    a, b = [int(x) for x in input().split()]
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

from collections import deque


def bfs(u):
    queue = deque([u])
    d = [-1] * n  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] == -1:
                d[i] = d[v] + 1
                queue.append(i)
    return d


# 0からの各頂点の距離
d = bfs(0)
#print(d)

for i in range(q):
    c, e = map(int, input().split())
    if (d[e - 1] - d[c - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
from itertools import islice


def solve(in_):
    N, Q = map(int, next(in_).split())
    _graph = [[] for _ in range(N)]
    _edges = tuple(
        tuple(map(int, line.split())) for line in islice(in_, N - 1))
    queries = tuple(tuple(map(int, line.split())) for line in islice(in_, Q))

    for a, b in _edges:
        a -= 1
        b -= 1
        _graph[a].append(b)
        _graph[b].append(a)
    C = [-1] * N
    C[0] = 0
    q = [0]
    while q:
        cur = q.pop()
        for d in _graph[cur]:
            if C[d] == -1:
                C[d] = 1 - C[cur]
                q.append(d)

    ans = []
    for c, d in queries:
        c -= 1
        d -= 1

        if (C[c] + C[d]) % 2:
            ans.append('Road')
        else:
            ans.append('Town')
    return ans


def main():
    answer = solve(sys.stdin.buffer)
    print('\n'.join(answer))


if __name__ == '__main__':
    main()
# -*- coding: utf-8 -*-


def main():
    from collections import deque
    import sys

    input = sys.stdin.readline

    n, q = map(int, input().split())
    graph = [[] for _ in range(n)]

    for _ in range(n - 1):
        ai, bi = map(int, input().split())
        ai -= 1
        bi -= 1

        graph[ai].append(bi)
        graph[bi].append(ai)

    used = [False for _ in range(n)]
    dist = [10**7 for _ in range(n)]
    dist[0] = 0
    d = deque()
    d.append(0)

    while d:
        di = d.popleft()
        used[di] = True

        for to in graph[di]:
            if used[to]:
                continue

            dist[to] = min(dist[to], dist[di] + 1)
            d.append(to)

    for i in range(q):
        ci, di = map(int, input().split())
        ci -= 1
        di -= 1

        if abs(dist[ci] - dist[di]) % 2 == 1:
            print("Road")
        else:
            print("Town")


if __name__ == "__main__":
    main()
from collections import deque

N, Q = map(int, input().split())
E = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    E[a].append(b)
    E[b].append(a)
CD = []

for i in range(Q):
    c, d = map(int, input().split())
    CD.append([c, d])

distance = [-1 for _ in range(N + 1)]
visited = [False for _ in range(N + 1)]
q = deque()
q.append((1, 0))
visited[1] = True
while len(q) > 0:
    v, hop = q.pop()
    visited[v] = True
    distance[v] = hop
    for e in E[v]:
        if visited[e] == False:
            q.appendleft((e, hop + 1))

for i in range(Q):
    c, d = CD[i]
    temp = distance[c] + distance[d]
    if temp % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline

n, q = map(int, input().split())
g = [[] for _ in range(n)]  # 隣接リスト

for _ in range(n - 1):
    a, b = [int(x) for x in input().split()]
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * n  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


# 0からの各頂点の距離
# d = bfs(0)
# print(d)

ans = []
D_o = bfs(0)
for i in range(len(D_o)):
    if D_o[i] % 2 == 0:
        D_o[i] = 2
    else:
        D_o[i] = 1

for i in range(q):
    c, d = map(int, input().split())
    if D_o[c - 1] % 2 == 0:
        if D_o[d - 1] == 2:
            ans.append('Town')
        else:
            ans.append('Road')
    else:
        if D_o[d - 1] == 2:
            ans.append('Road')
        else:
            ans.append('Town')

for i in range(q):
    print(ans[i])
import sys
from collections import defaultdict

sys.setrecursionlimit(10**7)

N, Q, *X = list(map(int, open(0).read().split()))
a, b = X[0::2][:N - 1], X[1::2][:N - 1]
c, d = X[0::2][N - 1:], X[1::2][N - 1:]

g = defaultdict(list)

for aa, bb in zip(a, b):
    g[aa].append(bb)
    g[bb].append(aa)

result = [-1] * (N + 1)


def dfs(curr):
    v = g[curr]
    for vv in v:
        if result[vv] < 0:
            result[vv] = result[curr] + 1
            dfs(vv)


dfs(1)

for cc, dd in zip(c, d):
    print("Town" if (result[cc] - result[dd]) % 2 == 0 else "Road")
import sys
import collections

sys.setrecursionlimit(10**5)

INF = 10**10

N, Q = map(int, input().split())

G = [[] for _ in range(N)]
seen = [-1] * N
todo = collections.deque()
th = []
et = [[INF, -1] for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)


def dfs(G, v):
    seen[v] = 0
    th.append(v)
    if len(G[v]) == 0:
        return
    else:
        for r in G[v]:
            if seen[r] != -1:
                continue
            else:
                dfs(G, r)
                th.append(v)


dfs(G, 0)
#print(th)
for i in range(len(th)):
    et[th[i]][0] = min(et[th[i]][0], i)
    et[th[i]][1] = max(et[th[i]][1], i)

#print(et)

for i in range(Q):
    c, d = map(int, input().split())
    s1, s2, e1, e2 = et[c - 1][0], et[d - 1][0], et[c - 1][1], et[d - 1][1]
    if max(s1, s2) <= min(e1, e2):
        dist = abs(s1 - s2) - 1
    else:
        dist = abs(min(e1, e2) - max(s1, s2)) - 1

    if dist % 2 == 1:
        print('Town')
    else:
        print('Road')
from collections import deque


def adjlist(n, edges, digraph=False):
    adj = [set() for _ in range(n + 1)]

    if digraph:
        for s, t in edges:
            adj[s].add(t)
    else:
        for s, t in edges:
            adj[s].add(t)
            adj[t].add(s)

    return adj


def tmap(fn, seq):
    return tuple(map(fn, seq))


def solve():
    N, Q = map(int, input().split())
    E = [tmap(int, input().split()) for _ in range(N - 1)]
    qs = [tmap(int, input().split()) for _ in range(Q)]
    # print(N, Q, E, qs)

    adj = adjlist(N, E)

    todo = deque([1])
    seen = [False] * (N + 1)
    color = [True] * (N + 1)

    while todo:
        v = todo.pop()
        seen[v] = True
        for t in adj[v]:
            if not seen[t]:
                todo.appendleft(t)
                color[t] = not color[v]

    for c, d in qs:
        if color[c] == color[d]:
            print("Town")
        else:
            print("Road")


solve()
import queue

N, Q = list(map(int, input().split()))
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
dep = [-1] * N
dep[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if dep[i] == -1:
            dep[i] = dep[t] + 1
            que.put(i)
for _ in range(Q):
    c, d = map(int, input().split())
    if (dep[c - 1] + dep[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]

connect = [[] for _ in range(N + 1)]
for a, b in ab:
    connect[a].append(b)
    connect[b].append(a)

odd = [None] * (N + 1)
checked = [False] * (N + 1)
checked[1] = True
odd[1] = True
q = [1]
while q:
    s = q.pop(0)
    for n in connect[s]:
        if not checked[n]:
            checked[n] = True
            odd[n] = not odd[s]
            q.append(n)
for _ in range(Q):
    c, d = map(int, input().split())
    if odd[c] == odd[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    edge[x].append(y)
    edge[y].append(x)  # 有向グラフならこの行は消す!!

seen = [0] * N
node_to_depth = {}
queue = deque([(0, 0)])
while queue:
    now, depth = queue.popleft()
    if seen[now]:
        continue
    seen[now] = 1
    node_to_depth[now] = depth
    for n_node in edge[now]:
        if seen[n_node]:
            continue
        queue.append((n_node, depth + 1))

for _ in range(Q):
    c, d = map(lambda n: int(n) - 1, input().split())

    if abs(node_to_depth[c] - node_to_depth[d]) % 2:
        print("Road")
    else:
        print("Town")
import sys  #おまじない

sys.setrecursionlimit(10**6)
n, q = map(int, input().split())
road = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)


def dfs(s):  #深さ優先探索
    mile = [-1 for i in range(n)]
    mile[s] = 0  #スタート地点
    flag = [s]

    while flag:
        point = flag.pop(-1)
        nd = mile[point] + 1
        for next in road[point]:
            if mile[next] >= 0:
                continue
            mile[next] = nd
            flag.append(next)
    return mile


start = dfs(0)
for i in range(q):
    c, d = map(int, input().split())
    if abs(start[c - 1] - start[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

# 初期ノードからの距離
vec = [-1] * N
vec[0] = 0

# キューの作成
q = queue.Queue()
q.put(0)

while not q.empty():
    v = q.get()
    for g in G[v]:
        if vec[g] == -1:
            vec[g] = vec[v] + 1
            q.put(g)

for _ in range(Q):
    c, d = map(int, input().split())
    if (vec[c - 1] + vec[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
def main():
    N, Q = map(int, input().split())

    import collections
    tree = collections.defaultdict(list)
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        tree[a].append(b)
        tree[b].append(a)

    RED = 1
    BLACK = 2
    colors = [None] * N

    # DFS for color
    stack = [(0, RED)]
    while stack:
        u, c = stack.pop()
        colors[u] = c
        next_c = BLACK if c == RED else RED
        for v in tree[u]:
            if not colors[v]:
                stack.append((v, next_c))

    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        if colors[c] == colors[d]:
            print('Town')
        else:
            print('Road')


if __name__ == "__main__":
    main()
from collections import deque
import collections

N, Q = map(int, input().split())
edges = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)

dist = [-1] * N
que = deque()
que.append(0)
dist[0] = 0
while que:
    now = que.popleft()
    for i in edges[now]:
        if dist[i] != -1:
            continue
        dist[i] = dist[now] + 1
        que.append(i)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
# region header
import sys, bisect, math, itertools, heapq, collections
from operator import itemgetter
from pprint import pprint
# a.sort(key=itemgetter(i)) # i番目要素でsort
from functools import lru_cache
import copy
# @lru_cache(maxsize=None)
sys.setrecursionlimit(2 * 10**6)
input = sys.stdin.readline
INF = 10**18
mod = 10**9 + 7
eps = 10**-7
ALPHABETS_LEN = 26
# endregion
# region input function


def inp():
    '''
    一つの整数
    '''
    return int(input())


def inpl():
    '''
    一行に複数の整数
    '''
    return list(map(int, input().split()))


def str_inp():
    '''
    文字列をリストとして読み込む
    '''
    return list(input()[:-1])


def outl(output, sep=" "):
    print(sep.join(map(str, output)))


# endregion


class Dijkstra():
    def __init__(self):
        self.e = collections.defaultdict(list)

    def add(self, u, v, d, directed=False):
        """
        Parameters
        ----------
        u:int
            from node
        v:int
            to node
        d:int
            cost
        directed:bool
            there is direction
        """
        if directed is False:
            self.e[u].append([v, d])
            self.e[v].append([u, d])
        else:
            self.e[u].append([v, d])

    def delete(self, u, v):
        """
        Parameters
        ----------
        u:int
            from node
        v:int
            to node
        """
        self.e[u] = [_ for _ in self.e[u] if _[0] != v]
        self.e[v] = [_ for _ in self.e[v] if _[0] != u]

    def Dijkstra_search(self, s):
        """
        Parameters
        ----------
        s:int
            start node

        Return
        ----------
        d:dict(int:int)
            shortest cost from start node to each node
            {to : cost}

        prev:dict(int:int)
            previous node on the shortest path
            {from : to}
        """
        d = collections.defaultdict(lambda: float('inf'))
        prev = collections.defaultdict(lambda: None)
        d[s] = 0
        q = []
        heapq.heappush(q, (0, s))  # (cost, 探索候補ノード)
        v = collections.defaultdict(bool)  # 確定済かどうか
        while len(q):
            # ノードuにおけるコストはk
            k, u = heapq.heappop(q)
            if v[u]:
                continue
            v[u] = True

            for uv, ud in self.e[u]:  # cost is ud from u to uv
                if v[uv]:
                    continue
                vd = k + ud
                if d[uv] > vd:
                    d[uv] = vd
                    prev[uv] = u
                    heapq.heappush(q, (vd, uv))

        return d, prev


def solve():
    n, q = inpl()
    g = Dijkstra()
    for i in range(n - 1):
        a, b = inpl()
        g.add(a, b, 1)
    dist, _ = g.Dijkstra_search(1)
    query = [inpl() for _ in range(q)]
    for i in range(q):
        c, d = query[i]
        if (dist[c] + dist[d]) % 2:
            print("Road")
        else:
            print("Town")


# region output


def main():
    solve()


main()

# endregion
from collections import deque
from sys import stdin

readline = stdin.readline

INF = 10**15

N, Q = map(int, readline().split())

links = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, readline().split())
    links[a].append(b)
    links[b].append(a)

dp = [INF] * N
dp[0] = 0
q = deque([0])
while q:
    a = q.popleft()
    for b in links[a]:
        if dp[b] <= dp[a] + 1:
            continue
        dp[b] = dp[a] + 1
        q.append(b)

result = []
for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, readline().split())
    if (dp[c] + dp[d]) % 2 == 0:
        result.append('Town')
    else:
        result.append('Road')
print(*result, sep='\n')
from sys import setrecursionlimit, stdin
import math

setrecursionlimit(10**7)
input = stdin.readline

N, Q = map(int, input().split())
path = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    path[a].append(b)
    path[b].append(a)

dist = [None] * (N + 1)
dist[1] = 0
length = 0


def dfs(n, length):
    length += 1
    for v in path[n]:
        if dist[v] == None or dist[v] > length:
            dist[v] = length
            dfs(v, length)


dfs(1, 0)
for i in range(1, N + 1):
    if dist[i] % 2:
        dist[i] = 1
    else:
        dist[i] = 0

for _ in range(Q):
    c, d = map(int, input().split())
    if dist[c] == dist[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1

    graph[a].append(b)
    graph[b].append(a)

visited = [-1] * N

start = 0
q = deque()
q.append(0)
visited[start] = 0

while q:

    now = q.popleft()

    for next in graph[now]:
        if visited[next] != -1:
            continue

        q.append(next)
        visited[next] = visited[now] + 1

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    if (visited[c] - visited[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys
import copy
import math
import itertools
import collections
import heapq
import decimal

sys.setrecursionlimit(10**9)


def main():
    n, q = map(int, input().split())
    li = list(list() for i in range(n))
    for i in range(n - 1):
        a, b = map(int, input().split())
        li[a - 1].append(b - 1)
        li[a - 1].append(1)
        li[b - 1].append(a - 1)
        li[b - 1].append(1)

    resli = dijkstra(li)

    for i in range(q):
        c, d = map(int, input().split())
        if abs(resli[c - 1] - resli[d - 1]) % 2 == 0:
            print("Town")
        else:
            print("Road")


def dijkstra(adjacencyList):
    placeFlag = list(False for _ in range(len(adjacencyList)))
    placeArray = list(float("inf") for _ in range(len(adjacencyList)))
    roadHeap = list()

    nowPlace = 0
    nowDistance = 0
    placeArray[0] = 0

    while False in placeFlag:
        placeFlag[nowPlace] = True

        for i in range(0, len(adjacencyList[nowPlace]), 2):
            currentDistance = placeArray[nowPlace]
            destination = adjacencyList[nowPlace][i]
            distance = adjacencyList[nowPlace][i + 1]
            placeArray[destination] = min(placeArray[destination],
                                          placeArray[nowPlace] + distance)

            if placeFlag[destination] is False:
                heapq.heappush(roadHeap,
                               Road(currentDistance, destination, distance))

        while roadHeap:
            candidateRoad = heapq.heappop(roadHeap)
            if placeFlag[candidateRoad.destination] is False:
                nowPlace = candidateRoad.destination
                break

    return placeArray


class Road:
    currentDistance = int()
    destination = int()
    distance = int()

    def __init__(self, currentDistance, destination, distance):
        self.currentDistance = currentDistance
        self.destination = destination
        self.distance = distance

    def __lt__(self, other):
        return self.currentDistance + self.distance < other.currentDistance + other.distance


main()
# ダイクストラ法

# 使い方
# ① collectionをインポート
# ② n,mの取得
# ③ nodeのリストnodesの大枠を作成
# ④ 隣接ノード、道の所要時間など、道の情報をnodeに追加
# ⑤ 開始位置を設定
# ⑥ 最短距離探索コードの修正
from collections import deque  # ①
import sys

sys.setrecursionlimit(10**6)
INF = 10**18

# # n:nodeの数,　m:道の数
# # たいてい下のコードで取得可能

n, q = map(int, input().split())  # ②


class Node:
    def __init__(self, number):
        self.number = number  # 名前をつける
        self.depth = INF
        # node,所要時間のリストを格納
        # node: このノードから進むことのできるnode
        # 所要時間:　進むのにかかる時間
        self.road_information = []


# #nodeのリストを作る。たいてい下のコードで元をつくり、次のコードで中身を入れる。
nodes = [None] + [Node(i) for i in range(1, n + 1)]  # ③
nodes[1].depth = 0
# # nodeの道の情報を入れる。④
for i in range(n - 1):
    a, b = map(int, input().split())
    nodes[a].road_information.append([nodes[b], 1])
    nodes[b].road_information.append([nodes[a], 1])

que = deque()

que.append(nodes[1])

# 最短距離計算コード
while que:
    node = que.popleft()
    for child, cost in node.road_information:
        if child.depth == INF:
            child.depth = node.depth + 1
            que.append(child)
        # N: 頂点数
        # G[v]: 頂点vの子頂点 (親頂点は含まない)
min_time = [INF] * (n + 1)

for i in range(1, n + 1):
    min_time[i] = nodes[i].depth
    # Euler Tour の構築

# nodes = nodes[1:]
# S = []
# F = [0] * n
# depth = [0]*n

# def dfs(parent, v, d):
#     F[v.number-1] = len(S)
#     depth[v.number-1] = d
#     S.append(v.number-1)
#     for w, cost in nodes[v.number-1].road_information:
#         if parent != w or parent is None:
#             dfs(v, w, d+1)
#             S.append(v.number-1)

# dfs(None, nodes[0], 0)

# # 存在しない範囲は深さが他よりも大きくなるようにする
# INF = (n, None)

# # LCAを計算するクエリの前計算
# M = 2*n
# M0 = 2**(M-1).bit_length()
# data = [INF]*(2*M0)
# for i, v in enumerate(S):
#     data[M0-1+i] = (depth[v], i)
# for i in range(M0-2, -1, -1):
#     data[i] = min(data[2*i+1], data[2*i+2])

# # LCAの計算 (generatorで最小値を求める)

# def _query(a, b):
#     yield INF
#     a += M0
#     b += M0
#     while a < b:
#         if b & 1:
#             b -= 1
#             yield data[b-1]
#         if a & 1:
#             yield data[a-1]
#             a += 1
#         a >>= 1
#         b >>= 1

# # LCAの計算 (外から呼び出す関数)

# def query(u, v):
#     fu = F[u]
#     fv = F[v]
#     if fu > fv:
#         fu, fv = fv, fu
#     return S[min(_query(fu, fv+1))[1]]

for i in range(q):
    c, d = map(int, input().split())
    ans = min_time[c] + min_time[d]
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
from collections import deque

n, q = map(int, input().split())

depth = [-1] * n
depth[0] = 0
edge = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)

stack = deque([0])

while stack:
    at = stack.popleft()
    d = depth[at]
    for town in edge[at]:
        if depth[town] == -1:
            stack.append(town)
            depth[town] = d + 1

for i in range(q):
    c, d = map(int, input().split())
    if (depth[c - 1] + depth[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
def main():
    n, qqqq = map(int, input().split())
    ab = [list(map(int, input().split())) for _ in [0] * (n - 1)]
    g = [[] for _ in [0] * n]
    [g[a - 1].append(b - 1) for a, b in ab]
    [g[b - 1].append(a - 1) for a, b in ab]
    root = 0  # 根
    d = [-1] * n  # 根からの距離
    d[root] = 0
    q = [root]
    cnt = 0
    while q:  # BFS
        cnt += 1
        qq = []
        while q:
            i = q.pop()
            for j in g[i]:
                if d[j] == -1:
                    d[j] = cnt
                    qq.append(j)
        q = qq

    for i in range(qqqq):
        c, dd = map(int, input().split())
        if (d[c - 1] + d[dd - 1]) % 2:
            print("Road")
        else:
            print("Town")


main()
import sys
try:
    sys.setrecursionlimit(1 << 30)
    n, q = map(int, input().split())
    vector = [[] for i in range(n + 1)]
    level = [0] * (n + 1)
    query = []

    def bfs(start):
        queue = []
        vis = [False] * (n + 1)
        queue.append((start, 0))
        vis[start] = True
        while len(queue) > 0:
            now = queue.pop(0)
            level[now[0]] = now[1] + 1
            for it in vector[now[0]]:
                if vis[it]:
                    continue
                else:
                    queue.append((it, now[1] + 1))
                    vis[it] = True

    for i in range(n - 1):
        a, b = map(int, input().split())
        vector[a].append(b)
        vector[b].append(a)
    for i in range(q):
        a, b = map(int, input().split())
        query.append((a, b))
    bfs(1)
    for it in query:
        if abs(level[it[1]] - level[it[0]]) % 2 == 1:
            print('Road')
        else:
            print('Town')
except:
    pass
#!python3

import sys
from collections import defaultdict, deque

iim = lambda: map(int, sys.stdin.readline().rstrip().split())


def resolve():
    it = map(int, sys.stdin.read().split())
    N, Q = next(it), next(it)

    inf = float("inf")
    d1 = defaultdict(list)
    for i in range(N - 1):
        a, b = next(it) - 1, next(it) - 1
        d1[a].append(b)
        d1[b].append(a)

    ds = [0] * N

    def dfs(i, d=0):
        vis[i] = 1
        ds[i] = d
        for j in d1[i]:
            if vis[j]: continue
            dfs(j, d + 1)

    dq = deque([(0, 1)])
    while dq:
        i, d = dq.pop()

        ds[i] = d
        for j in d1[i]:
            if ds[j]: continue
            dq.append((j, d + 1))

    ans = []
    for i in range(Q):
        a, b = next(it) - 1, next(it) - 1
        c = ds[a] + ds[b]
        ans.append("Road" if c % 2 else "Town")

    print(*ans, sep="\n")


if __name__ == "__main__":
    resolve()
from collections import deque
import sys

input = sys.stdin.readline

n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

visited = [-1] * n
temp = deque([0])
visited[0] = 0

while temp:
    p = temp.popleft()
    for pp in g[p]:
        if visited[pp] != -1: continue
        visited[pp] = visited[p] + 1
        temp.append(pp)

for i in range(q):
    c, d = map(int, input().split())
    if visited[c - 1] % 2 == visited[d - 1] % 2: print('Town')
    else: print('Road')
from collections import defaultdict
import sys

sys.setrecursionlimit(10**9)

N, Q = map(int, input().split())

_G = defaultdict(list)
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    _G[a].append(b)
    _G[b].append(a)

depth = [-1] * N
depth[0] = 0

q = [0]
while q:
    pa = q.pop()
    for to in _G[pa]:
        if depth[to] != -1:
            continue
        depth[to] = depth[pa] + 1
        q.append(to)

G = defaultdict(list)
for i in range(N):
    for node in _G[i]:
        if depth[node] > depth[i]:
            G[i].append(node)

S = []
F = [0] * N
depth = [0] * N


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in G[v]:
        dfs(w, d + 1)
        S.append(v)


dfs(0, 0)

INF = (N, None)
M = 2 * N
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    lca = query(c, d)
    dist = depth[c] + depth[d] - 2 * depth[lca]
    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
import collections

n, q = list(map(int, input().split()))

queries = []
mp = collections.defaultdict(list)

for i in range(n + q - 1):
    a, b = list(map(int, input().split()))
    if i < n - 1:

        mp[a].append(b)
        mp[b].append(a)
    else:
        queries.append([a, b])

dist = [-1 for i in range(n + 1)]


def bfs(node):

    vis = [0 for i in range(n + 1)]
    queue = collections.deque()

    queue.append(node)
    vis[node] = 1
    dist[node] = 0
    level = 1
    while len(queue) > 0:
        curr_node = queue.popleft()
        for child in mp[curr_node]:
            if not vis[child]:
                queue.append(child)
                vis[child] = 1
                dist[child] = 1 - dist[curr_node]
        level += 1


bfs(1)
# print(dist)

for c, d in queries:
    # c,d = list(map(int, input().split()))
    # print(f"from {c} to {d} : {dist[c] - dist[d]}")
    if dist[c] == dist[d]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
a = [[]]
for _ in range(n):
    a.append([])
for _ in range(n - 1):
    b = list(map(int, input().split()))
    a[b[0]].append(b[1])
    a[b[1]].append(b[0])

visited = [False] * (n + 1)
visited[1] = True
e = [1]
f = [-1] * (n + 1)
f[1] = 0
while len(e) > 0:
    for i in a[e[0]]:
        if not visited[i]:
            e.append(i)
            f[i] = (f[e[0]] + 1) % 2
            visited[i] = True
    e.pop(0)
for i in range(q):
    c, d = map(int, input().split())
    if f[c] == f[d]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda a: int(a) - 1, input().split())
    g[a].append(b)
    g[b].append(a)
stack = [0]
color = [0] * n
color[0] = 1
while stack:
    u = stack.pop()
    for v in g[u]:
        if color[v] > 0:
            continue
        color[v] = 3 - color[u]
        stack.append(v)
for _ in range(q):
    c, d = map(lambda a: int(a) - 1, input().split())
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")from collections import deque


def main():
    TOWN = "Town"
    ROAD = "Road"

    N, Q = map(int, input().split())
    e = [set() for _ in range(N)]

    for _ in range(N - 1):
        A, B = map(int, input().split())
        e[A - 1].add(B - 1)
        e[B - 1].add(A - 1)

    q = deque([0])
    color = [-1] * N
    color[0] = 0

    while q:
        v = q.popleft()

        for i in e[v]:
            if color[i] < 0:
                color[i] = color[v] ^ 1
                q.append(i)

    ans = []
    for _ in range(Q):
        C, D = map(int, input().split())
        if color[C - 1] == color[D - 1]:
            ans.append(TOWN)
        else:
            ans.append(ROAD)

    print(*ans, sep="\n")


if __name__ == "__main__":
    main()
def main():
    #n=int(input())
    #a,b=map(int,input().split())
    #a=list(map(int,input().split()))
    #a=[list(map(int,input().split())) for _ in range(h)]
    from collections import deque
    n, Q = map(int, input().split())
    ab = [[] * n for _ in range(n)]
    color = [0] * n
    for i in range(n - 1):
        a, b = map(int, input().split())
        ab[a - 1].append(b - 1)
        ab[b - 1].append(a - 1)
    q = deque()
    q.append([0, 1])
    while q:
        pos, col = q.popleft()
        color[pos] = col
        col *= -1
        for nx in ab[pos]:
            if color[nx] != 0:
                continue
            q.append([nx, col])
    for i in range(Q):
        c, d = map(int, input().split())
        if color[c - 1] == color[d - 1]:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
import sys

sys.setrecursionlimit(10**7)
N, Q = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    G[a].append(b)
    G[b].append(a)

# Euler Tour Technique
S = []
FS = [0] * N
depth = [0] * N


def dfs(v, p, d):
    depth[v] = d
    FS[v] = len(S)
    S.append(v)
    for w in G[v]:
        if w == p:
            continue
        dfs(w, v, d + 1)
        S.append(v)


dfs(0, -1, 0)

# Sparse Table
L = len(S)
lg = [0] * (L + 1)
for i in range(2, L + 1):
    lg[i] = lg[i >> 1] + 1
st = [None] * (lg[L] + 1)
st0 = st[0] = S
b = 1
for i in range(lg[L]):
    st0 = st[i + 1] = [
        p if depth[p] <= depth[q] else q for p, q in zip(st0, st0[b:])
    ]
    b <<= 1


# LCA O(1)
def query(u, v):
    x = FS[u]
    y = FS[v]
    if x > y:
        x, y = y, x
    l = lg[y - x + 1]
    px = st[l][x]
    py = st[l][y - (1 << l) + 1]
    return px if depth[px] <= depth[py] else py


q = [list(map(int, input().split())) for _ in range(Q)]

for x, y in q:
    x, y = x - 1, y - 1
    z = query(x, y)
    d = depth[x] + depth[y] - 2 * depth[z]
    print("Town") if d % 2 == 0 else print("Road")
from collections import deque

N, Q = map(int, input().split())
relation = [[] for _ in range(N)]
reached = {0}
dist = [0] * N
for i in range(N - 1):
    A, B = map(int, input().split())
    relation[A - 1].append(B - 1)
    relation[B - 1].append(A - 1)

odd_nodes = []
even_nodes = []

que = deque([0])
while que:
    tmp = que.popleft()
    for crt in relation[tmp]:
        if crt in reached:
            pass
        else:
            reached.add(crt)
            dist[crt] = dist[tmp] + 1
            que.append(crt)

for i in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
# -*- coding: utf-8 -*-


def main():
    from collections import deque
    import sys

    input = sys.stdin.readline

    n, q = map(int, input().split())
    graph = [[] for _ in range(n)]

    for _ in range(n - 1):
        ai, bi = map(int, input().split())
        ai -= 1
        bi -= 1

        graph[ai].append(bi)
        graph[bi].append(ai)

    used = [False for _ in range(n)]
    dist = [10**7 for _ in range(n)]
    dist[0] = 0
    d = deque()
    d.append(0)

    while d:
        di = d.popleft()
        used[di] = True

        for to in graph[di]:
            if used[to]:
                continue

            dist[to] = min(dist[to], dist[di] + 1)
            d.append(to)

    for i in range(q):
        ci, di = map(int, input().split())
        ci -= 1
        di -= 1

        if abs(dist[ci] - dist[di]) % 2 == 1:
            print("Road")
        else:
            print("Town")


if __name__ == "__main__":
    main()
n, q = map(int, input().split())
g = [[] for _ in range(0, n + 1)]

for i in range(0, n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

from collections import deque


def bfs(N: int, X: int, g):
    q = deque([X])
    visit = [float("inf") for _ in range(0, N)]
    visit[X] = 0

    while q:
        x = q.popleft()
        for dest in g[x]:
            if visit[dest] > visit[x] + 1:
                visit[dest] = visit[x] + 1
                q.append(dest)
    return visit


dist = bfs(n + 1, 1, g)
# print(dist)

anss = []
for i in range(0, q):
    c, d = map(int, input().split())
    if abs(dist[d] - dist[c]) % 2 == 0:
        anss.append("Town")
    else:
        anss.append("Road")

print("\n".join(anss))
N, Q = map(int, input().split())
Edge = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    Edge[a].append(b)
    Edge[b].append(a)
dis = [0 for _ in range(N)]
from collections import deque

q = deque()
q.append((0, 0))
seen = [False for _ in range(N)]
while q:
    now, t = q.popleft()
    seen[now] = True
    dis[now] = t
    for next in Edge[now]:
        if not seen[next]:
            q.append((next, t + 1))
for _ in range(Q):
    c, d = map(int, input().split())
    if (dis[c - 1] + dis[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque
import time

N, Q = map(int, input().split())
graph = {}
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph.setdefault(a, [])
    graph.setdefault(b, [])
    graph[a].append(b)
    graph[b].append(a)

array = [-1] * N
d = deque()
d.append((0, 0))

while len(d):
    v, distance = d.popleft()
    array[v] = distance
    for w in graph.get(v, []):
        if array[w] != -1:
            continue

        d.append((w, distance + 1))

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    if (array[c] - array[d]) % 2 != 0:
        print('Road')
    else:
        print('Town')
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())

edge = [[] for _ in range(n)]
dep = [0] * n
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)


def dfs(x, last=-1):
    for to in edge[x]:
        if to == last:
            continue
        dep[to] = dep[x] + 1
        dfs(to, x)


dfs(0)
for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dep[c] % 2 == dep[d] % 2:
        print("Town")
    else:
        print("Road")
class segtree:
    """
    Segment tree
    Store value as object type and optional function for binary operarion.
    "get" function return a value by binary operarion result. O(logN)
    "update" function update tree's a value. O(logN)

    Attributes
    ----------
    n : int
        Number of elements
    identity element_func : func
        identity_element for initialization
        if operator is * and identiry element is e, e * A = A and A * e = A
    binary_operation_func : func
        function for binary operation x and y
        function must have associative law
        if operator is *, (A * B) * C = A * (B * C)

    Methods
    -------
    update(i, x)
        update tree[i] value to x
    get(a, b)
        get value from [a, b)
        include a but not include b, return a merged value
    """
    def __init__(self, n: int, identity_element_func, binary_operation_func):
        """
        Constructer(Initialize parameter in this class)

        Parameters
        ----------
        n : int
            Number of elements
        identity_element_func : func
            identity element for initialization
            if operator is * and identiry element is e, e * A = A and A * e = A
        binary_operation_func : func
            function for binary operation x and y
            function must have associative law
            if operator is *, (A * B) * C = A * (B * C)
        """
        self.n = n
        self.identity = identity_element_func
        self.binary = binary_operation_func
        n2 = 1  # n2はnより大きい2の冪数
        while n2 < n:
            n2 <<= 1
        self.n2 = n2
        self.tree = [identity_element_func() for _ in range(n2 << 1)]

    def update(self, index: int, x: int):
        """
        Update segment-tree's a value and update segment-tree's tree

        Parameters
        ----------
        index : int
            index of update value
        x : int
            new value
        """
        index += self.n2
        self.tree[index] = self.binary(self.tree[index], x)
        while index > 1:
            # (index ^ 1) はiと1の排他的論理和(XOR)
            x = self.binary(x, self.tree[index ^ 1])
            index >>= 1  # 右ビットシフトで親ノードのインデックスへ移動
            self.tree[index] = self.binary(self.tree[index], x)

    def get(self, a: int, b: int) -> int:
        """
        Get a specific value by result of binary operation from interval [a, b)

        Parameters
        ----------
        a, b : int
            index of interval
            this is hald open interval, this interval include a but not b
        """
        result = self.identity()
        q = [(1, 0, self.n2)]
        while q:
            k, left, right = q.pop()
            if a <= left and right <= b:
                result = self.binary(result, self.tree[k])
                continue
            m = (left + right) // 2
            k <<= 1
            if a < m and left < b:
                q.append((k, left, m))
            if a < right and left < m:
                q.append((k + 1, m, right))
        return result


N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    edge[x].append(y)
    edge[y].append(x)  # 有向グラフならこの行は消す!!
INF = 10**18

first_seen_i_on_tour = [-1] * N
height_tour = segtree(N, lambda: INF, min)
cnt = 0
queue = [(0, 0)]
while queue:
    now, depth = queue.pop()
    if first_seen_i_on_tour[now] != -1:
        continue
    first_seen_i_on_tour[now] = cnt
    height_tour.update(cnt, depth)
    cnt += 1

    depth += 1
    for n_node in edge[now]:
        if first_seen_i_on_tour[n_node] != -1:
            continue
        queue.append((n_node, depth))

for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    left, right = sorted(first_seen_i_on_tour[i] for i in (c, d))
    lca = height_tour.get(left, right)
    ans = sum(height_tour.get(i, i + 1) for i in (left, right))
    ans -= 2 * height_tour.get(lca, lca + 1)
    if ans & 1:
        print("Road")
    else:
        print("Town")
#!/usr/bin/env python3
import sys
import queue

input = sys.stdin.readline
sys.setrecursionlimit(100000)

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
#print(G)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
#print(que)

while (not que.empty()):
    tmp = que.get()
    #print(tmp)
    for i in G[tmp]:
        if (color[i] == -1):
            color[i] = 1 - color[tmp]
            que.put(i)

for i in range(Q):
    a, b = map(int, input().split())
    if (color[a - 1] == color[b - 1]):
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
town = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    town[a - 1].append(b)
    town[b - 1].append(a)

deep, data = [-1] * n, [[1, 0]]
cnt = 0

while len(data) > 0:
    temp, depth = data.pop(0)
    if deep[temp - 1] >= 0:
        continue
    deep[temp - 1] = depth
    depth += 1
    for i in town[temp - 1]:
        if deep[i - 1] >= 0:
            continue
        data.append([i, depth])

for _ in range(q):
    c, d = map(int, input().split())
    ans = abs(deep[c - 1] - deep[d - 1])
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque, Counter, defaultdict
import sys

input = sys.stdin.readline

n, q = map(int, input().split())
E = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

INF = 10**18


class SegTree():
    def __init__(self, size, segfunc, ide_ele):
        self.size = 2**(size - 1).bit_length()
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.tree = [ide_ele] * (self.size * 2)

    def update(self, k, a):
        k += self.size
        self.tree[k] = a
        while k > 0:
            k >>= 1
            self.tree[k] = self.segfunc(self.tree[k * 2], self.tree[k * 2 + 1])

    def query(self, l, r):
        l += self.size
        r += self.size
        lres, rres = self.ide_ele, self.ide_ele
        while l < r:
            if (l & 1):
                lres = self.segfunc(lres, self.tree[l])
                l += 1
            if (r & 1):
                r -= 1
                rres = self.segfunc(self.tree[r], rres)
            l >>= 1
            r >>= 1
        res = self.segfunc(lres, rres)
        return res


# Euler Tour
def euler_tour(n, G, s):
    stack = deque([~s, s])
    done = [0] * n
    time = 0
    d = -1

    in_t = [0] * n  # in time
    out_t = [0] * n  # out time
    depth = [0] * n  # depth
    et = []  # euler tour 探索順
    p = [0] * n  # parent

    while stack:
        cur = stack.pop()
        # 行きがけ処理
        if cur >= 0:
            done[cur] = 1
            et.append(cur)
            in_t[cur] = time
            d += 1
            depth[cur] = d
            for e in G[cur]:
                if done[e]: continue
                stack.append(~e)
                stack.append(e)
                p[e] = cur
            time += 1
        # 帰りがけ処理
        else:
            out_t[~cur] = time
            et.append(p[~cur])
            d -= 1
            time += 1

    return et, in_t, out_t, depth


class LCA():
    def __init__(self, n, E, start):
        self.et, self.in_t, self.out_t, self.depth = euler_tour(n, E, start)
        self.seg = SegTree(len(self.et), lambda a, b: a
                           if a[0] <= b[0] else b, (INF, 0))
        for i, eti in enumerate(self.et):
            self.seg.update(i, (self.depth[eti], eti))

    def query(self, a, b):
        l, r = sorted([self.in_t[a], self.in_t[b]])
        depth_p, p = self.seg.query(l, r + 1)
        return depth_p, p


lca = LCA(n, E, 0)
for i in range(q):
    c, d = map(int, input().split())
    depth_c = lca.depth[c - 1]
    depth_d = lca.depth[d - 1]
    depth_p, p = lca.query(c - 1, d - 1)

    if (abs(depth_c - depth_p) - abs(depth_d - depth_p)) % 2:
        print("Road")
    else:
        print("Town")
import sys
import queue

sys.setrecursionlimit(1000000)

N, Q = map(int, input().split())
L = N - 1

adj = [[] for i in range(N)]

for i in range(L):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    adj[a].append(b)
    adj[b].append(a)

node = [-1] * N
node[0] = 0

q = queue.Queue()
q.put(0)
while not q.empty():
    current = q.get()
    for next in adj[current]:
        if node[next] == -1:
            if node[current] == 0:
                node[next] = 1
            else:
                node[next] = 0
            q.put(next)

for i in range(Q):
    c, d = map(int, input().split())
    if node[c - 1] == node[d - 1]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(3000000)
n, q = map(int, input().split())
H = [[] for j in range(n)]
d = [0] * n
for i in range(n - 1):
    a, b = map(int, input().split())
    H[a - 1].append(b - 1)
    H[b - 1].append(a - 1)
flg = [0] * n
flg[0] = 1


def re(s, we):
    d[s] = we + 1
    for itm in H[s]:
        if flg[itm] == 0:
            flg[itm] = 1
            re(itm, we + 1)


re(0, 0)
for i in range(q):
    cc, dd = map(int, input().split())
    if abs(d[cc - 1] - d[dd - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
def dfs(cur, prev):
    global depth, parent
    depth[cur] = depth[prev] + 1
    parent[cur][0] = prev
    for next_ in tree[cur]:
        if next_ != prev:
            dfs(next_, cur)


def addEdge(u, v):
    global tree
    tree[u].append(v)
    tree[v].append(u)


def precompute(n):
    for i in range(1, level):
        for node in range(1, n + 1):
            if parent[node][i - 1] != -1:
                parent[node][i] = parent[parent[node][i - 1]][i - 1]


def lca(u, v):
    if depth[v] < depth[u]:
        u, v = v, u

    diff = depth[v] - depth[u]

    for i in range(level):
        if ((diff >> i) & 1):
            v = parent[v][i]

    if u == v:
        return u

    for i in range(level - 1, -1, -1):
        if (parent[u][i] != parent[v][i]):
            u = parent[u][i]
            v = parent[v][i]

    return parent[u][0]


import sys

sys.setrecursionlimit(200002)

MAXN = 200002
level = 4

tree = [[] for _ in range(MAXN)]
depth = [0 for _ in range(MAXN)]
parent = [[-1 for _ in range(level)] for _ in range(MAXN)]

n, q = map(int, input().split())
for _ in range(n - 1):
    a, b = map(int, input().split())
    addEdge(a, b)

depth[0] = 0
dfs(1, 0)

precompute(n)

for i in range(q):
    c, d = map(int, input().split())
    if (depth[c] + depth[d] - 2 * lca(c, d)) % 2 != 0:
        print("Road")
    else:
        print("Town")
from collections import deque


def main():
    # input
    N, Q = map(int, input().split())
    abs = [[*map(int, input().split())] for _ in range(N - 1)]
    cds = [[*map(int, input().split())] for _ in range(Q)]

    # compute
    adjss = [[] for _ in range(N)]
    for a, b in abs:
        a -= 1
        b -= 1
        adjss[a].append(b)
        adjss[b].append(a)

    ## BFS
    deq = deque([0])
    dist = [-1] * N
    dist[0] = 0
    while deq:
        v = deq.popleft()
        for i in adjss[v]:
            if dist[i] == -1:
                dist[i] = 1 - dist[v]
                deq.append(i)

    # output
    for c, d in cds:
        c -= 1
        d -= 1
        if dist[c] == dist[d]:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
import sys

sys.setrecursionlimit(500005)
stdin = sys.stdin

ni = lambda: int(ns())
nm = lambda: map(int, stdin.readline().split())
nl = lambda: list(nm())
ns = lambda: stdin.readline().strip()


class LCADoubling:
    """
    I used these sites as reference
    - https://ikatakos.com/pot/programming_algorithm/graph_theory/lowest_common_ancestor
    - https://algo-logic.info/lca/
    
    """
    def __init__(self, graph, root=0, with_weight=False):
        n = len(graph)
        self.depths = [-1] * n
        self.distances = [-1] * n
        prev_ancestors = self._init_dfs(graph, root, with_weight)
        self.ancestors = [prev_ancestors]
        max_depth = max(self.depths)
        d = 1
        while d < max_depth:
            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]
            self.ancestors.append(next_ancestors)
            d <<= 1
            prev_ancestors = next_ancestors

    def _init_dfs(self, graph, root=0, with_weight=False):
        q = [(root, -1, 0, 0)]
        direct_ancestors = [-1] * (len(graph) + 1)
        while q:
            v, p, dep, dist = q.pop()
            direct_ancestors[v] = p
            self.depths[v] = dep
            self.distances[v] = dist
            if with_weight:
                q.extend(
                    (u, v, dep + 1, dist + w) for u, w in graph[v] if u != p)
            else:
                q.extend((u, v, dep + 1, dist + 1) for u in graph[v] if u != p)
        return direct_ancestors

    def get_lca(self, u, v):
        du, dv = self.depths[u], self.depths[v]
        if du > dv:
            u, v = v, u
            du, dv = dv, du
        tu = u
        tv = self.upstream(v, dv - du)
        if u == tv:
            return u

        for k in range(du.bit_length() - 1, -1, -1):
            mu = self.ancestors[k][tu]
            mv = self.ancestors[k][tv]
            if mu != mv:
                tu = mu
                tv = mv
        lca = self.ancestors[0][tu]
        assert lca == self.ancestors[0][tv]
        return lca

    def upstream(self, v, k):
        i = 0
        while k:
            if k & 1:
                v = self.ancestors[i][v]
            k >>= 1
            i += 1
        return v

    def get_distance(self, u, v):
        lca = self.get_lca(u, v)
        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]

    def is_on_path(self, u, v, a):
        return self.get_distance(u, a) + self.get_distance(
            a, v) == self.get_distance(u, v)


n, q = nm()

g = [[] for i in range(n)]

for _ in range(n - 1):
    a, b = nm()
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

lca = LCADoubling(g)

for _ in range(q):
    c, d = nm()
    c -= 1
    d -= 1

    dis = lca.get_distance(c, d)

    if dis % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
graph = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
dist = [-1] * (N + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)
while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)
for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[c] - dist[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
ab = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    ab[a - 1].append(b - 1)
    ab[b - 1].append(a - 1)

st = deque()
st.append(0)
dist = [-1] * n
dist[0] = 0
while st:
    cur = st.popleft()
    for j in ab[cur]:
        if dist[j] != -1:
            continue
        dist[j] = dist[cur] + 1
        st.append(j)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 0:
        ans = "Town"
    else:
        ans = "Road"
    print(ans)
n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

from collections import defaultdict

g = defaultdict(list)
for a, b in ab:
    g[a] += [b]
    g[b] += [a]

# Euler Tour の構築


def dfs(u, d):
    F = [0] * (n + 1)
    ET = []

    que = [(u, d)]

    while len(que) > 0:
        u, d = que.pop()
        #print(u, d)
        if u > 0:
            F[u] = len(ET)
            ET += [(u, d)]
            for v in g[u]:
                if F[v] == 0:
                    que += [(-v, d + 1)]
                    que += [(v, d + 1)]
        else:
            ET += [(u, d)]
        #print(que)
    return F, ET


F, ET = dfs(1, 0)
A = [et[1] for et in ET]


def init_min(init_min_val):
    #set_val
    for i in range(n):
        seg_min[i + num_min - 1] = init_min_val[i]
    #built
    for i in range(num_min - 2, -1, -1):
        seg_min[i] = min(seg_min[2 * i + 1], seg_min[2 * i + 2])


def query_min(p, q):
    if q <= p:
        return ide_ele_min
    p += num_min - 1
    q += num_min - 2
    res = ide_ele_min
    while q - p > 1:
        if p & 1 == 0:
            res = min(res, seg_min[p])
        if q & 1 == 1:
            res = min(res, seg_min[q])
            q -= 1
        p = p // 2
        q = (q - 1) // 2
    if p == q:
        res = min(res, seg_min[p])
    else:
        res = min(min(res, seg_min[p]), seg_min[q])
    return res


n = len(A)
ide_ele_min = 10**5 + 1

#num_min:n以上の最小の2のべき乗
num_min = 2**(n - 1).bit_length()
seg_min = [ide_ele_min] * 2 * num_min

#init
init_min(A)

for c, d in cd:
    pc, pd = F[c], F[d]

    dc, dd = A[pc], A[pd]
    #print(c, d)
    #print(F[c], F[d])
    #print(ET[pc], ET[pd])
    #print()
    #continue
    m = query_min(pc, pd)

    #print(c,d,pc,pd,dc,dd,m)

    dist = dc + dd - 2 * m
    #print(dist)
    #print(ET[pc:pd+1])

    if dist % 2 == 0:
        print(  #dist, 
            "Town")
    else:
        print(  #dist, 
            "Road")
    #print()
from collections import deque

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1] * N


def bfs():
    global dist
    dist[0] = 0
    q = deque([0])
    while q:
        u = q.popleft()
        for v in G[u]:
            if dist[v] < 0:
                dist[v] = dist[u] + 1
                q.append(v)


bfs()
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
#    ____                       _   _                _     _ _
#   / ___| __ _ _ __ __ _      | | | | __ _ _ __ ___| |__ (_) |_
#  | |  _ / _` | '__/ _` |_____| |_| |/ _` | '__/ __| '_ \| | __|
#  | |_| | (_| | | | (_| |_____|  _  | (_| | |  \__ \ | | | | |_
#   \____|\__,_|_|  \__, |     |_| |_|\__,_|_|  |___/_| |_|_|\__|
#                   |___/

from typing import Counter
import sys
from collections import defaultdict
from math import *
from collections import deque


def vinp():
    return map(int, input().split())


def linp():
    return list(map(int, input().split()))


def sinp():
    return input()


def inp():
    return int(input())


def mod(f):
    return f % 1000000007


def pr(*x):
    print(*x)


def finp():
    f = open("input.txt", "r")
    f = f.read().split("\n")
    return f


def finp():
    f = open("input.txt", "r")
    f = f.read().split("\n")
    return f


def fout():
    return open("output.txt", "w")


def fpr(f, x):
    f.write(x + "\n")


def csort(c):
    sorted(c.items(), key=lambda pair: pair[1], reverse=True)


def indc(l, n):
    c = {}
    for i in range(n):
        c[l[i]] = c.get(l[i], []) + [i + 1]
    return c


def LcA(a, b):
    for i in range(ma, -1, -1):
        if lc[a][i] != -1 and lc[a][i] != lc[b][i]:
            a = lc[a][i]
            b = lc[b][i]
    return lc[a][0]


def EQUAL(a, b):
    x, y = dis[a], dis[b]
    z = abs(x - y)
    if z == 0:
        return a, b
    if x > y:
        while z:
            p = int(log(z, 2))
            a = lc[a][p]
            z -= (1 << p)
    else:
        while z:
            p = int(log(z, 2))
            b = lc[b][p]
            z -= (1 << p)
    return a, b


n, qu = vinp()
d = defaultdict(list)
for i in range(n - 1):
    a, b = vinp()
    d[a].append(b)
    d[b].append(a)
dis = [0 for i in range(n + 1)]
q = deque()
q.append(1)
v = [0 for i in range(n + 1)]
ma = int(log(n, 2))
lc = [[-1 for i in range(ma + 1)] for j in range(n + 1)]
while q:
    a = q.popleft()
    v[a] = 1
    for i in d[a]:
        if not v[i]:
            v[i] = 1
            lc[i][0] = a
            q.append(i)
            dis[i] = dis[a] + 1
for j in range(1, ma + 1):
    for i in range(1, n + 1):
        if lc[i][j - 1] != -1:
            p = lc[i][j - 1]
            lc[i][j] = lc[p][j - 1]
ans = []
Q = [linp() for i in range(qu)]
for i in Q:
    a, b = i
    x, y = EQUAL(a, b)
    if x == y:
        vp = dis[a] + dis[b] - (2 * dis[y])
        if vp % 2:
            ans.append('Road')
        else:
            ans.append('Town')
        continue
    z = LcA(x, y)
    vp = dis[a] + dis[b] - (2 * dis[z])
    if vp % 2:
        ans.append('Road')
    else:
        ans.append('Town')
pr('\n'.join(ans))
from collections import deque

n, q = map(int, input().split())
l = [[] for i in range(n)]
t = [float("inf") for i in range(n)]
t[0] = 0
for i in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    l[a].append(b)
    l[b].append(a)
d = deque()
for i in range(len(l[0])):
    d.append([0, l[0][i]])
while len(d) > 0:
    x = d.popleft()
    t[x[1]] = x[0] + 1
    for i in range(len(l[x[1]])):
        if t[l[x[1]][i]] == float("inf"):
            d.append([t[x[1]], l[x[1]][i]])
for i in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (t[c] - t[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
def main():
    from collections import deque
    import sys
    input = sys.stdin.readline

    N, Q = map(int, input().split())

    G = tuple(list() for _ in range(N))
    for _ in range(N - 1):
        a, b = (int(x) - 1 for x in input().split())
        G[a].append(b)
        G[b].append(a)

    color = [None] * N
    color[0] = 0

    dq = deque()
    dq.append(0)
    while dq:
        v = dq.popleft()
        nc = color[v] ^ 1
        for u in G[v]:
            if color[u] is None:
                color[u] = nc
                dq.append(u)

    ans = []
    for _ in range(Q):
        c, d = (int(x) - 1 for x in input().split())
        msg = "Road" if color[c] ^ color[d] else "Town"
        ans.append(msg)
    print(*ans, sep='\n')


if __name__ == "__main__":
    main()
import queue

n, Q = map(int, input().split())
g = [[] for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

used = [False] * n
dep = [0] * n

q = queue.Queue()
used[0] = 1
q.put(0)

while not q.empty():
    v = q.get()
    for u in g[v]:
        if used[u]:
            continue
        dep[u] = dep[v] + 1
        used[u] = 1
        q.put(u)

ans = []
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if abs(dep[d] - dep[c]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import collections

n, m = map(int, input().split())
g = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

visited = [0] * (n + 1)
visited[1] = 1
dist = [0] * (n + 1)
que = collections.deque([1])

while que:
    q = que.popleft()
    for i in g[q]:
        if visited[i] == 0:
            visited[i] = 1
            que.append(i)
            dist[i] = dist[q] + 1

for i in range(m):
    c, d = map(int, input().split())
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**6)

N, Q = map(int, input().split())
ab = [[int(i) for i in input().split()] for _ in range(N - 1)]
cd = [[int(i) for i in input().split()] for _ in range(Q)]
G = [[] for _ in range(N)]
for a, b in ab:
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

#Euler tour
vs = [-1] * (len(G) * 2 - 1)  #DFSの訪問順
depth = [-1] * (len(G) * 2 - 1)  #根からの深さ
id = [-1] * len(G)  #各頂点がvsに初めて登場するindex
k = 0


def dfs(v, p, d):
    global k
    id[v] = k
    vs[k] = v
    depth[k] = d
    k += 1
    for i in range(len(G[v])):
        if G[v][i] != p:
            dfs(G[v][i], v, d + 1)
            vs[k] = v
            depth[k] = d
            k += 1


dfs(0, -1, 0)
for c, d in cd:
    print('Road' if (depth[id[c - 1]] - depth[id[d - 1]]) % 2 else 'Town')
# coding: utf-8
import sys
import math
import io
from collections import Counter
from collections import deque


def i_input():
    return int(input())


def i_map():
    return map(int, input().split())


def i_list():
    return list(i_map())


def main():
    n, q = i_map()
    global R
    R = [[] for _ in range(n + 1)]
    global color
    color = [0 for _ in range(n + 1)]
    color[1] = 1

    for _ in range(n - 1):
        a, b = i_map()
        R[a].append(b)
        R[b].append(a)

    #dfs(1)
    que = deque()

    que.append(1)

    while que:
        t = que.popleft()
        for r in R[t]:
            if color[r] == 0:
                color[r] = color[t] * -1
                que.append(r)

    for i in range(q):
        c, d = i_map()
        if color[c] == color[d]:
            print("Town")
        else:
            print("Road")


def dfs(s):
    for r in R[s]:
        if color[r] == 0:
            color[r] = color[s] * -1
            dfs(r)


if __name__ == '__main__':
    _INPUT = '''\
4 1
1 2
2 3
2 4
1 2


    '''
    if sys.platform == 'win32':
        sys.stdin = io.StringIO(_INPUT)

    main()
import sys

sys.setrecursionlimit(100000)

N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]

# 各節点について、接続先節点のリストを作成
roads = [[] for _ in range(N)]
for a, b in AB:
    roads[a - 1].append(b - 1)
    roads[b - 1].append(a - 1)


class Dfs():
    def __init__(self, graphs, num):
        self.graphs = graphs
        self.times = [0] * num
        self.group = [[], []]
        self.time = 0
        self.queue = []
        self.gid = [0] * (num + 1)

    def __call__(self, start_pos):
        self.queue.append([start_pos, -1, 0])  #(current, previous, group)
        while self.queue:
            node_id, pre_node, group_id = self.queue.pop()
            self.group[group_id].append(node_id + 1)  #0index+1
            self.gid[node_id + 1] = group_id
            for next_id in self.graphs[node_id]:
                if not next_id == pre_node:
                    self.queue.append([next_id, node_id, group_id ^ 1])


dfs = Dfs(roads, N)

dfs(1)
for c, d in CD:
    if dfs.gid[c] == dfs.gid[d]:
        print("Town")
    else:
        print("Road")
from sys import exit, stdin, setrecursionlimit

setrecursionlimit(10**9)
MOD = 1000000007
#import copy
#input = stdin.readline

#from collections import deque, Counter
#import numpy as np
#from math import gcd, comb, factorial

from collections import deque


def bfs(graph, s0=0):
    """
	graph:隣接リスト (nextnode)
	s0:start位置
	return:各頂点の距離
	"""
    dist = [-1] * len(graph)
    que = deque()
    que.append(s0)
    dist[s0] = 0

    while que:
        now = que.popleft()
        for next in graph[now]:
            if dist[next] == -1:
                dist[next] = (dist[now] + 1) % 2
                que.append(next)
    return dist


N, Q = map(int, input().split())

D = [[] for _ in range(N)]
for _ in range(N - 1):
    A, B = map(int, input().split())
    A -= 1
    B -= 1
    D[A].append(B)
    D[B].append(A)

G = bfs(D)
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if G[c] == G[d]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**9)
N, Q = map(int, input().split())

tree = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    tree[a].append(b)
    tree[b].append(a)
#rint(tree)

depth = [-1] * (N + 1)


def dfs0(u, d):
    depth[u] = d
    for v in tree[u]:
        if depth[v] == -1:
            dfs0(v, 1 - d)


dfs0(1, 0)

#rint(depth)
for _ in range(Q):
    c, d = map(int, input().split())
    length = depth[d] - depth[c]
    if length % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
graph = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

dp = [0] * n

que = deque()
que.append([0, 1])
ch = [False] * n
while (que):
    t = que.popleft()
    x = t[0]
    cnt = t[1]
    for i in graph[x]:
        if (ch[i]):
            continue
        else:
            if (cnt % 2):
                dp[i] = 1
            ch[i] = True
            que.append([i, cnt + 1])

ans = [0] * q
for i in range(q):
    c, d = map(int, input().split())
    if (dp[c - 1] == dp[d - 1]):
        ans[i] = 1

for i in range(q):
    if (ans[i]):
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
edges = {}
visited = {}
for i in range(1, n + 1):
    edges[i] = []
    visited[i] = -1
for i in range(n - 1):
    a, b = map(int, input().split())
    edges[a].append(b)
    edges[b].append(a)

from collections import deque


def bfs(edges, root):
    global visited
    que = deque()
    que.append(root)
    visited[root] = 0
    while que:
        x = que.popleft()
        for y in edges[x]:
            if visited[y] == -1:
                que.append(y)
                visited[y] = visited[x] + 1


bfs(edges, 1)
for i in range(q):
    x, y = map(int, input().split())
    if (visited[x] + visited[y]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import collections

N, Q = map(int, input().split())
pathes = collections.defaultdict(list)
for i in range(N - 1):
    a, b = map(int, input().split())
    pathes[a].append(b)
    pathes[b].append(a)
parent = dict()
seen = set()
root = 1
que = set([root])
d = 0
depth = dict()
while (que):
    buff = set()
    for p in que:
        if (p in seen):
            continue
        seen.add(p)
        depth[p] = d
        for ch in pathes[p]:
            if (not ch in seen):
                buff.add(ch)
    d += 1
    que = buff
for i in range(Q):
    c, d = map(int, input().split())
    ans = "Town" if (depth[c] + depth[d]) % 2 == 0 else "Road"
    print(ans)
from collections import deque

n, q = map(int, input().split())
edge = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)
deeply = [0 for _ in range(n)]

que = deque()
que.append((0, 0, -1))
while len(que) > 0:
    idx, deep, up = que.popleft()
    deeply[idx] = deep
    for i in edge[idx]:
        if i != up:
            que.append((i, deep + 1, idx))

for i in range(q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    diff = abs(deeply[a] - deeply[b])
    if diff % 2 == 1:
        print("Road")
    else:
        print("Town")
import math

from collections import deque, Counter

from itertools import product, combinations, permutations

n, q = map(int, input().split())

ab = [list(map(int, input().split())) for _ in range(n - 1)]

cd = [list(map(int, input().split())) for _ in range(q)]

G = [[] for _ in range(n)]

for i in range(n - 1):

    a, b = ab[i][0], ab[i][1]

    a -= 1

    b -= 1

    G[a].append(b)

    G[b].append(a)

dist = [-1] * n

goto = deque()

root = 0

dist[root] = 0

goto.append(root)

while (goto):

    v = goto.popleft()

    for next in G[v]:

        if dist[next] != -1:

            continue

        else:

            dist[next] = dist[v] + 1

            goto.append(next)

for query in cd:

    if (dist[query[1] - 1] - dist[query[0] - 1]) % 2 == 0:

        print("Town")

    else:

        print("Road")
def bfs() -> list:
    # Data Structure for graph search
    vertices_num = len(a_graph)  # Number of vertices the graph has
    seen = [False] * vertices_num  # All vertices are not "seen" yet,
    seen[0] = 0  # but only vertex-s (root of tree) is "seen"
    todo = [0]  # Only vertex-s (root of tree) is in "todo"
    depth = 0  # Variable to count depth of tree

    # Continue searching until "todo" becomes empty
    while todo:
        depth += 1
        todo_tmp = []
        # Pull out a vertex from the head of "todo"
        for i in todo:
            # Search all "not-seen" vertices adjacent to vertex-i
            for j in a_graph[i]:
                # Do nothing if vertex-j is already "seen"
                if seen[j]:
                    continue

                # Make vertex-j "seen", and append it into "todo_tmp"
                seen[j] = depth
                todo_tmp.append(j)

        todo = todo_tmp

    return seen


def create_graph(edge_num: int, edge_list: list) -> dict:
    """
    Create a graph expressed with adjacency list
    :dict_key    : int (a vertex)
    :dict_value  : set (consisted of vertices adjacent to key vertex)
    """
    a_graph = {i: set() for i in range(edge_num)}

    for a, b in edge_list:
        a_graph[a - 1].add(b - 1)  # All graphs always need this line
        a_graph[b - 1].add(a - 1)  # Only undirected graph needs this line

    return a_graph


N, Q = map(int, input().split())
LL1 = [list(map(int, input().split())) for _ in range(N - 1)]
LL2 = [list(map(int, input().split())) for _ in range(Q)]

a_graph = create_graph(N, LL1)
a_list = bfs()
for c, d in LL2:
    res = 'Town' if (a_list[c - 1] + a_list[d - 1]) % 2 == 0 else 'Road'
    print(res)
def chk(i, f):
    f = (f + 1) % 2
    ablist[i] = f
    for r in route[i]:
        if ablist[r] == INF:
            chk(r, f)
    return


import sys

sys.setrecursionlimit(100000)

n, q = map(int, input().split())

INF = float('INF')
ablist = [INF] * n
route = []
for i in range(n):
    route.append([])

for i in range(n - 1):
    a, b = map(int, input().split())
    route[a - 1].append(b - 1)
    route[b - 1].append(a - 1)

#print(route)
chk(0, 0)
#print(ablist)

for i in range(q):
    c, d = map(int, input().split())
    if (ablist[c - 1] + ablist[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque
import copy

n, q = map(int, input().split())
G = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)
INF = pow(10, 9) + 7

# dp = [[INF,set()] for i in range(n)]
# dp[0] = [0,{0}]
# def dijkstra(s,p):
#     # dp = [[INF,set()]]*n
#     d = deque()
#     d.append((s, 0, p))
#     while(d):
#         v,cost,p = d.popleft()
#         # if(dp[v][0] <= cost): continue
#         dp[v][0] = cost
#         if(p!=-1): dp[v][1] = copy.deepcopy(dp[p][1])
#         dp[v][1].add(v)

#         # if(v == g): return dp[g][0]
#         for to in G[v]:
#             if(dp[to][0] <= cost+1): continue
#             # if(to == v): continue
#             d.append((to, cost+1, v))

# dijkstra(0, -1)

d = deque()
d.append(0)
dp = [-1] * n
dp[0] = 0
while (d):
    v = d.popleft()
    for to in G[v]:
        if (dp[to] != -1): continue
        dp[to] = 1 - dp[v]
        d.append(to)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dp[c] == dp[d]): print('Town')
    else: print('Road')
from collections import defaultdict, deque

n, q = list(map(int, input().split()))

graph = defaultdict(list)

for i in range(n - 1):
    a, b = list(map(int, input().split()))
    graph[a].append(b)
    graph[b].append(a)


def bfs(root):
    st = root
    Q = deque()
    Q.append(st)

    visited = [False] * (n + 1)
    dist = [0] * (n + 1)
    visited[st] = True

    while len(Q) > 0:
        v = Q.popleft()
        for e in graph[v]:
            if visited[e]:
                continue
            dist[e] = dist[v] + 1
            visited[e] = True
            Q.append(e)

    return dist


dist = bfs(1)
ans = []
for _ in range(q):
    c, d = list(map(int, input().split()))
    even_odd = (dist[c] + dist[d]) % 2
    if even_odd:
        ans.append("Road")
    else:
        ans.append("Town")

for a in ans:
    print(a)
from collections import deque


def main():
    N, Q = map(int, input().split())
    G = [[] for i in range(N)]
    Query = []
    for i in range(N - 1):
        a, b = map(int, input().split())
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)

    for i in range(Q):
        c, d = map(int, input().split())
        Query.append([c, d])

    trace = [-1 for i in range(N)]
    layer = 0

    q = deque()
    s = 0
    trace[s] = layer
    q.append([s, layer])

    while len(q) > 0:
        s_layer = q.popleft()
        s = s_layer[0]
        layer = s_layer[1]
        for i in range(len(G[s])):
            s_ = G[s][i]
            if trace[s_] == -1:
                trace[s_] = layer + 1
                q.append([G[s][i], layer + 1])

    for i in range(Q):
        c = Query[i][0] - 1
        d = Query[i][1] - 1
        if (trace[d] - trace[c]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
from queue import Queue

N, Q = map(int, input().split())
edges = [list(map(int, input().split())) for _ in range(N - 1)]
queries = [list(map(int, input().split())) for _ in range(Q)]

edges_from = dict.fromkeys([i for i in range(1, N + 1)])

for vertex in edges_from.keys():
    edges_from[vertex] = []

for edge in edges:
    a = edge[0]
    b = edge[1]

    edges_from[a].append(b)
    edges_from[b].append(a)

vertex_waitlist = Queue()
visited = [-1 for _ in range(N + 1)]  # -1 = not visited, 0 = even, 1 = odd

vertex_waitlist.put(1)
visited[1] = 0

while not vertex_waitlist.empty():
    vertex = vertex_waitlist.get()

    for next_vertex in edges_from[vertex]:
        if visited[next_vertex] != -1:
            continue

        vertex_waitlist.put(next_vertex)
        visited[next_vertex] = (visited[vertex] +
                                1) % 2  # flip between 0 and 1

for query in queries:
    c = query[0]
    d = query[1]

    if visited[c] == visited[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())

G = []
for i in range(N):
    G.append([])

for i in range(N - 1):
    A, B = map(int, input().split())
    A -= 1
    B -= 1
    G[A].append(B)
    G[B].append(A)

dist = []
for i in range(N):
    dist.append(-1)

s = 0
q = deque()
q.append(s)
dist[s] = 0

while len(q) > 0:
    i = q.popleft()
    for j in G[i]:
        if dist[j] == -1:
            dist[j] = dist[i] + 1
            q.append(j)

for i in range(Q):
    C, D = map(int, input().split())
    C -= 1
    D -= 1
    temp = dist[C] + dist[D]
    if temp % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())

g = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)


def bfs(u):
    queue = deque([u])
    d = [None] * (n + 2)
    d[u] = 0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


x = bfs(1)
for i in range(q):
    c, d = map(int, input().split())

    if (x[c] + x[d]) % 2 == 1:

        print("Road")
    else:
        print("Town")
#!/usr/bin/env python3

from sys import setrecursionlimit, stdin
from typing import Dict, Iterable, Set

INF: int = 2**62
MOD: int = 10**9 + 7

setrecursionlimit(10**6)


def inputs(type_=int):
    ins = input().split(' ')
    ins = [x for x in ins if x != '']

    if isinstance(type_, Iterable):
        return [t(x) for t, x in zip(type_, ins)]
    else:
        return list(map(type_, ins))


def input_(type_=int):
    a, = inputs(type_)
    return a


inputi = input_


def inputstr():
    return input_(str)


# b/aの切り上げ
def ceil(b, a):
    return (a + b - 1) // a


def answer(res) -> None:
    print(res)
    exit()


def compute():
    return


def bfs_dist_graph(start: int, size, graph: Dict[int, Set[int]]) -> int:
    dists = [-1] * size
    dists[start] = 0
    checked = set()
    checked.add(start)

    from collections import deque
    nexts = deque([(0, start)])
    while nexts:
        depth, now = nexts.popleft()
        dists[now] = depth
        checked.add(now)
        for next_ in graph[now]:
            if next_ not in checked:
                nexts.append((depth + 1, next_))

    return dists


def main():
    n, q = inputs()
    from collections import defaultdict
    path = defaultdict(set)

    # print(n)
    for _ in range(n - 1):
        a, b = inputs()
        a -= 1
        b -= 1
        path[a].add(b)
        path[b].add(a)

    edges = defaultdict(lambda: defaultdict(int))
    for i in range(n):
        edges[i][i] = 0

    for a in range(n):
        for b in path[a]:
            edges[a][b] = 1
            edges[b][a] = 1

    dists = bfs_dist_graph(0, n, path)

    for _ in range(q):
        c, d = inputs()
        c -= 1
        d -= 1
        d = dists[c] + dists[d]
        if d % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
import sys

input = lambda: sys.stdin.readline().rstrip()

sys.setrecursionlimit(2 * 10**5 + 10)
write = lambda x: sys.stdout.write(x + "\n")
debug = lambda x: sys.stderr.write(x + "\n")
writef = lambda x: print("{:.12f}".format(x))

### 木の読み込み yomikomi
n, qq = map(int, input().split())
ns = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    ns[u].append(v)
    ns[v].append(u)
# 深さ優先探索 (巻き戻しあり) dfs tree
q = [(0, -1)]
ds = [0] * n
while q:
    u, prv = q.pop()
    if u < 0:
        # 返るときの処理
        u = ~u
        for v in ns[u]:
            if v == prv:
                continue
            pass
    else:
        q.append((~u, prv))
        for v in ns[u]:
            # 進むときの処理
            if v == prv:
                continue
            q.append((v, u))
            ds[v] = ds[u] + 1
ans = []
for i in range(qq):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (ds[c] + ds[d]) % 2 == 0:
        ans.append("Town")
    else:
        ans.append("Road")
write("\n".join(ans))
from collections import deque

N, Q = list(map(int, input().split()))
edges = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = [i - 1 for i in list(map(int, input().split()))]
    edges[a].append(b)
    edges[b].append(a)

d = [-1 for _ in range(N)]
d[0] = 0
que = deque([0])
while que:
    t = que.popleft()
    for to in edges[t]:
        if d[to] == -1:
            d[to] = d[t] ^ 1
            que.append(to)

for i in range(Q):
    a, b = [i - 1 for i in list(map(int, input().split()))]
    if d[a] == d[b]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
l = [tuple(map(int, input().split())) for _ in range(n - 1)]
g = [list() for _ in range(n)]
for (u, v) in l:
    g[u - 1].append(v - 1)
    g[v - 1].append(u - 1)

depth = [n] * n
depth[0] = 0
st = [0]
while st:
    v = st.pop()
    for u in g[v]:
        if depth[u] == n:
            depth[u] = depth[v] + 1
            st.append(u)

l = [tuple(map(int, input().split())) for _ in range(q)]
for (u, v) in l:
    if (depth[u - 1] + depth[v - 1]) & 1:
        print("Road")
    else:
        print("Town")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

from collections import defaultdict

g = defaultdict(list)
for a, b in ab:
    g[a] += [b]
    g[b] += [a]

# Euler Tour の構築


def dfs(u, d):
    F = [0] * (n + 1)
    ET = []
    que = [(1, u, d)]

    while len(que) > 0:
        s, u, d = que.pop()
        #print(s, u, d)
        if s == 1:
            if F[u] == 0:
                F[u] = len(ET)
                ET += [d]
                for v in g[u]:
                    que += [(0, v, d + 1)]
                    que += [(1, v, d + 1)]
        else:
            ET += [d]

    return F, ET


F, ET = dfs(1, 0)


def init_min(init_min_val):
    #set_val
    for i in range(n):
        seg_min[i + num_min - 1] = init_min_val[i]
    #built
    for i in range(num_min - 2, -1, -1):
        seg_min[i] = min(seg_min[2 * i + 1], seg_min[2 * i + 2])


def query_min(p, q):
    if q <= p:
        return ide_ele_min
    p += num_min - 1
    q += num_min - 2
    res = ide_ele_min
    while q - p > 1:
        if p & 1 == 0:
            res = min(res, seg_min[p])
        if q & 1 == 1:
            res = min(res, seg_min[q])
            q -= 1
        p = p // 2
        q = (q - 1) // 2
    if p == q:
        res = min(res, seg_min[p])
    else:
        res = min(min(res, seg_min[p]), seg_min[q])
    return res


n = len(ET)
ide_ele_min = 10**5 + 1

#num_min:n以上の最小の2のべき乗
num_min = 2**(n - 1).bit_length()
seg_min = [ide_ele_min] * 2 * num_min

#init
init_min(ET)

for c, d in cd:
    pc, pd = F[c], F[d]
    dc, dd = ET[pc], ET[pd]
    m = query_min(pc, pd)
    #print(c,d,pc,pd,dc,dd,m)
    dist = dc + dd - 2 * m
    #print(dist, sd[pc:pd+1])
    if dist % 2 == 0:
        print(  #dist, 
            "Town")
    else:
        print(  #dist, 
            "Road")
def solv():
    N, Q = map(int, input().split())
    edges = [list(map(int, input().split())) for i in range(N - 1)]
    query = [list(map(int, input().split())) for i in range(Q)]

    #print(edges)
    #print(query)
    roots_color = [-1] * N

    def BFS(edges, N, roots_color):
        # ノードリスト
        roots = [[] for i in range(N)]
        # 辺を取り出す
        for a, b in edges:
            roots[a - 1] += [(b - 1, 1)]
            roots[b - 1] += [(a - 1, 1)]
        stack = []
        roots_color[0] = 0
        stack.append(0)
        now_color = roots_color[0]
        while stack:
            label = stack.pop(-1)
            now_color = roots_color[label]
            for i, cost in roots[label]:
                if roots_color[i] == -1:
                    roots_color[i] = now_color ^ 1
                    stack += [i]
        return roots_color

    roots_color = BFS(edges, N, roots_color)

    #print(roots_color)

    for x, y in query:
        if roots_color[x - 1] == roots_color[y - 1]:
            print('Town')
        else:
            print('Road')


if __name__ == "__main__":
    solv()
from bisect import bisect_right

inpl = lambda: list(map(int, input().split()))
output = ['Town', 'Road']
N, Q = inpl()
edges = [set() for _ in range(N)]
for _ in range(N - 1):
    a, b = inpl()
    a -= 1
    b -= 1
    edges[a].add(b)
    edges[b].add(a)
cd = []
c2q = [set() for _ in range(N)]
for q in range(Q):
    c, d = inpl()
    c -= 1
    d -= 1
    cd.append((c, d))
    c2q[c].add(q)
    c2q[d].add(q)

FORWARD, BACK = 0, 1
pool = [(FORWARD, 0, 0)]  # s, x, dep
parent = [-1] * N
depth = [-1] * N
route = [-1] * Q
history = []
in_order = [-1] * N
cur = -1
while pool:
    s, x, dep = pool.pop()
    if s == FORWARD:
        depth[x] = dep
        cur += 1
        history.append(cur)
        in_order[x] = cur
        for q in c2q[x]:
            c, d = cd[q]
            y = d if x == c else c
            prev = in_order[y]
            if prev < 0:
                continue
            else:
                p = bisect_right(history, prev) - 1
                route[q] = depth[x] + depth[y] - 2 * p

        pool.append((BACK, x, dep))
        for y in edges[x]:
            if y == parent[x]:
                continue
            else:
                parent[y] = x
                pool.append((FORWARD, y, dep + 1))
    else:
        history.pop()

for q in range(Q):
    print(output[route[q] % 2])
# for q in range(Q):
#     print(route[q])
import sys

sys.setrecursionlimit(10**7)

N, Q = map(int, input().split())
INF = 1 << 60
t = [set() for i in range(N)]
d = [INF] * N
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    t[a].add(b)
    t[b].add(a)


def dfs(x):
    #今いる町からいける町へ移動する
    for nt in t[x]:
        #すでに探索済みの町が来たら0をreturn
        if d[nt] != INF:
            continue
        d[nt] = d[x] + 1
        dfs(nt)
    return True


d[0] = 0
dfs(0)

for q in range(Q):
    c, dd = map(int, input().split())
    c -= 1
    dd -= 1
    ans = d[c] + d[dd]
    if ans % 2 == 1:
        print("Road")
    else:
        print("Town")
N, Q = map(int, input().split())

e_list = [[] for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    e_list[a - 1].append(b - 1)
    e_list[b - 1].append(a - 1)

from collections import deque


def dijkstra(N, s, e_list):
    done = [False for _ in range(N)]
    dist = [0 for _ in range(N)]  #1なら間の辺の数は偶数

    d = deque()

    d.append(s)

    while d:
        cur_node = d.popleft()
        for e in e_list[cur_node]:
            if done[e] == False:
                done[e] = True
                dist[e] = dist[cur_node] + 1
                d.append(e)
    return dist


res = dijkstra(N, 0, e_list)
for i in range(Q):
    c, d = map(int, input().split())
    if (res[c - 1] - res[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
road = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)

distance = [0] * N
que = deque([(0, 0)])

arrived = {}
while que:
    now = que.popleft()
    distance[now[1]] = now[0]
    arrived[now[1]] = 1
    for town in road[now[1]]:
        if town not in arrived:
            que.append((now[0] + 1, town))

for _ in range(Q):
    c, d = map(int, input().split())
    if (distance[c - 1] - distance[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys
import math
import heapq


def input():
    return sys.stdin.readline().rstrip()


def RL():
    return map(int, input().split())


def main():
    N, Q = RL()
    ROOT = [[] for _ in range(N)]
    for i in range(N - 1):
        a, b = RL()
        a -= 1
        b -= 1
        ROOT[a].append(b)
        ROOT[b].append(a)

    q = [0]
    GRID = [3] * N
    GRID[0] = 0
    while q:
        p = q.pop()

        for j in ROOT[p]:
            if GRID[j] == 3:
                GRID[j] = 1 - GRID[p]
                q.append(j)

    for i in range(Q):
        a, b = RL()
        a -= 1
        b -= 1
        if GRID[a] == GRID[b]:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
from collections import deque


def getDist(n, graph, rootNum) -> list:
    # print("getdist")
    # print("n", n)
    # print("m", m)
    dist = list()
    dist = [-1] * (n + 1)
    dist[0] = 0
    dist[rootNum] = 0
    # print(dist)

    d = deque()
    d.append(rootNum)

    while d:
        v = d.popleft()
        for i in graph[v]:
            if dist[i] != -1:
                continue
            dist[i] = dist[v] + 1
            d.append(i)

    ans = dist[1:]
    # print(*ans, sep="\n")
    return ans


def solve():

    N, Q = map(int, input().split())

    n, m = N, N - 1

    graph = [[] for _ in range(n + 1)]

    for i in range(m):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)

    # print("n", n)
    # print("m", m)

    DD = list()
    # for i in range(N):
    for i in range(1):
        nnn = i + 1
        # print("rootNum", nnn, getDist(nnn))
        DD.append(getDist(n, graph, nnn))

    for i in range(Q):
        a, b = map(int, input().split())
        # print("Q:", a, b)
        # print(a-1, b)
        # print(DD)
        # assert DD[a-1]
        # assert DD[a-1][b-1]
        # if DD[a-1][b-1] % 2 == 1:
        #     print("Road")
        # else:
        #     print("Town")
        if (DD[0][a - 1] + DD[0][b - 1]) % 2 == 1:
            print("Road")
        else:
            print("Town")


solve()
class LcaDoubling:
    """
    links[v] = { (u, w), (u, w), ... }  (u:隣接頂点, w:辺の重み)
    というグラフ情報から、ダブリングによるLCAを構築。
    任意の2頂点のLCAおよび距離を取得できるようにする
    """
    def __init__(self, n, links, root=0):
        self.depths = [-1] * n
        self.distances = [-1] * n
        prev_ancestors = self._init_dfs(n, links, root)
        self.ancestors = [prev_ancestors]
        max_depth = max(self.depths)
        d = 1
        while d < max_depth:
            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]
            self.ancestors.append(next_ancestors)
            d <<= 1
            prev_ancestors = next_ancestors

    def _init_dfs(self, n, links, root):
        q = [(root, -1, 0, 0)]
        direct_ancestors = [-1] * (n + 1
                                   )  # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1
        while q:
            v, p, dep, dist = q.pop()
            direct_ancestors[v] = p
            self.depths[v] = dep
            self.distances[v] = dist
            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)
        return direct_ancestors

    def get_lca(self, u, v):
        du, dv = self.depths[u], self.depths[v]
        if du > dv:
            u, v = v, u
            du, dv = dv, du
        tu = u
        tv = self.upstream(v, dv - du)
        if u == tv:
            return u
        for k in range(du.bit_length() - 1, -1, -1):
            mu = self.ancestors[k][tu]
            mv = self.ancestors[k][tv]
            if mu != mv:
                tu = mu
                tv = mv
        lca = self.ancestors[0][tu]
        assert lca == self.ancestors[0][tv]
        return lca

    def get_distance(self, u, v):
        lca = self.get_lca(u, v)
        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]

    def upstream(self, v, k):
        i = 0
        while k:
            if k & 1:
                v = self.ancestors[i][v]
            k >>= 1
            i += 1
        return v


n, q = map(int, input().split())
links = [set() for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    links[a].add((b, 1))
    links[b].add((a, 1))

lcad = LcaDoubling(n, links)

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    distance = lcad.get_distance(c, d)

    if distance % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
ikeru = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    ikeru[a - 1].append(b - 1)
    ikeru[b - 1].append(a - 1)

fukasa = [0 for _ in range(n)]
kaisuu = 0
settansaku = set([])
setmada = {0}
kouho = 1

while kouho != 0:
    kaisuu += 1
    for i in list(setmada):
        settansaku.add(i)
        setmada.remove(i)
        kouho -= 1
        for k in ikeru[i]:
            if not k in setmada:
                if not k in settansaku:
                    setmada.add(k)
                    kouho += 1
                    fukasa[k] = kaisuu

for i in range(q):
    c, d = map(int, input().split())
    if (fukasa[c - 1] - fukasa[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, Q = map(int, input().split())
edge = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)
depth = [0] * n
que = deque([0])
check = [False] * n
check[0] = True
while que:
    q = que.popleft()
    for i in edge[q]:
        if not check[i]:
            check[i] = True
            que.append(i)
            depth[i] = depth[q] + 1
for i in range(Q):
    c, d = map(int, input().split())
    if (depth[c - 1] + depth[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
# node n
# edge n-1
# ->tree

n, query = map(int, input().split())

g = [[] for i in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

oe = [-1 for i in range(n + 1)]
check = [0 for i in range(n + 1)]

from collections import deque

q = deque()
q.append(1)

oe[1] = 0

while q:
    now = q.popleft()
    for i in g[now]:
        if (check[i] == 1):
            continue
        q.append(i)
        oe[i] = (oe[now] + 1) % 2
        check[i] = 1

judge = ["Town", "Road"]

for i in range(query):
    c, d = map(int, input().split())
    print(judge[oe[c] ^ oe[d]])
import sys

sys.setrecursionlimit(100000)

N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]
G = [[] for _ in range(N)]
dp = [[0] * N for _ in range(2)]
visited = [0] * N


def dfs(x, c, a):
    for i in G[x]:
        if visited[i] == 0:
            visited[i] = 1
            dp[a][i] = c + 1
            dfs(i, c + 1, a)


for ab in AB:
    a, b = ab
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

for i in range(N):
    if len(G[i]) == 1:
        s = i
        break

visited = [0] * N
visited[s] = 1
dfs(s, 0, 0)
s = dp[0].index(max(dp[0]))
#print(s)
visited = [0] * N
visited[s] = 1
dfs(s, 0, 1)
#print(dp)
for cd in CD:
    c, d = cd
    c -= 1
    d -= 1
    if max(abs(dp[0][c] - dp[0][d]), abs(dp[1][c] - dp[1][d])) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
from collections import defaultdict
from itertools import groupby, permutations as pm, combinations as cm, product, combinations_with_replacement as cmrp

sys.setrecursionlimit(1000000)


def input():
    return sys.stdin.readline()[:-1]


def insp():
    return map(int, input().split())


def stsp():
    return input().split()


def solve():
    n, q = insp()
    graph = defaultdict(list)
    for i in range(n - 1):
        a, b = insp()
        graph[a].append(b)
        graph[b].append(a)

    qs = []
    for i in range(q):
        a, b = insp()
        qs.append((a, b))

    answers = ["Road"] * q
    start = 0
    stack = [1]
    dis = [0 for i in range(n + 1)]
    searched = [False for i in range(n + 1)]
    while stack:
        search = stack.pop()
        if searched[search]:
            continue
        searched[search] = True
        for t in graph[search]:
            dis[t] = (dis[search] + 1) % 2
            stack.append(t)

    for i, query in enumerate(qs):
        if dis[query[0]] == dis[query[1]]:
            answers[i] = "Town"

    print(*answers, sep="\n")
    return 0


if __name__ == "__main__":
    solve()
import queue

city, Q = map(int, input().split())
road = [[] for i in range(city)]
flag = [-1] * (city)
for i in range(city - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)
flag[0] = 0

que = queue.Queue()
que.put(0)
while not que.empty():
    memo = que.get()
    for i in road[memo]:
        if flag[i] == -1:
            if flag[memo] == 0:
                flag[i] = 1
            else:
                flag[i] = 0
            que.put(i)
Queri = [0] * Q
for i in range(Q):
    Queri[i] = list(map(int, input().split()))
for i in range(Q):
    if flag[Queri[i][0] - 1] == flag[Queri[i][1] - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, Q = map(int, input().split())
data = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    data[a].append(b)
    data[b].append(a)
dist = [-1] * (n + 1)
dist[1] = 0
q = deque()
q.append(1)
while q:
    now = q.pop()
    for to in data[now]:
        if dist[to] != -1:
            continue
        dist[to] = dist[now] + 1
        q.append(to)
for i in range(Q):
    c, d = map(int, input().split())
    if dist[c] % 2 == 0 and dist[d] % 2 == 0:
        print("Town")
    elif dist[c] % 2 == 1 and dist[d] % 2 == 1:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
# 無向グラフの隣接リスト設定
graph = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    A, B = map(int, input().split())
    graph[A].append(B)
    graph[B].append(A)

dist = [-1] * (N + 1)
dist[1] = 0
q = deque([1])
while q:
    x = q.popleft()
    for y in graph[x]:
        if dist[y] == -1:
            dist[y] = dist[x] + 1
            q.append(y)

for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[c] - dist[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
G = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)


def bfs(u):
    queue = deque([u])
    d = [None] * n
    d[u] = 0

    while queue:
        v = queue.popleft()
        for j in G[v]:
            if d[j] == None:
                d[j] = (d[v] + 1) % 2
                queue.append(j)
    return d


dis = bfs(0)

for j in range(q):
    q1, q2 = map(int, input().split())
    if dis[q1 - 1] != dis[q2 - 1]:
        print("Road")
    else:
        print("Town")
import sys


def main():
    sys.setrecursionlimit(1000000)

    N, Q = [int(x) for x in input().split()]

    # 隣接リスト形式でグラフをつくる
    # 重み付きの場合は、[行き先, weight]をそれぞれの行に持たせれば良い。
    graph = [[] for i in range(N)]
    for i in range(N - 1):
        a, b = [int(x) for x in input().split()]
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)

    queries = []
    for i in range(Q):
        c, d = [int(x) for x in input().split()]
        queries.append([c - 1, d - 1])

    distances = [-1 for x in range(N)]
    distances[0] = 0
    dfs(graph, distances, 0)

    for query in queries:
        if (distances[query[0]] - distances[query[1]]) % 2 == 0:
            print("Town")
        else:
            print("Road")


def dfs(graph, distances, current_node):
    next_nodes = graph[current_node]
    for next_node in next_nodes:
        if distances[next_node] < 0:
            distances[next_node] = distances[current_node] + 1
            dfs(graph, distances, next_node)


if __name__ == "__main__":
    main()
import sys

input = sys.stdin.readline


def main():
    def is_bipartite(graph):
        n = len(graph)
        color = [-1] * n

        for start in range(n):
            if color[start] == -1:
                color[start] = 0
                stack = [start]

                while stack:
                    parent = stack.pop()

                    for child in graph[parent]:
                        if color[child] == -1:
                            color[child] = 1 - color[parent]
                            stack.append(child)
                        elif color[parent] == color[child]:
                            return False, color

        return color

    n, q = map(int, input().split())

    g = [[] for _ in range(n)]

    for _ in range(n - 1):
        a, b = map(int, input().split())
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)

    c = is_bipartite(g)

    for _ in range(q):
        a, b = map(int, input().split())
        if c[a - 1] == c[b - 1]:
            print("Town")
        else:
            print("Road")


main()
import sys

sys.setrecursionlimit(100000)

n, q = map(int, input().split())

con = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    con[a - 1].append(b - 1)
    con[b - 1].append(a - 1)

dep = [-1 for i in range(n)]


def dfs(v, p=-1, depth=0):
    dep[v] = depth
    for i in con[v]:
        if i == p:
            continue
        else:
            dfs(i, v, depth + 1)


dfs(0)

for i in range(q):
    c, d = map(int, input().split())
    sub = dep[c - 1] - dep[d - 1]
    print("Town" if sub % 2 == 0 else "Road")
import sys

input = sys.stdin.readline
N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
p = [0]
flg = [True] * N
pnt = 0
cnt = 1
color = [-1] * N
color[0] = 0
while pnt < cnt:
    n = cnt
    for i in range(pnt, cnt):
        c = p[i]
        for j in graph[c]:
            if flg[j]:
                flg[j] = False
                p.append(j)
                color[j] = 1 - color[c]
                cnt += 1
    pnt = n
for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
road = [[] for i in range(N)]
for i in range(N - 1):
    A, B = map(int, input().split())
    road[A - 1].append(B - 1)
    road[B - 1].append(A - 1)

que = [0]
color = [-1] * N
color[0] = 0
while len(que) > 0:
    tmp = que.pop(0)
    for i in road[tmp]:
        if color[i] == -1:
            color[i] = 1 - color[tmp]
            que.append(i)

for i in range(Q):
    C, D = map(int, input().split())
    if color[C - 1] == color[D - 1]:
        print("Town")
    else:
        print("Road")
# ------------- ココカラ提出 -------------
import sys

n, q = map(int, sys.stdin.readline().split())
g = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, sys.stdin.readline().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)


def BFS(G, s):
    from collections import deque
    N = len(G)  # グラフのサイズ

    # 探索のためのデータ構造
    dist = [-1 for _ in range(N)]  # 全ての頂点を未訪問に
    que = deque()  # 空のスタック

    # 初期条件
    que.append(s)  # キューにenqueue
    dist[s] = 0

    # todoがからになるまで探索を行う
    while (que):
        v = que.popleft()  # キューからデキュー

        # vからたどれる頂点をすべて調べる
        for x in G[v]:
            # 既に探索済みの頂点は探索しない
            if dist[x] != -1:
                continue

            # 探索済みにセットして、todoに挿入
            dist[x] = dist[v] + 1
            que.append(x)

    return dist


dist = BFS(g, 0)

for i in range(q):
    c, d = map(int, sys.stdin.readline().split())
    c = c - 1
    d = d - 1

    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")

# ------------- ココマデ提出 -------------
import math
from collections import deque, Counter
from itertools import product, combinations, permutations

lkopmn, axsder = map(int, input().split())
hyujg = [list(map(int, input().split())) for _ in range(lkopmn - 1)]
anmjki = [list(map(int, input().split())) for _ in range(axsder)]
QWS = [[] for _ in range(lkopmn)]
for ptgfre in range(lkopmn - 1):
    dfre, juinb = hyujg[ptgfre][0], hyujg[ptgfre][1]
    dfre -= 1
    juinb -= 1
    QWS[dfre].append(juinb)
    QWS[juinb].append(dfre)

akjm = [-1] * lkopmn
poewq = deque()
vbnjui = 0
akjm[vbnjui] = 0
poewq.append(vbnjui)
while (poewq):
    zxcfrt = poewq.popleft()
    for satyuj in QWS[zxcfrt]:
        if akjm[satyuj] != -1:
            continue
        else:
            akjm[satyuj] = akjm[zxcfrt] + 1
            poewq.append(satyuj)
for bnjcd in anmjki:
    if (akjm[bnjcd[1] - 1] - akjm[bnjcd[0] - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    graph[a].append(b)
    graph[b].append(a)

# graph, n and root is necessary
idx = 0

root = 0


def dfs(start, graph):
    global idx
    par = [-1] * n
    depth = [-1] * n
    stack = []
    stack.append(~start)
    stack.append(start)
    depth[start] = 0
    euler = []
    left = [-1] * n
    right = [-1] * n
    while stack:
        v = stack.pop()
        if v >= 0:
            d = depth[v]
            euler.append(v)
            if left[v] == -1:
                left[v] = idx
            idx += 1
            for u in graph[v]:
                if par[v] == u:
                    continue
                par[u] = v
                depth[u] = d + 1
                stack.append(~u)
                stack.append(u)
        else:
            a = ~v
            euler.append(par[a])
            if right[a] == -1:
                right[a] = idx
            idx += 1

    return euler, left, right, depth


euler, left, right, depth = dfs(root, graph)

depths = [depth[v] for v in euler]


class SegmentTree:
    # SEG木は1-index
    # Aに関しては0-index

    def __init__(self, n, ele, func):  # Aは0-idx
        self.n = n
        self.ele = ele
        self.func = func
        self.num = 2**((self.n - 1).bit_length())
        self.SEG = [self.ele] * (2 * self.num)

    def search(self, idx):
        return self.SEG[idx + self.num]

    def initialize(self, A):
        for i in range(self.n):
            self.SEG[i + self.num] = A[i]
        for i in range(self.num - 1, 0, -1):
            self.SEG[i] = self.func(self.SEG[2 * i], self.SEG[2 * i + 1])

    # 1点更新
    def set(self, idx, val):
        idx += self.num
        self.SEG[idx] = val
        idx //= 2
        while idx:
            self.SEG[idx] = self.func(self.SEG[2 * idx], self.SEG[2 * idx + 1])
            idx //= 2

    # 区間取得
    def query(self, left, right):
        # 開区間
        resleft = self.ele
        resright = self.ele
        left += self.num
        right += self.num
        while right - left > 0:
            if left % 2 == 1:
                resleft = self.func(resleft, self.SEG[left])
                left += 1
            if right % 2 == 1:
                right -= 1
                resright = self.func(resright, self.SEG[right])
            left //= 2
            right //= 2
        return self.func(resleft, resright)


# 初期条件
def func(a, b):
    return min(a, b)


ele = 1 << 40

ST = SegmentTree(len(euler), ele, func)
ST.initialize(depths)

for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    C = depth[c]
    D = depth[d]
    if C > D:
        c, d = d, c
        C = depth[c]
        D = depth[d]
    dd = ST.query(c, d + 1)
    dist = D + C - 2 * dd
    if dist % 2:
        print("Road")
    else:
        print("Town")
import sys

sys.setrecursionlimit(10**9)

N, Q = map(int, input().split(' '))

seen = [False for _ in range(N)]

roads = [[] for _ in range(N)]
score = [0 for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split(' '))
    roads[a - 1].append(b)
    roads[b - 1].append(a)
Q_list = []
for i in range(Q):
    c, d = map(int, input().split(' '))
    Q_list.append((c, d))


def dfs(city):
    for subcity in roads[city - 1]:
        if seen[subcity - 1] != True:
            score[subcity - 1] += (1 + score[city - 1])
            seen[subcity - 1] = True
            dfs(subcity)
    return 0


seen[0] = True
dfs(1)

for i, j in Q_list:

    if abs(score[i - 1] - score[j - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())
graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)
seen = [0 for _ in range(n)]
tr = [0 for _ in range(n)]


def dfs(x, hu):
    seen[x] = 1
    tr[x] = hu
    for i in graph[x]:
        if seen[i]: continue
        dfs(i, hu + 1)


dfs(0, 0)
for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (tr[c] - tr[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

N, Q = map(int, input().split())
Tree = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    Tree[a].append(b)  # 次の頂点
    Tree[b].append(a)

d = [0] * N  # 根からの距離
parent = [-1] * N


def dfs(v, p=-1):
    # v: 子, p: 親
    parent[v] = p
    for u in Tree[v]:
        # u: 行き先
        if u == p:
            continue
        d[u] += d[v] + 1
        dfs(u, v)


dfs(0)
out = []
for i in range(Q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if abs(d[a] - d[b]) % 2 == 1:
        out.append("Road")
    else:
        out.append("Town")
print(*out, sep="\n")
# author:  Taichicchi
# created: 10.07.2021 21:13:51

import sys

sys.setrecursionlimit(10**6)

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)


def EulerTour(to, root=0):
    n = len(to)
    depth = [-1] * n
    depth[root] = 0
    first_visit_index = [-1] * n
    res = []
    stack = [(root, 0)]
    while stack:
        u, i = stack.pop()
        if i == 0:
            first_visit_index[u] = len(res)
        res.append(u)
        if i < len(to[u]):
            v = to[u][i]
            stack.append((u, i + 1))
            if depth[v] == -1:
                depth[v] = depth[u] + 1
                stack.append((v, 0))
            else:
                res.pop()
    return res, first_visit_index, depth


class SparseTableMin:
    def __init__(self, aa):
        w = len(aa)
        h = w.bit_length()
        table = [aa] + [[-1] * w for _ in range(h - 1)]
        tablei1 = table[0]
        for i in range(1, h):
            tablei = table[i]
            for j in range(w - (1 << i) + 1):
                rj = j + (1 << (i - 1))
                tablei[j] = min(tablei1[j], tablei1[rj])
            tablei1 = tablei
        self.table = table

    # [l,r)の最小値
    def min(self, l, r):
        i = (r - l).bit_length() - 1
        tablei = self.table[i]
        Lmin = tablei[l]
        Rmin = tablei[r - (1 << i)]
        if Lmin < Rmin:
            Rmin = Lmin
        return Rmin


# intにしてから1引く関数。頂点の入力に使う
def int1(x):
    return int(x) - 1


# et...オイラーツアーの頂点順
# fi...頂点がオイラーツアーで最初に現れるindex
# dep...頂点の深さ
et, fi, dep = EulerTour(G)
# オイラーツアーに対応させた深さのリストをスパーステーブルに渡す
sp = SparseTableMin([dep[u] for u in et])

for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    q = sp.min(c, d)
    dist = 1 + dep[c] + dep[d] - 2 * dep[q]
    print("Town" if dist % 2 == 1 else "Road")
def main():
    from collections import deque
    from sys import stdin
    input = stdin.readline
    N, M = map(int, input().split())
    G = [[] for _ in range(N)]
    for _ in [0] * (N - 1):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        G[x].append(y)
        G[y].append(x)

    #各頂点の偶奇判定
    Q = deque()
    toured = [-1] * N
    Q.appendleft(0)
    toured[0] = 0
    dist = 0

    while len(Q) > 0:
        tmp = Q.popleft()
        for i in G[tmp]:
            if toured[i] == -1:
                toured[i] = (toured[tmp] + 1) % 2
                Q.append(i)

    for i in range(M):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        if (toured[x] + toured[y]) % 2 == 0:
            print("Town")
        else:
            print("Road")


main()
from heapq import heappush, heappop


def dijkstra(s, n):  #（始点, ノード数）
    dist = [float('inf')] * n
    dist[s] = 0
    seen = [False] * n  #ノードの最短距離が確定済かどうか
    hq = [(0, s)]  #（距離, ノード）

    while hq:  #未確定のノードがなくなるまで
        v = heappop(hq)[1]
        seen[v] = True
        for to, cost in adj[v]:  #ノードvに隣接しているノードtoについて
            if not seen[to] and dist[v] + cost < dist[
                    to]:  #s→toの最短距離が未確定かつ、s→v→toの距離がs→toの暫定最短距離より短いならば
                dist[to] = dist[v] + cost  #s→toの距離をs→v→toの距離に上書き
                heappush(hq, (dist[to], to))

    return dist


N, Q = map(int, input().split())

adj = [[] for i in range(N)]  #重み付き隣接リスト
for i in range(N - 1):
    A, B = map(int, input().split())
    adj[A - 1].append((B - 1, 1))
    adj[B - 1].append((A - 1, 1))

dist = dijkstra(0, N)

for q in range(Q):
    c, d = map(int, input().split())
    x = (dist[c - 1] - dist[d - 1]) % 2
    if x == 1:
        print("Road")
    else:
        print("Town")
# 頂点N、重みなしの木を構成する
N, Q = map(int, input().split())
edge = [[] for i in range(N)]
for i in range(1, N):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)

# bfs:幅優先探索
from collections import deque

que = deque()
que.append(0)
dist = [-1] * N
dist[0] = 0
while que:
    now = que.pop()
    for nex in edge[now]:
        if dist[nex] == -1:
            dist[nex] = dist[now] + 1
            que.append(nex)

for i in range(Q):
    c, d = map(int, input().split())
    ans = "Town"
    if dist[c - 1] % 2 != dist[d - 1] % 2:
        ans = "Road"
    print(ans)
N, Q = map(int, input().split())
tree = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    tree[a].append(b)
    tree[b].append(a)

color = [-1] * N
color[0] = 0
stack = [(0, -1)]
while stack:
    node, par = stack.pop()
    c = 1 - color[node]
    for child in tree[node]:
        if child == par:
            continue

        color[child] = c
        stack.append((child, node))

ans = []
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if color[c] == color[d]:
        ans.append('Town')
    else:
        ans.append('Road')

print(*ans, sep='\n')
import sys
from collections import defaultdict, deque


def main(f):
    N, Q = list(map(int, f.readline().split()))
    children = [[] for _ in range(N + 1)]
    for i in range(1, N):
        a, b = list(map(int, f.readline().split()))
        children[a].append(b)
        children[b].append(a)

    parity = [None] * (N + 1)

    q = deque()
    q.append((1, -1))
    while q:
        i, parent = q.popleft()
        if parent == -1:
            parity[i] = 1
        else:
            parity[i] = -parity[parent]
        for j in children[i]:
            if j == parent:
                continue
            q.append((j, i))

    for i in range(1, Q + 1):
        c, d = list(map(int, f.readline().split()))
        if parity[c] == parity[d]:
            print('Town')
        else:
            print('Road')


main(sys.stdin)
# -*- coding: UTF-8 -*-

import sys

input = sys.stdin.readline

N, Q = map(int, input().split())
adj = [[] for n in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    adj[a].append(b)
    adj[b].append(a)


def BFS(vnum, sv, adj):
    from collections import deque
    dist = [-1] * (vnum + 1)
    dist[sv] = 0
    que = deque([sv])
    while que:
        v = que.popleft()
        for x in adj[v]:
            if not dist[x] == -1:
                continue
            dist[x] = dist[v] + 1
            que.append(x)
    return dist[1:]


first_bfs = BFS(N, 1, adj)
max_cost, edge = 0, 0
for i in range(N):
    if max_cost < first_bfs[i]:
        edge = i + 1
        max_cost = first_bfs[i]
second_bfs = BFS(N, edge, adj)
#print(second_bfs)
for q in range(Q):
    c, d = map(int, input().split())
    if abs(second_bfs[c - 1] - second_bfs[d - 1]) % 2:
        print('Road')
    else:
        print('Town')
import sys

input = sys.stdin.readline


class LCA:
    def __init__(self, G, root):
        V = len(G)
        self.log = 0
        while 2**self.log <= V:
            self.log += 1

        self.parent = [[-1] * V for _ in range(self.log)]
        self.depth = [0] * V
        stack = [root]
        while stack:
            v = stack.pop()
            p = self.parent[0][v]
            for c in G[v]:
                if c != p:
                    self.parent[0][c] = v
                    self.depth[c] = self.depth[v] + 1
                    stack.append(c)

        for k in range(self.log - 1):
            for v in range(V):
                if self.parent[k][v] >= 0:
                    self.parent[k + 1][v] = self.parent[k][self.parent[k][v]]

    def lca(self, u, v):
        if self.depth[u] > self.depth[v]:
            u, v = v, u

        # go up to the same depth
        for k in range(self.log):
            if (self.depth[v] - self.depth[u]) >> k & 1:
                v = self.parent[k][v]
        if u == v:
            return u

        for k in range(self.log)[::-1]:
            if self.parent[k][u] != self.parent[k][v]:
                u = self.parent[k][u]
                v = self.parent[k][v]
        return self.parent[0][u]

    def dist(self, u, v):
        return self.depth[u] + self.depth[v] - 2 * self.depth[self.lca(u, v)]


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)
lca = LCA(G, 0)
for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if lca.dist(c, d) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, C = map(int, input().split())
M = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    M[a].append(b)
    M[b].append(a)

from collections import deque

Q = deque()
path = [0 for i in range(N + 1)]
color = [0 for i in range(N + 1)]
Q.append(1)
while (len(Q) > 0):
    q = Q.popleft()
    color[q] = 1
    for item in M[q]:
        if (color[item] == 0):
            Q.append(item)
            path[item] = path[q] + 1

for _ in range(C):
    a, b = map(int, input().split())
    if ((path[a] + path[b]) % 2 == 0):
        print("Town")
    else:
        print("Road")
from collections import deque

d = deque()
n, q = map(int, input().split())
link = [[] for _ in range(n)]
distant = [0] * n
for _ in range(n - 1):
    a, b = map(int, input().split())
    link[a - 1].append(b - 1)
    link[b - 1].append(a - 1)
d.append((0, 0))
while d:
    now, ct = d.popleft()
    if distant[now] or (ct != 0 and now == 0):
        continue
    distant[now] = ct
    for nxt in link[now]:
        d.append((nxt, ct + 1))
for _ in range(q):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    if abs(distant[a] - distant[b]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**6)
input = sys.stdin.readline

n, q = map(int, input().split())
graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)
seen = [0 for _ in range(n)]
tr = [0 for _ in range(n)]


def dfs(x, hu):
    seen[x] = 1
    tr[x] = hu
    for i in graph[x]:
        if seen[i]: continue
        dfs(i, hu + 1)


dfs(0, 0)
for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (tr[c] - tr[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
from collections import deque


class Graph:
    def __init__(self):
        self.edges = {}

    def append_edge(self, sv, ev, weight=1):
        if sv in self.edges:
            self.edges[sv].append((ev, weight))
        else:
            self.edges[sv] = [(ev, weight)]

    def bfs(self, sv, N):
        dist = [-1] * N
        q = deque([])  # キュー
        q.append(sv)
        dist[sv] = 0
        connect_vtxs = []
        while len(q) > 0:
            p = q.popleft()  # キュー取りだし（先頭）
            connect_vtxs.append(p)
            if p not in self.edges:
                return [-1] * N, connect_vtxs
            for (ev, w) in self.edges[p]:
                if dist[ev] != -1:
                    continue
                q.append(ev)  # キュー追加
                dist[ev] = dist[p] + 1
        return dist, connect_vtxs


def main():
    N, Q = map(int, input().split())
    ab = [list(map(int, input().split())) for i in range(N - 1)]
    g = Graph()
    for i in range(len(ab)):
        a, b = ab[i]
        g.append_edge(a - 1, b - 1)
        g.append_edge(b - 1, a - 1)
    dist, connect_vtxs = g.bfs(0, N)

    for i in range(Q):
        c, d = map(int, input().split())
        if (dist[c - 1] + dist[d - 1]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
# AtCoder Beginner Contest 209
# D - Collision

N, Q = map(int, input().split())
G = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

white = set()
black = set()

todo = []
todo.append(1)
white.add(1)

col = 0  #0:white 1:black

while len(todo) > 0:
    v = todo.pop()
    if v in white:
        col = 0
    else:
        col = 1

    for i in range(len(G[v])):
        nxt = G[v][i]
        if nxt in white or nxt in black:
            continue
        if col == 0:
            black.add(nxt)
        else:
            white.add(nxt)
        todo.append(nxt)

# print(white)
# print(black)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if c in white and d in white:
        print("Town")
    if c in black and d in black:
        print("Town")
    if c in white and d in black:
        print("Road")
    if c in black and d in white:
        print("Road")
#!/usr/bin/env python3

N, Q = map(int, input().split())
M = []
for i in range(N):
    M.append([])
for i in range(N - 1):
    a, b = map(int, input().split())
    M[a - 1].append(b - 1)
    M[b - 1].append(a - 1)
D = [0] * N
next = [0]
added = set()
added.add(0)
L = 0
while len(next) > 0:
    nnext = []
    L += 1
    while len(next) > 0:
        p = next.pop()
        for pc in M[p]:
            if pc not in added:
                nnext.append(pc)
                added.add(pc)
        D[p] = L
    next = nnext

for i in range(Q):
    s, t = map(int, input().split())
    dd = abs(D[s - 1] - D[t - 1])
    print("Road" if dd % 2 == 1 else "Town")
from collections import deque

INF = 10**9

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

q = deque()
dist = [-1] * N
dist[0] = 0
q.append(0)
while q:
    p = q.popleft()
    for i in G[p]:
        if dist[i] == -1:
            dist[i] = dist[p] + 1
            q.append(i)
for i in range(Q):
    a, b = map(int, input().split())
    if dist[a - 1] % 2 == dist[b - 1] % 2:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a] += b,
    G[b] += a,
from collections import deque

queue = deque([[0, 0]])
dists1 = [0 for i in range(N)]
seen = [False] * N
seen[0] = True
while queue:
    dist, node = queue.popleft()
    dist += 1
    for v in G[node]:
        if seen[v]: continue
        seen[v] = True
        dists1[v] = dist
        queue.append([dist, v])
for i in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print(["Road", "Town"][(dists1[d] + dists1[c]) % 2 == 0])
N, Q = map(int, input().split())
L = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    L[a].append(b)
    L[b].append(a)

dp = [-1 for _ in range(N)]
dp[0] == 0
que = [0]

for i in que:
    for j in L[i]:
        if dp[j] == -1:
            que.append(j)
            dp[j] = abs(dp[i] - 1)

for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    tmp = dp[c] + dp[d]
    print('Road' if tmp % 2 else 'Town')
N, Q = map(int, input().split())
E = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

color = [None for _ in range(N)]
color[0] = 0
stack = [0]
while stack:
    v = stack.pop()
    nc = int(not color[v])
    for nv in E[v]:
        if color[nv] == None:
            color[nv] = nc
            stack.append(nv)

for _ in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
"""
n = int(input())
a = list(map(int, input().split()))
xy = list(map(int, input().split()))
xy = [map(int, input().split()) for _ in range(n)]
x, y = [list(i) for i in zip(*xy)]
i, j = map(int, input().split())
"""
from collections import deque

n, q = map(int, input().split())
road = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)


def bfs(graph):
    dist = [-1] * n
    que = deque([0])
    dist[0] = 0
    while que:
        v = que.popleft()
        # v = que.pop()
        d = dist[v]
        for w in graph[v]:
            if dist[w] > -1:
                continue
            dist[w] = d + 1
            que.append(w)

    return dist


color = bfs(road)

for i in range(q):
    s_taka, s_aoki = map(int, input().split())

    if color[s_aoki - 1] % 2 == color[s_taka - 1] % 2:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = list(map(int, input().split()))
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = list(map(int, input().split()))
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)
l = [0] * n


def bfs(u):
    queue = deque([u])
    d = [None] * n  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


l = bfs(0)
for i in range(q):
    c, d = list(map(int, input().split()))
    c -= 1
    d -= 1
    k = l[c] - l[d]
    if k % 2 == 1:
        print("Road")
    else:
        print("Town")
from collections import deque

N, Q = map(int, input().split())
#G=: _番目の町に隣接している町リスト
G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = deque()
color = [-1] * N
color[0] = 0
que.append(0)

while que:
    now = que.pop()
    for i in G[now]:
        if color[i] == -1:
            color[i] = color[now] + 1
            que.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    ans = "Town"
    if color[c - 1] % 2 != color[d - 1] % 2:
        ans = "Road"
    print(ans)
from collections import deque

n, q = map(int, input().split())
tree = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    tree[a - 1].append(b - 1)
    tree[b - 1].append(a - 1)
color = [-1 for _ in range(n)]
queue = [(0, 0)]
queue = deque(queue)
while queue:
    v, c = queue.popleft()
    color[v] = c
    for nex in tree[v]:
        if color[nex] == -1:
            queue.append((nex, (c + 1) % 2))
# print(color)
for _ in range(q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
T = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    T[a - 1].append(b - 1)
    T[b - 1].append(a - 1)

D = [-1] * N
que = deque([0])
D[0] = 0
while que:
    s = que.pop()

    for to in T[s]:
        if D[to] != -1:
            continue
        D[to] = D[s] + 1
        que.append(to)

for _ in range(Q):
    c, d = map(int, input().split())
    if abs(D[c - 1] - D[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
G = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
color = [False] * n
dist = [-1] * n
#町xからの距離の偶奇を記録する
dist[0] = 0
d = deque()
d.append(0)
while d:
    v = d.popleft()
    for i in G[v]:
        if dist[i] != -1:
            continue
        dist[i] = (dist[v] + 1) % 2
        d.append(i)
for i in range(q):
    c, d = map(int, input().split())
    if dist[c - 1] == dist[d - 1]:
        print('Town')
    else:
        print('Road')
import sys
import numpy as np
#from numba import njit, b1, i1, i4, i8, f8 #, jitclass,
sys.setrecursionlimit(10**9)

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines


def input():
    return sys.stdin.readline().strip()


def from_read(dtype=np.int64):
    return np.fromstring(read().decode(), dtype=dtype, sep=' ')


def from_readline(dtype=np.int64):
    return np.fromstring(readline().decode(), dtype=dtype, sep=' ')


#@njit("(i8,i8,i8[:,:],)", cache=True)
def main(N, Q, A, B, C, D):
    repn = [[] for _ in range(N)]
    for a, b in zip(A, B):
        repn[a].append(b)
        repn[b].append(a)

    depth = [0] * N

    def dfs(v, p=-1):
        for nv in repn[v]:
            if nv == p: continue
            depth[nv] = depth[v] + 1
            dfs(nv, v)

    dfs(0)
    for c, d in zip(C, D):
        dist = (depth[c] + depth[d]) % 2
        print('Town' if dist % 2 == 0 else 'Road')


if __name__ == '__main__':
    N, Q = from_readline()
    inp = from_read()
    A, B = inp[:(N - 1) * 2].reshape(N - 1, 2).T
    C, D = inp[(N - 1) * 2:].reshape(Q, 2).T
    main(N, Q, A - 1, B - 1, C - 1, D - 1)
from collections import deque

n, q = map(int, input().split())
graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)


def bfs(s):
    cost = [float("inf")] * n
    cost[s] = 0
    q = deque([s])
    while q:
        x = q.popleft()
        for y in graph[x]:
            if cost[y] > cost[x] + 1:
                cost[y] = cost[x] + 1
                q.append(y)
    return cost


cost = bfs(0)

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    ans = abs(cost[c] - cost[d])
    if ans % 2:
        print("Road")
    else:
        print("Town")
N, Q = map(int, input().split())
T = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    T[a].append(b)
    T[b].append(a)

depth = [0] * N
visited = [0] * N
stack = [0]
while stack:
    n = stack.pop()
    if visited[n]:
        continue
    visited[n] = 1

    for to in T[n]:
        if visited[to]:
            continue
        depth[to] = depth[n] + 1
        stack.append(to)

for i in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    diff = abs(depth[c] - depth[d])
    print('Road' if diff % 2 == 1 else 'Town')
from collections import deque

N, Q = map(int, input().split())

ranklst = [-1] * N
ranklst[0] = 0
edges = []

for i in range(N):
    edges.append([])

for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)

d = deque()
d.append(0)
while d:
    now = d.popleft()
    nowrank = ranklst[now]
    for i in edges[now]:
        if ranklst[i] == -1:
            ranklst[i] = nowrank + 1
            d.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if ranklst[c] % 2 == ranklst[d] % 2:
        ans = 'Town'
    else:
        ans = 'Road'

    print(ans)
from collections import defaultdict


class Graph:
    def __init__(self, N):
        self.V = N
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u - 1].append(v - 1)
        self.graph[v - 1].append(u - 1)

    def findAllDistance(self):
        dist = [-1] * (self.V)
        dist[0] = 0
        queue = [0]
        while queue:
            node = queue.pop(0)
            for n in self.graph[node]:
                if dist[n] == -1:
                    dist[n] = 1 - dist[node]
                    queue.append(n)
        return dist


if __name__ == '__main__':
    N, Q = map(int, input().split(" "))
    g = Graph(N)
    out = []
    for i in range(N - 1):
        g.add_edge(*map(int, input().split(" ")))
    ret = g.findAllDistance()
    for i in range(Q):
        a, b = map(int, input().split(" "))
        if ret[a - 1] == ret[b - 1]: out.append("Town")
        else: out.append("Road")
    print(*out, sep="\n")
mod = 10**9 + 7
import collections

n, q = map(int, input().split())

edges = [[] for _ in range(n)]
queue = collections.deque([0])
visited = [True for _ in range(n)]
dist = [0 for i in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    edges[a].append(b)
    edges[b].append(a)

while queue:
    now = queue.popleft()
    visited[now] = False
    for ed in edges[now]:
        if visited[ed]:
            queue.append(ed)
            dist[ed] = (dist[now] + 1) % 2

for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if dist[c] == dist[d]:
        print('Town')
    else:
        print('Road')
from collections import deque


class Reunion:
    def __init__(self, N):
        self.depthmap = [-1 for i in range(N + 1)]
        self.graph = [[] for _ in range(N + 1)]

    def adding(self, a, b):
        self.graph[b].append(a)
        self.graph[a].append(b)

    def valid(self):
        queue = deque()
        queue.append((1, 0))
        while len(queue) > 0:
            (node, depth) = queue.pop()
            self.depthmap[node] = depth
            for child in self.graph[node]:
                if self.depthmap[child] >= 0:
                    continue
                queue.append((child, depth + 1))

    def judge(self, a, b):
        if (self.depthmap[a] + self.depthmap[b]) % 2 == 0:
            print('Town')
        else:
            print('Road')


N, q = map(int, input().split())
RU = Reunion(N)
for _ in range(N - 1):
    a, b = map(int, input().split())
    RU.adding(a, b)
RU.valid()
for _ in range(q):
    a, b = map(int, input().split())
    RU.judge(a, b)
# region template
import sys
import typing
from typing import Callable, Dict, List, Set, Tuple
from collections import deque

sys.setrecursionlimit(10**6)
Vec = List[int]
VecVec = List[Vec]
sinput: Callable[..., str] = sys.stdin.readline
MOD: int = 1000000007
INF: float = float("Inf")
IINF: int = sys.maxsize
# endregion


class BreadthFirstSearch:
    def __init__(self, graph: VecVec) -> None:
        self.graph = graph
        self.n = len(graph)

    def search(self, start: int) -> typing.List[typing.Union[float, int]]:
        que = deque([start])
        self.cost = [INF] * self.n
        self.cost[start] = 0

        while que:
            dep = que.popleft()
            for arr in self.graph[dep]:
                if self.cost[arr] == INF:
                    self.cost[arr] = self.cost[dep] + 1
                    que.append(arr)

        return self.cost


def main() -> None:
    n, q = map(int, sinput().split())
    adj: VecVec = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = map(int, sinput().split())
        adj[a - 1].append(b - 1)
        adj[b - 1].append(a - 1)

    bfs = BreadthFirstSearch(adj)
    cost = bfs.search(0)

    for _ in range(q):
        c, d = map(int, sinput().split())
        if (cost[c - 1] + cost[d - 1]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
# coding : utf-8


def main():
    N, num_Q = map(int, input().split())

    # グラフの初期化
    city = {}
    for i in range(1, N + 1):
        city[str(i)] = []

    # グラフの作成
    for i in range(N - 1):
        a, b = map(int, input().split())
        city[str(a)].append(b)
        city[str(b)].append(a)

    # 1の街を根ノードとして、深さを記録していく
    city_depth = {}
    Q = [1]  # Qに根ノードだけ加えておき、子ノードをどんどん加えていく。
    depth = 0
    while (len(Q) >= 1):  # Qが空になるまで繰り返す。
        new_Q = []
        for q in Q:
            # Qに入っているノードの深さを記録
            city_depth[str(q)] = depth
            # Qに入っているノードの子ノードをQに加える。ただし深さが既知は除く。
            for q_child in city[str(q)]:
                if not str(q_child) in city_depth:
                    new_Q.append(q_child)
                else:
                    pass
            # qをQから取り除く
        Q = new_Q
        depth += 1

    # 次にクエリに答えていく
    for i in range(num_Q):
        c, d = map(int, input().split())
        if abs(city_depth[str(c)] - city_depth[str(d)]) % 2 == 0:
            print("Town")
        else:
            print("Road")


main()
#まずはリストに道の状況を格納する
#その後、クエリを順に試す。

from collections import deque

N, M = map(int, input().split(' '))
list_1 = []
for i in range(N):
    list_1.append([])

# 双方向である必要はない。

for i in range(N - 1):
    a, b = map(int, input().split(' '))
    a -= 1
    b -= 1
    list_1[a].append(b)
    list_1[b].append(a)

# 深さを記録と1を根とする根付きツリーを作成する。
depth_tree = [-1 for i in range(N)]

Q = deque()
Q.append([0, 0])

while len(Q) > 0:
    node, depth = Q.pop()
    depth_tree[node] = depth
    for c in list_1[node]:
        if depth_tree[c] >= 0:
            continue
        Q.append([c, depth + 1])

for i in range(M):
    c, d = map(int, input().split(' '))
    c -= 1
    d -= 1
    if (depth_tree[c] + depth_tree[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
#                _          _                                        _
#   ___ ___   __| | ___  __| |_ __ ___  __ _ _ __ ___   ___ _ __  __| | __ _
#  / __/ _ \ / _` |/ _ \/ _` | '__/ _ \/ _` | '_ ` _ \ / _ \ '__|/ _` |/ _` |
# | (_| (_) | (_| |  __/ (_| | | |  __/ (_| | | | | | |  __/ |  | (_| | (_| |
#  \___\___/ \__,_|\___|\__,_|_|  \___|\__,_|_| |_| |_|\___|_|___\__,_|\__, |
#                                                           |_____|    |___/
from sys import *
'''sys.stdin = open('input.txt', 'r')  
sys.stdout = open('output.txt', 'w') '''
from collections import defaultdict as dd
from collections import deque
from math import *
from bisect import *


#sys.setrecursionlimit(10 ** 8)
def sinp():
    return input()


def inp():
    return int(sinp())


def minp():
    return map(int, sinp().split())


def linp():
    return list(minp())


def strl():
    return list(sinp())


def pr(x):
    print(x)


def EQUAL(a, b):
    x, y = dis[a], dis[b]
    z = abs(x - y)
    if z == 0:
        return a, b
    if x > y:
        while z:
            p = int(log(z, 2))
            a = LCA[a][p]
            z -= (1 << p)
    else:
        while z:
            p = int(log(z, 2))
            b = LCA[b][p]
            z -= (1 << p)
    return a, b


def LcA(a, b):
    for i in range(maxN, -1, -1):
        if LCA[a][i] != -1 and LCA[a][i] != LCA[b][i]:
            a = LCA[a][i]
            b = LCA[b][i]
    return LCA[a][0]


mod = int(1e9 + 7)
n, Q = minp()
d = dd(list)
for i in range(n - 1):
    a, b = minp()
    d[a].append(b)
    d[b].append(a)
dis = [0 for i in range(n + 1)]
q = deque()
q.append(1)
v = [0 for i in range(n + 1)]
maxN = int(log(n, 2))
LCA = [[-1 for i in range(maxN + 1)] for j in range(n + 1)]
while q:
    a = q.popleft()
    v[a] = 1
    for i in d[a]:
        if not v[i]:
            v[i] = 1
            LCA[i][0] = a
            q.append(i)
            dis[i] = dis[a] + 1
for j in range(1, maxN + 1):
    for i in range(1, n + 1):
        if LCA[i][j - 1] != -1:
            p = LCA[i][j - 1]
            LCA[i][j] = LCA[p][j - 1]
ans = []
Q = [linp() for i in range(Q)]
for i in Q:
    a, b = i
    x, y = EQUAL(a, b)
    if x == y:
        vp = dis[a] + dis[b] - (2 * dis[y])
        if vp % 2:
            ans.append('Road')
        else:
            ans.append('Town')
        continue
    z = LcA(x, y)
    vp = dis[a] + dis[b] - (2 * dis[z])
    if vp % 2:
        ans.append('Road')
    else:
        ans.append('Town')
pr('\n'.join(ans))
from collections import deque


def fukatan(g, n):
    dist = [-1] * (n + 1)
    dist[0], dist[1] = 0, 0
    q = deque([1])
    while q:
        v = q.popleft()
        for u in g[v]:
            if dist[u] != -1:
                continue
            dist[u] = dist[v] + 1
            q.append(u)
    return dist


N, Q = map(int, input().split())
g = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)
dist = fukatan(g, N)
for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
#import numpy as np
#from scipy.sparse.csgraph import shortest_path
from collections import deque

# BFS(幅優先探索)
N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
#print(G)  # 上三角行列になる

visited = [False] * N  # 頂点iが訪問済か否か(0-index)
d = deque()
d.append(0)  # 頂点1を探索済に
visited[0] = True

inf = 2 << 30
D = [inf] * N  # 頂点1からの距離を保存する配列
D[0] = 0  # 頂点1から頂点1までの距離は0

while d:  # dが空ではない間続ける
    # BFSなのでスタックを利用
    v = d.popleft()  # 先頭の要素を削除しそれをvに保存
    for i in G[v]:
        if visited[i] == False:  # 未訪問の頂点である場合
            visited[i] = True  # 訪問済にする
            D[i] = D[v] + 1  # 頂点v->iへ移動可能なので+1
            d.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    if D[c - 1] % 2 == D[d - 1] % 2:
        print('Town')
    else:
        print('Road')
''' この方法はTLE
L = np.array(l)
for i in range(Q):
  c, d = map(int, input().split())
  S = shortest_path(L)
  #print(S)
  if S[c - 1][d - 1] % 2:
    print('Road')
  else:
    print('Town')
'''

# 重みが全て1だからBFS, 重みがある時はダイクストラ
# D after contest
from collections import deque, defaultdict


def main():
    N, Q = map(int, input().split())

    edges = defaultdict(list)
    for _ in range(N - 1):
        a, b = map(int, input().split())
        edges[a].append(b)
        edges[b].append(a)

    def bfs(start):
        q = deque()
        q.append(start)
        # 訪問済み、または、これから訪れる頂点部分集合
        C = set()
        C.add(start)
        distances[start] = 0

        while q:
            v = q.popleft()
            for each in edges[v]:
                if each not in C:
                    C.add(each)
                    q.append(each)
                    distances[each] = distances[v] + 1

    # 最短経路リスト
    distances = [-1] * (N + 1)
    # スタート地点からの最短距離をもれなく更新
    bfs(1)

    while Q:
        Q -= 1
        c, d = map(int, input().split())
        print('Town' if abs(distances[c] - distances[d]) % 2 == 0 else 'Road')


if __name__ == '__main__':
    main()
N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    edge[a].append(b)
    edge[b].append(a)

q = [0]
dep = [0] * N
fixed = [False] * N
while q:
    now = q.pop()
    fixed[now] = True
    for e in edge[now]:
        if fixed[e]:
            continue
        dep[e] = dep[now] + 1
        q.append(e)

ans = []
for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (dep[c] + dep[d]) & 1:
        ans.append("Road")
    else:
        ans.append("Town")
print(*ans, sep="\n")
N, Q = map(int, input().split())
E = {n: [] for n in range(1, 1 + N)}
for i in range(1, N):
    a, b = map(int, input().split())
    E[a] += [b]
    E[b] += [a]

D = {1: 0}
P = [1]
while P:
    p = P.pop(0)  # BFS
    for d in E[p]:
        if d in D: continue
        D[d] = D[p] + 1
        P += [d]

for _ in range(Q):
    c, d = map(int, input().split())
    print(D[c] % 2 == D[d] % 2 and 'Town' or 'Road')
N, Q = list(map(int, input().split()))

a = list()
b = list()
c = list()
d = list()
connection = list()
for i in range(N + 1):
    connection.append([])

for i in range(N - 1):
    a_, b_ = list(map(int, input().split()))
    a.append(a_)
    b.append(b_)
    connection[a_].append(b_)
    connection[b_].append(a_)

for i in range(Q):
    c_, d_ = list(map(int, input().split()))
    c.append(c_)
    d.append(d_)

R = R = [100001] * (N + 1)


def distance():
    r = 0
    next_town = [1]
    next_town_memo = []

    while r < N:
        next_town_memo = []
        for town in next_town:
            if R[town] > r:
                R[town] = r
                for i in connection[town]:
                    next_town_memo.append(i)
        next_town = next_town_memo
        r = r + 1

    return R


distance()

for i in range(Q):
    e = R[c[i]] - R[d[i]]
    if e % 2 == 0:
        print('Town')
    else:
        print('Road')
#!/usr/bin python3
# -*- coding: utf-8 -*-


class Tree():
    def __init__(self, n):
        self.n = n
        self.edges = [[] for _ in range(n)]
        self.root = None  # 根
        self.etnodes = []  # i番目の頂点番号
        self.etedges = []  # i番目の辺の番号
        self.etL = [0] * n  # in
        self.etR = [0] * n  # out
        self.depthbynodes = [0] * n
        self.etdepth = []  # i番目の辺の

    def add_edge(self, u, v):
        self.edges[u].append(v)
        self.edges[v].append(u)

    def set_euler_tour(self, root):
        self.root = root  # 根を設定して
        pa = [0] * self.n
        stack = [~root, root]
        ct = -1
        de = -1
        while stack:
            v = stack.pop()
            ct += 1
            self.etedges.append(v)
            if v >= 0:
                de += 1
                self.etnodes.append(v)
                self.etdepth.append(de)
                self.etL[v] = ct
                self.depthbynodes[v] = de
                p = pa[v]
                for w in self.edges[v][::-1]:
                    if w == p: continue
                    pa[w] = v
                    stack.append(~w)
                    stack.append(w)
            else:
                de -= 1
                if de < 0:
                    self.etdepth.append(self.n)
                else:
                    self.etdepth.append(de)
                self.etnodes.append(pa[~v])
                self.etR[~v] = ct


#############################################
class SegmentTree:
    # 初期化処理
    # f     : SegmentTreeにのせるモノイド
    # idele : fに対する単位元
    def __init__(self, size, f=lambda x, y: min(x, y), idele=float('inf')):
        self.size = 2**(size - 1).bit_length()  # 簡単のため要素数nを2冪にする
        self.idele = idele  # 単位元
        self.f = f  # モノイド
        self.dat = [(self.idele, -1)] * (self.size * 2)  # 要素を単位元で初期化

## one point

    def update(self, i, x):
        i += self.size  # 1番下の層におけるインデックス
        self.dat[i] = (x, i)
        while i > 0:  # 層をのぼりながら値を更新 indexが0になれば終了
            i >>= 1  # 1つ上の層のインデックス(完全二分木における親)
            # 下の層2つの演算結果の代入(完全二分木における子同士の演算)
            self.dat[i] = self.f(self.dat[i * 2], self.dat[i * 2 + 1])

## range

    def query(self, l, r):
        l += self.size  # 1番下の層におけるインデックス
        r += self.size  # 1番下の層におけるインデックス
        lres, rres = (self.idele, -1), (self.idele, -1)  # 左側の答えと右側の答えを初期化
        while l < r:  # lとrが重なるまで上記の判定を用いて演算を実行
            # 左が子同士の右側(lが奇数)(lの末桁=1)ならば、dat[l]を加算
            if l & 1:
                lres = self.f(lres, self.dat[l])
                l += 1
            # 右が子同士の右側(rが奇数)(rの末桁=1)ならば、dat[r-1]を加算
            if r & 1:
                r -= 1
                rres = self.f(self.dat[r],
                              rres)  # モノイドでは可換律は保証されていないので演算の方向に注意
            l >>= 1
            r >>= 1
        res = self.f(lres, rres)
        return res

    def init(self, a):
        for i, x in enumerate(a):
            # 1番下の層におけるインデックス
            self.dat[i + self.size] = (x, i)
        for i in range(self.size - 1, -1, -1):
            self.dat[i] = self.f(self.dat[i * 2], self.dat[i * 2 + 1])


############################################
n, q = map(int, input().split())
T = Tree(n)
for _ in range(n - 1):
    a, b = map(int, input().split())
    T.add_edge(a - 1, b - 1)

T.set_euler_tour(0)
depth = T.etdepth

SGT = SegmentTree(len(depth))
SGT.init(depth)

for i in range(q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    l = T.etL[a]
    r = T.etL[b]
    if l > r:
        l, r = r, l
    r += 1
    x = SGT.query(l, r)[1]
    lca = T.etnodes[x]
    d = T.depthbynodes[a] + T.depthbynodes[b] - 2 * T.depthbynodes[lca]
    if d % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque
import sys

sys.setrecursionlimit(10**7)

n, q = map(int, input().split())
G = [set() for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].add(b - 1)
    G[b - 1].add(a - 1)


def dfs0(i, par=-1):
    for to in G[i]:
        if to == par: continue
        if i in G[to]:
            G[to].remove(i)
        dfs0(to, i)


# dfs0(i, -1)

# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)
N = n
# Euler Tour の構築
S = []
F = [0] * N
depth = [0] * N


def dfs(v, d, par=-1):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in G[v]:
        if w == par: continue
        dfs(w, d + 1, v)
        S.append(v)


dfs(0, 0)

# 存在しない範囲は深さが他よりも大きくなるようにする
INF = (N, None)

# LCAを計算するクエリの前計算
M = 2 * N
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


# LCAの計算 (外から呼び出す関数)
def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    p = query(c, d)
    dist = depth[c] + depth[d] - 2 * depth[c]
    if dist % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque


def solve(N, Q, ab, c, d):
    deplist = [-1] * (N + 1)
    deplist[1] = 0

    de = deque()
    de.append((1, 0))

    dpnode = 1
    dpt = 1
    while de:
        (v, dep) = de.popleft()
        for i in ab[v]:
            if deplist[i] != -1:
                continue
            deplist[i] = dep + 1
            de.append((i, dep + 1))

    for que in range(Q):
        if (deplist[c[que]] + deplist[d[que]]) % 2 == 0:
            print("Town")
        else:
            print("Road")


def main():
    N, Q = map(int, input().split())
    ab = [[] for _ in range(N + 1)]
    c = [None for _ in range(Q)]
    d = [None for _ in range(Q)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        ab[a].append(b)
        ab[b].append(a)
    for i in range(Q):
        c[i], d[i] = map(int, input().split())
    solve(N, Q, ab, c, d)


if __name__ == '__main__':
    main()
import sys
import collections

sys.setrecursionlimit(10**8)

input = sys.stdin.readline


def main():
    N, Q = [int(x) for x in input().split()]
    AB = [[int(x) for x in input().split()] for _ in range(N - 1)]
    CD = [[int(x) for x in input().split()] for _ in range(Q)]

    edge = [[] for j in range(N)]

    for a, b in AB:
        edge[a - 1].append(b - 1)
        edge[b - 1].append(a - 1)

    ans = [-1] * N
    ans[0] = 0

    q = collections.deque()
    q.append([0, 0])
    visited = set()
    visited.add(0)

    while q:
        c, cc = q.pop()
        next_color = (cc + 1) % 2

        for next in edge[c]:
            if next not in visited:
                visited.add(next)
                ans[next] = next_color
                q.append([next, next_color])

    for c, d in CD:
        c -= 1
        d -= 1
        if ans[c] == ans[d]:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
import queue

n, q = map(int, input().split())
G = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * n
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print('Town')
    else:
        print('Road')
from collections import deque


def main():
    N, nQ = list(map(int, input().split()))
    E = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = list(map(int, input().split()))
        a -= 1
        b -= 1
        E[a].append(b)
        E[b].append(a)

    def bfs(s, E):
        Q = deque()
        Q.append(s)
        visited = set()
        visited.add(s)
        dist = {}
        dist[s] = 0
        while len(Q) > 0:
            i = Q.popleft()
            for j in E[i]:
                if j in visited:
                    continue
                dist[j] = dist[i] + 1
                visited.add(j)
                Q.append(j)
        return dist

    s = 0
    dist = bfs(s, E)

    for _ in range(nQ):
        c, d = list(map(int, input().split()))
        c -= 1
        d -= 1
        if (dist[c] - dist[d]) % 2 == 0:
            ans = "Town"
        else:
            ans = "Road"
        print(ans)


main()
(n, q), *t = [map(int, t.split()) for t in open(0)]
d = [1] * n + [0]
s = [n]
e = [[] for _ in d]
for a, b in t[:-q]:
    e[a] += b,
    e[b] += a,
for v in s:
    for w in e[v]:
        s += [w] * d[w]
        d[w] = ~d[v]
for a, b in t[-q:]:
    print('RTooawdn'[d[a] == d[b]::2])
import sys

# sys.setrecursionlimit(10**6)
input = sys.stdin.buffer.readline
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep="\n")


def II():
    return int(input())


def LI():
    return list(map(int, input().split()))


def LLI(rows_number):
    return [LI() for _ in range(rows_number)]


def LI1():
    return list(map(int1, input().split()))


def LLI1(rows_number):
    return [LI1() for _ in range(rows_number)]


def BI():
    return input().rstrip()


def SI():
    return input().rstrip().decode()


def LSI():
    return SI().split()


def LLSI(rows_number):
    return [SI() for _ in range(rows_number)]


INF = 10**16
MOD = 10**9 + 7
# MOD = 998244353

from heapq import heappop, heappush
import sys

input = sys.stdin.readline

N, Q = LI()
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = LI()
    edge[a - 1].append((1, b - 1))
    edge[b - 1].append((1, a - 1))

INF = 10**15
dist = [INF] * N
dist[0] = 0
q = [(0, 0)]
while q:
    now, from_idx = heappop(q)
    if now > dist[from_idx]: continue
    for d, to_idx in edge[from_idx]:
        t = now + d
        if t >= dist[to_idx]: continue
        dist[to_idx] = t
        heappush(q, (dist[to_idx], to_idx))

for _ in range(Q):
    c, d = LI()
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())

I = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    I[a].append(b)
    I[b].append(a)


def derive_parity(I):
    s = 0
    task = [s]
    parity = [-1] * N
    parity[s] = 0
    vis = [False] * N
    vis[s] = True
    while task:
        p = task.pop()
        for q in I[p]:
            if vis[q]: continue
            vis[q] = True
            parity[q] = 1 ^ parity[p]
            task.append(q)
    return parity


parity = derive_parity(I)

for _ in range(Q):
    p, q = map(int, input().split())
    p -= 1
    q -= 1
    if parity[p] == parity[q]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(100000000)


def search(a, v, depth, d):
    for i in v[a]:
        v[i].remove(a)
        depth[i] = d + 1
        search(i, v, depth, d + 1)


N, M = map(int, input().split())
v = [[] for i in range(N)]
depth = [0] * N
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    v[a].append(b)
    v[b].append(a)
search(0, v, depth, 0)
for i in range(M):
    a, b = map(int, input().split())
    if (depth[a - 1] - depth[b - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]

graph = [[] for _ in range(N + 1)]
for a, b in AB:
    graph[a].append(b)
    graph[b].append(a)
#print(graph)

INF = 10**18
dist = [INF] * (N + 1)

dist[1] = 0
stack = [1]

while stack:
    i = stack.pop()
    #print(i, dist)
    for j in graph[i]:
        if dist[j] == INF:
            dist[j] = dist[i] + 1
            stack.append(j)


def road_or_town(i, j):
    if (dist[i] + dist[j]) % 2:
        return "Road"
    else:
        return "Town"


for c, d in CD:
    print(road_or_town(c, d))
from heapq import heappush, heappop


class Graph():
    def __init__(self, n, INF=10**18):
        self.n = n
        self.INF = INF
        self.edges = [[] for _ in range(n)]

    def add_edge(self, u, v, w, directed=True):
        self.edges[u].append([v, w])
        if not directed:
            self.edges[v].append([u, w])

    def dijkstra(self, s):
        dist = [self.INF] * self.n
        hq = [(0, s)]
        dist[s] = 0

        while hq:
            cur = heappop(hq)[1]
            for nxt, cost in self.edges[cur]:
                if dist[nxt] > dist[cur] + cost:
                    dist[nxt] = dist[cur] + cost
                    heappush(hq, (dist[nxt], nxt))
        return dist

    def bfs(self, s):
        dist = [self.INF] * self.n
        que = [s]
        dist[s] = 0

        for cur in que:
            for nxt, w in self.edges[cur]:
                assert w == 1
                if dist[nxt] != self.INF:
                    continue
                dist[nxt] = dist[cur] + 1
                que.append(nxt)
        return dist


N, Q = map(int, input().split())
AB = [[*map(int, input().split())] for _ in range(N - 1)]
CD = [[*map(int, input().split())] for _ in range(Q)]
G = Graph(N)

for a, b in AB:
    G.add_edge(a - 1, b - 1, 1, directed=False)

dist = G.bfs(0)

for c, d in CD:
    c, d = c - 1, d - 1
    print('Road' if (dist[c] + dist[d]) & 1 else 'Town')
import sys

sys.setrecursionlimit(10**8)

n, q = map(int, input().split())
p = {}
for i in range(n - 1):
    a, b = map(int, input().split())
    if a in p:
        p[a].add(b)
    else:
        p[a] = set([b])
    if b in p:
        p[b].add(a)
    else:
        p[b] = set([a])
town = [0] * (n + 1)


def aaa(k):
    for l in p[k]:
        if town[l] == 0:
            town[l] = 3 - town[k]
            aaa(l)


town[1] = 1
aaa(1)
for j in range(q):
    a, b = map(int, input().split())
    if town[a] == town[b]:
        print("Town")
    else:
        print("Road")
N, Q = list(map(int, input().split()))
AB = [[None, None] for i in range(N - 1)]
Node = [[] for i in range(N)]


def WFS():
    St = [0] * N
    Q = {0}
    Q1 = set()
    i = 1
    while Q:
        Q1.clear()
        Q1 |= Q
        for q in Q:
            if St[q] == 0:
                if i % 2 == 1:
                    St[q] = 1
                else:
                    St[q] = 2

                Q1.remove(q)
                Q1 |= set(Node[q])
            else:
                Q1.remove(q)
        i += 1
        Q.clear()
        Q |= Q1
    return St


for i in range(N - 1):
    AB[i] = list(map(int, input().split()))
    Node[AB[i][0] - 1].append(AB[i][1] - 1)
    Node[AB[i][1] - 1].append(AB[i][0] - 1)

D = WFS()
ans = [0] * Q

for i in range(Q):
    c, d = list(map(int, input().split()))
    if D[c - 1] == D[d - 1]:
        ans[i] = 0
    else:
        ans[i] = 1

for i in range(Q):
    if ans[i] % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())

tree = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    tree[a].append(b)
    tree[b].append(a)
#rint(tree)

depth = [-1] * (N + 1)
queue = {1}
d = 0
while queue:
    new_queue = set()
    for q in queue:
        depth[q] = d
        for v in tree[q]:
            if depth[v] == -1:
                new_queue.add(v)
    queue = new_queue
    d += 1

#print(depth)
for _ in range(Q):
    c, d = map(int, input().split())
    length = depth[d] + depth[c]
    if length % 2 == 0:
        print("Town")
    else:
        print("Road")
# -*- coding: utf-8 -*-
from collections import deque

N, Q = map(int, input().split())

D = dict()
for i in range(N):
    D[i] = []

for i in range(N - 1):
    A, B = map(int, input().split())
    D[A - 1].append(B - 1)
    D[B - 1].append(A - 1)

X = [0] * N

q = deque([0])
X[0] = 1

while (q):
    i = q.popleft()
    for j in D[i]:
        if X[j] == 0:
            X[j] = X[i] * -1
            q.append(j)

for i in range(Q):
    C, D = map(int, input().split())
    if X[C - 1] * X[D - 1] < 0:
        print("Road")
    else:
        print("Town")
import sys, math, heapq, bisect
from collections import defaultdict, deque

input = sys.stdin.readline

mod = (10**9) + 7

n, q = map(int, input().split())
G = defaultdict(list)
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)

vis = [-1] * (n + 1)
vis[1] = 0

Q = deque([1])

while (len(Q) != 0):
    a = Q.popleft()
    for b in G[a]:
        if (vis[b] == -1):
            vis[b] = vis[a] + 1
            Q.append(b)

for i in range(q):
    a, b = map(int, input().split())
    val = abs(vis[a] - vis[b])
    if (val % 2 != 0):
        print("Road")
    else:
        print("Town")
from queue import Queue

n, q = map(int, input().split())

g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    g[a].append(b)
    g[b].append(a)

que = Queue()
col = [-1] * n
col[0] = 0
que.put(0)

while not que.empty():
    t = que.get()
    for i in g[t]:
        if col[i] == -1:
            col[i] = 1 - col[t]
            que.put(i)

for i in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if col[c] == col[d]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**9)
N, Q = map(int, input().split())
#
next_town = [[] for _ in range(N)]
for k in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    next_town[a].append(b)
    next_town[b].append(a)

odd_or_even = [-1 for _ in range(N)]

town_lis = [0]
bit = 1
while town_lis:
    next_ = []
    for town in town_lis:
        odd_or_even[town] = bit
        for n_town in next_town[town]:
            if odd_or_even[n_town] == -1:
                next_.append(n_town)
    town_lis = next_
    bit ^= 1

#print(odd_or_even)
#
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if odd_or_even[c] == odd_or_even[d]:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
edges = [set() for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    edges[a].add(b)
    edges[b].add(a)

nums = [None] * (N + 1)
nums[1] = 0
queue = deque()
queue.append((1, 0))
done = {1}
while queue:
    cur, num = queue.popleft()
    nums[cur] = num
    for n in edges[cur]:
        if n in done:
            continue
        queue.append((n, 1 - num))
        done.add(n)

for _ in range(Q):
    c, d = map(int, input().split())
    print('Town' if nums[c] == nums[d] else 'Road')
'''
[問題]
https://atcoder.jp/contests/abc209/tasks/abc209_d

[解法]
https://youtu.be/FEDp2Kzc7jk?t=3245
　二分木の問題。
　c,d間の距離の偶奇が答えになる。
　最小共通祖先（Lowest Common Ancestor）を求めなければならない気がするが、偶奇の判定はc,dの深さだけで問題ない。
　depを深さと考えて、最短距離は
　dep[c] + dep[d] - dep[lca] * 2
　lcaはx2なので、lcaが奇数でも偶数でも結果偶数になる。よってlcaは偶奇に影響しない。

[参考]
二分木における最小共通祖先（Lowest Common Ancestor）の探索
https://qiita.com/maebaru/items/0fec7d2987c4a1efaa8a

https://atcoder.jp/contests/abc209/submissions/24350316
'''

import sys

sys.setrecursionlimit(10**6)  # 再帰上限の引き上げ
input = sys.stdin.readline

INF = 10**18 + 7

N, Q = map(int, input().split())

route = [[] for _ in range(N)]
dep = [0] * N

for _ in range(N - 1):
    A, B = map(int, input().split())
    A -= 1
    B -= 1
    route[A].append(B)
    route[B].append(A)


# Depth First Searchで深さを計算する
def dfs(x, last=-1):
    for to in route[x]:
        if to == last:
            continue
        dep[to] = dep[x] + 1
        dfs(to, x)


dfs(0)

# クエリ処理
for _ in range(Q):
    C, D = map(int, input().split())

    if (dep[C - 1] + dep[D - 1]) % 2 == 1:
        # 経路が奇数なら道
        print("Road")
    else:
        print("Town")
from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * n  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


n, q = map(int, input().split())
el = [list(map(int, input().split())) for i in range(n - 1)]
g = [[] for _ in range(n)]
for i in range(n - 1):
    g[el[i][0] - 1].append(el[i][1] - 1)
    g[el[i][1] - 1].append(el[i][0] - 1)

d = bfs(0)
d = [i % 2 for i in d]

dic = {}
for i in range(q):
    a, b = map(int, input().split())
    if d[a - 1] == d[b - 1]:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
from collections import deque

sys.setrecursionlimit(10**6)


class Tree:
    def __init__(self, N):
        self.V = N
        self.edge = [[] for _ in range(N)]
        self.order = []

    def add_edges(self, ind=1, bi=True):
        for i in range(self.V - 1):
            a, b = map(int, input().split())
            a -= ind
            b -= ind
            self.edge[a].append(b)
            if bi: self.edge[b].append(a)

    def add_edge(self, a, b, bi=True):
        self.edge[a].append(b)
        if bi: self.edge[b].append(a)

    def dp(self, start):
        stack = deque([start])
        self.parent = [self.V] * self.V
        self.parent[start] = -1
        self.order.append(start)
        #記録したい値の配列を定義
        self.dp = [0] * self.V
        while stack:
            v = stack.pop()
            for u in self.edge[v]:
                if u == self.parent[v]: continue
                self.parent[u] = v
                self.dp[u] = self.dp[v] ^ 1
                stack.append(u)

    def bfs(self, start):
        d = deque([start])
        self.min_cost = [-1] * self.V
        self.min_cost[start] = 0
        while len(d) > 0:
            v = d.popleft()
            for w in self.edge[v]:
                if self.min_cost[w] == -1:
                    self.min_cost[w] = self.min_cost[v] + 1
                    d.append(w)
        return


N, Q = map(int, input().split())
G = Tree(N)
G.add_edges(ind=1, bi=True)
G.dp(0)
ans = ['Road'] * Q
for i in range(Q):
    c, d = map(int, input().split())
    if G.dp[c - 1] == G.dp[d - 1]: ans[i] = 'Town'
print(*ans, sep='\n')
n, q = map(int, input().split())
tree = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    tree[a].append(b)
    tree[b].append(a)
from collections import deque

dq = deque()
dq.append(0)
dist = [-1] * n
dist[0] = 1
while dq:
    now = dq.popleft()
    for next in tree[now]:
        if dist[next] != -1: continue
        dist[next] = dist[now] + 1
        dq.append(next)
for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    c2 = dist[c] % 2
    d2 = dist[d] % 2
    if c2 ^ d2: print('Road')
    else: print('Town')
from collections import deque
import sys

input = sys.stdin.readline


class Node(object):
    def __init__(self, index, nears):
        self.index = index
        self.nears = nears
        self.visit = -1


def main():
    n, q = map(int, input().split())
    g = [[] for _ in range(n)]

    for _ in range(n - 1):
        a, b = map(int, input().split())
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)

    nodes = []
    for i in range(n):
        nodes.append(Node(i, g[i]))

    queue = deque()
    queue.append(nodes[0])
    nodes[0].visit = 0

    while queue:
        node = queue.popleft()
        nears = node.nears
        x = node.visit + 1
        for near in nears:
            if nodes[near].visit == -1:
                nodes[near].visit = x
                queue.append(nodes[near])

    for _ in range(q):
        c, d = map(int, input().split())

        if nodes[c - 1].visit % 2 == nodes[d - 1].visit % 2:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
#スタック、キューを使う
from collections import deque

N, Query = map(int, input().split())

G = []
for _ in range(N):
    G.append([])

#距離の配列
dist = []
for _ in range(N):
    dist.append(-1)

#BFSで使うキュー
Q = deque()

#入力からグラフを生成
for i in range(N - 1):
    #各頂点の情報を読み込み
    ms, me = map(int, input().split())
    #0オリジン
    ms -= 1
    me -= 1
    #無向グラフ
    G[ms].append(me)
    G[me].append(ms)


def bfs(s):
    #始点sをキューに追加
    Q.append(s)
    dist[s] = 0

    while len(Q) > 0:
        i = Q.popleft()  #キューの頂点をiに取り出す
        #uに未訪問の隣接ノードがある限りキューに入れる
        for j in G[i]:
            if dist[j] == -1:
                dist[j] = dist[i] + 1
                Q.append(j)


# クエリを読み込むがその都度BFSしてたら間に合わない
# 予めある地点からの距離を求めておき各クエリにおいて、その距離の偶奇を調べることによって
# 道で出会うか、街で出会うか判定できる。
# 両方の偶奇が一緒 → 街で出会う。両方の偶奇が一致しない → 道で出会う。
# 偶奇が一緒かどうかの判定は足して偶数であれば 一致 合わなければ 不一致 である。

#距離の配列
dist = []
for _ in range(N):
    dist.append(-1)

#ある地点からの距離を計算しておく。
bfs(0)

for i in range(Query):
    s, t = map(int, input().split())
    s -= 1
    t -= 1

    if (dist[s] + dist[t]) % 2 == 0:
        print('Town')
    else:
        print('Road')
#!/usr/bin/env python3
# import math
# import numpy as np
from collections import deque

# from collections import defaultdict
# import bisect
# import itertools
# from collections import Counter
# from numba import njit
# from functools import lru_cache # memo @lru_cache
# from heapq import heapify, heappop, heappush, heappushpop
# from decimal import Decimal # memo DON'T USE PYPY
# import sys
# sys.setrecursionlimit(10**8)


# Generated by 2.4.0 https://github.com/kyuridenamida/atcoder-tools
# (tips: You use the default template now. You can remove this line by
# using your custom template)
def main():
    N, Q = map(int, input().split())
    T = [None] * N
    adj = [[] for _ in range(N)]
    for _ in range(N - 1):
        S = input().split()
        a = int(S[0]) - 1
        b = int(S[1]) - 1
        adj[a].append(b)
        adj[b].append(a)

    T[0] = True
    F = deque()
    F.append(0)
    while len(F) > 0:
        f = F.popleft()
        for r in adj[f]:
            if T[r] is not None:
                continue
            T[r] = not T[f]
            F.append(r)

    for _ in range(Q):
        S = input().split()
        a = int(S[0]) - 1
        b = int(S[1]) - 1
        if not T[a] ^ T[b]:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
from collections import deque

N, Q = map(int, input().split())
h = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    #m[a][b],m[b][a] = 1,1
    h[a].append(b)
    h[b].append(a)


def main():
    q = deque()
    q.append(0)
    tree = [-1] * N
    tree[0] = 0
    while len(q) != 0:
        x = q.popleft()
        for y in h[x]:
            if tree[y] == -1:
                tree[y] = tree[x] + 1
                q.append(y)
    #print(tree)
    for i in range(Q):
        s, g = map(int, input().split())
        s, g = s - 1, g - 1
        if (tree[s] + tree[g]) % 2 != 1:
            print("Town")
        else:
            print("Road")
    pass


if __name__ == "__main__":
    main()
import numpy as np
import queue


def stdin_input():
    N, Q = map(int, input().split())
    a, b = [], []
    for i in range(N - 1):
        line = input()
        a.append(int(line.split()[0]) - 1)
        b.append(int(line.split()[1]) - 1)
    c, d = [], []
    for i in range(Q):
        line = input()
        c.append(int(line.split()[0]) - 1)
        d.append(int(line.split()[1]) - 1)
    return N, Q, a, b, c, d


def fixed_input():
    input_text = '''9 9
8 9
2 3
4 8
4 5
5 6
3 4
1 9
3 7
7 9
2 5
2 6
4 6
2 4
5 8
7 8
3 6
5 6
'''
    lines = input_text.splitlines()
    N, Q = map(int, lines[0].split())
    a, b = [], []
    for i in range(N - 1):
        a.append(int(lines[1 + i].split()[0]) - 1)
        b.append(int(lines[1 + i].split()[1]) - 1)
    c, d = [], []
    for i in range(Q):
        c.append(int(lines[N + i].split()[0]) - 1)
        d.append(int(lines[N + i].split()[1]) - 1)
    return N, Q, a, b, c, d


def get_distance_from_0(N, a, b):
    #paths = sorted([(min(a[i], b[i]), max(a[i], b[i])) for i in range(N-1)])
    # destination = [[] for i in range(N)]
    # for i in range(N-1):
    #   destination[a[i]].append(b[i])
    #   destination[b[i]].append(a[i])
    # dist = np.zeros(N, dtype=int)
    # for path in paths:
    #   dist[path[1]] = dist[path[0]] + 1
    # return dist

    dist = [-1 for i in range(N)]
    dist[0] = 0
    destination = [[] for i in range(N)]
    for i in range(N - 1):
        destination[a[i]].append(b[i])
        destination[b[i]].append(a[i])
    q = queue.Queue()
    q.put(0)
    while not q.empty():
        i = q.get()
        for j in destination[i]:
            if dist[j] >= 0:
                continue
            q.put(j)
            dist[j] = dist[i] + 1
    return dist


def is_meet_town(in_obj):
    N, Q, a, b, c, d = in_obj
    d0 = get_distance_from_0(N, a, b)
    results = []
    for i in range(Q):
        results.append((d0[c[i]] + d0[d[i]]) % 2 == 0)
    return results


def show_result(out_obj):
    for result in out_obj:
        print("Town" if result else "Road")


#in_obj = fixed_input()
in_obj = stdin_input()
out_obj = is_meet_town(in_obj)
show_result(out_obj)
import bisect, collections, copy, heapq, itertools, math, sys

input = sys.stdin.readline


def main():
    N, Q = map(int, input().split())
    graph = [collections.deque() for _ in range(N + 1)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)
    dist = [-1] * (N + 1)
    dist[1] = 0
    stack = collections.deque([(1, 0)])
    while stack:
        r, c = stack.popleft()
        for to in graph[r]:
            if dist[to] == -1:
                dist[to] = c + 1
                stack.append((to, c + 1))
    ans = []
    for _ in range(Q):
        c, d = map(int, input().split())
        if abs(dist[c] - dist[d]) % 2 == 0:
            ans.append("Town")
        else:
            ans.append("Road")
    print(*ans, sep="\n")


if __name__ == "__main__":
    main()
n, q = map(int, input().split())

E, D = [[] for _ in range(-~n)], [0] * -~n
for i in range(n - 1):
    a, b = map(int, input().split())
    E[a] += [b]
    E[b] += [a]

L, p = [1], -1
while L:
    v = L.pop()
    d = D[v]
    for n in E[v]:
        if D[n] == 0:
            D[n] = -~d
            L += [n]

for i in range(q):
    c, d = map(int, input().split())
    print('Road' if abs(D[c] - D[d]) % 2 else 'Town')
import sys

sys.setrecursionlimit(10**9)
N, Q = list(map(int, input().split()))
color = [-1] * N
graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = list(map(int, input().split()))
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)
passed = [False] * N


def dfs(t, c):
    color[t] = c
    for nx in graph[t]:
        if passed[nx]: continue
        passed[nx] = True
        dfs(nx, abs(c - 1))


dfs(0, 0)
for _ in range(Q):
    c, d = list(map(int, input().split()))
    c -= 1
    d -= 1
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
G = {i: [] for i in range(1, N + 1)}
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)
dist = [-1 for _ in range(N + 1)]
dist[1] = 0
que = deque([1])
while que:
    x = que.popleft()
    for y in G[x]:
        if dist[y] < 0:
            dist[y] = dist[x] + 1
            que.append(y)
for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python3


# Generated by 2.5.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    INF = 10**16

    def bfs(edges: "List[to]", start_node: int) -> list:
        q = set()
        dist = [INF] * len(edges)
        q.add(start_node)
        dist[start_node] = 0
        while len(q) != 0:
            now = q.pop()
            for next in edges[now]:
                if dist[next] != INF:
                    continue
                q.add(next)
                dist[next] = (dist[now] + 1) % 2
        return dist

    N, Q = map(int, input().split())
    nodes = [[] for _ in range(N)]
    for i in range(N - 1):
        a, b = map(int, input().split())
        nodes[a - 1].append(b - 1)
        nodes[b - 1].append(a - 1)
    f = bfs(nodes, 0)
    # print(f)

    for i in range(Q):
        c, d = map(int, input().split())
        print("Town" if f[c - 1] == f[d - 1] else "Road")


if __name__ == '__main__':
    main()
import sys
from collections import deque


class RootTree(object):
    def __init__(self, v, e, root=0):
        """[summary]

        Args:
            v (int): num of vartex
            e (list): list of edges(1-indexed)
        """
        self.v = v
        self.root = root
        self.parent = [root] * v
        self.depth = [0] * v
        self.children = [set([]) for _ in range(v)]
        self.edge = e

        tempchildren = [[] for _ in range(v)]
        for a, b in e:
            a, b = a - 1, b - 1
            tempchildren[a].append(b)
            tempchildren[b].append(a)

        que = deque([])
        que.append(root)
        frag = [False] * v
        frag[root] = True
        while len(que) > 0:
            q = que.popleft()
            for p in tempchildren[q]:
                if frag[p]: continue
                frag[p] = True
                self.children[q].add(p)
                self.parent[p] = q
                self.depth[p] = self.depth[q] + 1
                que.append(p)

    def bfs(self, v_i):
        que = deque([v_i])
        while (len(que) > 0):
            q = que.popleft()
            yield q
            for c in self.children[q]:
                que.append(c)

    def dfs(self, v_i):
        que = [v_i]
        while (len(que) > 0):
            q = que.pop()
            yield q
            for c in self.children[q]:
                que.append(c)

    def diameter(self):
        _, idx = max([(d, i) for (i, d) in enumerate(self.depth)])
        t = RootTree(self.v, self.edge, root=idx)
        return max(t.depth)

    def eulartour(self):
        que = [self.root]
        frag = [False] * self.v
        while (len(que) > 0):
            q = que.pop()
            yield q
            if frag[q]: continue
            for c in self.children[q]:
                que.append(q)
                que.append(c)
            frag[q] = True

    def buildLCA(self):
        return RootTree.LCA(self)

    class LCA(object):
        class SparseTable(object):
            def __init__(self, lst, operator, idm):
                n = len(lst)
                max_k = n.bit_length() + 1
                table = [[idm] * max_k for _ in range(n)]
                for i in range(n):
                    table[i][0] = lst[i]
                for k in range(1, max_k):
                    for i in range(n + 1 - (1 << k)):
                        table[i][k] = operator(
                            table[i][k - 1], table[i + (1 << (k - 1))][k - 1])

                logtable = [0] * (n + 1)
                for i in range(2, n + 1):
                    logtable[i] = logtable[i >> 1] + 1
                self.table = table
                self.logtable = logtable
                self.operator = operator

            def query(self, l, r):
                """operated value of [l, r)

                Args:
                    l (int): left closed interval
                    r (int): right open interval
                """
                k = self.logtable[r - l]
                return self.operator(self.table[l][k],
                                     self.table[r - (1 << k)][k])

        def __init__(self, roottree):
            eulartour = []
            self.firstappear = [-1] * roottree.v
            for i, v in enumerate(roottree.eulartour()):
                if self.firstappear[v] == -1:
                    self.firstappear[v] = i
                eulartour.append((roottree.depth[v], v))

            self.sparse = RootTree.LCA.SparseTable(eulartour, min,
                                                   (10**18, -1))

        def query(self, v1, v2):
            l, r = self.firstappear[v1], self.firstappear[v2]
            if l > r:
                l, r = r, l
            _, v = self.sparse.query(l, r + 1)
            return v


def readint():
    return int(sys.stdin.readline())


def readints():
    return tuple(map(int, sys.stdin.readline().split()))


def readintslist(n):
    return [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]


def main():
    n, q = readints()
    edges = []
    for _ in range(n - 1):
        a, b = readints()
        edges.append((a, b))

    tree = RootTree(n, edges)
    lca = tree.buildLCA()

    #print(tree.depth)

    for c, d in readintslist(q):
        c, d = c - 1, d - 1
        common = lca.query(c, d)
        dist = tree.depth[c] + tree.depth[d] - 2 * tree.depth[common]

        if dist % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
import sys

sys.setrecursionlimit(1000000)
N, Q = map(int, input().split())
E = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    E[a - 1] += [b - 1]
    E[b - 1] += [a - 1]

seen = [False for _ in range(N)]
dist = [0] * N


def dfs(v, d):  # vは頂点
    seen[v] = True
    dist[v] = d
    for next_v in E[v]:
        if seen[next_v]:
            continue
        dfs(next_v, d + 1)


dfs(N - 1, 0)
for i in range(Q):
    x, y = map(int, input().split())
    if (dist[x - 1] + dist[y - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for i in range(N - 1)]
CD = [list(map(int, input().split())) for i in range(Q)]
c = [[] for i in range(N)]
for x, y in AB:
    c[x - 1].append(y - 1)
    c[y - 1].append(x - 1)
dep = [0] * N
from collections import deque

q = deque([(0, 0)])
v = [0] * N
v[0] = 1
A = [-1] * N
while q:
    p, d = q.popleft()
    dep[p] = d
    for n in c[p]:
        if v[n] == 0:
            v[n] = 1
            A[n] = p
            q.append((n, d + 1))
bit = N.bit_length()
d = [[0] * N for i in range(bit)]
d[0] = A
for i in range(bit - 1):
    for j in range(N):
        d[i + 1][j] = d[i][j] if d[i][j] == -1 else d[i][d[i][j]]


def db(N, K, s):
    for i in range(bit):
        if K & 1:
            s = d[i][s]
        K >>= 1
    return s


def lca(a, b):
    dd = dep[a] - dep[b]
    if dd > 0:
        a = db(N, dd, a)
    elif dd < 0:
        b = db(N, -dd, b)
    if a == b:
        return a
    for i in range(bit - 1, -1, -1):
        if d[i][a] != d[i][b]:
            a, b = d[i][a], d[i][b]
    return d[0][a]


for C, D in CD:
    x = dep[C - 1] + dep[D - 1] + dep[lca(C - 1, D - 1)] * 2
    print('Road' if x % 2 else 'Town')
from collections import deque

n, q = map(int, input().split())
edge = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)
que = deque([0])
d = [-1] * n
d[0] = 0
while que:
    x = que.popleft()
    for nx in edge[x]:
        if d[nx] != -1:
            continue
        d[nx] = d[x] + 1
        que.append(nx)
for _ in range(q):
    ci, di = map(int, input().split())
    ci -= 1
    di -= 1
    if (d[ci] + d[di]) % 2:
        print("Road")
    else:
        print("Town")
n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)
d = [None] * n
d[0] = 0
queue = [0]
l = 0
while l < len(queue):
    u = queue[l]
    l += 1
    for v in G[u]:
        if d[v] is None:
            d[v] = d[u] + 1
            queue.append(v)

for _ in range(q):
    ci, di = map(int, input().split())
    ci -= 1
    di -= 1
    if (d[ci] + d[di]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
import math
import collections

sys.setrecursionlimit(500 * 500)


def main():

    input = sys.stdin.readline

    N, Q = map(int, input().split())

    global town_road
    global town

    town_road = [[] for _ in range(N)]
    town = [-1] * N

    for _ in range(N - 1):
        a, b = map(int, input().split())
        a = a - 1
        b = b - 1

        town_road[a].append(b)
        town_road[b].append(a)

    query = []
    for _ in range(Q):
        c, d = map(int, input().split())

        c = c - 1
        d = d - 1

        query.append([c, d])

    dfs(0, 0)

    for c, d in query:
        if town[c] == town[d]:
            print("Town")
        else:
            print("Road")


def dfs(check_town, before_town):
    if town[check_town] == -1:
        if before_town == 0:
            town[check_town] = 1
        else:
            town[check_town] = 0
        for check in town_road[check_town]:
            dfs(check, town[check_town])
    return


if __name__ == "__main__":
    main()
from collections import deque


def main():
    N, Q = map(int, input().split())
    graph = [[] for _ in range(N + 1)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)
    depth_vec = [-1] * (N + 1)
    queue = deque()
    queue.append((1, 0))
    while len(queue) > 0:
        node, depth = queue.pop()
        depth_vec[node] = depth
        for child in graph[node]:
            if depth_vec[child] >= 0:
                continue
            queue.append((child, depth + 1))
    for query in range(Q):
        c, d = map(int, input().split())
        print('RTooawdn'[(depth_vec[c] + depth_vec[d]) % 2 == 0::2])


if __name__ == '__main__':
    main()
import queue

n, q = list(map(int, input().split()))
d = {}
e = [-1] * n
for _ in range(n - 1):
    a, b = list(map(int, input().split()))
    if a - 1 not in d: d[a - 1] = []
    if b - 1 not in d: d[b - 1] = []
    d[a - 1].append(b - 1)
    d[b - 1].append(a - 1)
e[0] = 1
que = queue.Queue()
que.put(0)
while not que.empty():
    t = que.get()
    for i in d[t]:
        if e[i] == -1:
            que.put(i)
            e[i] = 1 - e[t]
for j in range(q):
    a, b = list(map(int, input().split()))
    print("Road" if e[a - 1] - e[b - 1] else "Town")
n, q = map(int, input().split())
dist = [0 for i in range(n + 1)]

adj = [[] for i in range(n + 1)]
par = [0 for i in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())

    adj[a].append(b)
    adj[b].append(a)


def bfs(root):
    q = [root]
    vis = [False for _ in range(n + 1)]
    vis[1] = True

    while q:
        now = q.pop(0)

        for nxt in adj[now]:
            if vis[nxt] == False:
                q.append(nxt)
                dist[nxt] = dist[now] + 1
                vis[now] = True


def find_p(node):
    k = dist[node]
    for can in range(adj[node]):
        if dist[can] < k:
            par[node] = can


bfs(1)

for _ in range(q):
    a, b = map(int, input().split())

    if (dist[a] + dist[b]) % 2 == 0:
        print('Town')
    else:
        print('Road')
def main():
    n, qqqq = map(int, input().split())
    ab = [list(map(int, input().split())) for _ in [0] * (n - 1)]
    g = [[] for _ in [0] * n]
    [g[a - 1].append(b - 1) for a, b in ab]
    [g[b - 1].append(a - 1) for a, b in ab]
    root = 0  # 根
    d = [-1] * n  # 根からの距離
    d[root] = 0
    q = [root]
    cnt = 0
    while q:  # BFS
        cnt += 1
        qq = []
        while q:
            i = q.pop()
            for j in g[i]:
                if d[j] == -1:
                    d[j] = cnt
                    qq.append(j)
        q = qq

    for i in range(qqqq):
        c, dd = map(int, input().split())
        if (d[c - 1] + d[dd - 1]) % 2:
            print("Road")
        else:
            print("Town")


main()
n, q = map(int, input().split())
import sys

sys.setrecursionlimit(10**9)

E = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

visited = set()
ranks = [0] * n


def dfs(G, node, rank):
    ranks[node] = rank
    visited.add(node)
    for child in G[node]:
        if child in visited:
            continue
        dfs(G, child, rank + 1)


dfs(E, 0, 0)

for i in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (ranks[c] - ranks[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(10**8)

n, q = [int(i) for i in input().split()]
tree = [[] for i in range(n)]
for i in range(n - 1):
    a, b = [int(i) for i in input().split()]
    tree[a - 1].append(b - 1)
    tree[b - 1].append(a - 1)
cd = [[int(i) - 1 for i in input().split()] for j in range(q)]

depth = [-1] * n


def dp(node: int, pare: int):
    depth[node] = depth[pare] + 1
    for child in tree[node]:
        if child == pare:
            continue
        dp(child, node)


dp(0, -1)

for qu in cd:
    if (depth[qu[0]] + depth[qu[1]]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from sys import stdin

read = stdin.readline
(N, Q) = map(int, read().split())
AB = [list(map(lambda i: int(i) - 1, read().split())) for j in range(N - 1)]
CD = [list(map(lambda i: int(i) - 1, read().split())) for j in range(Q)]

nbr = [set() for i in range(N)]
for (a, b) in AB:
    nbr[a].add(b), nbr[b].add(a)

dtc = [None for i in range(N)]
q = [(0, 0)]
used = set()
while len(q) != 0:
    (i, d) = q.pop()
    used.add(i)
    dtc[i] = d
    for j in nbr[i]:
        if j in used:
            continue
        q.append((j, d + 1))

for (c, d) in CD:
    print("Town" if dtc[c] % 2 == dtc[d] % 2 else "Road")
#!/usr/bin/env python3

from functools import lru_cache
from heapq import heappush, heappop, heappushpop
from itertools import permutations
from operator import itemgetter
from collections import deque
from collections import Counter
from itertools import accumulate
from collections import defaultdict
import sys
import math
from bisect import bisect_right as br
from bisect import bisect_left as bl

sys.setrecursionlimit(2147483647)
mod = 10**9 + 7
inf = float('inf')


def I():
    return int(sys.stdin.readline())


def LI():
    return list(map(int, sys.stdin.readline().split()))


n, q = LI()
edges = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = LI()
    edges[a - 1].append(b - 1)
    edges[b - 1].append(a - 1)

D = [0] * n
checked = [False] * n
que = deque([(0, -1)])
checked[0] = True
while que:
    v, p = que.popleft()
    for u in edges[v]:
        if checked[u]:
            continue
        if u == p:
            continue
        checked[u] = True
        D[u] = D[v] + 1
        que.append((u, v))

for _ in range(q):
    c, d = LI()
    if (D[c - 1] + D[d - 1]) % 2:
        print("Road")
    else:
        print("Town")
import sys
from collections import deque

input = lambda: sys.stdin.readline().rstrip()


def main():
    N, Q = map(int, input().split())
    M = N - 1
    G = [[] for _ in range(N)]
    for _ in range(M):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        G[a].append([b, 1])
        G[b].append([a, 1])

    seen = [-1] * N
    que = deque()
    que.append(0)
    while que:
        k = que.popleft()
        for next in G[k]:
            j = next[0]
            if seen[j] != -1:
                continue
            seen[j] = 1 - seen[k]
            que.append(j)

    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        if seen[c] == seen[d]:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
#!/usr/bin/env python3
import sys
from collections import deque

# import io
# _INPUT = """\
# """
# sys.stdin = io.StringIO(_INPUT)


def input():
    return sys.stdin.readline()[:-1]


def bfs(graph, startV):
    dist = [-1] * len(graph)
    dist[startV] = 0

    que = deque()
    que.append(startV)

    while que:
        curV = que.popleft()

        neighborVs = graph[curV]
        for v in neighborVs:
            # 探索済の場合
            if dist[v] != -1:
                dist[v] = min(dist[v], dist[curV] + 1)
                continue

            que.append(v)
            dist[v] = dist[curV] + 1

    return dist


def main():
    N, Q = map(int, input().split())
    a, b = [0] * N, [0] * N
    graph = [[] for _ in range(N + 1)]
    for i in range(1, N):
        _a, _b = map(int, input().split())
        a[i], b[i] = _a, _b
        graph[_a].append(_b)
        graph[_b].append(_a)

    dist = bfs(graph, 1)
    colors = [0] * (N + 1)
    for i in range(len(dist)):
        if dist[i] % 2 == 0:
            colors[i] = 1

    for i in range(Q):
        c, d = map(int, input().split())

        # 距離が偶数ならRoad、奇数ならTown
        isMeetingInTown = colors[c] == colors[d]
        print('Town' if isMeetingInTown else 'Road')


if __name__ == "__main__":
    main()
#幅優先探索
n, Q = map(int, input().split())
m = n - 1
e = [[] for _ in range(n)]
for _ in range(m):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    e[a].append(b)
    e[b].append(a)

que = [0]
visited = [0] * n
dist = [0] * n
visited[0] = 1
while len(que):
    q = que.pop(0)
    d = dist[q] + 1
    for i in e[q]:
        if visited[i] == 0:
            visited[i] = 1
            dist[i] = d
            que.append(i)

for i in range(Q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if abs(dist[a] - dist[b]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(1000000)

n, q = map(int, input().split())

edges = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    edges[a].append(b)
    edges[b].append(a)

CNT = [-1] * n
CNT[0] = 0


def dfs(x):
    for y in edges[x]:
        if CNT[y] >= 0:
            continue
        CNT[y] = CNT[x] + 1
        dfs(y)


dfs(0)
# print(CNT)

for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if (CNT[c] - CNT[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
import math
from collections import deque

sys.setrecursionlimit(10**6)
INF = float('inf')


def solve():
    N, Q = map(int, input().split())

    graph = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        graph[a].append(b)
        graph[b].append(a)

    visited = [False] * N
    is_red = [False] * N

    deq = deque()
    deq.append(0)
    while len(deq) != 0:
        cur = deq.popleft()
        visited[cur] = True
        for next in graph[cur]:
            if visited[next]:
                continue
            deq.append(next)
            if not is_red[cur]:
                is_red[next] = True
    ans = []
    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        if is_red[c] == is_red[d]:
            ans.append('Town')
        else:
            ans.append('Road')

    print(*ans, sep='\n')


if __name__ == '__main__':
    solve()
import queue

N, Q = map(int, input().split())
X = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    X[a - 1].append(b - 1)
    X[b - 1].append(a - 1)

color = [-1] * N
color[0] = 0
q = queue.Queue()
q.put(0)
while not q.empty():
    t = q.get()
    for i in X[t]:
        if color[i] == -1:
            color[i] = color[t] ^ 1
            q.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(10**7)

n, q = map(int, input().split())

g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1] += [b - 1]
    g[b - 1] += [a - 1]

visited = [-1] * n
visited[0] = 0


def dfs(v, p, res):
    if p != -1:
        visited[v] = visited[p] ^ 1
    for nv in g[v]:
        if nv == p:
            continue
        dfs(nv, v, visited)
    return


dfs(0, -1, visited)

for _ in range(q):
    c, d = map(int, input().split())
    if visited[c - 1] == visited[d - 1]:
        print('Town')
    else:
        print('Road')
# -*- coding: utf-8 -*-
import bisect
import heapq
import math
import random
from collections import Counter, defaultdict, deque
from decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal
from fractions import Fraction
from functools import lru_cache, reduce
from itertools import combinations, combinations_with_replacement, product, permutations, accumulate
from operator import add, mul, sub, itemgetter, attrgetter

import sys

sys.setrecursionlimit(10**6)
# readline = sys.stdin.buffer.readline
readline = sys.stdin.readline

INF = 1 << 60


def read_int():
    return int(readline())


def read_int_n():
    return list(map(int, readline().split()))


def read_float():
    return float(readline())


def read_float_n():
    return list(map(float, readline().split()))


def read_str():
    return readline().strip()


def read_str_n():
    return readline().strip().split()


def ep(*args):
    import sys
    print(*args, file=sys.stderr)


def epp(o):
    import sys
    import pprint
    pprint.pprint(o, stream=sys.stderr)


def gen_2d_array(n, m, fill=0):
    if callable(fill):
        return [[fill() for _ in range(m)] for _ in range(n)]
    else:
        return [[fill] * m for _ in range(n)]


def gen_3d_array(n, m, k, fill=0):
    if callable(fill):
        return [[[fill() for _ in range(k)] for _ in range(m)]
                for _ in range(n)]
    else:
        return [[[fill] * k for _ in range(m)] for _ in range(n)]


def mt(f):
    import time
    import sys

    def wrap(*args, **kwargs):
        s = time.perf_counter()
        ret = f(*args, **kwargs)
        e = time.perf_counter()

        print(e - s, 'sec', file=sys.stderr)
        return ret

    return wrap


class Doubling():
    def __init__(self, a0, M):
        """
        a0 is an array-like object which contains ai, 0 <= i < N.
        ai is the next value of i.
        """
        N = len(a0)
        self.N = N
        self.nt = [[None] * N for i in range(M.bit_length() + 1)]
        for i, a in enumerate(a0):
            self.nt[0][i] = a

        for i in range(1, len(self.nt)):
            for j in range(N):
                if self.nt[i - 1][j] is None:
                    self.nt[i][j] = None
                else:
                    self.nt[i][j] = self.nt[i - 1][self.nt[i - 1][j]]

    def apply(self, i, n):
        """
        Apply n times from i
        """
        j = i
        for k in range(n.bit_length()):
            m = 1 << k
            if m & n:
                j = self.nt[k][j]
            if j is None:
                break
        return j


class LCA():
    def __init__(self, g, root):
        s = [root]
        self.N = len(g)
        self.p = [None] * self.N
        self.d = [INF] * self.N

        self.p[root] = root
        self.d[root] = 0
        while s:
            u = s.pop()
            for v in g[u]:
                if self.d[v] is INF:
                    self.p[v] = u
                    self.d[v] = self.d[u] + 1
                    s.append(v)

        self.doubling = Doubling(self.p, self.N)

    def query(self, u, v):
        if self.d[u] > self.d[v]:
            u, v = v, u
        o = self.d[v] - self.d[u]
        v = self.doubling.apply(v, o)

        if u == v:
            return u

        for k in range(len(self.doubling.nt) - 1, -1, -1):
            if self.doubling.nt[k][u] != self.doubling.nt[k][v]:
                u = self.doubling.nt[k][u]
                v = self.doubling.nt[k][v]
        return self.doubling.nt[0][u]

    def dist(self, u, v):
        return self.d[u] + self.d[v] - 2 * self.d[self.query(u, v)]


@mt
def slv(N, Q, AB, CD):
    g = defaultdict(list)
    for a, b in AB:
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)

    lca = LCA(g, 0)

    ans = []
    for c, d in CD:
        l = lca.dist(c - 1, d - 1)
        if l % 2 == 0:
            ans.append('Town')
        else:
            ans.append('Road')
    return ans


def main():
    N, Q = read_int_n()
    AB = [read_int_n() for _ in range(N - 1)]
    CD = [read_int_n() for _ in range(Q)]
    print(*slv(N, Q, AB, CD), sep='\n')


if __name__ == '__main__':
    main()
from collections import defaultdict, deque

n, q = map(int, input().split())
paths = defaultdict(lambda: [])

depth = [-1] * n
que = deque()
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    paths[a].append(b)
    paths[b].append(a)

depth[0] = 1
que.append(0)
while que:
    now = que.popleft()
    for v in paths[now]:
        if depth[v] != -1:
            continue
        depth[v] = depth[now] + 1
        que.append(v)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (depth[c] - depth[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
def main():
    from collections import deque
    N, Q = map(int, input().split())
    ab = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        ab[a - 1].append(b - 1)
        ab[b - 1].append(a - 1)

    def bfs(s):
        q = deque([s])
        D = [-1] * N
        D[s] = 0
        while q:
            v = q.popleft()
            for i in ab[v]:
                if D[i] == -1:
                    D[i] = D[v] + 1
                    q.append(i)
        return D

    D = bfs(0)

    for _ in range(Q):
        c, d = map(int, input().split())
        if (D[c - 1] - D[d - 1]) % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
import sys
from collections import deque


def main():
    N, Q = map(int, input().split())
    graph = [[] for _ in range(N)]
    # M辺の情報
    for m in range(N - 1):
        a, b = map(int, input().split())
        # 頂点が0始まりで無ければ、1を引く
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)
    dist = [-1 for _ in range(N)]  # 最短距離
    dist[0] = 0

    to_visit = deque()
    to_visit.append(0)

    while to_visit:
        old_v = to_visit.popleft()
        for new_v in graph[old_v]:
            if dist[new_v] == -1:
                dist[new_v] = 1 - dist[old_v]
                to_visit.append(new_v)

    for q in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        if dist[c] == dist[d]:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
import sys

sys.setrecursionlimit(10**6)

N, Q = map(int, input().split())
edge = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)

ps = [0] * N
used = [False] * N


def dfs(frm):
    for to in edge[frm]:
        if used[to]: continue
        ps[to] = ps[frm] + 1
        used[to] = True
        dfs(to)
    return


dfs(0)

for q in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (ps[c] + ps[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
# BFS
# DFS
import sys

sys.setrecursionlimit(20000000)
n, q = map(int, input().split())
a = [[] for i in range(n - 1)]
b = [[] for i in range(n - 1)]
c = [0] * q
d = [0] * q
g = [[] for i in range(n)]

for i in range(n - 1):
    a[i], b[i] = map(int, input().split())
    g[a[i] - 1].append(b[i] - 1)
    g[b[i] - 1].append(a[i] - 1)
for i in range(q):
    c[i], d[i] = map(int, input().split())

seen = [False for i in range(n)]
color = [-1 for i in range(n)]


def BFS(g, start):
    seen[start] = True

    for i in g[start]:
        if (seen[i] == False):
            seen[i] = True
            color[i] = 1 - color[start]
            BFS(g, i)


color[0] = 0
BFS(g, 0)

for i in range(q):
    if (color[c[i] - 1] == color[d[i] - 1]):
        print('Town')
    else:
        print('Road')
import sys
from collections import deque

input = sys.stdin.buffer.readline

N, Q = map(int, input().split())
T = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = (int(x) - 1 for x in input().split())
    T[a].append(b)
    T[b].append(a)

table = [None] * N
d = deque([0])
table[0] = True
while d:
    v = d.pop()
    bx = not table[v]
    for x in T[v]:
        if table[x] is None:
            table[x] = bx
            d.append(x)
for _ in range(Q):
    c, d = (int(x) - 1 for x in input().split())
    print('Road' if table[c] ^ table[d] else 'Town')
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
from collections import deque

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

dist = [-1] * N
dist[0] = 0

d = deque()
d.append(0)

while d:
    v = d.popleft()
    for i in G[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i in range(Q):
    c, e = map(int, input().split())
    if (dist[c - 1] - dist[e - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")

#print(dist)
import sys

sys.setrecursionlimit(
    700000)  # if you think this value, change pypy to python3...?


def s_in():
    return input()


def n_in():
    return int(input())


def l_in():
    return list(map(int, input().split()))


class LCA:
    def __init__(self, n, root, edges):
        self.n = n
        self.depth, parents = tree_depth(n, root, edges)
        k = n.bit_length()
        self.double = Doubling(n, k, parents)

    def get_lca(self, u, v):
        dd = self.depth[v] - self.depth[u]
        if dd < 0:
            u, v = v, u
            dd = -dd

        # assert depth[u] <= depth[v]
        for k in range(self.double.max_k + 1):
            if dd & 1:
                v = self.double.double[v][k]
            dd >>= 1

        # assert depth[u] == depth[v]
        if u == v:
            return u

        for k in range(self.double.max_k - 1, -1, -1):
            pu = self.double.double[u][k]
            pv = self.double.double[v][k]
            if pu != pv:
                u = pu
                v = pv

        # assert kprv[0][u] == kprv[0][v]
        return self.double.double[u][0]


def tree_depth(n, root, edges):
    depth = [-1] * n
    parents = [-1] * n
    depth[root] = 0
    parents[root] = root

    stack = [root]

    while len(stack) > 0:
        u = stack.pop()
        for v in edges[u]:
            if not depth[v] == -1: continue
            stack.append(v)
            parents[v] = u
            depth[v] = depth[u] + 1

    return depth, parents


class Doubling:
    def __init__(self, n, k, trans):
        self.n = n
        self.max_k = k
        double = [[-1] * k for _ in range(n)]

        for i in range(n):
            double[i][0] = trans[i]
        for j in range(1, k):
            for i in range(n):
                double[i][j] = double[double[i][j - 1]][j - 1]
        self.double = double

    def forward(self, p, step):
        while step > 0:
            for k in range(0, self.max_k):
                if 2**(k + 1) > step: break
            step -= 2**k
            p = self.double[p][k]
        return p


def _main(n, edges, q):
    lca = LCA(n, 0, edges)

    for c, d in q:
        u = lca.get_lca(c, d)
        dist = lca.depth[c] + lca.depth[d] - 2 * lca.depth[u]

        if dist % 2 == 0:
            print("Town")
        else:
            print("Road")


def main():
    n, qq = l_in()
    edges = [[] for _ in range(n)]

    for i in range(n - 1):
        a, b = l_in()
        edges[a - 1].append(b - 1)
        edges[b - 1].append(a - 1)

    q = [None] * qq

    for i in range(qq):
        c, d = l_in()
        q[i] = (c - 1, d - 1)

    _main(n, edges, q)


if __name__ == "__main__":
    main()
from collections import deque

n, Q = map(int, input().split())
graph = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

dist = [-1] * n
dist[0] = 0

q = deque()
q.append(0)

while q:
    v = q.popleft()
    for i in set(graph[v]):
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        q.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if abs(dist[c] - dist[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
import sys
import resource

sys.setrecursionlimit(10**6)
N, Q = map(int, input().split())
INF = 10**18

edge = [[] for _ in range(N)]

for i in range(N - 1):
    A, B = map(int, input().split())
    A -= 1
    B -= 1
    edge[A].append(B)
    edge[B].append(A)
dep = [0] * N


def dfs(now, last=-1):
    for next in edge[now]:
        if next == last:
            continue
        dep[next] = dep[now] + 1
        dfs(next, now)


dfs(1)
for i in range(Q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if (dep[a] + dep[b]) % 2 == 0:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys

sys.setrecursionlimit(10**7)
from pprint import pprint as pp
from pprint import pformat as pf
# @pysnooper.snoop()
#import pysnooper # debug


def ternary_op(flg, a, b):
    if flg:
        return a
    else:
        return b


import math
#from sortedcontainers import SortedList, SortedDict, SortedSet # no in atcoder
import bisect
# Queue is very slow
from collections import defaultdict


class Graph:
    def __init__(self, size):
        # id starts from 0
        self.size = size
        self.vertices = [0] * size  # store depth
        self.edges = [None] * size
        for i in range(size):
            self.edges[i] = []

    def __repr__(self):
        out = []
        out.append("vertices {}".format(self.vertices))
        for i, e in enumerate(self.edges):
            out.append("{}{}".format(i, pf(e)))
        return "\n".join(out)

    def add_edge(self, frm, to):
        self.edges[frm].append(to)
        self.edges[to].append(frm)


def prepare(graph):
    visited = [False] * graph.size
    dfs(graph, 0, visited, 0)


def dfs(graph, v, visited, depth):
    visited[v] = True
    graph.vertices[v] = depth
    depth += 1
    for to in graph.edges[v]:
        if visited[to]:
            continue
        dfs(graph, to, visited, depth)


def solve(graph, c, d):
    depth_c = graph.vertices[c]
    depth_d = graph.vertices[d]
    dist_like = depth_c + depth_d
    if dist_like % 2 == 0:
        return "Town"
    else:
        return "Road"


if __name__ == '__main__':
    n, q = list(map(int, input().split()))
    graph = Graph(n)
    for _ in range(n - 1):
        a, b = list(map(int, input().split()))
        a -= 1
        b -= 1
        graph.add_edge(a, b)
    prepare(graph)
    #print('graph') # debug
    #pp(graph) # debug
    for _ in range(q):
        c, d = list(map(int, input().split()))
        c -= 1
        d -= 1
        ans = solve(graph, c, d)
        print(ans)

    #print('\33[32m' + 'end' + '\033[0m') # debug
# region Template
# fmt: off
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)
from collections import Counter, deque, defaultdict


# from itertools import combinations, permutations, accumulate, groupby, product
# from bisect import bisect_left,bisect_right
# from heapq import heapify, heappop, heappush
# from math import floor, ceil ,factorial, gcd
# from operator import itemgetter
# from copy import deepcopy
def I():
    return int(input())


def MI():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


def SI():
    return input().rstrip()


def printns(x):
    print('\n'.join(x))


def printni(x):
    print('\n'.join(list(map(str, x))))


inf = 10**17
mod = 10**9 + 7
#mod =998244353


def INT():
    return int(sys.stdin.readline().rstrip())


def LINT():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def STR():
    return sys.stdin.readline().rstrip()


def LSTR():
    return list(sys.stdin.readline().rstrip().split())


# fmt: on
# endregion Template


def main():
    N, Q = MI()
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = MI()
        a -= 1
        b -= 1
        G[a].append(b)
        G[b].append(a)

    dist = [-1] * N
    dist[0] = 0
    que = deque([])
    que.append(0)

    while que:
        cur = que[0]
        que.popleft()
        for next in G[cur]:
            if dist[next] != -1:
                continue
            dist[next] = dist[cur] + 1
            que.append(next)

    for _ in range(Q):
        c, d = MI()
        c -= 1
        d -= 1
        if (dist[c] - dist[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
from collections import deque


def main():
    N, nQ = list(map(int, input().split()))
    E = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = list(map(int, input().split()))
        a -= 1
        b -= 1
        E[a].append(b)
        E[b].append(a)

    def bfs(s, E):
        Q = deque()
        Q.append(s)
        visited = set()
        visited.add(s)
        dist = {}
        dist[s] = 0
        while len(Q) > 0:
            i = Q.popleft()
            for j in E[i]:
                if j in visited:
                    continue
                dist[j] = dist[i] + 1
                visited.add(j)
                Q.append(j)
        return dist

    dist = bfs(0, E)

    for _ in range(nQ):
        c, d = list(map(int, input().split()))
        c -= 1
        d -= 1
        if (dist[c] + dist[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


main()
from collections import defaultdict

N, Q = map(int, input().split())
Edges = defaultdict(list)
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    Edges[a].append(b)
    Edges[b].append(a)


class LCA():
    '''answer LCA queries for tree G.

        parameters:
            N:int
            G:tree(dict(list or set)), non-directed edges

        functions:
            get_lca:
                give two nodes x, y
                -> return LCA of x, y
            get_dist:
                give two nodes x,y
                -> return distance between x and y

        Examples:
            AOJ_GRL_5_C
            ABC_014_D
            etc...
    '''
    def __init__(self, N, G, root=0):
        if N == 1:
            return
        self.INF = N + 1
        self.dist = [self.INF] * N
        self.task = [(root, -1, 0)]
        self.P = [0] * N
        for v, p, d in self.task:
            self.dist[v] = d
            self.P[v] = p
            for e in G[v]:
                if e != p:
                    self.task.append((e, v, d + 1))
        self.md = self.task[-1][2]
        self.K = self.md.bit_length()
        self.L = [[0] * N for _ in range(self.K)]
        self.L[0] = [self.P[i] for i in range(N)]
        self.L[0][root] = root
        for i in range(1, self.K):
            for j in range(N):
                self.L[i][j] = self.L[i - 1][self.L[i - 1][j]]

    def get_lca(self, a, b):
        if N == 1:
            return a
        if self.dist[a] < self.dist[b]:
            a, b = b, a
        for j in range(self.K):
            if ((self.dist[a] - self.dist[b]) >> j) & 1:
                a = self.L[j][a]
        if a == b:
            return a
        for j in range(self.K - 1, -1, -1):
            if self.L[j][a] != self.L[j][b]:
                a = self.L[j][a]
                b = self.L[j][b]
        return self.L[0][a]

    def get_dist(self, a, b):
        if N == 1:
            return 0
        c = self.get_lca(a, b)
        return self.dist[a] + self.dist[b] - self.dist[c] * 2


lca = LCA(N, Edges)
S = ['Town', 'Road']
ans = []

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    v = lca.get_dist(c, d)
    ans.append(S[v % 2])

print(*ans, sep='\n')
import sys

input = sys.stdin.readline
N, Q = map(int, input().split())
AB = [tuple(map(int, input().split())) for i in range(N - 1)]
CD = [tuple(map(int, input().split())) for i in range(Q)]

es = [[] for _ in range(N)]
for a, b in AB:
    a, b = a - 1, b - 1
    es[a].append(b)
    es[b].append(a)

MK = len(bin(N)) - 1
dp = [[-1] * N for _ in range(MK)]
depth = [0] * N
visited = [0] * N
visited[0] = 1
stack = [0]
while stack:
    v = stack.pop()
    for to in es[v]:
        if visited[to]: continue
        visited[to] = 1
        dp[0][to] = v
        depth[to] = depth[v] + 1
        stack.append(to)

for k in range(MK - 1):
    for i in range(N):
        if dp[k][i] < 0: continue
        dp[k + 1][i] = dp[k][dp[k][i]]


def lca(s, t):
    if depth[s] < depth[t]: s, t = t, s
    for k in range(MK):
        if ((depth[s] - depth[t]) >> k) & 1:
            s = dp[k][s]
    if s == t: return s
    for k in range(MK - 1, -1, -1):
        if dp[k][s] != dp[k][t]:
            s = dp[k][s]
            t = dp[k][t]
    return dp[0][s]


ans = []
for c, d in CD:
    c, d = c - 1, d - 1
    a = lca(c, d)
    dist = depth[c] + depth[d] - depth[a] * 2
    ans.append('Road' if dist % 2 else 'Town')
print(*ans, sep='\n')
import sys

input = sys.stdin.readline
sys.setrecursionlimit(2 * (10**5))
INF = float("INF")
MOD = 10**9 + 7
import heapq
import math
from collections import Counter, deque
from itertools import combinations, combinations_with_replacement, permutations
from bisect import bisect_left, bisect_right

n, q = map(int, input().split())
edge = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    edge[a].append(b)
    edge[b].append(a)

dist = [-1] * n
dist[0] = 0
que = deque()
que.append(0)

while que:
    x = que.popleft()
    for to in edge[x]:
        if dist[to] != -1:
            continue
        dist[to] = dist[x] + 1
        que.append(to)

for i in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
from collections import deque

sys.setrecursionlimit(10**6)


def main(input, print):
    n, q = map(int, input().split())
    table = [[] for _ in range(n)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        table[a].append(b)
        table[b].append(a)
    color = [-1] * n
    color[0] = 0
    que = deque()
    que.append(0)
    while que:
        now = que.popleft()
        for next in table[now]:
            if color[next] == -1:
                color[next] = 1 - color[now]
                que.append(next)
    for i in range(q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        if (color[c] == color[d]):
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main(sys.stdin.readline, print)
import sys

ipt = sys.stdin.readline
sys.setrecursionlimit(10**6)
N, Q = map(int, ipt().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, ipt().split())
    a, b = a - 1, b - 1
    G[a].append(b)
    G[b].append(a)

qq = [list(map(int, ipt().split())) for _ in range(Q)]

# Euler Tour Technique
S = []
FS = [0] * N
depth = [0] * N


def dfs(v, p, d):
    depth[v] = d
    FS[v] = len(S)
    S.append(v)
    for w in G[v]:
        if w == p:
            continue
        dfs(w, v, d + 1)
        S.append(v)


dfs(0, -1, 0)

# Sparse Table
L = len(S)
lg = [0] * (L + 1)
for i in range(2, L + 1):
    lg[i] = lg[i >> 1] + 1
st = [None] * (lg[L] + 1)
st0 = st[0] = S
b = 1
for i in range(lg[L]):
    st0 = st[i + 1] = [
        p if depth[p] <= depth[q] else q for p, q in zip(st0, st0[b:])
    ]
    b <<= 1


# LCA O(1)
def query(u, v):
    x = FS[u]
    y = FS[v]
    if x > y:
        x, y = y, x
    l = lg[y - x + 1]
    px = st[l][x]
    py = st[l][y - (1 << l) + 1]
    return px if depth[px] <= depth[py] else py


visited = [False] * N
Dist = [0] * N
Depth = [0] * N
Pare = [-1] * N


def rec(cur, dist):
    Dist[cur] = dist
    depth = 0
    visited[cur] = True
    for nxt in G[cur]:
        if visited[nxt]:
            continue
        Pare[nxt] = cur
        depth = max(depth, rec(nxt, dist + 1))
    Depth[cur] = depth
    return depth + 1


rec(0, 0)

for c, d in qq:
    c, d = c - 1, d - 1
    a = query(c, d)
    dis = Dist[c] + Dist[d] - 2 * Dist[a]
    if dis % 2:
        print("Road")
    else:
        print("Town")
import sys
import bisect
from collections import deque
import itertools
import math

# sys.setrecursionlimit(10**4)
from sys import stdin
# readline = stdin.readline
sr = lambda: input()
ir = lambda: int(sr())
lr = lambda: list(map(int, sr().split()))

inf = 10**18
mod = 10**9 + 7
# mod = 998244353

import numpy as np
from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson

if __name__ == '__main__':
    n, q = lr()
    e = [lr() for i in range(n - 1)]
    m = n - 1
    edge = np.array(e, dtype=np.int64).T
    tmp = np.ones(m, dtype=np.int64).T
    graph = csr_matrix((tmp, (edge[:] - 1)), (n, n))
    dist = shortest_path(graph, indices=0, method='D', directed=False)

    for _ in range(q):
        c, d = lr()
        c -= 1
        d -= 1
        if (dist[c] - dist[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")
from collections import deque


def main():
    N, Q = map(int, input().split())
    G = [set() for _ in range(N)]

    for _ in range(N - 1):
        a, b = map(int, input().split())
        G[a - 1].add(b - 1)
        G[b - 1].add(a - 1)

    depth = [-1] * N
    depth[0] = 0

    que = deque([0])

    while que:
        v = que.pop()
        d = depth[v]
        for nv in G[v]:
            if depth[nv] != -1: continue
            depth[nv] = d + 1
            que.append(nv)

    query = [list(map(int, input().split())) for _ in range(Q)]
    ans = []
    R = ['Town', 'Road']

    for c, d in query:
        if (depth[c - 1] - depth[d - 1]) % 2 == 0:
            ans.append(0)
        else:
            ans.append(1)

    for a in ans:
        print(R[a])


if __name__ == '__main__':
    main()
import os, io

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
n, q = map(int, input().split())
graph = []
INF = 10**9
for i in range(n):
    graph.append([])
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
dist = [INF] * n
curr = 0
stack = [(0, 0)]
while stack:
    a, pos = stack.pop()
    dist[pos] = a
    for i in graph[pos]:
        if dist[i] == INF:
            stack.append((a + 1, i))
for i in range(q):
    c, d = map(int, input().split())
    if dist[c - 1] % 2 == dist[d - 1] % 2:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
city = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    city[a - 1].append(b - 1)
    city[b - 1].append(a - 1)

# 道路は同じ長さ
# 街の数が奇数なら街で合い、偶数なら道路で会う


def bfs(s):
    seen = deque()
    seen.append(s)
    visited = [None] * N
    visited[s] = 1
    while seen:
        v = seen.popleft()
        for adj in city[v]:
            if visited[adj] is None:
                visited[adj] = visited[v] + 1
                seen.append(adj)
    return visited


dist = bfs(0)
for j in range(Q):
    c, d = map(int, input().split())
    diff = abs(dist[c - 1] - dist[d - 1]) + 1
    if diff % 2 == 0:
        print('Road')
    else:
        print('Town')
# a, b = map(int, input().split())
import heapq


def dijkstra(start, graph):
    inf = 10**18
    n = len(graph)
    dist = [inf] * n
    dist[start] = 0
    q = [(0, start)]  # q = [(startからの距離, 現在地)]
    while q:
        d, v = heapq.heappop(q)
        if dist[v] < d:
            continue
        for nx, nxd in graph[v]:
            if dist[v] + nxd < dist[nx]:
                dist[nx] = dist[v] + nxd
                heapq.heappush(q, (dist[nx], nx))
    return dist


n, q = map(int, input().split())

G = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append((b, 1))
    G[b].append((a, 1))

dist = dijkstra(0, G)
for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    tmp_dist = dist[c] + dist[d]
    if tmp_dist % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
g = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)
from collections import deque


def fukatan(g, n):
    color = [-1] * (n + 1)
    color[1] = 0
    q = deque([1])
    while q:
        v = q.popleft()
        for u in g[v]:
            if color[u] != -1:
                continue
            color[u] = (color[v] + 1) % 2
            q.append(u)
    return color


color = fukatan(g, N)
for _ in range(Q):
    c, d = map(int, input().split())
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**8)

N, Q = map(int, input().split())
L = [[] for i in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    L[a].append(b)
    L[b].append(a)
P = [0] * (N + 1)
T = [0] * (N + 1)


def dfs(p, cnt):
    P[p] = cnt
    T[p] = 1
    for l in L[p]:
        if T[l] == 0:
            dfs(l, cnt + 1)


dfs(1, 0)

for i in range(Q):
    a, b = map(int, input().split())
    if (P[a] + P[b]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
node_lst = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    node_lst[a].append(b)
    node_lst[b].append(a)
# print(node_lst)
dep_lst = [-1 for _ in range(n)]
que = deque()
que.append((0, 0))

while len(que) > 0:
    node, depth = que.popleft()
    dep_lst[node] = depth
    # print(node_lst[node])
    for child in node_lst[node]:
        if dep_lst[child] >= 0: continue
        que.append((child, depth + 1))

for _ in range(q):
    ans = 0
    fr, to = map(int, input().split())
    fr -= 1
    to -= 1
    ans = (dep_lst[fr] + dep_lst[to]) % 2
    print(["Town", "Road"][ans])
def main():
    N, Q = map(int, input().split())
    L = [[] for i in range(N + 1)]
    X = [0 for i in range(N + 1)]
    for i in range(N - 1):
        a, b = map(int, input().split())
        L[a].append(b)
        L[b].append(a)

    NEXT = [1]
    CAN = [True for i in range(N + 1)]
    CAN[1] = False
    while (len(NEXT) > 0):
        NOW = NEXT
        NEXT = []
        for a in NOW:
            x = (X[a] + 1) % 2
            for b in L[a]:
                if CAN[b]:
                    X[b] = x
                    CAN[b] = False
                    NEXT.append(b)

    for q in range(Q):
        c, d = map(int, input().split())
        ans = 'Road'
        if X[c] == X[d]:
            ans = 'Town'

        print(ans)


if __name__ == '__main__':
    main()
import sys

sys.setrecursionlimit(20000000)
n, q = map(int, input().split())
a = [[] for i in range(n - 1)]
b = [[] for i in range(n - 1)]
c = [0] * q
d = [0] * q
g = [[] for i in range(n)]

for i in range(n - 1):
    a[i], b[i] = map(int, input().split())
    g[a[i] - 1].append(b[i] - 1)
    g[b[i] - 1].append(a[i] - 1)
for i in range(q):
    c[i], d[i] = map(int, input().split())

seen = [False for i in range(n)]
color = [-1 for i in range(n)]


def BFS(g, start):
    seen[start] = True

    for i in g[start]:
        if (seen[i] == False):
            seen[i] = True
            color[i] = 1 - color[start]
            BFS(g, i)


deep = [[] for i in range(n)]


def BFS_2(g, start):
    seen[start] = True

    for i in g[start]:
        if (seen[i] == False):
            seen[i] = True
            deep[i] = deep[start] + 1
            BFS_2(g, i)


color[0] = 0
deep[0] = 0
BFS_2(g, 0)

for i in range(q):
    if ((deep[c[i] - 1] + deep[d[i] - 1]) % 2 == 0):
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(500000)
n, q = map(int, input().split())
adj = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)
c = [0] * q
d = [0] * q
for i in range(q):
    c[i], d[i] = map(int, input().split())
    c[i] -= 1
    d[i] -= 1
S = []
F = [0] * n
depth = [0] * n
seen = [0] * n


def dfs(v, e):
    F[v] = len(S)
    depth[v] = e
    S.append(v)
    seen[v] = 1
    for w in adj[v]:
        if not seen[w]:
            dfs(w, e + 1)
            S.append(v)


dfs(0, 0)

INF = (n, None)

M = 2 * n
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for i in range(q):
    lca = query(c[i], d[i])
    ans = depth[c[i]] + depth[d[i]] - 2 * depth[lca]
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
from bisect import bisect_left, bisect_right, insort_left, insort_right
from collections import Counter, defaultdict, deque
from copy import copy, deepcopy
from decimal import Decimal
from heapq import heapify, heappop, heappush
from itertools import combinations, permutations, combinations_with_replacement, product
from math import gcd, factorial, log2, ceil, floor, sin, asin, cos, acos, tan, atan, degrees
from pprint import pprint
from random import randrange
from sys import setrecursionlimit
from time import time

setrecursionlimit(10**9)
MOD = 10**9 + 7
INF = 10**18

N, Q = map(int, input().split())
#道の数のメモを作る？
#1からの距離を覚えておいてそれの差でいいんじゃないの？
road = [[] for _ in range(N)]
for n in range(N - 1):
    A, B = map(int, input().split())
    road[A - 1].append(B - 1)
    road[B - 1].append(A - 1)
dist = 0
dist_from0 = [0] * N
visited = [0] * N
visited[0] = 1


def dfs(now):
    global dist
    dist += 1
    dist_from0[now] = dist
    for next_town in road[now]:
        if visited[next_town] == 0:
            visited[next_town] = 1
            dfs(next_town)
    dist -= 1


dfs(0)
for q in range(Q):
    C, D = map(int, input().split())
    if abs(dist_from0[C - 1] - dist_from0[D - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from sys import stdin

input = stdin.readline

n, q = map(int, input().split())

e = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    e[a - 1].append(b - 1)
    e[b - 1].append(a - 1)

dist = [-1] * n
stack = [0]
dist[0] = 0
while stack:
    v = stack.pop(-1)
    for u in e[v]:
        if dist[u] == -1:
            dist[u] = dist[v] + 1
            stack += [u]

for j in range(q):
    c, d = map(int, input().split())
    ans = dist[c - 1] + dist[d - 1]

    if ans % 2 == 1:
        print('Road')
    else:
        print('Town')
from collections import deque

N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]
root = [[] for _ in range(N)]
for a, b in AB:
    a, b = a - 1, b - 1
    root[a].append(b)
    root[b].append(a)

dists = [-1] * N
dists[0] = 0
stack = deque([0])
while len(stack):
    now = stack.popleft()
    for i in root[now]:
        if dists[i] == -1:
            dists[i] = dists[now] + 1
            stack.append(i)

for c, d in CD:
    c, d = c - 1, d - 1
    if abs(dists[c] - dists[d]) % 2:
        print('Road')
    else:
        print('Town')
from collections import defaultdict

N, Q = map(int, input().split())

graph = defaultdict(list)

for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

queries = []

for _ in range(Q):
    c, d = map(int, input().split())
    queries.append([c, d])

visited = defaultdict(bool)
distances = defaultdict(int)

queue = [1]
visited[1] = True
distances[1] = 0

while len(queue) > 0:
    current_node = queue.pop(0)

    for node in graph[current_node]:
        if visited[node]:
            continue
        visited[node] = True
        distances[node] = distances[current_node] + 1
        queue.append(node)

for query in queries:
    if (distances[query[0]] - distances[query[1]]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import collections


def bfs(tree):
    d = collections.deque([])
    d.append(1)
    level = {1: 0}
    vis = collections.defaultdict(bool)
    vis[1] = True
    while d:
        u = d.popleft()
        for v in tree[u]:
            if not vis[v]:
                vis[v] = True
                level[v] = level[u] + 1
                d.append(v)
    return level


n, q = map(int, input().split())
tree = collections.defaultdict(list)
for i in range(n - 1):
    a, b = map(int, input().split())
    tree[a].append(b)
    tree[b].append(a)
level = bfs(tree)
for k in range(q):
    a, b = map(int, input().split())
    if (level[a] + level[b]) % 2 == 0:
        print("Town")
    else:
        print('Road')
n, k = map(int, input().split(' '))
from collections import defaultdict, deque

g = defaultdict(list)
for _ in range(n - 1):
    a, b = map(int, input().split(' '))
    g[a].append(b)
    g[b].append(a)
d = defaultdict(int)
q = deque()
q.append((1, -1))
v = {1}
while q:
    t, par = q.popleft()
    if par == -1:
        d[t] = 0
    else:
        d[t] = abs(d[par] - 1)
    for child in g[t]:
        if child not in v:
            v.add(child)
            q.append((child, t))

for _ in range(k):
    a, b = map(int, input().split(' '))
    if d[a] == d[b]:
        print('Town')
    else:
        print('Road')
from string import ascii_lowercase
from decimal import Decimal
from random import randrange, choice, randint
import time
from heapq import heappop, heappush
from copy import copy
from bisect import bisect_right, bisect_left
from sys import stdin
from functools import reduce
from math import e, sqrt, gcd, pi, factorial, ceil, floor, sin
from itertools import permutations
from collections import defaultdict, deque, Counter
from enum import Enum, auto
import sys

sys.setrecursionlimit(1000000)

n, q = map(int, input().split())
to = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    to[a - 1].append(b - 1)
    to[b - 1].append(a - 1)

k = 1
while 2**k <= n - 1:
    k += 1
parent = [[-1 for _ in range(n)] for _ in range(k)]
dist = [-1 for _ in range(n)]

# def dfs(now, par, dis):
#     parent[0][now] = par
#     dist[now] = dis
#     for next in to[now]:
#         if next != par:
#             dfs(next, now, dis + 1)

visited = [False for _ in range(n)]
que = deque([(0, -1, 0)])
while que:
    now, par, dis = que.popleft()
    parent[0][now] = dis
    dist[now] = dis
    visited[now] = True
    for next in to[now]:
        if not visited[next]:
            que.append((next, now, dis + 1))

# dfs(0, -1, 0)

for i in range(k - 1):
    for j in range(n - 1):
        if parent[i][j] < 0:
            parent[i + 1][j] = -1
        parent[i + 1][j] = parent[i][parent[i][j]]


def query(u, v):
    if dist[u] < dist[v]:
        u, v = v, u
    for i in range(k):
        if (dist[u] - dist[v]) >> i & 1:
            u = parent[i][u]
    if u == v:
        return u
    for i in reversed(range(0, k)):
        if parent[i][u] != parent[i][v]:
            u = parent[i][u]
            v = parent[i][v]
    return parent[0][u]


for _ in range(q):
    c, d = map(int, input().split())
    par = query(c - 1, d - 1)
    dis = dist[c - 1] + dist[d - 1] - 2 * dist[par]
    if dis % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
E = [[] for _ in range(n)]
GK = [0] * n
for _ in range(n - 1):
    a, b = map(int, input().split())
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)
queue = deque()
queue.append(0)
seen = [False] * n
while queue:
    temp = queue.popleft()
    seen[temp] = True
    for e in E[temp]:
        if not seen[e]:
            seen[e] = True
            queue.append(e)
            GK[e] = GK[temp] + 1

for _ in range(q):
    c, d = map(int, input().split())
    if (GK[d - 1] - GK[c - 1]) % 2 == 1:
        print("Road")
    else:
        print("Town")
from collections import deque


def lmap(func, iter):
    return list(map(func, iter))


def main():
    n, q = map(int, input().split())
    ABs = [lmap(int, input().split()) for _ in range(n - 1)]
    CDs = [lmap(int, input().split()) for _ in range(q)]

    adjs = [[] for _ in range(n)]
    for a, b in ABs:
        adjs[a - 1].append(b - 1)
        adjs[b - 1].append(a - 1)

    cols = [-1] * n
    cols[0] = 0
    q = deque([(0, 0)])
    while q:
        v, c = q.popleft()
        for vi in adjs[v]:
            if cols[vi] == -1:
                cols[vi] = (c + 1) % 2
                q.append((vi, (c + 1) % 2))

    for c, d in CDs:
        if cols[c - 1] ^ cols[d - 1]:
            print('Road')
        else:
            print('Town')


if __name__ == '__main__':
    main()
import sys
import collections

infile = sys.stdin.buffer


def gs():
    return infile.readline().rstrip()


def gi():
    return int(gs())


def gf():
    return float(gs())


def gss():
    return gs().split()


def gis():
    return [int(x) for x in gss()]


def gfs():
    return [float(x) for x in gss()]


def main(infn=""):
    global infile
    infile = open(infn, "r") if infn else open(
        sys.argv[1], "r") if len(sys.argv) > 1 else sys.stdin
    N, Q = gis()
    A = [0] * (N - 1)
    B = [0] * (N - 1)
    C = [0] * Q
    D = [0] * Q
    for i in range(N - 1):
        A[i], B[i] = gis()
    for i in range(Q):
        C[i], D[i] = gis()
    gr = [[] for i in range(N)]
    for i in range(N - 1):
        gr[A[i] - 1].append(B[i] - 1)
        gr[B[i] - 1].append(A[i] - 1)

    ## Do BFS
    sb = [0] * N
    q = collections.deque()
    q.append((1, -1))
    while q:
        (n, p) = q.popleft()
        for c in gr[n]:
            if c == p: continue
            sb[c] = 1 - sb[n]
            q.append((c, n))

    ansarr = []
    for i in range(Q):
        c, d = C[i] - 1, D[i] - 1
        ans = "Town" if sb[c] == sb[d] else "Road"
        ansarr.append(ans)

    ans = "\n".join(ansarr)
    sys.stdout.write(str(ans) + '\n')


if __name__ == '__main__':
    main()
    sys.stdout.flush()
from collections import deque

n, z = map(int,
           input().split())
p, e, q = [[] for _ in range(n)], [0] * n, deque([0])
e[0] = 1
for i in range(n - 1):
    a, b = map(int,
               input().split())
    p[a - 1].append(b - 1)
    p[b - 1].append(a - 1)
while len(q):
    m = q.popleft()
    for i in p[m]:
        if e[i] == 0:
            e[i] = e[m] + 1
            q.append(i)
for i in range(z):
    c, d = map(int,
               input().split())
    print("Road") if (e[c - 1] - e[d - 1]) % 2 else print("Town")
import collections


def main():

    N, Q = map(int, input().split())
    tree = collections.defaultdict(set)
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        tree[a].add(b)
        tree[b].add(a)
    # print(tree)

    dist = dict()
    dist[0] = 0
    cur = [0]
    visited = [0 for _ in range(N)]
    visited[0] = 1
    d = 0
    while cur:
        tmp = []
        d += 1
        for a in cur:
            for b in tree[a]:
                if visited[b] == 0:
                    visited[b] = 1
                    tmp.append(b)
                    dist[b] = d
        cur = tmp

    # print(dist)

    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        u = dist[c] - dist[d]
        if u % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
from sys import setrecursionlimit

setrecursionlimit(10**6)

n, q = map(int, input().split())
g = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a] += [b]
    g[b] += [a]

# n: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)

# Euler Tour の構築
S = []
F = [0] * n
depth = [0] * n


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in g[v]:
        if depth[w] == 0:
            dfs(w, d + 1)
            S.append(v)


dfs(0, 0)

# 存在しない範囲は深さが他よりも大きくなるようにする
InF = (n, None)

# LCAを計算するクエリの前計算
M = 2 * n
M0 = 2**(M - 1).bit_length()
data = [InF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield InF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


# LCAの計算 (外から呼び出す関数)
def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    ans = depth[c] + depth[d] - 2 * depth[query(c, d)]
    if ans % 2 == 1:
        print("Road")
    else:
        print("Town")
from collections import defaultdict, deque
from itertools import permutations, combinations, product
from functools import lru_cache


def pprint(E):
    for e in E:
        print(e)


from sys import setrecursionlimit, stdin

setrecursionlimit(500000)
readline = stdin.readline
# @lru_cache(maxsize=None)
INF = 10**18
MOD = 1000000007
MOD2 = 998244353
cnt = ans = tmp = 0
yes, no = 'Yes', 'No'
yn = yes


def I():
    return int(readline())


def S():
    return readline()[:-1]


def LI():
    return list(map(int, readline().split()))


def SPI():
    return map(int, readline().split())


def FIE(x):
    return [readline()[:-1] for _ in [0] * x]


def ENU(x):
    return enumerate(x)


def NODE(x):
    return [[] for _ in [0] * (x + 1)]


def ZERO(x):
    return [0] * x


def ZEROS(y, x):
    return [[0] * x for _ in [0] * y]


def ZEROSS(z, y, x):
    return [[[0] * x for _ in [0] * y] for _ in [0] * z]


####################################################################
n, q = SPI()
node = NODE(n + 1)
for _ in range(n - 1):
    a, b = SPI()
    node[a].append((b, 1))
    node[b].append((a, 1))

from heapq import heappush, heappop

dist, done = [INF] * (n + 1), [0] * (n + 1)
hq = [(0, 1)]  # (cost, node)
dist[1] = 0
while hq:
    v = heappop(hq)[1]  # get a node
    done[v] = 1
    for to, cost in node[v]:
        if done[to] == 0 and dist[v] + cost < dist[to]:
            dist[to] = dist[v] + cost
            heappush(hq, (dist[to], to))

for _ in range(q):
    c, d = SPI()
    tmp = dist[c] + dist[d]
    if tmp % 2 == 0: print('Town')
    else: print('Road')
import sys

sys.setrecursionlimit(10**7)

mod = 998244353


def bfs():
    while len(que) > 0:
        que_now = que.pop(0)
        for nxt in way[que_now]:
            if dist[nxt] == -1:
                que.append(nxt)
                dist[nxt] = dist[que_now] + 1


if __name__ == '__main__':
    readline = sys.stdin.readline
    read = sys.stdin.read
    N, Q = map(int, readline().split())
    way = [[] for _ in range(N)]
    for i in [0] * (N - 1):
        A, B = map(int, readline().split())
        way[A - 1].append(B - 1)
        way[B - 1].append(A - 1)
    que = [0]
    dist = [-1] * N
    dist[0] = 0
    bfs()
    # print(dist)
    for q in [0] * Q:
        c, d = map(int, readline().split())
        if (dist[c - 1] - dist[d - 1]) % 2 == 0:
            print("Town")
        else:
            print("Road")
from sys import stdin
from sys import stdout
from sys import setrecursionlimit

import math
import collections
import heapq
import itertools
import functools


def printf(elem):
    stdout.write(str(elem) + "\n")


def printline(iter):
    stdout.write(" ".join(map(str, iter)) + "\n")


def readcontainer(type=int, container=list):
    return container(map(type, stdin.readline().split()))


def readigits(type=int, container=list):
    return container(map(type, stdin.readline()[:-1]))


def readnum(type=int):
    return type(stdin.readline())


def readline():
    return stdin.readline()[:-1]


setrecursionlimit(1000000)


def dfs(G, start, visited, colors):
    if not visited[start]:
        visited[start] = True
        for v in G[start]:
            colors[v] = not colors[start]
            dfs(G, v, visited, colors)


## Do stuff!! :)
n, q = readcontainer()
g = [set() for _ in range(n + 2)]
for _ in range(n - 1):
    a, b = readcontainer()
    g[a].add(b)
    g[b].add(a)

visited = [False for _ in range(n + 2)]
colors = [False for _ in range(n + 2)]

colors[1] = True
dfs(g, 1, visited, colors)

for _ in range(q):
    c, d = readcontainer()
    if colors[c] == colors[d]:
        printf("Town")
    else:
        printf("Road")
import sys


def segfunc(x, y):
    return x + y


ide_ele = 0


class SegTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] += x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def get(self, k):
        return self.query(k, k + 1)


N, Q = map(int, input().split())
path = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)

S = []
F = [0] * N

sys.setrecursionlimit(10**6)

q = [0]
INF = 10**18

depth = [INF] * N
depth[0] = 0

while q:
    at = q.pop()
    for to in path[at]:
        if depth[to] != INF:
            continue
        q.append(to)
        depth[to] = depth[at] + 1


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in path[v]:
        dfs(w, d + 1)
        S.append(v)


for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (depth[c] + depth[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
graph = [[] for _ in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dep = [-1 for _ in range(n + 1)]
from collections import deque

que = deque()
que.append((1, 0))
while len(que) > 0:
    (node, depth) = que.pop()
    dep[node] = depth
    for g in graph[node]:
        if dep[g] >= 0:
            continue
        que.append((g, depth + 1))

for i in range(q):
    c, d = map(int, input().split())
    if (dep[c] + dep[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())

from collections import deque

graph = []
for i in range(N):
    row = []
    graph.append(row)

for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

visited = []
for i in range(N):
    visited.append(False)

q = deque()
q.append(0)

visited[0] = True
dist = [0] * N
while len(q) > 0:
    i = q.popleft()
    for j in graph[i]:
        if not visited[j]:
            visited[j] = True
            q.append(j)
            dist[j] = dist[i] + 1
maxi = dist.index(max(dist))

visited = []
for i in range(N):
    visited.append(False)

q2 = deque()
q2.append(maxi)

visited[maxi] = True
dist = [0] * N
while len(q2) > 0:
    i = q2.popleft()
    for j in graph[i]:
        if not visited[j]:
            visited[j] = True
            q2.append(j)
            dist[j] = dist[i] + 1

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    dai = max(dist[c], dist[d])
    sho = min(dist[c], dist[d])
    if (dai - sho) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque


def bfs(routes, n, a, b):
    visited = [False for _ in range(n + 1)]

    deq = deque([(a, 0)])
    while deq:
        v = deq.popleft()
        for u in routes[v[0]]:
            if u == b:
                return v[1]
            if visited[u] == False:
                visited[u] = True
                deq.append((u, v[1] + 1))


def main():
    n, q = map(int, input().split())
    routes = [[] for _ in range(n + 1)]
    costs = [0 for _ in range(n + 1)]

    for _ in range(n - 1):
        a, b = map(int, input().split())
        routes[a].append(b)
        routes[b].append(a)

    # for i in range(n):
    #     for j in range(n):
    #         res = bfs(routes, n, i+1, j+1)
    #         costs[i+1] = res % 2
    #         costs[j+1] = res % 2
    deq = deque([(1, 0)])
    visited = [False for _ in range(n + 1)]
    while deq:
        v = deq.popleft()
        for u in routes[v[0]]:
            if visited[u] == False:
                visited[u] = True
                costs[u] = v[1] % 2
                deq.append((u, v[1] + 1))

    for _ in range(q):
        a, b = map(int, input().split())
        if costs[a] != costs[b]:
            print("Road")
        else:
            print("Town")


main()
import sys
from collections import deque

readline = sys.stdin.readline
split_int_readline = lambda: [int(v) for v in readline().split()]

N, Q = split_int_readline()
G = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = split_int_readline()
    G[a].append(b)
    G[b].append(a)

dist = [-1] * (N + 1)
dist[1] = 0
dq = deque([1])
while len(dq) > 0:
    v = dq.popleft()
    for v2 in G[v]:
        if dist[v2] == -1:
            dq.append(v2)
            dist[v2] = dist[v] + 1

for _ in range(Q):
    c, d = split_int_readline()
    e = dist[c] + dist[d]
    if e % 2:
        print("Road")
    else:
        print("Town")
from collections import deque

N, Q = [int(i) for i in input().split()]
graph = {i: set() for i in range(N)}
for _ in range(N - 1):
    a, b = [int(i) - 1 for i in input().split()]
    graph[a].add(b)
    graph[b].add(a)

color = [0] * N
que = deque([0])
seen = {0}
while que:
    node = que.popleft()
    for n in graph[node]:
        if n not in seen:
            color[n] = 1 - color[node]
            que.append(n)
            seen.add(n)
# print(color)

ans = [""] * Q
for q in range(Q):
    c, d = [int(i) - 1 for i in input().split()]
    ans[q] = "Town" if color[c] == color[d] else "Road"
print("\n".join(ans))
from collections import deque

N, Q = map(int, input().split())
road = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    road[a].append(b)
    road[b].append(a)

dist = [-1] * N
dist[0] = 0
que = deque()
que.append(0)
while que:
    i = que.popleft()
    for j in road[i]:
        if dist[j] == -1:
            dist[j] = dist[i] + 1
            que.append(j)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
E = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    E[a].append(b)
    E[b].append(a)
D = [0] * (N + 1)
V = [0] * (N + 1)
V[1] = 1
P = deque([1])
while P:
    x = P[0]
    for y in E[x]:
        if V[y] == 0:
            P.append(y)
            V[y] = 1
            D[y] = D[x] + 1
    P.popleft()
for q in range(Q):
    c, d = map(int, input().split())
    if abs(D[c] - D[d]) % 2 == 1:
        print('Road')
    else:
        print('Town')
import collections

N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
q = collections.deque()
q.append(0)
dist = [-1] * N
dist[0] = 0
while len(q) != 0:
    v = q.popleft()
    d = dist[v]
    for w in graph[v]:
        if dist[w] > -1:
            continue
        dist[w] = d + 1
        q.append(w)
for i in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] + dist[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys
from collections import deque


class LCA:
    def __init__(self, G, N, root):
        self.T = []
        self.FS = [-1] * N
        self.depth = [-1] * (N + 1)
        self.root = root
        self.depth[N] = float('inf')
        self.dfs(G, root)

        L = len(self.T)

        self.K = L.bit_length() - 1
        self.e = N
        self.pow2 = [1]
        self.mask = [x.bit_length() - 1 for x in range(L + 1)]
        for i in range(self.K):
            self.pow2.append(self.pow2[-1] * 2)
        self.ST = [[self.e] * (L) for i in range(self.K + 1)]
        self.ST[0] = self.T

        for i in reversed(range(L)):
            for k in range(1, self.K + 1):
                if L < i + self.pow2[k]:
                    break
                self.ST[k][i] = self.op(self.ST[k - 1][i],
                                        self.ST[k - 1][i + self.pow2[k - 1]])

    def op(self, a, b):
        return a if self.depth[a] < self.depth[b] else b

    def st_query(self, l, r):
        if l >= r:
            return self.e
        x = r - l
        t = self.mask[x]
        return self.op(self.ST[t][l], self.ST[t][r - self.pow2[t]])

    def lca(self, u, v):
        l, r = self.FS[u], self.FS[v]
        if l > r:
            l, r = r, l
        return self.st_query(l, r + 1)

    def dfs(self, G, s):
        stack = deque([(s, -1, 0)])
        while stack:
            v, p, d = stack.pop()
            if v < 0:
                self.T.append(~v)
                continue
            self.depth[v] = d
            self.FS[v] = len(self.T)
            self.T.append(v)
            for nv in G[v]:
                if nv == p:
                    continue
                stack.append((~v, v, d + 1))
                stack.append((nv, v, d + 1))

    def dist(self, u, v):
        p = self.lca(u, v)
        return self.depth[u] + self.depth[v] - self.depth[p] * 2


n, q = map(int, input().split())
G = [[] for i in range(n)]

for i in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

lca = LCA(G, n, 0)
ans = []
for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if lca.dist(c, d) % 2:
        ans.append('Road')
    else:
        ans.append('Town')

print(*ans, sep='\n')
from collections import deque

N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

dist = [float('inf') for _ in range(N)]
dist[0] = 0

data = [0]
data = deque(data)
while data:
    pos = data.popleft()
    for el in graph[pos]:
        if dist[el] == float('inf'):
            dist[el] = dist[pos] + 1
            data.append(el)

for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')class FastTree:
    def __init__(self, graph):
        self.n = len(graph)
        self.ancestor_table = [None] * self.n

        stack = [[0, -1, 0]]

        while stack:
            data = stack[-1]
            cur, parent, index = data
            children = graph[cur]
            if index >= len(children):
                stack.pop()
            else:
                if index == 0:
                    depth = len(stack)
                    table = []
                    i = 1
                    while i < depth:
                        table.append(stack[depth - i - 1][0])
                        i *= 2
                    self.ancestor_table[cur] = (depth - 1, table)

                child = children[index]
                if parent != child:
                    stack.append([child, cur, 0])
                data[2] += 1

    def get_depth(self, c):
        return self.ancestor_table[c][0]


N, Q = map(int, input().split())

graph = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

ft = FastTree(graph)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    dc = ft.get_depth(c)
    dd = ft.get_depth(d)
    #	x = ft.get_common_ancestor(c, d)
    #	dx = ft.get_depth(x)
    #	l = (dc - dx) + (dd - dx)
    #	print(dx, dc, dd)
    l = dc + dd
    if l % 2 == 1:
        print("Road")
    else:
        print("Town")
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

D = [0] * N
vst = set([0])
stc = [0]
dst = [0]
while stc:
    cur = stc.pop()
    d = dst.pop()
    D[cur] = d
    for to in G[cur]:
        if to in vst:
            continue
        stc.append(to)
        dst.append(d + 1)
        vst.add(to)

ans = []
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (D[c] - D[d]) % 2:
        ans.append('Road')
    else:
        ans.append('Town')

print(*ans, sep='\n')
import sys

sys.setrecursionlimit(10**8)

N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]

g = [set() for _ in range(N)]
for a, b in AB:
    a -= 1
    b -= 1
    g[a].add(b)
    g[b].add(a)

color = [-1] * N
color[0] = 0


def set_color_around(i):
    for to in g[i]:
        if color[to] != -1:
            continue
        color[to] = not color[i]
        set_color_around(to)


set_color_around(0)

for c, d in CD:
    c -= 1
    d -= 1
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)
#
# - construct
# prv[u] = v: 頂点uの一つ上の祖先頂点v
# - lca
# kprv[k][u] = v: 頂点uの2^k個上の祖先頂点v
# depth[u]: 頂点uの深さ (根頂点は0)
import sys

sys.setrecursionlimit(500000)
N, Q = map(int, input().split())
G = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)

# Euler Tour の構築
S = []
F = [0] * 200000
depth = [-1] * 200000


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in G[v]:
        if depth[w] == -1:
            dfs(w, d + 1)
        S.append(v)


depth[0] = 0
dfs(0, 0)
for i in range(Q):
    c, d = map(int, input().split())
    if (depth[c - 1] + depth[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
def d_collision():
    import sys
    sys.setrecursionlimit(10**7)
    N, Q = [int(_) for _ in input().split()]
    Roads = [[int(col) - 1 for col in input().split()] for row in range(N - 1)]
    Queries = [[int(col) - 1 for col in input().split()] for row in range(Q)]

    class LowestCommonAncestor(object):
        """木の最近共通祖先を求める"""
        def __init__(self, tree):
            """入力は木を二次元リストで表現したものであることを前提としている"""
            self.n = len(tree)
            self.tree = tree
            # parent[j][k]: 頂点 j から根に向かって 2**k 回進んで到達する頂点
            self.parent = [[] for _ in range(self.n)]
            # depth[j]: 根 (頂点 0) に対する頂点 j の深さ
            self.depth = [None] * self.n
            self.stack = []
            self._make_parent_table(0)

        def _make_parent_table(self, vertex):
            """parent と depth に値を格納"""
            recursion_time = len(self.stack)
            self.depth[vertex] = recursion_time

            # 親を (存在する限り) 2**k 回辿る
            k = 0
            while 2**k <= recursion_time:
                self.parent[vertex].append(self.stack[recursion_time - 2**k])
                k += 1

            self.stack.append(vertex)

            for next_vertex in self.tree[vertex]:
                if self.depth[next_vertex] is not None:
                    continue
                self._make_parent_table(next_vertex)
            self.stack.pop()

        def depth_from_root(self, v):
            return self.depth[v]

        def get_lca(self, u, v):
            """頂点 u, v の LCA を求める"""
            if self.depth[u] > self.depth[v]:  # より深い頂点を v とする
                u, v = v, u

            depth_add = self.depth[u] + self.depth[v]
            depth_diff = self.depth[v] - self.depth[u]

            # u と v が同じ深さになるまで v (深い方) を根に向かって登らせる
            while depth_diff > 0:
                k = 1
                while 2**k < depth_diff:
                    k += 1
                k -= 1

                v = self.parent[v][k]
                depth_diff -= 2**k

            # u と v が同じ頂点を指さないギリギリまで u, v を根に向かって登らせる
            # そこから 1 つ登った頂点は u, v の LCA である
            while u != v:
                k = 1
                length = len(self.parent[u])
                # 登ることができ，親が同じでない
                while length > k and self.parent[u][k] != self.parent[v][k]:
                    k += 1
                k -= 1
                u = self.parent[u][k]
                v = self.parent[v][k]
            return u

    tree = [[] for _ in range(N)]
    for a, b in Roads:
        tree[a].append(b)
        tree[b].append(a)

    lowest_common_ancestor = LowestCommonAncestor(tree)
    lca = lowest_common_ancestor.get_lca
    dist = lowest_common_ancestor.depth_from_root
    ans = []

    for a, b in Queries:
        l = lca(a, b)
        d = dist(a) + dist(b) - 2 * dist(l) + 1
        ans.append('Road' if d % 2 == 0 else 'Town')
    return '\n'.join(map(str, ans))


print(d_collision())
import heapq

N, Q = map(int, input().split())
L = [[] * N for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    L[a - 1].append(b - 1)
    L[b - 1].append(a - 1)

from collections import deque

dist = [-1] * N
que = deque([0])
dist[0] = 0

while que:
    v = que.popleft()
    d = dist[v]
    for w in L[v]:
        if dist[w] > -1:
            continue
        dist[w] = d + 1
        que.append(w)

for _ in range(Q):
    c, d = map(int, input().split())
    if c > d:
        c, d = d, c
    C = dist[c - 1]
    D = dist[d - 1]
    if (D - C) % 2 == 1:
        print('Road')
    else:
        print('Town')
def int_sp():
    return map(int, input().split())


def li_int_sp():
    return list(map(int, input().split()))


def trans_li_int_sp():
    return list(map(list, (zip(*[li_int_sp() for _ in range(N)]))))


# おまじない
import sys
import pdb

sys.setrecursionlimit(1000000)
# 入力の読み込み
N, Q = map(int, input().split())
G = [[] for i in range(N)]
# G[i] は都市iから道路で直接繋がっている都市のリスト
for i in range(N - 1):
    A, B = map(int, input().split())
    G[A - 1].append(B - 1)
    G[B - 1].append(A - 1)

visited_time = [-1] * (N)
temp = [False] * (N)


# dfs
def dfs(v, dist):
    if temp[v]: return  # 同じ頂点を2度以上調べないためのreturn
    temp[v] = True
    visited_time[v] = dist
    for vv in G[v]:
        dfs(vv, dist + 1)


ans = 0
# 0ノードからスタート
dfs(0, 0)

for _ in range(Q):
    c, d = li_int_sp()
    if abs(visited_time[c - 1] - visited_time[d - 1]) % 2 == 1:
        print('Road')
    else:
        print('Town')
from collections import deque


def bfs(e, n):
    path = deque()
    cost = [0] * n
    path.append(0)
    while path:
        now = path.popleft()
        for next in e[now]:
            if cost[next] == 0:
                cost[next] = cost[now] + 1
                path.append(next)
    return cost


def main():
    N, Q = map(int, input().split())
    e = [[] for _ in range(N)]
    for i in range(N - 1):
        a, b = map(int, input().split())
        e[a - 1].append(b - 1)
        e[b - 1].append(a - 1)
    #前処理なし??
    cost = bfs(e, N)
    for k in range(Q):
        c, d = map(int, input().split())
        print("Road") if cost[c - 1] % 2 != cost[d - 1] % 2 else print("Town")


main()
import queue

n, q = map(int, input().split())

g = [[] for i in range(n)]
for i in range(n - 1):
    a_i, b_i = map(int, input().split())
    a_i -= 1
    b_i -= 1
    g[a_i].append(b_i)
    g[b_i].append(a_i)

bipartite_flags = [False] * n

adj_q = queue.Queue()
adj_q.put(0)
visited = [False] * n
while not adj_q.empty():
    node = adj_q.get()
    for adj in g[node]:
        if not visited[adj]:
            bipartite_flags[adj] = not bipartite_flags[node]
            adj_q.put(adj)
            visited[adj] = True

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    print("Town" if bipartite_flags[c] == bipartite_flags[d] else "Road")
import sys

sys.setrecursionlimit(100000)

N, Q = map(int, input().split())

bridges = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    bridges[a - 1].append(b - 1)
    bridges[b - 1].append(a - 1)
a = [-1] * N
a[0] = 0


def bfs(c):
    for i in bridges[c]:
        if a[i] == -1:
            a[i] = 0 if a[c] else 1
            bfs(i)


bfs(0)

for i in range(Q):
    x, y = map(int, input().split())
    print('Road' if a[x - 1] != a[y - 1] else 'Town')
import queue
import sys

s = sys.stdin.readlines()

n, q = map(int, s[0].split())

adj = [[] for _ in range(n)]
ad = []
for e in s[1:n]:
    a, b = map(int, e.split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * n
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in adj[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for e in s[n:]:
    c, d = map(int, e.split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
#
# LCA : Lowest Common Ancestor
#
import collections
import sys

sys.setrecursionlimit(10**6)


class LCA:
    def __init__(self, n, adj):
        K = 1
        while (1 << K) < n:
            K += 1
        self.parent = [[-1] * n for _ in range(K)]
        self.dist = [-1] * n
        self._dfs2(node=0, par=-1, d=0, adj=adj)
        for k in range(K - 1):
            for v in range(n):
                if self.parent[k][v] < 0:
                    self.parent[k + 1][v] = -1
                else:
                    self.parent[k + 1][v] = self.parent[k][self.parent[k][v]]

    def _dfs(self, node, par, d, adj):
        self.parent[0][node] = par
        self.dist[node] = d
        for nd in adj[node]:
            if nd == par: continue
            self._dfs(nd, node, d + 1, adj)

    def _dfs2(self, node, par, d, adj):
        s = [(node, par, d)]
        while s:
            node, par, d = s.pop()
            self.parent[0][node] = par
            self.dist[node] = d
            for nd in adj[node]:
                if nd == par: continue
                s.append((nd, node, d + 1))

    def query(self, u: int, v: int) -> int:
        if self.dist[u] < self.dist[v]: u, v = v, u
        K = len(self.parent)
        # LCA までの距離を同じにする
        for k in range(K):
            if (self.dist[u] - self.dist[v]) >> k & 1:
                u = self.parent[k][u]
        # 二分探索で LCA を求める
        if u == v: return u
        for k in range(K - 1, -1, -1):
            if self.parent[k][u] != self.parent[k][v]:
                u = self.parent[k][u]
                v = self.parent[k][v]
        return self.parent[0][u]

    def distance(self, u: int, v: int) -> int:
        return self.dist[u] + self.dist[v] - 2 * self.dist[self.query(u, v)]

    def is_on_path(self, u, v, a) -> bool:
        return self.distance(u, a) + self.distance(a, v) == self.distance(u, v)


N, Q = map(int, input().split())
adj = collections.defaultdict(list)
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    adj[a].append(b)
    adj[b].append(a)

lca = LCA(N, adj)
for _ in range(Q):
    c, d = map(int, input().split())
    if lca.distance(c - 1, d - 1) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys
import math
from collections import deque, Counter

sys.setrecursionlimit(10**7)
int1 = lambda x: int(x) - 1

mi = lambda: map(int, input().split())
li = lambda: list(mi())
mi1 = lambda: map(int1, input().split())
li1 = lambda: list(mi1())
mis = lambda: map(str, input().split())
lis = lambda: list(mis())

from collections import defaultdict
"""
d=defaultdict(int) #初期値 0
d=defaultdict(lambda:1) #初期値 1
"""

mod = 10**9 + 7
Mod = 998244353
INF = 10**18
ans = 0

# N: 頂点数
N, q = mi()
# edge:辺
edge = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)
# Euler Tour の構築
S = []
F = [0] * N
depth = [-1] * N
depth[0] = 0


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in edge[v]:
        if depth[w] == -1:
            dfs(w, d + 1)
            S.append(v)


dfs(0, 0)

# 存在しない範囲は深さが他よりも大きくなるようにする
INF = (N, None)

# LCAを計算するクエリの前計算
M = 2 * N
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


# LCAの計算 (外から呼び出す関数)
def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


#クエリ処理 0-index に注意
for i in range(q):
    c, d = mi1()
    t = query(c, d)
    s = depth[c] + depth[d] - 2 * depth[t]
    if s % 2 == 0:
        print('Town')
    else:
        print('Road')
import math
from sys import setrecursionlimit

setrecursionlimit(1000000)


def ADJ(pos, ppos=None):
    log.append(pos)
    for i in D[pos - 1]:
        if i != ppos:
            d[i - 1] = d[pos - 1] + 1
            ADJ(i, pos)
    if d[pos - 1] > 0:
        D[pos - 1] = [
            log[-((2**j) + 1)]
            for j in range(int(math.log(d[pos - 1], 2)) + 1)
        ]
    else:
        D[pos - 1] = []
    log.pop()


def Search(a, b, n):
    #print(a, b, n)
    for k in range(len(D[b - 1])):
        if D[a - 1][k] == D[b - 1][k]:
            if k <= 1:
                return n + (2**(k + 1))
            else:
                return Search(D[a - 1][k - 1], D[b - 1][k - 1], n + (2**(k)))
    else:
        return Search(D[a - 1][-1], D[b - 1][-1], n + (2**(len(D[b - 1]))))


N, Q = map(int, input().split())
D = [[] for _ in range(N)]
d = [0] * N
for i in range(N - 1):
    x, y = map(int, input().split())
    D[x - 1].append(y)
    D[y - 1].append(x)
log = []
ADJ(N // 2)
#print(d)
#print(*D, sep = "\n")
for i in range(Q):
    a, b = map(int, input().split())
    sa = d[b - 1] - d[a - 1]
    if sa < 0:
        a, b = b, a
        sa *= -1
    print('Town' if sa % 2 == 0 else 'Road')
from collections import deque

n, q = map(int, input().split())
g = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b)
    g[b - 1].append(a)

#0, 1に採色
start = 1
color = [-1 for _ in range(n)]  #dist
color[start - 1] = 0
todo = deque([start])
seen = deque()

while len(todo) > 0:
    seek = todo.popleft()
    seen.append(seek)

    for v in g[seek - 1]:
        if color[v - 1] == -1:
            color[v - 1] = 1 - color[seek - 1]
            todo.append(v)

for _ in range(q):
    c, d = map(int, input().split())

    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
(N, _), *r = [map(int, s.split()) for s in open(0)]
G = [[] for _ in r + [7]]
for a, b in r[:N - 1]:
    G[a] += b,
    G[b] += a,
V = [1] * N + [0]
q = [N]
while q:
    i = q.pop()
    for j in G[i]:
        q += [j] * V[j]
        V[j] = ~V[i]
for c, d in r[N - 1:]:
    print('RTooawdn'[V[c] == V[d]::2])
def main():
    import sys
    input = sys.stdin.readline
    from collections import deque
    N, Q = map(int, input().split())
    connect = [list() for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        connect[a - 1].append(b - 1)
        connect[b - 1].append(a - 1)
    distance = [-1] * N
    q = deque()
    q.append((0, 0))
    while q:
        now = q.popleft()
        now_pos, distance_from_zero = now
        distance[now_pos] = distance_from_zero
        for nxt in connect[now_pos]:
            if distance[nxt] > -1:
                continue
            q.append((nxt, distance_from_zero + 1))
    #print(distance)
    for _ in range(Q):
        c, d = map(int, input().split())
        dis = distance[c - 1] + distance[d - 1]
        if dis % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
from collections import deque

n, q = map(int, input().split())

g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1] += [b - 1]
    g[b - 1] += [a - 1]

visited = [-1] * n
deq = deque([0])
visited[0] = 0

while deq:
    v = deq.pop()
    for nv in g[v]:
        if visited[nv] != -1:
            continue
        visited[nv] = visited[v] ^ 1
        deq.append(nv)

for _ in range(q):
    c, d = map(int, input().split())
    if visited[c - 1] == visited[d - 1]:
        print('Town')
    else:
        print('Road')from collections import deque

n, q = map(int, input().split())
graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
dist = [10**18] * n
dist[0] = 0
p = deque()
p.append(0)
while len(p) > 0:
    x = p.popleft()
    for y in graph[x]:
        if dist[y] > dist[x] + 1:
            dist[y] = dist[x] + 1
            p.append(y)
ans = []
for _ in range(q):
    c, d = map(int, input().split())
    if (dist[c - 1] + dist[d - 1]) % 2 == 0:
        ans.append("Town")
    else:
        ans.append("Road")
print(*ans, sep="\n")
n, q = map(int, input().split())
ab = [list(map(int, input().split())) for i in range(n - 1)]
cd = [list(map(int, input().split())) for i in range(q)]
import sys

sys.setrecursionlimit(10**7)
from collections import defaultdict

roads = defaultdict(list)
for a, b in ab:
    roads[a - 1].append(b - 1)
    roads[b - 1].append(a - 1)

color = [-10**10] * n


def dfs(maenoiro, gen):
    color[gen] = not maenoiro
    for i in roads[gen]:
        if color[i] < 0:
            dfs(color[gen], i)


dfs(1, 0)

for c, d in cd:
    c, d = c - 1, d - 1
    print("Road" if color[c] != color[d] else "Town")
import sys
from collections import deque


def source():
    spi = lambda x: map(int, x.split())
    S = sys.stdin.read().splitlines()

    n, q = spi(S[0])
    roads = [list(spi(row)) for row in S[1:n]]

    G = [[] for _ in range(n)]
    for s, e in roads:
        s -= 1
        e -= 1
        G[s] += [e]
        G[e] += [s]

    q_list = [list(spi(row)) for row in S[n:n + q]]
    queries = [[i - 1, v - 1] for i, v in q_list]

    return n, q, G, queries


def bfs(n, G):
    # キュー
    queue = deque([0])
    # 最短経路の記録
    dp = [-1] * n
    # スタート地点は0に
    dp[0] = 0

    while queue:
        # 取り出し
        target = queue.pop()
        # targetから行ける場所
        children = G[target]
        for child in children:
            if dp[child] == -1:
                dp[child] = dp[target] + 1
                queue.append(child)

    # dpを返す
    return dp


def solve(n, q, G, queries):
    # bfsを実行
    # BFSを毎回やっていると時間がかかってTLEになるので、差分で求める
    dp = bfs(n, G)

    for c, d in queries:
        dpc, dpd = dp[c], dp[d]
        if dpc % 2 == dpd % 2:
            print('Town')
        else:
            print('Road')


def main():
    n, q, G, queries = source()
    solve(n, q, G, queries)


if __name__ == '__main__':
    main()
import sys

sys.setrecursionlimit(100000)


def scan(s, c):
    if lb[s] == None:
        if c % 2 == 0:
            lb[s] = [0, c]
        else:
            lb[s] = [1, c]
    else:
        if lb[s][1] > c:
            if c % 2 == 0:
                lb[s] = [0, c]
            else:
                lb[s] = [1, c]
        else:
            return
    for i in la[s]:
        scan(i, c + 1)
    return


n, q = map(int, input().split())
la = [[] for _ in range(n + 1)]
lb = [None] * (n + 1)
for i in range(n - 1):
    a, b = map(int, input().split())
    la[a].append(b)
    la[b].append(a)
scan(1, 0)
for j in range(q):
    c, d = map(int, input().split())
    if lb[c][0] == lb[d][0]:
        print("Town")
    else:
        print("Road")
from itertools import *

# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)
#
# - construct
# prv[u] = v: 頂点uの一つ上の祖先頂点v
# - lca
# kprv[k][u] = v: 頂点uの2^k個上の祖先頂点v
# depth[u]: 頂点uの深さ (根頂点は0)


def construct(prv):
    kprv = [prv]
    S = prv
    for k in range(lv):
        T = [0] * n
        for i in range(n):
            if S[i] is None:
                continue
            T[i] = S[S[i]]
        kprv.append(T)
        S = T
    return kprv


def lca(u, v, kprv, depth):
    dd = depth[v] - depth[u]
    if dd < 0:
        u, v = v, u
        dd = -dd

    # assert depth[u] <= depth[v]
    for k in range(lv + 1):
        if dd & 1:
            v = kprv[k][v]
        dd >>= 1

    # assert depth[u] == depth[v]
    if u == v:
        return u

    for k in range(lv - 1, -1, -1):
        pu = kprv[k][u]
        pv = kprv[k][v]
        if pu != pv:
            u = pu
            v = pv

    # assert kprv[0][u] == kprv[0][v]
    return kprv[0][u]


def distance(u, v, kprv, depth):
    return depth[u] + depth[v] - 2 * depth[lca(u, v, kprv, depth)]


n, q = map(int, input().split())
m = [[] for _ in [0] * n]  # 近傍
for _ in [0] * (n - 1):
    a, b = map(int, input().split())
    m[a - 1] += [b - 1]
    m[b - 1] += [a - 1]
depth = [0] * n
prv = [-1] * n  # 親
c = [[] for _ in [0] * n]  # 子供
prv[0] = float('inf')  # 根が 0
l = [0]  # 根が 0
order = [0] * n
o = 0
while l:
    v = l.pop()
    order[v] = o
    o += 1
    for u in m[v]:
        if prv[u] < 0:
            prv[u] = v
            c[v] += [u]
            depth[u] = depth[v] + 1
            l += [u]
prv[0] = None
lv = (n - 1).bit_length()
kprv = construct(prv)
for i in range(q):
    c, d = map(int, input().split())
    if distance(c - 1, d - 1, kprv, depth) % 2 == 1:
        print("Road")
    else:
        print("Town")
import sys

sys.setrecursionlimit(100000)
n, q = map(int, input().split())
r = list([] for i in range(n - 1))
for i in range(n - 1):
    r[i] = list(map(int, input().split()))
t = list([] for i in range(n))
for i in range(n - 1):
    t[r[i][0] - 1].append(r[i][1] - 1)
    t[r[i][1] - 1].append(r[i][0] - 1)
l = [0] * n


def dt(x, y, z):
    for i in t[x]:
        if i != z:
            l[i] = y + 1
            dt(i, y + 1, x)


dt(0, 0, None)
for i in range(q):
    c, d = map(int, input().split())
    f = l[c - 1] + l[d - 1]
    if f % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
tree = [[] for i in range(N)]
d2one = [0 for i in range(N)]
is_visited = [False for i in range(N)]
for i in range(N - 1):
    ai, bi = map(int, input().split())
    ai = ai - 1
    bi = bi - 1
    tree[ai] += [bi]
    tree[bi] += [ai]

queue = deque()
queue.append((0, 0))
is_visited[0] = True

while queue:
    node, d = queue.popleft()
    d2one[node] = d
    for to_node in tree[node]:
        if not is_visited[to_node]:
            queue.append((to_node, d + 1))
            is_visited[to_node] = True

for i in range(Q):
    ci, di = map(int, input().split())
    ci = ci - 1
    di = di - 1
    if d2one[ci] % 2 == d2one[di] % 2:
        print("Town")
    else:
        print("Road")
import sys
import math
from collections import deque, Counter
#sys.setrecursionlimit(10**7)
int1 = lambda x: int(x) - 1

mi = lambda: map(int, input().split())
li = lambda: list(mi())
mi1 = lambda: map(int1, input().split())
li1 = lambda: list(mi1())
mis = lambda: map(str, input().split())
lis = lambda: list(mis())

from collections import defaultdict
"""
d=defaultdict(int) #初期値 0
d=defaultdict(lambda:1) #初期値 1
"""

mod = 10**9 + 7
Mod = 998244353
INF = 10**18
ans = 0

d = deque()
n, q = mi()
# edge:辺
edge = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)
d.append(0)
depth = [-1] * n
depth[0] = 0
while d:
    x = d.pop()
    for i in edge[x]:
        if depth[i] == -1:
            depth[i] = depth[x] + 1
            d.append(i)
for i in range(q):
    c, d = mi1()
    s = depth[c] + depth[d]
    if s % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
G = [[] for i in range(n)]  # n : Number of vertices
for i in range(n - 1):  # n - 1 : Number of edges
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)  # Undirected graph

dist = [None] * n  # Distance to each vertex
que = deque([0])
dist[0] = 0
color = [None] * n
color[0] = True
while que:
    v = que.popleft()
    d = dist[v]
    for w in G[v]:
        if dist[w] is not None:
            continue
        dist[w] = d + 1
        if (dist[w] % 2 == 0):
            color[w] = True
        else:
            color[w] = False
        que.append(w)

for i in range(q):
    s, t = map(int, input().split())
    if (color[s - 1] == color[t - 1]):
        print("Town")
    else:
        print("Road")
import sys
from collections import deque

sys.setrecursionlimit(10**6)

N, Q = list(map(int, input().split()))
nodes = [[] for _ in range(N)]
child = [False] * N
for _ in range(N - 1):
    a, b = map(int, input().split())
    nodes[a - 1].append(b - 1)
    child[a - 1] = True
    nodes[b - 1].append(a - 1)
    child[b - 1] = True
parents = [0] * N
depths = [0] * N


def get_child(depth, now):
    if depths[now] != 0:
        return
    depths[now] = depth
    for i in range(len(nodes[now])):
        get_child(depth + 1, nodes[now][i])
        parents[nodes[now][i]] = now


def solve(child, nodes):
    for i in range(len(child)):
        if not child[i]:
            parent = i
            break
    get_child(0, parent)
    parents[parent] = -1


get_child(0, 0)
parents[0] = -1

for _ in range(Q):
    c, d = map(int, input().split())
    dist = abs(depths[c - 1] - depths[d - 1] + 1)
    if dist % 2 == 0:
        print("Road")
    else:
        print("Town")
# print(depths)
# region Template
# fmt: off
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)
from collections import Counter, deque, defaultdict


# from itertools import combinations, permutations, accumulate, groupby, product
# from bisect import bisect_left,bisect_right
# from heapq import heapify, heappop, heappush
# from math import floor, ceil ,factorial, gcd
# from operator import itemgetter
# from copy import deepcopy
def I():
    return int(input())


def MI():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


def SI():
    return input().rstrip()


def printns(x):
    print('\n'.join(x))


def printni(x):
    print('\n'.join(list(map(str, x))))


inf = 10**17
mod = 10**9 + 7
#mod =998244353


def INT():
    return int(sys.stdin.readline().rstrip())


def LINT():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def STR():
    return sys.stdin.readline().rstrip()


def LSTR():
    return list(sys.stdin.readline().rstrip().split())


# fmt: on
# endregion Template


def main():
    N, Q = MI()
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = MI()
        a -= 1
        b -= 1
        G[a].append(b)
        G[b].append(a)

    dist = [-1] * N
    dist[0] = 0
    que = deque([])
    que.append(0)

    while que:
        cur = que[0]
        que.popleft()
        for next in G[cur]:
            if dist[next] != -1:
                continue
            dist[next] = dist[cur] + 1
            que.append(next)

    for _ in range(Q):
        c, d = MI()
        c -= 1
        d -= 1
        if (dist[c] - dist[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
""" convenient functions
# for i, a in enumerate(iterable)
# q, mod = divmod(a, b)
# divmod(x, y) returns the tuple (x//y, x%y)
# Higher-order function: reduce(operator.mul, xyz_count, 1)
# manage median(s) using two heapq https://atcoder.jp/contests/abc127/tasks/abc127_f
"""
"""convenient decorator
# @functools.lru_cache():
# to facilitate use of recursive function
    # ex:
    # from functools import lru_cache
    # import sys
    # sys.setrecursionlimit(10**9)
    # @lru_cache(maxsize=None)
    # def fib(n):
    #     if n < 2:
    #         return n
    #     return fib(n-1) + fib(n-2)
    # print(fib(1000))
"""

import sys

sys.setrecursionlimit(10**9)
import typing
from typing import Deque, List, Tuple, Any, Callable

from itertools import accumulate, combinations, permutations, product, combinations_with_replacement  # https://docs.python.org/ja/3/library/itertools.html
# accumulate() returns iterator! to get list: list(accumulate())
from math import factorial, ceil, floor, sqrt
from math import degrees, radians, tan, atan, atan2, cos, acos, sin, asin, pi
# radians(180) が180°を意味します。sin180°はsin(radians(180))と書けばOK。誤差があるので、完全一致必要な場合は注意。
# degrees(atan(1)) => 45.0

# class Vec2D():
#     """2つの2次元ベクトルから間の角度を回転方向付きで求める(-pi < theta <= pi)
#     # 未完成
#     calc_thetaで求めた値はcos()などの引数として使用できる。
#     ref: http://www5d.biglobe.ne.jp/~noocyte/Programming/Geometry/RotationDirection.html#GetAngle
#     ref: https://atcoder.jp/contests/abc207/tasks/abc207_d
#     """
#     def __init__(self, va: List[int], vb: List[int]) -> None:
#         self.va = va
#         self.vb = vb
#         self.inner_product = self.inner_product_2D(self.va, self.vb)
#         self.cross_product = self.cross_product_2D(self.va, self.vb)
#         self.theta = self.calc_theta(self.cross_product, self.inner_product)

#     def inner_product_2D(self, va: List[int], vb: List[int]) -> int:
#         return sum([a*b for a, b in zip(va, vb)])

#     def cross_product_2D(self, va: List[int], vb: List[int]) -> int:
#         return va[0]*vb[1] - va[1]*vb[0]

#     def calc_theta(self, cross_product: int, inner_product: int) -> float:
#         return atan2(cross_product, inner_product)

# optimize # for python (not pypy)
# from scipy.optimize import fmin
# https://atcoder.jp/contests/abc151/tasks/abc151_f
# ex:
# def calc(k):
#     i, j = k
#     ans = 0
#     for x, y in XY:
#         ans = max(ans, (x-i)**2+(y-j)**2)
#     return ans
# x, y = fmin(calc, [500, 500], disp=0)


def sum_xor(A: List, max_digit: int = 61, MOD: int = 10**9 + 7):
    # https://atcoder.jp/contests/abc147/tasks/abc147_d
    # count_each_digit
    L: List[int] = [0] * max_digit
    for a in A:
        tmp = a
        current_digit = 0
        while tmp:
            tmp, residual = divmod(tmp, 2)
            if residual:
                L[current_digit] += 1
            current_digit += 1

    ans: int = 0
    tmp: int = 1
    for i in range(max_digit):
        ans += (len(A) - L[i]) * L[i] * tmp
        ans %= MOD
        tmp *= 2
        tmp %= MOD
    return ans


def factorize(n):
    """return the factors of the Arg and count of each factor
    
    Args:
        n (long): number to be resolved into factors
    
    Returns:
        list of tuples: factorize(220) returns [(2, 2), (5, 1), (11, 1)]
    """
    fct = []  # prime factor
    b, e = 2, 0  # base, exponent
    while b * b <= n:
        while n % b == 0:
            n = n // b
            e = e + 1
        if e > 0:
            fct.append((b, e))
        b, e = b + 1, 0
    if n > 1:
        fct.append((n, 1))
    return fct


def combinations_count(n, r):
    """Return the number of selecting r pieces of items from n kinds of items.
    
    Args:
        n (long): number
        r (long): number
    
    Raises:
        Exception: not defined when n or r is negative
    
    Returns:
        long: number
    """
    # TODO: How should I do when n - r is negative?
    if n < 0 or r < 0:
        raise Exception(
            'combinations_count(n, r) not defined when n or r is negative')
    if n - r < r: r = n - r
    if r < 0: return 0
    if r == 0: return 1
    if r == 1: return n
    numerator = [n - r + k + 1 for k in range(r)]
    denominator = [k + 1 for k in range(r)]
    for p in range(2, r + 1):
        pivot = denominator[p - 1]
        if pivot > 1:
            offset = (n - r) % p
            for k in range(p - 1, r, p):
                numerator[k - offset] /= pivot
                denominator[k] /= pivot
    result = 1
    for k in range(r):
        if numerator[k] > 1:
            result *= int(numerator[k])
    return result


def combinations_with_replacement_count(n, r):
    """Return the number of selecting r pieces of items from n kinds of items allowing individual elements to be repeated more than once.
    
    Args:
        n (long): number
        r (long): number
    
    Raises:
        Exception: not defined when n or r is negative
    
    Returns:
        long: number
    """
    if n < 0 or r < 0:
        raise Exception(
            'combinations_with_replacement_count(n, r) not defined when n or r is negative'
        )
    elif n == 0:
        return 1
    else:
        return combinations_count(n + r - 1, r)


def permutations_count(n, r, MOD=None):
    ans = 1
    if MOD:
        for i in range(r):
            ans = (ans * (n - i)) % MOD
    else:
        for i in range(r):
            ans = (ans * (n - i))
    return ans


from copy import deepcopy, copy  # https://docs.python.org/ja/3/library/copy.html
import operator
# from operator import add, mul
from operator import itemgetter  #sort
# ex1: List.sort(key=itemgetter(1))
# ex2: sorted(tuples, key=itemgetter(1,2))
# ex3: ABC.sort(key=lambda x: x[0]+x[1]) # sort by a+b <= itemgetter is not used
from functools import partial, reduce, lru_cache


# ************ DP ************
def chmin(dp, i, x):
    """chmin; same as:
    dp[i] = min(dp[i], x)
    ref: https://twitter.com/cs_c_r_5/status/1266610488210681857
    Args:
        dp (list): one dimensional list
        i (int): index of dp
        x (int): value to be compared with

    Returns:
        bool: True if update is done
    
    ex:
        # one dimensional dp
        chmin(dp,i,x)
        
        # two dimensional dp
        chmin(dp[i],j,x)
    """
    if x < dp[i]:
        dp[i] = x
        return True
    return False


def chmax(dp, i, x):
    """chmax; same as:
    dp[i] = max(dp[i], x)
    ref: https://twitter.com/cs_c_r_5/status/1266610488210681857
    Args:
        dp (list): one dimensional list
        i (int): index of dp
        x (int): value to be compared with

    Returns:
        bool: True if update is done
    
    ex:
        # one dimensional dp
        chmax(dp,i,x)
        
        # two dimensional dp
        chmax(dp[i],j,x)
    """
    if x > dp[i]:
        dp[i] = x
        return True
    return False


# ************ bit演算 ************
# bitcount (population count; popcount)
def bit_count(x):
    """count number of bit
    # ref: https://qiita.com/zawawahoge/items/8bbd4c2319e7f7746266
    Args:
        x (int): number. Advice: use int('10110', 2) if input is '10110'
    Returns:
        int: bit summation
    """
    # 2bitごとの組に分け、立っているビット数を2bitで表現する
    x = x - ((x >> 1) & 0x5555555555555555)
    # 4bit整数に 上位2bit + 下位2bit を計算した値を入れる
    # bin(0x333) => 0b1100110011
    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)

    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f  # 8bitごと
    x = x + (x >> 8)  # 16bitごと
    x = x + (x >> 16)  # 32bitごと
    x = x + (x >> 32)  # 64bitごと = 全部の合計
    return x & 0x0000007f


def bit_last(x):
    """
    Get the last digit where 1 stands (0-indexed)
    x.bit_length()と同じ。
    ref: https://www.slideshare.net/KMC_JP/slide-www

    Args:
        x (int): bit

    Returns:
        int: last digit
    
    >>> bit_last(1)
    0
    >>> bit_last(4)
    2
    >>> bit_last(6)
    1
    >>> bit_last(0b1011000)
    3
    """
    return (x & -x).bit_length() - 1


def bit_first(x):
    """Get the first digit where 1 stands(0-indexed)

    Args:
        x (int): bit

    Returns:
        int: first digit
    >>> bit_first(1)
    0
    >>> bit_first(4)
    2
    >>> bit_first(6)
    2
    >>> bit_first(0b1011000)
    6
    """
    return x.bit_length() - 1


atoz = list('abcdefghijklmnopqrstuvwxyz')  # 26
AtoZ = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')  # 26
HEXADECIMAL = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    "A": 10,
    "B": 11,
    "C": 12,
    "D": 13,
    "E": 14,
    "F": 15
}
ALPHAtoNUM = lambda c: ord(c) - ord('A') + 1
alphatonum = lambda c: ord(c) - ord('a') + 1
atoA = {a: A for a, A in zip(atoz, AtoZ)}
Atoa = {A: a for a, A in zip(atoz, AtoZ)}
YesNo = lambda condition, Yes='Yes', No='No': print(
    Yes) if condition else print(No)
# ************ Math ************
# greatest common divisor
from math import gcd
# from fractions import gcd
# def gcd(a,b):
#     # from fractions import gcd # Deprecated since version 3.5: Use math.gcd() instead.
#     # => 最近の環境でfractions.gcdを使うとTLEする。
#     # aまたはbが0の場合もう一方を返すようにすると良いかも。gcdの単位元を0とするケースがあるため。
#     if a<b:
#         a, b = b, a
#     while a%b !=0 :
#         a, b = b, a%b
#     return b

# def gcd(p,q):
#     while q != 0:
#         r = p % q
#         p = q
#         q = r
#     return p


def gcds(numbers):
    return reduce(gcd, numbers)


# least common multiple
def lcm(x, y):
    return (x * y) // gcd(x, y)


def lcms(numbers):
    return reduce(lcm, numbers, 1)


# 約数列挙 約数
def make_divisors(n, reversed=False):
    """create list of divisors O(root(N))
    
    Args:
        number (int): number from which list of divisors is created
        reversed (bool, optional): ascending order if False. Defaults to False.
    
    Returns:
        list: list of divisors
    """
    divisors = set()
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            divisors.add(i)
            divisors.add(n // i)
    return sorted(list(divisors), reverse=reversed)


# Eratosthenesの篩により、整数end未満の素数を列挙する 素数 "素数List"と"is_prime"を返す。
def sieve_of_eratosthenes(end, typecode="L"):
    """get primes list and is_prime list 
    # len(sieve_of_eratosthenes(10**7)) => 664579; 514ms in pypy
    # len(sieve_of_eratosthenes(10**6)) => 78498; 134ms in pypy
 
    # https://hamukichi.hatenablog.jp/entry/2016/02/17/215948#Eratosthenes%E3%81%AE%E7%AF%A9%E3%81%A8%E5%8C%BA%E9%96%93%E7%AF%A9

    Args:
        end (int): maximum number to be checked
        typecode (str, optional): I don't know.. Defaults to "L".

    Returns:
        array, array: primes, is_prime
    """
    import array
    import textwrap
    assert end > 1
    # 整数iが素数であるかをis_prime[i]が示す
    # 最初はすべてTrueで初期化しておく
    # 最終的にprimesではなくこれを返してもよい
    is_prime = array.array("B", (True for i in range(end)))
    # 0, 1はいずれも素数ではない
    is_prime[0] = False
    is_prime[1] = False
    # 素数を格納する配列
    primes = array.array(typecode)
    # 篩う
    for i in range(2, end):
        if is_prime[i]:
            primes.append(i)
            for j in range(2 * i, end, i):
                is_prime[j] = False  # 素数ではないため除外する
    return primes, is_prime


# 因数分解 因数
class PrimeFactorization:
    '''初期化にO(NloglogN), 因数分解クエリをO(log(k)), 素数判定クエリをO(1)で行う
    >>> pf = PrimeFactorization(100)
    >>> pf.query(100)
    ((2, 2), (5, 2))
    >>> pf.is_prime(97)
    True
    >>> pf.is_prime(99)
    False
    >>> pf.divisors(100)
    [1, 2, 4, 5, 10, 20, 25, 50, 100]
    '''

    # 自分で実装した。
    # https://atcoder.jp/contests/abc177/editorial/82
    # 高速素因数分解
    # 問題： A 以下の数が N 個与えられる。全て素因数分解せよ。
    # 前計算としてエラトステネスの篩を行い、「その数をふるい落とした素数」を配列 D に記録します。
    # 例えば D[4]=D[6]=2,D[35]=5 です。x が素数のときは D[x]=x としておきます。この配列はエラトステネスの篩と同様 O(AloglogA) で構築できます。
    # D[x] は x を割り切る最小の素数なので、この配列 D を利用すると素因数分解を行うときに「試し割り」をする必要がなくなり(D[x]で割ればよい)、1つの数の素因数分解が素因数の個数である O(logA) でできるようになります。
    def __init__(self, Num=10**6):
        # from collections import defaultdict
        from math import floor
        self.Num = Num
        self.D = [-1] * (Num + 1)
        for i in range(2, Num + 1):
            if self.D[i] != -1:
                continue
            self.D[i] = i
            for j in range(1, floor(Num / i) + 1):
                if self.D[j * i] != -1:
                    continue
                else:
                    self.D[j * i] = i

    def divisors(self, k):
        """
        ex:
        >>> pf = PrimeFactorization(300)
        >>> pf.divisors(300)
        [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 25, 30, 50, 60, 75, 100, 150, 300]
        """
        if k == 1:
            return [1]
        return sorted(
            reduce(lambda x, y: x * y, i)
            for i in product(*[[pow(a, bb) for bb in range(b + 1)]
                               for a, b in self.query(k)]))

    def query(self, k):
        """
        ex:
        >>> pf = PrimeFactorization(100)
        >>> pf.query(100)
        ((2, 2), (5, 2))
        """
        from collections import defaultdict
        ans = defaultdict(int)
        tmp = k
        while self.D[tmp] != -1:
            div = self.D[tmp]
            ans[div] += 1
            tmp = tmp // div
        return tuple(ans.items())

    def is_prime(self, k):
        return k == self.D[k]


INF = 10**18
modpow = lambda a, n, p: pow(a, n, p)  # Recursive function in python is slow!


def modinv_Fermat(a, p):
    # evaluate reciprocal using Fermat's little theorem:
    # a**(p-1) is identical to 1 (mod p) when a and p is coprime
    return modpow(a, p - 2, p)


def modinv(a, p):
    # inverse_element 逆元
    # 多分 O(log N)
    # https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a
    b, u, v = p, 1, 0
    while b:
        t = a // b
        a -= t * b
        a, b = b, a
        u -= t * v
        u, v = v, u
    u %= p
    if u < 0:
        u += p
    return u


def modinv_list(n, p):
    if n <= 1:
        return [0, 1][:n + 1]
    else:
        inv_t = [0, 1]
        for i in range(2, n + 1):
            inv_t += [inv_t[p % i] * (p - int(p / i)) % p]
        return inv_t


# factorial: 階乗
def modfactorial_list(n, p):
    if n == 0:
        return [1]
    else:
        l = [0] * (n + 1)
        tmp = 1
        for i in range(1, n + 1):
            tmp = tmp * i % p
            l[i] = tmp
        return l


def modcomb(n, k, p, fac_list=None):
    if not fac_list:
        fac_list = []
    # fac_list = modfactorial_list(100)
    # print(modcomb(100, 5, modfactorial_list(100)))
    from math import factorial
    if n < 0 or k < 0 or n < k: return 0
    if n == 0 or k == 0: return 1
    if len(fac_list) <= n:
        a = factorial(n) % p
        b = factorial(k) % p
        c = factorial(n - k) % p
    else:
        a = fac_list[n]
        b = fac_list[k]
        c = fac_list[n - k]
    return (a * modpow(b, p - 2, p) * modpow(c, p - 2, p)) % p


class ModComb:
    """MODのcombinationsや整数の逆元, 階乗, 階乗の逆元を求める。準備にO(NlogN)?
    ref: https://atcoder.jp/contests/abc167/submissions/13041012

    使い方:
        fact: 階乗(O(1))
        fact_inv: 階乗の逆元(O(1))
        comb: combinations(O(1))
        inv: 階乗(O(1))

    ex:
        comb = ModComb(n, mod)
        print(comb.comb(n, k))
    """
    def __init__(self, n, MOD):
        self.n = n
        self.MOD = MOD
        self.fact = self.make_fact(n)
        self.fact_inv = self.make_fact_inv(n)

    def make_fact(self, n):  #0~nの階乗を求める
        res = [1] * (n + 1)
        for i in range(1, n + 1):
            res[i] = res[i - 1] * i % self.MOD
        return res

    def make_fact_inv(self, n):  #0~nの階乗のMODに関する逆元を求める
        fact_inv = [1] * (n + 1)
        fact_inv[n] = self.modinv(self.fact[n])  # 拡張ユークリッドの互除法にした
        # fact_inv[n] = pow(self.fact[n], self.MOD-2, self.MOD)#フェルマーの小定理
        for i in range(n, 0, -1):
            fact_inv[i - 1] = fact_inv[i] * i % self.MOD
        return fact_inv

    def comb(self, m, k):
        if m < k: return 0
        if m < 0 or k < 0: return 0  # 本当か？
        return self.fact[m] * self.fact_inv[k] * self.fact_inv[m -
                                                               k] % self.MOD

    def modinv(self, a):
        # inverse_element 逆元
        # https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a
        p = self.MOD
        b, u, v = p, 1, 0
        while b:
            t = a // b
            a -= t * b
            a, b = b, a
            u -= t * v
            u, v = v, u
        u %= p
        if u < 0:
            u += p
        return u

    def inv(self, n):
        return (self.fact_inv[n] * self.fact[n - 1]) % self.MOD


def modadd(a, b, p):
    return (a + b) % p


def modsub(a, b, p):
    return (a - b) % p


def modmul(a, b, p):
    return ((a % p) * (b % p)) % p


def moddiv_Fermat(a, b, p):
    # 法 p が素数でないと使えない
    return modmul(a, modpow(b, p - 2, p), p)


def moddiv(a, b, p):
    # https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a
    # 法 pp が素数でなくても逆元存在条件を満たせば使える
    return modmul(a, modinv(b, p), p)


MOD_MODINT = 10**9 + 7


# MOD_MODINT = 998244353
class ModInt(int):
    """ref: https://atcoder.jp/contests/abc147/submissions/9330230?lang=ja
    Caution: MOD_MODINTを直して使う必要がある。
    TODO: __eq__系が欠けていたので追加した。もう少し機能完備したものを誰かが作っていると思う。探すか作りましょう。
    memo: intを継承させた。これによりlistのslice材料として使えるようになった。（そもそもそういう数値はmodint型にする必要なさそうだが） ref: https://twitter.com/maspy_stars/status/1218419292187889664/photo/1
    """
    def __init__(self, x):
        self.x = x % MOD_MODINT

    def __str__(self):
        return str(self.x)

    __repr__ = __str__

    def __add__(self, other):
        return (ModInt(self.x + other.x)
                if isinstance(other, ModInt) else ModInt(self.x + other))

    def __sub__(self, other):
        return (ModInt(self.x - other.x)
                if isinstance(other, ModInt) else ModInt(self.x - other))

    def __mul__(self, other):
        return (ModInt(self.x * other.x)
                if isinstance(other, ModInt) else ModInt(self.x * other))

    def __truediv__(self, other):
        return (ModInt(self.x * pow(other.x, MOD_MODINT - 2, MOD_MODINT))
                if isinstance(other, ModInt) else ModInt(
                    self.x * pow(other, MOD_MODINT - 2, MOD_MODINT)))

    __floordiv__ = __truediv__  # //

    def __eq__(self, other):
        return (self.x == other.x
                if isinstance(other, ModInt) else self.x == other)

    def __ne__(self, other):
        return (self.x != other.x
                if isinstance(other, ModInt) else self.x != other)

    def __lt__(self, other):
        return (self.x < other.x
                if isinstance(other, ModInt) else self.x < other)

    def __gt__(self, other):
        return (self.x > other.x
                if isinstance(other, ModInt) else self.x > other)

    def __le__(self, other):
        return (self.x <= other.x
                if isinstance(other, ModInt) else self.x <= other)

    def __ge__(self, other):
        return (self.x >= other.x
                if isinstance(other, ModInt) else self.x >= other)

    def __pow__(self, other):
        return (ModInt(pow(self.x, other.x, MOD_MODINT)) if isinstance(
            other, ModInt) else ModInt(pow(self.x, other, MOD_MODINT)))

    __radd__ = __add__

    def __rsub__(self, other):
        return (ModInt(other.x - self.x)
                if isinstance(other, ModInt) else ModInt(other - self.x))

    __rmul__ = __mul__

    def __rtruediv__(self, other):
        return (ModInt(other.x * pow(self.x, MOD_MODINT - 2, MOD_MODINT))
                if isinstance(other, ModInt) else ModInt(
                    other * pow(self.x, MOD_MODINT - 2, MOD_MODINT)))

    def __rpow__(self, other):
        return (ModInt(pow(other.x, self.x, MOD_MODINT)) if isinstance(
            other, ModInt) else ModInt(pow(other, self.x, MOD_MODINT)))

    def __iadd__(self, other):
        self.x += other.x if isinstance(other, ModInt) else other
        self.x %= MOD_MODINT
        return self

    def __isub__(self, other):
        self.x += ModInt(MOD_MODINT - other.x) if isinstance(
            other, ModInt) else ModInt(MOD_MODINT - other)
        return self

    def __imul__(self, other):
        self.x *= other.x if isinstance(other, ModInt) else other
        self.x %= MOD_MODINT
        return self

    def factorical(self, n):
        tmp = ModInt(1)
        for i in range(n):
            tmp *= (i + 1)
        return tmp

    #m:int MOD_MODINT
    def modinv(self, a, m=MOD_MODINT):
        b = m
        u = 1
        v = 0
        while (b):
            t = a // b
            a -= t * b
            a, b = b, a
            u -= t * v
            u, v = v, u
        return ModInt(u)

    def comb(self, n, r):
        n = int(n)
        r = int(r)
        if r > n or n < 0 or r < 0:
            return 0
        m = n + 1
        nterms = min(r, n - r)
        numerator = ModInt(1)
        denominator = ModInt(1)
        for j in range(1, nterms + 1):
            numerator *= m - j
            denominator *= j
        return numerator * self.modinv(denominator.x)


class Math():
    """
    ref: https://github.com/shakayami/ACL-for-python/blob/master/math.py
    ref: https://qiita.com/R_olldIce/items/3e2c80baa6d5e6f3abe9
    """
    @classmethod
    def inv_gcd(cls, a, b):
        a = a % b
        if a == 0:
            return (b, 0)
        s = b
        t = a
        m0 = 0
        m1 = 1
        while (t):
            u = s // t
            s -= t * u
            m0 -= m1 * u
            s, t = t, s
            m0, m1 = m1, m0
        if m0 < 0:
            m0 += b // s
        return (s, m0)

    @classmethod
    def inv_mod(cls, x, m):
        assert 1 <= m
        z = cls.inv_gcd(x, m)
        assert z[0] == 1
        return z[1]

    @classmethod
    def crt(cls, r: typing.List[int], m: typing.List[int]):
        """chinese remainder theorem
        ref: https://qiita.com/R_olldIce/items/3e2c80baa6d5e6f3abe9
        ref: https://www.creativ.xyz/ect-gcd-crt-garner-927/
        ref: https://qiita.com/drken/items/ae02240cd1f8edfc86fd
        TODO: アルゴリズムの理解

        Args:
            r (list): r from [x = r0 mod m0, r1 mod m1, r2 mod m2..]
            m (list): m from [x = r0 mod m0, r1 mod m1, r2 mod m2..]

        Returns:
            tuple: (r, m) of x = r mod m if answer exists else (0, 0)
        """
        assert len(r) == len(m)
        n = len(r)
        r0 = 0
        m0 = 1
        for i in range(n):
            assert 1 <= m[i]
            r1 = r[i] % m[i]
            m1 = m[i]
            if m0 < m1:
                r0, r1 = r1, r0
                m0, m1 = m1, m0
            if (m0 % m1 == 0):
                if (r0 % m1 != r1):
                    return (0, 0)
                continue
            g, im = cls.inv_gcd(m0, m1)
            u1 = m1 // g
            if ((r1 - r0) % g):
                return (0, 0)
            x = (r1 - r0) // g % u1 * im % u1
            r0 += x * m0
            m0 *= u1
            if r0 < 0:
                r0 += m0
        return (r0, m0)

    @classmethod
    def floor_sum(cls, n: int, m: int, a: int, b: int):
        """ref: https://atcoder.jp/contests/practice2/editorial/579
        TODO: アルゴリズムの理解

        Args:
            n (int): [description]
            m (int): [description]
            a (int): [description]
            b (int): [description]

        Returns:
            int: Sum_(i=0~n-1)floor((a*i+b)/m)
            O(log a + log m)
        """
        ans = 0
        if a >= m:
            ans += (n - 1) * n * (a // m) // 2
            a %= m
        if b >= m:
            ans += n * (b // m)
            b %= m
        y_max = (a * n + b) // m
        x_max = (y_max * m - b)
        if y_max == 0:
            return ans
        ans += (n - (x_max + a - 1) // a) * y_max
        ans += cls.floor_sum(y_max, a, m, (a - x_max % a) % a)
        return ans


def extGCD(a: int, b: int):
    """answer pair (x, y) of equation ax + by = gcd(a, b)

    Args:
        a (int): [description]
        b (int): [description]

    Returns:
        typle: answer pair (x, y)
    """
    x, y, u, v = 1, 0, 0, 1
    while b:
        k = a // b
        x -= k * u
        y -= k * v
        x, u = u, x
        y, v = v, y
        a, b = b, a % b
    return x, y


# get [Sigma_j=0~i(A_j*B_i-j) for i in range(N)]
class Convolution:
    """高速フーリエ変換 
    # 使用例
    
    # 以下の2行はグローバルに書いている。これが早いみたい。
    MOD_COMV = 998244353 # 1007681537 でも良いらしい
    conv=Convolution()
    
    # main関数内
    A, B: List[int]
    print(*conv.convolution(A,B))

    # この実装：https://atcoder.jp/contests/atc001/submissions/17104531
    # 他の実装や解説
    # https://github.com/shakayami/ACL-for-python/wiki
    # https://atcoder.jp/contests/atc001/submissions/17104531
    # 問題
    # https://atcoder.jp/contests/atc001/tasks/fft_c
    # https://atcoder.jp/contests/practice2/submissions/16789717

    # 998244353=119 * 2^23 + 1と書けるため、この素数はFFTに適しています。 2で23回割り切れるため、この場合はAとBの畳み込みを計算するときに、リストの大きさがlen(A)+len(B)-1<=2^23以内ならば畳み込みを正常に計算することが出来ます。
    """
    def __init__(self):
        # self.MOD_COMV = MOD_COMV # 遅くなる
        self.g = self.primitive_root(MOD_COMV)
        self.first_butterfly = True
        self.first_butterfly_inv = True
        self.sum_e = [0] * 30
        self.sum_ie = [0] * 30

    # 原始根の取得
    def primitive_root(self, m: int):
        if (m == 2):
            return 1
        if (m == 167772161):
            return 3
        if (m == 469762049):
            return 3
        if (m == 754974721):
            return 11
        if (m == 998244353):
            return 3
        divs = [0] * 20
        divs[0] = 2
        cnt = 1
        x = (m - 1) // 2
        while (x % 2 == 0):
            x //= 2
        for i in range(3, x + 1, 2):
            if (i**2 > x):
                break
            if (x % i == 0):
                divs[cnt] = i
                cnt += 1
                while (x % i == 0):
                    x //= i
        if (x > 1):
            divs[cnt] = x
            cnt += 1
        g = 2
        while (True):
            ok = True
            for i in range(cnt):
                if (pow(g, (m - 1) // divs[i], m) == 1):
                    ok = False
                    break
            if (ok):
                return g
            g += 1

        print('error')
        return 0

    def butterfly(self, a: list):
        # MOD_COMV = self.MOD_COMV
        n = len(a)
        h = (n - 1).bit_length()
        if (self.first_butterfly):
            self.first_butterfly = False
            es = [0] * 30
            ies = [0] * 30
            mod_m = MOD_COMV - 1
            cnt2 = (mod_m & -mod_m).bit_length() - 1
            e = pow(self.g, mod_m >> cnt2, MOD_COMV)
            ie = pow(e, MOD_COMV - 2, MOD_COMV)
            for i in range(cnt2 - 2, -1, -1):
                es[i] = e
                ies[i] = ie
                e *= e
                e %= MOD_COMV
                ie *= ie
                ie %= MOD_COMV
            now = 1
            for i in range(cnt2 - 1):
                self.sum_e[i] = (es[i] * now) % MOD_COMV
                now *= ies[i]
                now %= MOD_COMV
        for ph in range(1, h + 1):
            w = 1 << (ph - 1)
            p = 1 << (h - ph)
            now = 1
            for s in range(w):
                offset = s << (h - ph + 1)
                for i in range(p):
                    l = a[i + offset]
                    r = a[i + offset + p] * now
                    a[i + offset] = (l + r) % MOD_COMV
                    a[i + offset + p] = (l - r) % MOD_COMV
                now *= self.sum_e[(~s & -~s).bit_length() - 1]
                now %= MOD_COMV

    def butterfly_inv(self, a: list):
        # MOD_COMV = self.MOD_COMV
        n = len(a)
        h = (n - 1).bit_length()
        if (self.first_butterfly_inv):
            self.first_butterfly_inv = False
            es = [0] * 30
            ies = [0] * 30
            mod_m = MOD_COMV - 1
            cnt2 = (mod_m & -mod_m).bit_length() - 1
            e = pow(self.g, mod_m >> cnt2, MOD_COMV)
            ie = pow(e, MOD_COMV - 2, MOD_COMV)
            for i in range(cnt2 - 2, -1, -1):
                es[i] = e
                ies[i] = ie
                e *= e
                e %= MOD_COMV
                ie *= ie
                ie %= MOD_COMV
            now = 1
            for i in range(cnt2 - 1):
                self.sum_ie[i] = (ies[i] * now) % MOD_COMV
                now *= es[i]
                now %= MOD_COMV
        for ph in range(h, 0, -1):
            w = 1 << (ph - 1)
            p = 1 << (h - ph)
            inow = 1
            for s in range(w):
                offset = s << (h - ph + 1)
                for i in range(p):
                    l = a[i + offset]
                    r = a[i + offset + p]
                    a[i + offset] = (l + r) % MOD_COMV
                    a[i + offset + p] = ((l - r) * inow) % MOD_COMV
                inow *= self.sum_ie[(~s & -~s).bit_length() - 1]
                inow %= MOD_COMV

    def convolution(self, a: list, b: list):
        # MOD_COMV = self.MOD_COMV
        n = len(a)
        m = len(b)
        if (n == 0) | (m == 0):
            return []
        if (min(n, m) <= 60):
            if (n < m):
                a, b = b, a
                n, m = m, n
            ans = [0] * (n + m - 1)
            for i in range(n):
                for j in range(m):
                    ans[i + j] += a[i] * b[j]
                    ans[i + j] %= MOD_COMV
            return ans

        z = 1 << (n + m - 2).bit_length()
        a += [0] * (z - n)
        b += [0] * (z - m)
        self.butterfly(a)
        self.butterfly(b)
        for i in range(z):
            a[i] *= b[i]
            a[i] %= MOD_COMV
        self.butterfly_inv(a)
        a = a[:(n + m - 1)]
        iz = pow(z, MOD_COMV - 2, MOD_COMV)
        for i in range(n + m - 1):
            a[i] *= iz
            a[i] %= MOD_COMV
        return a

    def convolution_ll(self, a: list, b: list):
        from math import gcd
        global MOD_COMV
        n = len(a)
        m = len(b)
        if (n == 0) | (m == 0):
            return []

        MOD1 = 754974721  # 2^24
        MOD2 = 167772161  # 2^25
        MOD3 = 469762049  # 2^26
        M2M3 = MOD2 * MOD3
        M1M3 = MOD1 * MOD3
        M1M2 = MOD1 * MOD2
        M1M2M3 = MOD1 * MOD2 * MOD3

        i1 = gcd(M2M3, MOD1) * pow(M2M3 % MOD1, MOD1 - 2, MOD1) % MOD1
        i2 = gcd(M1M3, MOD2) * pow(M1M3 % MOD2, MOD2 - 2, MOD2) % MOD2
        i3 = gcd(M1M2, MOD3) * pow(M1M2 % MOD3, MOD3 - 2, MOD3) % MOD3

        MOD_COMV = MOD1
        A = a[::]
        B = b[::]
        self.__init__()
        c1 = self.convolution(A, B)
        MOD_COMV = MOD2
        # A = a[::]
        # B = b[::]
        self.__init__()
        c2 = self.convolution(A, B)
        MOD_COMV = MOD3
        # A = a[::]
        # B = b[::]
        self.__init__()
        c3 = self.convolution(A, B)

        c = [0] * (n + m - 1)
        for i in range(n + m - 1):
            x = 0
            x += (c1[i] * i1) % MOD1 * M2M3
            x += (c2[i] * i2) % MOD2 * M1M3
            x += (c3[i] * i3) % MOD3 * M1M2
            c[i] = x % M1M2M3

        return c


MOD_COMV = 998244353
conv = Convolution()


def ternary_search(f: Callable[[float], float], high: float,
                   low: float) -> float:
    # 三分探索の基本形
    # ref: https://juppy.hatenablog.com/entry/2019/04/11/ARC054_-B_%E3%83%A0%E3%83%BC%E3%82%A2%E3%81%AE%E6%B3%95%E5%89%87_-_%E4%B8%89%E5%88%86%E6%8E%A2%E7%B4%A2_Python_%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0_Atcoder
    # ref: https://atcoder.jp/contests/arc122/tasks/arc122_b
    # ref: https://atcoder.jp/contests/arc122/submissions/23395538

    # N = r_int()
    # A = R()

    # high = INF
    # low = 0.00000001

    # def f(mid):
    #     cost = mid*N
    #     for a in A:
    #         cost -= min(a, 2*mid)
    #     return cost

    # high = ternary_search(f, high, low)
    # print(sum([high+a-min(a, 2*high) for a in A])/len(A))

    while high - low > 0.000000001 and (high / low) > 1.00000001:
        mid_left = high / 3 + low * 2 / 3
        mid_right = high * 2 / 3 + low / 3
        if f(mid_left) >= f(mid_right):
            low = mid_left
        else:
            high = mid_right
    return high


# ************ Data Structure ************
from bisect import bisect_left, bisect_right
from collections import deque, Counter, defaultdict  # https://docs.python.org/ja/3/library/collections.html#collections.deque
from heapq import heapify, heappop, heappush, heappushpop, heapreplace, nlargest, nsmallest  # https://docs.python.org/ja/3/library/heapq.html


class Heap:
    """
    heapqのwrap
    pop(), push(), pushpop()がある。
    ex:
    heap = Heap([])で初期化。
    while heap:
        s = heap.pop()
    """
    def __init__(self, L):
        self.heaplist = L
        heapify(self.heaplist)

    def __bool__(self):
        return bool(self.heaplist)

    def pop(self):
        return heappop(self.heaplist)

    def push(self, x):
        heappush(self.heaplist, x)

    def pushpop(self, x):
        return heappushpop(self.heaplist, x)


class HeapDict:
    """
    heap + erase item: O(logN) + item exists: O(1)
    https://tsubo.hatenablog.jp/entry/2020/06/15/124657

    pop(), push(), erace(), exist(), min, heaplist

    ex:
    heap = HeapDict([]) # initialize
    while heap:
        s = heap.pop()
    """
    def __init__(self, L=None):
        self.d = defaultdict(int)
        if L is None:
            self.heaplist = []
        else:
            self.heaplist = L
            heapify(self.heaplist)
            for l in L:
                self.d[l] += 1

    def __bool__(self):
        return bool(self.heaplist)

    def __contains__(self, v):
        return self.d[v]

    def push(self, x):
        heappush(self.heaplist, x)
        self.d[x] += 1

    def pop(self):
        """TODO: 追加したけど正しいですか？

        Returns:
            [type]: [description]
        """
        tmp = self.heaplist[0]
        self.erase(tmp)
        return tmp

    def erase(self, x):
        """erace and return True (if x not exist, return False)

        Args:
            x (int): value

        Returns:
            bool: erased or not
        """
        if x not in self.d or self.d[x] == 0:
            return False
            # print(x,"is not in HeapDict")
            # raise Exception
            # exit()
        else:
            self.d[x] -= 1
        while len(self.heaplist) != 0:
            if self.d[self.heaplist[0]] == 0:
                heappop(self.heaplist)
            else:
                break
        return True

    def exist(self, x):
        if x in self.d and self.d[x] != 0:
            return True
        else:
            return False

    @property
    def min(self):
        return self.heaplist[0]

    @property
    def sum(self):
        return sum([k * v for k, v in self.d.items()])


class UnionFindTree:
    """union find tree class
    TODO: fix this description...
    how to use (example):
    >>  uf = UnionFindTree(N) 
    >>  if uf.find_root(a) == uf.find_root(b):
    >>      do something like:
    >>      pass
    >>  else:
    >>      do something like:
    >>      L[uf.find_root(a)] = L[uf.find_root(a)] + L[uf.find_root(b)]
    >>      L[uf.find_root(b)] = L[uf.find_root(a)]
    >>      
    >>      uf.unite(a, b)
    """
    def __init__(self, N):
        self.root = [-1] * (N + 1)
        self.rank = [0] * (N + 1)
        self.connected_num = [1] * (N + 1)

    def find_root(self, x):
        root = self.root
        while root[x] != -1:
            x = root[x]
        return x

    def unite(self, x, y):
        root = self.root
        rank = self.rank
        connected_num = self.connected_num
        find_root = self.find_root

        rx = find_root(x)
        ry = find_root(y)
        if rx != ry:
            if rank[rx] < rank[ry]:
                root[rx] = ry
                rx, ry = ry, rx
            else:
                if rank[rx] == rank[ry]:
                    rank[rx] += 1
                root[ry] = rx
            connected_num[rx] += connected_num[ry]


class UnionFindTree2:
    """union find tree class with specific list
    TODO: fix this description...
    how to use (example):
    >>  uf = UnionFindTree2(N, [1 for _ in range(N)]) 
    >>  if uf.find_root(a) == uf.find_root(b):
    >>      do something like:
    >>      pass
    >>  else:
    >>      do something like:
    >>      uf.unite(a, b, operator.add)
    >>      # L[uf.find_root(a)] = operator.add(L[uf.find_root(a)], L[uf.find_root(b)])
    >>      # L[uf.find_root(b)] = L[uf.find_root(a)]
 
    >>  uf = UnionFindTree2(N, [1 for i in range(N)])
    >>  uf.unite(0, 1, lambda x, y: x+y)
    >>  uf.find_root(0) == uf.find_root(1) # True
    >>  uf.find_root(0) == uf.find_root(2) # False
    >>  uf.find_L(0) # 2 => self.L[self.find_root(i)]
    >>  uf.find_L(1) # 2
    >>  uf.find_L(2) # 1
    
    """
    def __init__(self, N, L):
        self.root = [-1] * (N + 1)
        self.rank = [0] * (N + 1)
        self.connected_num = [1] * (N + 1)
        self.__L = L

    def find_root(self, x):
        root = self.root
        while root[x] != -1:
            x = root[x]
        return x

    def unite(self, x, y, f):
        root = self.root
        rank = self.rank
        connected_num = self.connected_num
        find_root = self.find_root

        # merge L
        L = self.__L
        L[self.find_root(x)] = f(L[self.find_root(x)], L[self.find_root(y)])
        L[self.find_root(y)] = L[self.find_root(x)]

        rx = find_root(x)
        ry = find_root(y)
        if rx != ry:
            if rank[rx] < rank[ry]:
                root[rx] = ry
                rx, ry = ry, rx
            else:
                if rank[rx] == rank[ry]:
                    rank[rx] += 1
                root[ry] = rx
            connected_num[rx] += connected_num[ry]

    def find_L(self, i):
        return self.__L[self.find_root(i)]


class UnionFindTree3:
    """union find tree class with specific list
    ref: https://atcoder.github.io/ac-library/master/document_ja/dsu.html
    ref: https://atcoder.jp/contests/abc177/tasks/abc177_d
    prob: groups -> https://atcoder.jp/contests/arc106/tasks/arc106_b
    # TODO: lambda x, y: 2*x+yみたいなのが果たしてうまく機能するのかはちょっと心配。

    >>> uf = UnionFindTree3(3, [1 for i in range(3)], lambda x, y: 2*x+y) # O(n)
    >>> uf.merge(0, 1)
    >>> uf.leader(0) == uf.leader(1)
    True
    >>> uf.same(0, 1)
    True
    >>> uf.leader(0) == uf.leader(2)
    False
    >>> uf.L(0)
    3
    >>> uf.L(1)
    3
    >>> uf.L(2)
    1
    >>> uf.size(2)
    1
    >>> uf.size(1)
    2
    >>> uf.groups() # O(n)
    [[0, 1], [2]]

    """
    def __init__(self, N, L=None, merge=lambda x, y: x + y):
        self.N = N
        self.root = [-1] * (N + 1)
        self.rank = [0] * (N + 1)
        self.__size = [1] * (N + 1)
        self.__L = L
        self.__merge = merge

    def leader(self, x):
        root = self.root
        while root[x] != -1:
            x = root[x]
        return x

    def merge(self, x, y):
        """xとyが非連結の場合、連結する。Lを初期設定している場合、merge functionに基づいてLも結合する。

        Args:
            x (int): node
            y (int): node
        """
        root = self.root
        rank = self.rank
        __size = self.__size
        leader = self.leader
        L = self.__L

        rx = leader(x)
        ry = leader(y)
        if rx != ry:
            if L is not None:  # merge L
                L[rx] = self.__merge(L[rx], L[ry])
                L[ry] = L[rx]
            if rank[rx] < rank[ry]:
                root[rx] = ry
                rx, ry = ry, rx
            else:
                if rank[rx] == rank[ry]:
                    rank[rx] += 1
                root[ry] = rx
            __size[rx] += __size[ry]
            # if L is not None:
            #     L[rx] = self.__merge(L[rx], L[ry])

    def size(self, i):
        return self.__size[self.leader(i)]

    def L(self, i):
        return self.__L[self.leader(i)]

    def same(self, i, j):
        return self.leader(i) == self.leader(j)

    def groups(self):
        checked = [-1] * self.N
        cnt = 0
        _groups = []
        for i in range(self.N):
            if checked[self.leader(i)] == -1:
                checked[self.leader(i)] = cnt
                cnt += 1
                _groups.append([i])
            else:
                _groups[checked[self.leader(i)]].append(i)
        return _groups


# c++ set
# https://nagiss.hateblo.jp/entry/2020/09/08/203701
class BalancingTree:
    """
    https://qiita.com/Kiri8128/items/6256f8559f0026485d90
    構築はO(1)
    >>  BT = BalancingTree(5) # 0 ～ 30 までの要素を入れられるピボット木
    >>  BT.append(3)
    >>  BT.append(20)
    >>  BT.append(5)
    >>  BT.append(10)
    >>  BT.append(13)
    >>  BT.append(8)
    >>  BT.delete(20)
    >>  print(BT.find_l(12)) # 10
    >>  print(BT.find_r(5)) # 8
    >>  print(BT.min) # 3
    >>  print(BT.max) # 13
    >>  print(3 in BT) # True
    >>  print(4 in BT) # False
    """
    def __init__(self, n):
        self.N = n
        self.root = self.node(1 << n, 1 << n)

    def debug(self):
        def debug_info(nd_):
            return (nd_.value - 1, nd_.pivot - 1,
                    nd_.left.value - 1 if nd_.left else -1,
                    nd_.right.value - 1 if nd_.right else -1)

        def debug_node(nd):
            re = []
            if nd.left:
                re += debug_node(nd.left)
            if nd.value: re.append(debug_info(nd))
            if nd.right:
                re += debug_node(nd.right)
            return re

        print("Debug - root =", self.root.value - 1,
              debug_node(self.root)[:50])

    def append(self, v):  # v を追加（その時点で v はない前提）
        v += 1
        nd = self.root
        while True:
            if v == nd.value:
                # v がすでに存在する場合に何か処理が必要ならここに書く
                return 0
            else:
                mi, ma = min(v, nd.value), max(v, nd.value)
                if mi < nd.pivot:
                    nd.value = ma
                    if nd.left:
                        nd = nd.left
                        v = mi
                    else:
                        p = nd.pivot
                        nd.left = self.node(mi, p - (p & -p) // 2)
                        break
                else:
                    nd.value = mi
                    if nd.right:
                        nd = nd.right
                        v = ma
                    else:
                        p = nd.pivot
                        nd.right = self.node(ma, p + (p & -p) // 2)
                        break

    def leftmost(self, nd):
        if nd.left: return self.leftmost(nd.left)
        return nd

    def rightmost(self, nd):
        if nd.right: return self.rightmost(nd.right)
        return nd

    def find_l(self, v):  # vより真に小さいやつの中での最大値（なければ-1）
        v += 1
        nd = self.root
        prev = 0
        if nd.value < v: prev = nd.value
        while True:
            if v <= nd.value:
                if nd.left:
                    nd = nd.left
                else:
                    return prev - 1
            else:
                prev = nd.value
                if nd.right:
                    nd = nd.right
                else:
                    return prev - 1

    def find_r(self, v):  # vより真に大きいやつの中での最小値（なければRoot）
        v += 1
        nd = self.root
        prev = 0
        if nd.value > v: prev = nd.value
        while True:
            if v < nd.value:
                prev = nd.value
                if nd.left:
                    nd = nd.left
                else:
                    return prev - 1
            else:
                if nd.right:
                    nd = nd.right
                else:
                    return prev - 1

    @property
    def max(self):
        return self.find_l((1 << self.N) - 1)

    @property
    def min(self):
        return self.find_r(-1)

    def delete(self, v, nd=None, prev=None):  # 値がvのノードがあれば削除（なければ何もしない）
        v += 1
        if not nd: nd = self.root
        if not prev: prev = nd
        while v != nd.value:
            prev = nd
            if v <= nd.value:
                if nd.left:
                    nd = nd.left
                else:
                    return
            else:
                if nd.right:
                    nd = nd.right
                else:
                    return
        if (not nd.left) and (not nd.right):
            if nd.value < prev.value:
                prev.left = None
            else:
                prev.right = None
        elif not nd.left:
            if nd.value < prev.value:
                prev.left = nd.right
            else:
                prev.right = nd.right
        elif not nd.right:
            if nd.value < prev.value:
                prev.left = nd.left
            else:
                prev.right = nd.left
        else:
            nd.value = self.leftmost(nd.right).value
            self.delete(nd.value - 1, nd.right, nd)

    def __contains__(self, v: int) -> bool:
        return self.find_r(v - 1) == v

    class node:
        def __init__(self, v, p):
            self.value = v
            self.pivot = p
            self.left = None
            self.right = None


# BalancingTreeを使いやすくしたつもり。3より速いがバグが含まれるらしい。
class BalancingTree2:
    """
    ref: https://qiita.com/Kiri8128/items/6256f8559f0026485d90
    ref: https://atcoder.jp/contests/abc140/tasks/abc140_f
    構築はO(1)
    >>> BT = BalancingTree2(-20, 25) # 少なくとも-20 ~ 25の整数を格納できるBT
    >>> BT.max
    -21
    >>> BT.append(3)
    >>> BT.append(20)
    >>> BT.append(5)
    >>> BT.append(10)
    >>> BT.append(13)
    >>> BT.append(8)
    >>> BT.delete(20)
    >>> BT.append(-5)
    >>> BT.append(-20)
    >>> BT.append(25)
    >>> BT.find_l(12)
    10
    >>> BT.find_r(5)
    8
    >>> BT.min
    -20
    >>> BT.max 
    25
    >>> 3 in BT
    True
    >>> 4 in BT
    False
    """
    def __init__(self, v_least, v_most):
        self.v_least = v_least
        self.v_most = v_most
        self.shift = 1 - self.v_least  # 内部では1~1+(v_most-v_least)を持つ
        self.N = 1 << (v_most - v_least + 1).bit_length()
        self.root = self.node(self.N, self.N)
        self.d = defaultdict(int)

    # def debug(self):
    #     def debug_info(nd_):
    #         return (nd_.value - 1, nd_.pivot - 1, nd_.left.value - 1 if nd_.left else -1, nd_.right.value - 1 if nd_.right else -1)

    #     def debug_node(nd):
    #         re = []
    #         if nd.left:
    #             re += debug_node(nd.left)
    #         if nd.value: re.append(debug_info(nd))
    #         if nd.right:
    #             re += debug_node(nd.right)
    #         return re
    #     print("Debug - root =", self.root.value - 1, debug_node(self.root)[:50])

    def append(self, v):  # v を追加
        assert self.v_least <= v <= self.v_most, f"value must be between {self.v_least} and {self.v_most}"
        iv = v + self.shift  # internal value
        nd = self.root
        if self.d[v] > 0:
            self.d[v] += 1
            return 0
        else:
            self.d[v] = 1
        while True:
            if iv == nd.value:
                # iv がすでに存在する場合に何か処理が必要ならここに書く
                return 0
            else:
                mi, ma = min(iv, nd.value), max(iv, nd.value)
                if mi < nd.pivot:
                    nd.value = ma
                    if nd.left:
                        nd = nd.left
                        iv = mi
                    else:
                        p = nd.pivot
                        nd.left = self.node(mi, p - (p & -p) // 2)
                        break
                else:
                    nd.value = mi
                    if nd.right:
                        nd = nd.right
                        iv = ma
                    else:
                        p = nd.pivot
                        nd.right = self.node(ma, p + (p & -p) // 2)
                        break

    def leftmost(self, nd):
        if nd.left: return self.leftmost(nd.left)
        return nd

    def rightmost(self, nd):
        if nd.right: return self.rightmost(nd.right)
        return nd

    def find_l(self, v):  # vより真に小さいやつの中での最大値（なければ最小値-1）
        iv = v + self.shift
        nd = self.root
        prev = 0
        if nd.value < iv: prev = nd.value
        while True:
            if iv <= nd.value:
                if nd.left:
                    nd = nd.left
                else:
                    return prev - self.shift
            else:
                prev = nd.value
                if nd.right:
                    nd = nd.right
                else:
                    return prev - self.shift

    def find_r(self, v):  # vより真に大きいやつの中での最小値（なければRoot）
        iv = v + self.shift
        nd = self.root
        prev = 0
        if nd.value > iv: prev = nd.value
        while True:
            if iv < nd.value:
                prev = nd.value
                if nd.left:
                    nd = nd.left
                else:
                    return prev - self.shift
            else:
                if nd.right:
                    nd = nd.right
                else:
                    return prev - self.shift

    @property
    def max(self):
        return self.find_l(self.N - self.shift)

    @property
    def min(self):
        return self.find_r(-self.shift)

    def delete(self, v, nd=None, prev=None):  # 値がvのノードがあれば削除（なければ何もしない）
        iv = v + self.shift
        if self.d[v] > 1 and nd is None:
            self.d[v] -= 1
            return
        elif not self.d[v] and nd is None:
            return
        else:
            if nd is None:
                del self.d[v]
            if nd is None: nd = self.root
            if prev is None: prev = nd
            while v != nd.value:
                prev = nd
                if v <= nd.value:
                    if nd.left:
                        nd = nd.left
                    else:
                        return
                else:
                    if nd.right:
                        nd = nd.right
                    else:
                        return
            if (nd.left is None) and (nd.right is None):
                if nd.value < prev.value:
                    prev.left = None
                else:
                    prev.right = None
            elif nd.left is None:
                if nd.value < prev.value:
                    prev.left = nd.right
                else:
                    prev.right = nd.right
            elif nd.right is None:
                if nd.value < prev.value:
                    prev.left = nd.left
                else:
                    prev.right = nd.left
            else:
                nd.value = self.leftmost(nd.right).value
                self.delete(nd.value - self.shift, nd.right, nd)

    def __contains__(self, v: int) -> bool:
        # return self.find_r(v - self.shift) == v
        return self.d[v] >= 1

    class node:
        def __init__(self, v, p):
            self.value = v
            self.pivot = p
            self.left = None
            self.right = None


class BalancingTree3:
    """
    ref: https://qiita.com/Kiri8128/items/6256f8559f0026485d90
    ref: https://atcoder.jp/contests/abc140/tasks/abc140_f
    ref: https://atcoder.jp/contests/cpsco2019-s1/tasks/cpsco2019_s1_e
    ref: https://atcoder.jp/contests/abc140/tasks/abc140_e
    
    構築はO(1)
    >>> BT = BalancingTree3(-20, 26) # 少なくとも-20 ~ 26の整数を格納できるBT
    >>> BT.max
    -21
    >>> BT.append(3)
    >>> BT.append(20)
    >>> BT.append(5)
    >>> BT.append(10)
    >>> BT.append(13)
    >>> BT.append(8)
    >>> BT.delete(20)
    >>> BT.append(-5)
    >>> BT.append(-20)
    >>> BT.append(25)
    >>> BT.find_l(12)
    10
    >>> BT.find_r(5)
    8
    >>> BT.find_r(25)
    27
    >>> BT.min
    -20
    >>> BT.max 
    25
    >>> 3 in BT
    True
    >>> 4 in BT
    False
    >>> BT.append(26)
    >>> BT.find_r(25)
    26
    >>> BT.find_r(26)
    27
    >>> BT.append(28)
    Traceback (most recent call last):
        ...
    AssertionError: value must be between -20 and 26
    >>> BT.count(3)
    1
    >>> BT.append(3)
    >>> BT.count(3)
    2
    """
    def __init__(self, v_least, v_most):
        self.v_least = v_least
        self.v_most = v_most
        self.shift = 1 - self.v_least  # 内部では1~1+(v_most-v_least)を持つ
        self.N = 1 << (v_most - v_least + 1).bit_length()
        self.root = self.node(self.N, self.N)
        self.d = defaultdict(int)

    def count(self, v):
        return self.d[v]

    def debug(self):
        def debug_info(nd_):
            return (nd_.value - self.shift, nd_.pivot - self.shift,
                    nd_.left.value - self.shift if nd_.left else -self.shift,
                    nd_.right.value - self.shift if nd_.right else -self.shift)

        def debug_node(nd):
            re = []
            if nd.left:
                re += debug_node(nd.left)
            if nd.value: re.append(debug_info(nd))
            if nd.right:
                re += debug_node(nd.right)
            return re

        print("Debug - root =", self.root.value - self.shift,
              debug_node(self.root)[:50])

    def debug_list(self):
        def debug_node(nd):
            re = []
            if nd.left:
                re += debug_node(nd.left)
            if nd.value: re.append(nd.value - self.shift)
            if nd.right:
                re += debug_node(nd.right)
            return re

        return debug_node(self.root)[:-1]

    def append(self, v):  # v を追加
        assert self.v_least <= v <= self.v_most, f"value must be between {self.v_least} and {self.v_most}"
        iv = v + self.shift  # internal value
        nd = self.root
        if self.d[v] > 0:
            self.d[v] += 1
            return
        else:
            self.d[v] = 1
        while True:
            if iv == nd.value:
                # iv がすでに存在する場合に何か処理が必要ならここに書く
                return
            else:
                mi, ma = min(iv, nd.value), max(iv, nd.value)
                if mi < nd.pivot:
                    nd.value = ma
                    if nd.left:
                        nd = nd.left
                        iv = mi
                    else:
                        p = nd.pivot
                        nd.left = self.node(mi, p - (p & -p) // 2)
                        break
                else:
                    nd.value = mi
                    if nd.right:
                        nd = nd.right
                        iv = ma
                    else:
                        p = nd.pivot
                        nd.right = self.node(ma, p + (p & -p) // 2)
                        break

    def leftmost(self, nd):
        if nd.left: return self.leftmost(nd.left)
        return nd

    def rightmost(self, nd):
        if nd.right: return self.rightmost(nd.right)
        return nd

    def find_l(self, v):
        """vより真に小さいやつの中での最大値（なければ最小値-1）

        Args:
            v (int): value

        Returns:
            int: vより真に小さいやつの中での最大値（なければ最小値-1）
        """
        iv = v + self.shift
        nd = self.root
        prev = 0
        if nd.value < iv: prev = nd.value
        while True:
            if iv <= nd.value:
                if nd.left:
                    nd = nd.left
                else:
                    return prev - self.shift
            else:
                prev = nd.value
                if nd.right:
                    nd = nd.right
                else:
                    return prev - self.shift

    def find_r(self, v):
        """vより真に大きいやつの中での最小値（なければself.v_most+1）
        
        # 実装追加したことでRootとv_most+1が異なってしまったので、Rootではなくv_most+1を返してくれたほうが都合が良くなってしまった。
        https://atcoder.jp/contests/abc140/tasks/abc140_e

        Args:
            v (int): value

        Returns:
            int: vより真に大きいやつの中での最小値（なければself.v_most+1）
        """
        if v > self.v_most: return self.v_most + 1  # 追加した
        iv = v + self.shift
        nd = self.root
        prev = 0
        if nd.value > iv: prev = nd.value
        while True:
            if iv < nd.value:
                prev = nd.value
                if nd.left:
                    nd = nd.left
                else:
                    return min(prev - self.shift, self.v_most + 1)
            else:
                if nd.right:
                    nd = nd.right
                else:
                    return min(prev - self.shift, self.v_most + 1)

    @property
    def max(self):
        return self.find_l(self.N - self.shift)

    @property
    def min(self):
        return self.find_r(-self.shift)

    def delete(self, v, nd=None, prev=None):  # 値がvのノードがあれば削除（なければ何もしない）
        iv = v + self.shift
        if self.d[v] > 1 and nd is None:
            self.d[v] -= 1
            return
        elif not self.d[v] and nd is None:
            return
        else:
            if nd is None:
                del self.d[v]
                nd = self.root
            if prev is None: prev = nd
            while iv != nd.value:
                prev = nd
                if iv <= nd.value:
                    if nd.left:
                        nd = nd.left
                    else:
                        return
                else:
                    if nd.right:
                        nd = nd.right
                    else:
                        return
            if (nd.left is None) and (nd.right is None):
                if prev.left is None:
                    prev.right = None
                elif prev.right is None:
                    prev.left = None
                else:
                    if nd.pivot == prev.left.pivot:
                        prev.left = None
                    else:
                        prev.right = None
            elif nd.right:
                nd.value = self.leftmost(nd.right).value
                self.delete(nd.value - self.shift, nd.right, nd)
            else:
                nd.value = self.rightmost(nd.left).value
                self.delete(nd.value - self.shift, nd.left, nd)

    def __contains__(self, v: int) -> bool:
        # return self.find_r(v - self.shift) == v
        return self.d[v] >= 1

    class node:
        def __init__(self, v, p):
            self.value = v
            self.pivot = p
            self.left = None
            self.right = None


# 2次元累積和
class Accum2D:
    """2次元[N, M]累積和listの作成O(NM)
    2次元累積和の範囲合計の計算O(1)
    
    problem: https://atcoder.jp/contests/abc086/tasks/arc089_b
    accum_2d = Accum2D(images, 2*K, 4*K)
    accum_2d.query(i, i+K, j, j+K)
    """
    def __init__(self, L: List[List[int]], x: int, y: int):
        self.L_acc = self.accumulate_2d(L, x, y)

    @staticmethod
    def accumulate_2d(L: List[List[int]], x: int, y: int) -> List[List[int]]:
        # 高速ゼータ変換: https://qiita.com/convexineq/items/afc84dfb9ee4ec4a67d5
        A = [l for l in L]
        for i in range(x):
            for j in range(y):
                if i: A[i][j] += A[i - 1][j]
        for i in range(x):
            for j in range(y):
                if j: A[i][j] += A[i][j - 1]
        return A

    @staticmethod
    def accumulate_2d_(L: List[List[int]], x: int, y: int) -> List[List[int]]:
        L_acc = [[0] * y for _ in range(x)]
        for i in range(x):
            for j in range(y):
                if i == 0 and j == 0:
                    L_acc[i][j] = L[i][j]
                elif i == 0:
                    L_acc[i][j] = L_acc[i][j - 1] + L[i][j]
                elif j == 0:
                    L_acc[i][j] = L_acc[i - 1][j] + L[i][j]
                else:
                    L_acc[i][j] = L[i][j] + L_acc[i][j - 1] + L_acc[
                        i - 1][j] - L_acc[i - 1][j - 1]
        return L_acc

    def query(self, top: int, bottom: int, left: int, right: int) -> int:
        """sum of 2d list [top, bottom) [left, right))

        Args:
            top (int): [description]
            bottom (int): [description]
            left (int): [description]
            right (int): [description]

        Returns:
            int: [description]
        """
        if top == left == 0:
            return self.L_acc[bottom - 1][right - 1]
        elif top == 0:
            return self.L_acc[bottom - 1][right - 1] - self.L_acc[bottom -
                                                                  1][left - 1]
        elif left == 0:
            return self.L_acc[bottom - 1][right - 1] - self.L_acc[top -
                                                                  1][right - 1]
        else:
            return self.L_acc[bottom - 1][right - 1] - self.L_acc[bottom - 1][
                left - 1] - self.L_acc[top - 1][right -
                                                1] + self.L_acc[top - 1][left -
                                                                         1]


# Binary Indexed Tree (Fenwick Tree; フェニック木)
# 数列A1,..Anが与えられたときに以下のそれぞれをO(logN)で実現するデータ構造
# 要素の更新：任意のi, xに対してAi += x を行う
# 部分和：任意のiに対して A1+A2+..+Aiの値を求める
class BIT:
    # https://juppy.hatenablog.com/entry/2018/11/17/%E8%9F%BB%E6%9C%AC_python_Binary_Indexed_Tree_%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0
    # SegTreeより軽いので積極的に使う
    # 外形上は0-indexだが内部は1-indexなのが少しややこしい。
    # BIT_RSQ_RAQがこのクラスを使っているので変更時は注意する。
    def __init__(self, N):
        self.N = N + 1
        self.bit = [0] * (N + 1)

    def __query__(self, i):
        # return sum of [0, i]
        # return 0 if i == -1
        res = 0
        idx = i + 1
        while idx:
            res += self.bit[idx]
            idx -= idx & (-idx)  # 最後に立っている 1 のビットを減算
        return res

    def query(self, l, r=-1):
        """sum of [l, r) if r else [0, l+1)

        Args:
            l (int): left
            r (int, optional): right. Defaults to -1.

        Returns:
            int: sum of [l, r) if r else [0, l+1)
        """
        if r == -1:
            return self.__query__(l)
        else:
            return self.__query__(r - 1) - self.__query__(l - 1)

    def add(self, i, x):
        """Ai += x: O(log N)

        Args:
            i (int): index
            x (int): value
        """
        idx = i + 1
        while idx < self.N:
            self.bit[idx] += x
            idx += idx & (-idx)  # 最後に立っている 1 のビットを加算

    def update(self, i, x):
        """Ai = x: O(log N)
        未検証, use add instead.

        Args:
            i (int): index
            x (int): value
        """
        x = x - self.query(i, i + 1)
        idx = i + 1
        while idx < self.N:
            self.bit[idx] += x
            idx += idx & (-idx)

    def lower_left(self, w):
        """min_i satisfying {sum(A0 ~ Ai) >= w} (Ai >= 0): O(log N)

        Args:
            w (int): value to be found

        Returns:
            int: min_i satisfying {sum(A0 ~ Ai) >= w} (Ai >= 0): O(log N)
        """
        if (w < 0):
            return -1
        x = 0
        k = 1 << (self.N.bit_length() - 1)
        while k > 0:
            if x + k < self.N and self.bit[x + k] < w:
                w -= self.bit[x + k]
                x += k
            k //= 2
        return x


class BIT_RSQ_RAQ:
    """区間加算(Range Sum Query), 区間取得(Range Add Query)をO(logN)で答えるBIT組み合わせ
    ref: https://algo-logic.info/binary-indexed-tree/ 区間加算(RAQ)対応 BIT
    Args:
        N (int): number of nodes
    """
    def __init__(self, N):
        """
        Args:
            N (int): number of nodes
        """
        self.N = N
        self.bit0 = BIT(N)
        self.bit1 = BIT(N)

    def __query__(self, i):
        """sum of [0, i]

        Args:
            i (int): right end (included)

        Returns:
            int: sum of [0, i]
        """
        return self.bit0.query(i) + self.bit1.query(i) * i

    def query(self, l, r=-1):
        """sum of [l, r) if r else [0, l+1) (logN)

        Args:
            l ([int]): left side
            r (int, optional): right side. Defaults to -1.

        Returns:
            int: sum of [l, r) if r else [0, l+1)
        """
        if r == -1:
            return self.__query__(l)
        else:
            return self.__query__(r - 1) - self.__query__(l - 1)

    def add(self, val, l, r=-1):
        """add val to [l, r) if r!=-1 else [l, l+1)

        Args:
            val (int or float?): val
            l (int): left
            r (int): right
        """
        if r == -1:
            r = l + 1
        # add val to [l, r): O(logN)
        self.bit0.add(l, -val * (l - 1))
        self.bit0.add(r, val * (r - 1))
        self.bit1.add(l, val)
        self.bit1.add(r, -val)

    def lower_left(self, w):
        """max_i satisfying {Ai < w} (Ai >= 0): O((log N)**2)
        TODO: 実装正しいか不安だが下記は通った。
        ref: https://atcoder.jp/contests/arc033/tasks/arc033_3
        本当はlog Nにできるようだが本実装のほうが分かりやすかった。
        TODO: {A0 ~ Ai < w}も欲しいと思う
        TODO: BITのlower_leftと名前同一機能不一致で分かりにくい。

        Args:
            w (int): value to be found (assume w>=0)

        Returns:
            int: min_i satisfying {sum(A0 ~ Ai) >= w} (Ai >= 0): O(log N)
        """
        if (w < 0):
            return -1
        x = 0
        k = 1 << (self.N.bit_length() - 1)
        while k > 0:
            if x + k < self.N and self.query(x + k, x + k + 1) < w:
                x += k
            k //= 2
        return x


class BIT_Injectable:
    """ref: https://ikatakos.com/pot/programming_algorithm/data_structure/binary_indexed_tree
    XOR, 掛け算, （欠陥ありで）max, minが載せられる
    初期値と演算する関数を外部注入できるようにした実装。
    identity_factory にはlistやdictなどを載せられるようにするため「引数無しで呼ぶと初期値を生成して返す関数」を書くとのことだがそもそもlistを載せるケースが良くわからない。
    """
    def __init__(self, n, identity_factory, func):
        self.size = n
        self.tree = [identity_factory() for _ in range(n + 1)]
        self.func = func
        self.idf = identity_factory

    def add(self, i, x):
        tree = self.tree
        func = self.func
        while i <= self.size:
            tree[i] = func(tree[i], x)
            i += i & -i

    def sum(self, i):
        s = self.idf()
        tree = self.tree
        func = self.func
        while i > 0:
            s = func(s, tree[i])
            i -= i & -i
        return s


class SegTree_Mine:
    """
    TODO: 機能拡充：https://ei1333.hateblo.jp/entry/2017/12/14/000000
    TODO: 機能拡充：https://atcoder.github.io/ac-library/document_ja/segtree.html
    ref: https://qiita.com/takayg1/items/c811bd07c21923d7ec69
    init(init_val, ide_ele): 配列init_valで初期化 O(N)
    update(k, x): k番目の値をxに更新 O(logN)
    query(l, r): 区間[l, r)をsegfuncしたものを返す O(logN)
    
    操作	    segfunc	        単位元
    最小値	    min(x, y)	    float('inf')
    最大値	    max(x, y)	    -float('inf')
    区間和	    x + y	        0
    区間積	    x * y	        1
    最大公約数	math.gcd(x, y)	0
    
    >>> seg = SegTree_Mine([14, 5, 9, 13], min, float('inf'))
    >>> seg.query(0, 4) # get segfunc([l, r))
    5
    >>> seg.mindex(0, 4) # get decisive index and its value in ([0, 4))
    (1, 5)
    >>> seg.add(1, 3) # add value of pos 2 to 3
    >>> seg.query(0, 4)
    8
    >>> seg.update(1, 3) # update value of pos 2 to 3
    >>> seg.query(0, 4)
    3

    >>> seg = SegTree_Mine([14, 5, 9, 13], lambda x, y: x+y, 0)
    """
    def __init__(self, init_val, segfunc, ide_ele):
        """
        init_val: 配列の初期値
        segfunc: 区間にしたい操作
        ide_ele: 単位元
        n: 要素数
        num: n以上の最小の2のべき乗
        tree: セグメント木(1-index)
        """
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # 配列の値を葉にセット
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # 構築していく
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def mindex(self, l, r):
        """find ([far left] index, value) where the query value in [l, r) is decided by the index when self.segfunc = min, max etc.
        ex: [8, 6, 3, 5, 9, 3], segfunc = min: => return (2, 3) (left minimum value "3" is placed at 2)
        O(log N) 
        ref: https://atcoder.jp/contests/abc194/tasks/abc194_e
        ref: https://atcoder.jp/contests/hhkb2020/tasks/hhkb2020_c
        ref: https://atcoder.jp/contests/abc116/tasks/abc116_c

        Args:
            l (int): index(0-index)
            r (int): index(0-index)
        """

        # ver O((log N)**2)
        # v = self.query(l, r)
        # bin = [l, r] # [l, r)
        # while bin[1]-bin[0] > 1:
        #     mid = (bin[1]+bin[0])//2
        #     if v == self.query(bin[0], mid):
        #         bin[1] = mid
        #     else:
        #         bin[0] = mid
        # return (v, bin[0])

        # queryと同じ要領でtreeを登りつつ、値が更新されるか、値が同じでかつ範囲がより左の部分であるような範囲が見つかった場合にそのvalue, indexを記録する。
        # 値が同じだった場合に範囲が左かどうかは、前回更新時に左で更新されていたら前回のほうが範囲が左、前回更新時に右で更新されていたら今回のほうが範囲が左となる。範囲の両端から見られていくため。

        res = self.ide_ele
        l += self.num
        r += self.num

        # candidate # 初期値はcand_pos=INFのように、弱く設定する方が自然に感じるが、cand_v以外は強くて小さい値にすると処理が速くなるっぽい。
        cand_v = res
        cand_pos = l
        cand_right = True
        cand_hight = 0
        current_hight = 0

        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                if (res != cand_v) or (res == self.segfunc(
                        self.ide_ele, self.tree[l]) and cand_right == False):
                    cand_v = res
                    cand_right = True
                    cand_pos = l
                    cand_hight = current_hight
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
                if (res != cand_v) or (res == self.segfunc(
                        self.ide_ele, self.tree[r - 1])
                                       and cand_right == False):
                    cand_v = res
                    cand_right = False
                    cand_pos = r - 1
                    cand_hight = current_hight
            l >>= 1
            r >>= 1
            current_hight += 1

        # cand_hight>0の場合、cand_posは1点ではなく範囲を意味するため、treeを降りつつ点[l, l+1)を特定する。
        while cand_hight:
            cand_hight -= 1
            if self.tree[cand_pos * 2] == cand_v:
                cand_pos = cand_pos * 2
            else:
                cand_pos = cand_pos * 2 + 1

        return (cand_pos - self.num, cand_v)

    def update(self, k, v):
        """
        k番目の値をxに更新
        k: index(0-index)
        v: update value
        """
        k += self.num
        self.tree[k] = v
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def add(self, k, v):
        """
        k番目の値にxをadd
        k: index(0-index)
        v: update value
        """
        k += self.num
        self.tree[k] += v
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        """
        [l, r)のsegfuncしたものを得る
        l: index(0-index)
        r: index(0-index)
        """
        res = self.ide_ele
        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res


class SegTree:
    """[summary]

    N, Q = R()
    A = R()
    seg = SegTree(max, -float('inf'), A)

    for _ in range(Q):
        t, x, v = R()
        if t == 1:
            seg.set(x-1, v)
        elif t == 2:
            l, r = x-1, v
            print(seg.prod(l, r))
        else:
            print(seg.max_right(x-1, lambda x: x<v)+1)
    """
    def __init__(self, op: typing.Callable[[typing.Any, typing.Any],
                                           typing.Any], e: typing.Any,
                 v: typing.Union[int, typing.List[typing.Any]]) -> None:
        self._op = op
        self._e = e

        if isinstance(v, int):
            v = [e] * v

        self._n = len(v)
        self._log = self._ceil_pow2(self._n)
        self._size = 1 << self._log
        self._d = [e] * (2 * self._size)

        for i in range(self._n):
            self._d[self._size + i] = v[i]
        for i in range(self._size - 1, 0, -1):
            self._update(i)

    def _ceil_pow2(self, n: int) -> int:
        x = 0
        while (1 << x) < n:
            x += 1

        return x

    def set(self, p: int, x: typing.Any) -> None:
        assert 0 <= p < self._n

        p += self._size
        self._d[p] = x
        for i in range(1, self._log + 1):
            self._update(p >> i)

    def get(self, p: int) -> typing.Any:
        assert 0 <= p < self._n

        return self._d[p + self._size]

    def prod(self, left: int, right: int) -> typing.Any:
        assert 0 <= left <= right <= self._n
        sml = self._e
        smr = self._e
        left += self._size
        right += self._size

        while left < right:
            if left & 1:
                sml = self._op(sml, self._d[left])
                left += 1
            if right & 1:
                right -= 1
                smr = self._op(self._d[right], smr)
            left >>= 1
            right >>= 1

        return self._op(sml, smr)

    def all_prod(self) -> typing.Any:
        return self._d[1]

    def max_right(self, left: int, f: typing.Callable[[typing.Any],
                                                      bool]) -> int:
        assert 0 <= left <= self._n
        assert f(self._e)

        if left == self._n:
            return self._n

        left += self._size
        sm = self._e

        first = True
        while first or (left & -left) != left:
            first = False
            while left % 2 == 0:
                left >>= 1
            if not f(self._op(sm, self._d[left])):
                while left < self._size:
                    left *= 2
                    if f(self._op(sm, self._d[left])):
                        sm = self._op(sm, self._d[left])
                        left += 1
                return left - self._size
            sm = self._op(sm, self._d[left])
            left += 1

        return self._n

    def min_left(self, right: int, f: typing.Callable[[typing.Any],
                                                      bool]) -> int:
        assert 0 <= right <= self._n
        assert f(self._e)

        if right == 0:
            return 0

        right += self._size
        sm = self._e

        first = True
        while first or (right & -right) != right:
            first = False
            right -= 1
            while right > 1 and right % 2:
                right >>= 1
            if not f(self._op(self._d[right], sm)):
                while right < self._size:
                    right = 2 * right + 1
                    if f(self._op(self._d[right], sm)):
                        sm = self._op(self._d[right], sm)
                        right -= 1
                return right + 1 - self._size
            sm = self._op(self._d[right], sm)

        return 0

    def _update(self, k: int) -> None:
        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])


class SegTree2D:
    """ref: https://qiita.com/tomato1997/items/83ccdfe0ce1f5548a42a
    ref: https://atcoder.jp/contests/abc086/tasks/arc089_b
    ref: 10**6程度でTLEしてしまったからなかなか使い所が難しい
    N, M, 2D List, func (pick up char from min,max,sum,prd(product),gcd,lmc,^,&,|)

    """
    DEFAULT = {
        'min': 1 << 60,
        'max': -(1 << 60),
        'sum': 0,
        'prd': 1,
        'gcd': 0,
        'lmc': 1,
        '^': 0,
        '&': (1 << 60) - 1,
        '|': 0,
    }

    FUNC = {
        'min': min,
        'max': max,
        'sum': (lambda x, y: x + y),
        'prd': (lambda x, y: x * y),
        'gcd': gcd,
        'lmc': (lambda x, y: (x * y) // gcd(x, y)),
        '^': (lambda x, y: x ^ y),
        '&': (lambda x, y: x & y),
        '|': (lambda x, y: x | y),
    }

    def __init__(self, N, M, ls2D, mode='min'):
        self.default = self.DEFAULT[mode]
        self.func = self.FUNC[mode]
        self.N = N
        self.M = M
        self.KN = (N - 1).bit_length()
        self.KM = (M - 1).bit_length()
        self.N2 = 1 << self.KN
        self.M2 = 1 << self.KM
        self.data = [[self.default] * (2**(self.KM + 1))
                     for i in range(2**(self.KN + 1))]
        for i in range(self.N):
            for j in range(self.M):
                self.data[self.N2 + i][self.M2 + j] = ls2D[i][j]
        self.__build()

    def __build(self):
        for j in range(self.M):
            for i in range(self.N2 - 1, 0, -1):
                self.data[i][self.M2 + j] = self.func(
                    self.data[i << 1][self.M2 + j],
                    self.data[i << 1 | 1][self.M2 + j])
        for i in range(2**(self.KN + 1)):
            for j in range(self.M2 - 1, 0, -1):
                self.data[i][j] = self.func(self.data[i][j << 1],
                                            self.data[i][j << 1 | 1])

    def leafvalue(self, x, y):  # (x,y)番目の値の取得
        return self.data[x + self.N2][y + self.M2]

    def update(self, x, y, value):  # (x,y)の値をvalueに変える
        """change value of (x, y) to value

        Args:
            x (int): x of (x, y)
            y (int): y of (x, y)
            value (int): value
        """
        i = x + self.N2
        j = y + self.M2
        self.data[i][j] = value
        while j > 1:
            j >>= 1
            self.data[i][j] = self.func(self.data[i][j << 1],
                                        self.data[i][j << 1 | 1])
        j = y + self.M2
        while i > 1:
            i >>= 1
            self.data[i][j] = self.func(self.data[i << 1][j],
                                        self.data[i << 1 | 1][j])
            while j > 1:
                j >>= 1
                self.data[i][j] = self.func(self.data[i][j << 1],
                                            self.data[i][j << 1 | 1])
            j = y + self.M2
        return

    def query(self, Lx, Rx, Ly, Ry):
        """value of [Lx,Rx)×[Ly,Ry)

        Args:
            Lx (int): left of x
            Rx (int): right of x
            Ly (int): left of y
            Ry (int): right of y

        Returns:
            int: value
        """
        Lx += self.N2
        Rx += self.N2
        Ly += self.M2
        Ry += self.M2
        vLx = self.default
        vRx = self.default
        while Lx < Rx:
            if Lx & 1:
                vLy = self.default
                vRy = self.default
                Ly1 = Ly
                Ry1 = Ry
                while Ly1 < Ry1:
                    if Ly1 & 1:
                        vLy = self.func(vLy, self.data[Lx][Ly1])
                        Ly1 += 1
                    if Ry1 & 1:
                        Ry1 -= 1
                        vRy = self.func(self.data[Lx][Ry1], vRy)
                    Ly1 >>= 1
                    Ry1 >>= 1
                vy = self.func(vLy, vRy)
                vLx = self.func(vLx, vy)
                Lx += 1
            if Rx & 1:
                Rx -= 1
                vLy = self.default
                vRy = self.default
                Ly1 = Ly
                Ry1 = Ry
                while Ly1 < Ry1:
                    if Ly1 & 1:
                        vLy = self.func(vLy, self.data[Rx][Ly1])
                        Ly1 += 1
                    if Ry1 & 1:
                        Ry1 -= 1
                        vRy = self.func(self.data[Rx][Ry1], vRy)
                    Ly1 >>= 1
                    Ry1 >>= 1
                vy = self.func(vLy, vRy)
                vRx = self.func(vy, vRx)
            Lx >>= 1
            Rx >>= 1
        return self.func(vLx, vRx)


# CHT, LiChaoTree
class LiChaoTree:
    """
    ref: https://atcoder.jp/contests/dp/submissions/17399987
    ref: https://atcoder.jp/contests/dp/tasks/dp_z
    ref: # 線分追加の実装
        https://smijake3.hatenablog.com/entry/2018/06/16/144548        
        https://maspypy.com/segment-tree-%e3%81%ae%e3%81%8a%e5%8b%89%e5%bc%b71#toc6
        問題：https://atcoder.jp/contests/abc076/tasks/abc076_d

    >>> lct = LiChaoTree([1, 2, 3, 5, 6, 8]) # X: List of x-axis values to be used for evaluation
    >>> lct.add_line(1, 3) # add 1*x + 3
    >>> lct.add_line(2, -3) # add 2*x - 3
    >>> lct.query(1) # minimum value of lines at x = x1
    -1
    >>> lct.query(2)
    1
    >>> lct.query(3)
    3
    >>> lct.query(5)
    7
    >>> lct.query(6)
    9
    >>> lct.query(8)
    11
    >>> lct.add_line_seg(0, -2, 2, 3) # add 0*x - 2 to interval of x :[2, 3]
    >>> lct.query(2)
    -2
    >>> lct.query(3)
    -2
    >>> lct.query(5)
    7
    """
    def __init__(self, X):
        X = sorted(list(set(X)))
        self.inf = INF
        self.n = 1 << (len(X) - 1).bit_length()
        self.X = X + [self.inf] * (self.n - len(X))
        self.D = {a: i for i, a in enumerate(X)}
        self.lmr = [(0, 0, 0)] * self.n + [(x, x, x) for x in self.X]
        for i in range(1, self.n)[::-1]:
            self.lmr[i] = (self.lmr[i * 2][0], self.lmr[i * 2][2],
                           self.lmr[i * 2 ^ 1][2])
        self.F = [None] * (self.n * 2)

    def _calc(self, f, x):
        return f[0] * x + f[1]

    def _update(self, i, f):
        while 1:
            l, m, r = self.lmr[i]
            fi = self.F[i]
            if fi is None:
                self.F[i] = f
                return
            cl = self._calc(fi, l) > self._calc(f, l)
            cr = self._calc(fi, r) > self._calc(f, r)
            if cl and cr:
                self.F[i] = f
                return
            if not cl and not cr:
                return
            if self._calc(fi, m) > self._calc(f, m):
                self.F[i], f = f, fi
                cl = not cl
            if cl:
                i *= 2
            else:
                i = i * 2 + 1

    def query(self, x):
        """min(a*x + b) at x = x : O(logN)

        Args:
            x (int): value of x-axis

        Returns:
            int: minimum value
        """
        i = self.D[x] + self.n
        mi = self.inf
        while i > 0:
            if self.F[i]:
                mi = min(mi, self._calc(self.F[i], x))
            i >>= 1
        return mi

    def add_line(self, a, b):
        """add line a*x + b : O(logN)

        Args:
            a (int): a of a*x + a
            b (int): b of a*x + b
        """
        f = (a, b)
        self._update(1, f)

    def add_line_seg(self, a, b, x_L, x_R):
        """add line segment a*x + b to interval [x_L, x_R] (closed, not half-open) : O((logN)**2)

        Args:
            a (int): a of a*x + a
            b (int): b of a*x + b
            x_L (int): left edge of line segment
            x_R (int): right edge of line segment
        """
        L = self.D[x_L] + self.n
        R = (self.D[x_R] + 1) + self.n  # half-open section
        f = (a, b)
        while L < R:
            if L & 1:
                self._update(L, f)
                L += 1
            if R & 1:
                R -= 1
                self._update(R, f)
            L >>= 1
            R >>= 1


class LazySegmentTree_RMQ_RAQ():
    """ RMQ and RAQ
    ref: https://atcoder.jp/contests/dp/submissions/16029749 <= この実装。速いしコードがシンプルで綺麗。
    ref: https://atcoder.jp/contests/dp/submissions/12866634 <= 機能が多くて便利そうだが使い方がまだ良くわからない。拡張機能の参考になりそうだがまず理解する必要あり。

    ex: 
    LST=LazySegmentTree(N,[0]*N,merge_func=min,ide_ele=10**18)
    LST.add(i, r+1, v)
    LST.query(0, N)

    そもそも遅延セグ木については…
    ref: https://maspypy.com/segment-tree-%E3%81%AE%E3%81%8A%E5%8B%89%E5%BC%B72 <= 初めに数学分からない人を門前払いしている感じだが諦めずに後ろを読むと非常に具体的でわかりやすい。
    ref: https://tsutaj.hatenablog.com/entry/2017/03/30/224339 <= とてもわかりやすい。具体例のNが小さいためにO(N)みたいに見えるが、Nを大きくして考えてみるとO(logN）っぽさが納得できる。
    
    """
    def __init__(self, n, init, merge_func=min, ide_ele=10**18):
        self.n = (n - 1).bit_length()
        self.merge_func = merge_func
        self.ide_ele = ide_ele
        self.data = [0 for i in range(1 << (self.n + 1))]
        self.lazy = [0 for i in range(1 << (self.n + 1))]
        for i in range(n):
            self.data[2**self.n + i] = init[i]
        for i in range(2**self.n - 1, 0, -1):
            self.data[i] = self.merge_func(self.data[2 * i],
                                           self.data[2 * i + 1])

    def propagate_above(self, i):
        m = i.bit_length() - 1
        for bit in range(m, 0, -1):
            v = i >> bit
            add = self.lazy[v]
            self.lazy[v] = 0
            self.data[2 * v] += add
            self.data[2 * v + 1] += add
            self.lazy[2 * v] += add
            self.lazy[2 * v + 1] += add

    def remerge_above(self, i):
        while i:
            i >>= 1
            self.data[i] = self.merge_func(self.data[2 * i],
                                           self.data[2 * i + 1]) + self.lazy[i]

    def add(self, l, r, x):
        l += 1 << self.n
        r += 1 << self.n
        l0 = l // (l & -l)
        r0 = r // (r & -r) - 1
        while l < r:
            self.data[l] += x * (l & 1)
            self.lazy[l] += x * (l & 1)
            l += (l & 1)
            self.data[r - 1] += x * (r & 1)
            self.lazy[r - 1] += x * (r & 1)
            l >>= 1
            r >>= 1
        self.remerge_above(l0)
        self.remerge_above(r0)

    def query(self, l, r):
        l += 1 << self.n
        r += 1 << self.n
        l0 = l // (l & -l)
        r0 = r // (r & -r) - 1
        self.propagate_above(l0)
        self.propagate_above(r0)
        res = self.ide_ele
        while l < r:
            if l & 1:
                res = self.merge_func(res, self.data[l])
                l += 1
            if r & 1:
                res = self.merge_func(res, self.data[r - 1])
            l >>= 1
            r >>= 1
        return res


def _ceil_pow2(n: int) -> int:
    x = 0
    while (1 << x) < n:
        x += 1

    return x


class LazySegTree:
    def __init__(self, op: typing.Callable[[typing.Any, typing.Any],
                                           typing.Any], e: typing.Any,
                 mapping: typing.Callable[[typing.Any, typing.Any],
                                          typing.Any],
                 composition: typing.Callable[[typing.Any, typing.Any],
                                              typing.Any], id_: typing.Any,
                 v: typing.Union[int, typing.List[typing.Any]]) -> None:
        self._op = op
        self._e = e
        self._mapping = mapping
        self._composition = composition
        self._id = id_

        if isinstance(v, int):
            v = [e] * v

        self._n = len(v)
        self._log = _ceil_pow2(self._n)
        self._size = 1 << self._log
        self._d = [e] * (2 * self._size)
        self._lz = [self._id] * self._size
        for i in range(self._n):
            self._d[self._size + i] = v[i]
        for i in range(self._size - 1, 0, -1):
            self._update(i)

    def set(self, p: int, x: typing.Any) -> None:
        assert 0 <= p < self._n

        p += self._size
        for i in range(self._log, 0, -1):
            self._push(p >> i)
        self._d[p] = x
        for i in range(1, self._log + 1):
            self._update(p >> i)

    def get(self, p: int) -> typing.Any:
        assert 0 <= p < self._n

        p += self._size
        for i in range(self._log, 0, -1):
            self._push(p >> i)
        return self._d[p]

    def prod(self, left: int, right: int) -> typing.Any:
        assert 0 <= left <= right <= self._n

        if left == right:
            return self._e

        left += self._size
        right += self._size

        for i in range(self._log, 0, -1):
            if ((left >> i) << i) != left:
                self._push(left >> i)
            if ((right >> i) << i) != right:
                self._push(right >> i)

        sml = self._e
        smr = self._e
        while left < right:
            if left & 1:
                sml = self._op(sml, self._d[left])
                left += 1
            if right & 1:
                right -= 1
                smr = self._op(self._d[right], smr)
            left >>= 1
            right >>= 1

        return self._op(sml, smr)

    def all_prod(self) -> typing.Any:
        return self._d[1]

    def apply(self,
              left: int,
              right: typing.Optional[int] = None,
              f: typing.Optional[typing.Any] = None) -> None:
        assert f is not None

        if right is None:
            p = left
            assert 0 <= left < self._n

            p += self._size
            for i in range(self._log, 0, -1):
                self._push(p >> i)
            self._d[p] = self._mapping(f, self._d[p])
            for i in range(1, self._log + 1):
                self._update(p >> i)
        else:
            assert 0 <= left <= right <= self._n
            if left == right:
                return

            left += self._size
            right += self._size

            for i in range(self._log, 0, -1):
                if ((left >> i) << i) != left:
                    self._push(left >> i)
                if ((right >> i) << i) != right:
                    self._push((right - 1) >> i)

            l2 = left
            r2 = right
            while left < right:
                if left & 1:
                    self._all_apply(left, f)
                    left += 1
                if right & 1:
                    right -= 1
                    self._all_apply(right, f)
                left >>= 1
                right >>= 1
            left = l2
            right = r2

            for i in range(1, self._log + 1):
                if ((left >> i) << i) != left:
                    self._update(left >> i)
                if ((right >> i) << i) != right:
                    self._update((right - 1) >> i)

    def max_right(self, left: int, g: typing.Callable[[typing.Any],
                                                      bool]) -> int:
        assert 0 <= left <= self._n
        assert g(self._e)

        if left == self._n:
            return self._n

        left += self._size
        for i in range(self._log, 0, -1):
            self._push(left >> i)

        sm = self._e
        first = True
        while first or (left & -left) != left:
            first = False
            while left % 2 == 0:
                left >>= 1
            if not g(self._op(sm, self._d[left])):
                while left < self._size:
                    self._push(left)
                    left *= 2
                    if g(self._op(sm, self._d[left])):
                        sm = self._op(sm, self._d[left])
                        left += 1
                return left - self._size
            sm = self._op(sm, self._d[left])
            left += 1

        return self._n

    def min_left(self, right: int, g: typing.Any) -> int:
        assert 0 <= right <= self._n
        assert g(self._e)

        if right == 0:
            return 0

        right += self._size
        for i in range(self._log, 0, -1):
            self._push((right - 1) >> i)

        sm = self._e
        first = True
        while first or (right & -right) != right:
            first = False
            right -= 1
            while right > 1 and right % 2:
                right >>= 1
            if not g(self._op(self._d[right], sm)):
                while right < self._size:
                    self._push(right)
                    right = 2 * right + 1
                    if g(self._op(self._d[right], sm)):
                        sm = self._op(self._d[right], sm)
                        right -= 1
                return right + 1 - self._size
            sm = self._op(self._d[right], sm)

        return 0

    def _update(self, k: int) -> None:
        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])

    def _all_apply(self, k: int, f: typing.Any) -> None:
        self._d[k] = self._mapping(f, self._d[k])
        if k < self._size:
            self._lz[k] = self._composition(f, self._lz[k])

    def _push(self, k: int) -> None:
        self._all_apply(2 * k, self._lz[k])
        self._all_apply(2 * k + 1, self._lz[k])
        self._lz[k] = self._id


def slide_max_index(a, K):
    """max_idx[i]: 区間 [i - K + 1, i] (両側閉区間)における a の最大値を与えるインデックス, 長さKに満たない左側領域もついでに計算
    ref: https://qiita.com/kuuso1/items/318d42cd089a49eeb332

    Args:
        a ([list]): 配列
        K ([int]): スライドの長さ

    Returns:
        list, list: max_idx, max_val
    """
    #
    N = len(a)
    max_idx = [0] * N  # (長さKに満たない左側領域もついでに計算する)
    max_val = [0] * N  # (長さKに満たない左側領域もついでに計算する)
    deq = deque()  # デック．番長順番待ちキューをシミュレートする．インデックスを格納しておく

    for i in range(0, N):
        while len(deq) > 0 and deq[0] <= i - K:
            deq.popleft()  # 卒業する
        while len(deq) > 0 and a[deq[-1]] < a[i]:
            deq.pop()  # a[i] の入学で 望みがなくなった先輩達が脱落する
        deq.append(i)  # 新入生i は常に番長になる望みがある
        max_idx[i] = deq[0]  # 番長順番待ちキューの最左が番長
        max_val[i] = a[deq[0]]  # 番長順番待ちキューの最左が番長

    return max_idx, max_val


# ************ Graph ************
# Graph: https://en.wikipedia.org/wiki/Directed_graph
# 最短経路問題: https://ja.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E7%B5%8C%E8%B7%AF%E5%95%8F%E9%A1%8C
# Visual site (graph×graph): https://hello-world-494ec.firebaseapp.com/ 最初に「nodeの数 辺の数」 次以降 「node node」を入力する。
# ダイクストラ Dijkstra: 各辺が非負のコストを持つときある1つのノードからあるもう一つのノードへの最短経路を求めるやつ。
# Bellman-Ford: O(|V||E|). Use this if there exists an edge with negative length in the graph
# After N steps, the shortest path has converded if there doesn't exist an cycle of edges with negative
# Watch out: d[N] == d[2*N] doesn't necessarily mean the graph doesn't have negative cycle
# ref: https://www.youtube.com/watch?v=1Z6ofKN03_Y


def BellmanFord(N,
                M,
                ABC,
                vertex_start,
                vertex_end,
                value_if_inf=-1,
                find_shortest=False):
    """to calculate furthest or shortest length between vertex_start and vertex_end using BellmanFord algorithm
    
    Args:
        N (int): number of vertices
        M (int): number of edges
        ABC (list): [(ai, bi, ci) for _ in range(N)] where i-th edge is directed from vertex ai to vertex bi and the length is ci 
        vertex_start (int): start vertex. usually use 0.
        vertex_end (int): end vertex. usually use N-1.
        value_if_inf (int or string as you like, optional): value you want when the furthest (or shortest) distance is infinite (or -infinite). Defaults to -1.
        find_shortest (bool, optional): choose False to find furthest path. Defaults to False.
    
    Returns:
        int or string: normally int (but can be str if you set value_if_inf to str)
        
    Example:
            N, M, P = R()
            ABC = [R() for _ in range(M)]
            ABC = [(a-1, b-1, c-P) for a, b, c in ABC]
            print(BellmanFord(N, M, ABC, 0, N-1, value_if_inf = 'inf'))
 
    """
    def make_reachable_list(N, M, ABC, vertex_start, vertex_end):
        reachable_to_direct = defaultdict(list)
        reachable_from_direct = defaultdict(list)
        reachable_from_start = [False] * N
        reachable_to_end = [False] * N
        reachable_from_start[vertex_start] = True
        reachable_to_end[vertex_end] = True
        reachable_from_both_sides = [False] * N
        dfs_from_start = []
        dfs_to_end = []
        for a, b, c in ABC:
            reachable_to_direct[a].append(b)
            reachable_from_direct[b].append(a)
            if a == vertex_start:
                dfs_from_start.append(b)
                reachable_from_start[b] = True
            if b == vertex_end:
                dfs_to_end.append(a)
                reachable_to_end[a] = True
        while dfs_from_start:
            v = dfs_from_start.pop()
            for i in reachable_to_direct[v]:
                if not reachable_from_start[i]:
                    reachable_from_start[i] = True
                    dfs_from_start.append(i)
        while dfs_to_end:
            v = dfs_to_end.pop()
            for i in reachable_from_direct[v]:
                if not reachable_to_end[i]:
                    reachable_to_end[i] = True
                    dfs_to_end.append(i)
        for i in range(N):
            reachable_from_both_sides[
                i] = reachable_from_start[i] and reachable_to_end[i]
        return reachable_from_both_sides

    reachable_from_both_sides = make_reachable_list(N, M, ABC, vertex_start,
                                                    vertex_end)

    if find_shortest:
        dist = [INF for i in range(N)]
    else:
        dist = [-INF for i in range(N)]

    dist[vertex_start] = 0
    for i in range(N):
        updated = False
        for a, b, c in ABC:
            if not reachable_from_both_sides[a]:
                continue
            elif find_shortest:
                update_condition = dist[a] + c < dist[b]
            else:
                update_condition = dist[a] + c > dist[b]
            if dist[a] != INF and update_condition:
                dist[b] = dist[a] + c
                updated = True
                if i == N - 1:
                    return value_if_inf
        if not updated:
            break
    return dist[vertex_end]


# Warshall Floyd O(V**3) # V:vertex(頂点, nodeともいう)
def warshall_floyd(number_vertex,
                   XYD,
                   directed=False,
                   shift_one_for_vertex=False,
                   init_dist=INF):
    """O(V**3)
    # ref: https://juppy.hatenablog.com/entry/2018/11/01/%E8%9F%BB%E6%9C%AC_python_%E5%85%A8%E7%82%B9%E5%AF%BE%E6%9C%80%E7%9F%AD%E7%B5%8C%E8%B7%AF%E6%B3%95%EF%BC%88%E3%83%AF%E3%83%BC%E3%82%B7%E3%83%A3%E3%83%AB%E3%83%95%E3%83%AD%E3%82%A4%E3%83%89%E6%B3%95

    Args:
        number_vertex (int): number of vertex(nodes)
        XYD (list): list of distance from x and y
        directed(bool, optional): True if XYD implies direction (only x -> y is approved, and y-> x is banned)
        shift_one_for_vertex (bool, optional): True if XY is 1-indexed. Defaults to False.

    Returns:
        list: d[i][j] is distance from i to j
    """
    d = [[init_dist] * number_vertex for i in range(number_vertex)]
    for x, y, dist in XYD:
        if shift_one_for_vertex:
            x = x - 1
            y = y - 1
        d[x][y] = dist
        if not directed:
            d[y][x] = dist
    for i in range(number_vertex):
        d[i][i] = 0  # distance of same vertex is 0
    for k in range(number_vertex):
        for i in range(number_vertex):
            for j in range(number_vertex):
                d[i][j] = min(d[i][j], d[i][k] + d[k][j])
    return d


# 最短ハミルトン路問題とは，グラフが与えられたとき，全ての頂点を一度ずつ通るパスで，経路長が最短のものを求める問題である．求めるものがパスでなく，サイクルである場合は最短ハミルトン閉路，もしくは巡回セールスマン問題という． O(N^2 2**N) => N=17程度
# ref: http://www.prefield.com/algorithm/graph/shortest_hamilton_path.html
# ref: https://atcoder.jp/contests/abc190/submissions/19832174


# 最小共通祖先
# https://ikatakos.com/pot/programming_algorithm/graph_theory/lowest_common_ancestor
class LcaDoubling:
    """
    links[v] = { (u, w), (u, w), ... }  (u:隣接頂点, w:辺の重み)
    というグラフ情報から、ダブリングによるLCAを構築。
    任意の2頂点のLCAおよび距離を取得できるようにする
    """
    def __init__(self, n, links, root=0):
        self.depths = [-1] * n
        self.distances = [-1] * n
        prev_ancestors = self._init_dfs(n, links, root)
        self.ancestors = [prev_ancestors]
        max_depth = max(self.depths)
        d = 1
        while d < max_depth:
            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]
            self.ancestors.append(next_ancestors)
            d <<= 1
            prev_ancestors = next_ancestors

    def _init_dfs(self, n, links, root):
        q = [(root, -1, 0, 0)]
        direct_ancestors = [-1] * (n + 1
                                   )  # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1
        while q:
            v, p, dep, dist = q.pop()
            direct_ancestors[v] = p
            self.depths[v] = dep
            self.distances[v] = dist
            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)
        return direct_ancestors

    def get_lca(self, u, v):
        du, dv = self.depths[u], self.depths[v]
        if du > dv:
            u, v = v, u
            du, dv = dv, du
        tu = u
        tv = self.upstream(v, dv - du)
        if u == tv:
            return u
        for k in range(du.bit_length() - 1, -1, -1):
            mu = self.ancestors[k][tu]
            mv = self.ancestors[k][tv]
            if mu != mv:
                tu = mu
                tv = mv
        lca = self.ancestors[0][tu]
        assert lca == self.ancestors[0][tv]
        return lca

    def get_distance(self, u, v):
        lca = self.get_lca(u, v)
        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]

    def upstream(self, v, k):
        i = 0
        while k:
            if k & 1:
                v = self.ancestors[i][v]
            k >>= 1
            i += 1
        return v


# 部分木に値追加を行うクエリなどに対応できる
class EulerTour:
    """
    N: number of node
    X: connection of each node, 0-index
    i0: root. 多分。
    
    Returns:
        [type]: [description]

    ref: https://qiita.com/Kiri8128/items/2b0023bed9af642c751c
    ref: https://maspypy.com/euler-tour-%E3%81%AE%E3%81%8A%E5%8B%89%E5%BC%B7
    
    ところでEulerTourのナンバーの振り方はバリエーションがあるようだ。その一つで、ノードにInとOutの際にカウントを増やす場合のイメージ図：https://atcoder.jp/contests/abc202/editorial/1864
    """
    def __init__(self, N, X, i0=0):
        self.N = N
        self.i0 = i0
        self.ET, self.In, self.Out, self.Depth = self.EulerTour(X.copy())

    def EulerTour(self, X):
        # Xは破壊してXとPができる
        P = [-1] * self.N
        Q = [~self.i0, self.i0]
        ct = -1
        ET = []
        ET1 = [0] * self.N
        ET2 = [0] * self.N
        DE = [0] * self.N
        de = -1
        while Q:
            i = Q.pop()
            if i < 0:
                # ↓ 戻りも数字を足す場合はこれを使う
                ct += 1
                # ↓ 戻りもETに入れる場合はこれを使う
                ET.append(P[~i])
                ET2[~i] = ct
                de -= 1
                continue
            if i >= 0:
                ET.append(i)
                ct += 1
                if ET1[i] == 0: ET1[i] = ct
                de += 1
                DE[i] = de
            for a in X[i][::-1]:
                if a != P[i]:
                    P[a] = i
                    for k in range(len(X[a])):
                        if X[a][k] == i:
                            del X[a][k]
                            break
                    Q.append(~a)
                    Q.append(a)
        return (ET, ET1, ET2, DE)


# chain decomposition による木の橋(bridge)と関節点(joint point)の探索。(ただ、橋と関節点はlowlinkによる実装が普通みたいです。)
def bridges_and_joint_points(
        G: List[List[int]], N: int) -> Tuple[List[Tuple[int, int]], List[int]]:
    """chain decompositionで木の橋と関節点を求める
    計算量: O(|V|+|E|)
    ref: https://smijake3.hatenablog.com/entry/2019/08/24/164727
    TODO: ロジックの理解
    problem: https://atcoder.jp/contests/abc075/tasks/abc075_c (制約が甘いので全探索でもOKな問題)

    Args:
        G (List[List[int]]): Graph. 良くedges = [list() for _ in range(N)], for a, b in AB: edges[a].append(b) edges[b].append(a)として作っているもの。
        N (int): number of nodes

    Returns:
        Tuple[List[Tuple[int, int]], List[int]]: tuple of Bridges and Joint points
        
    ex:
        # B: グラフGの橋
        # A: グラフGの関節点
        B, A = bridges_and_joint_points(G, N)
    """
    # P[v]: DFS-treeにおける頂点vの親頂点
    P = [0] * N
    # G0: グラフGのbackedgeのみに絞った有向グラフ
    G0 = [[] for i in range(N)]
    # V: 頂点をpre-orderに並べたもの
    V = []

    # P, V, G0 を計算するDFS
    lb = [0] * N

    def dfs(v, p):
        P[v] = p
        V.append(v)
        lb[v] = len(V)
        for w in G[v]:
            if w == p:
                continue
            if lb[w]:
                if lb[v] < lb[w]:
                    # (v, w) は backedge
                    G0[v].append(w)
                continue
            # (v, w) は tree edge
            dfs(w, v)

    dfs(0, -1)

    # B: 橋となる辺e = (u, v) のリスト
    B = []
    # ap[v]: 頂点vが関節点であるか?
    ap = [0] * N

    used = [0] * N
    first = 1
    used[0] = 1
    # グラフの頂点をpre-orderで見ていく
    for u in V:
        if not used[u]:
            # 頂点uは以前に探索されてない
            # -> この親頂点pへのtree edgeがchainとして含まれない
            # -> 辺(u, p) は橋
            p = P[u]
            B.append((u, p) if u < p else (p, u))
            # 橋に隣接し、次数が2以上の頂点は関節点
            if len(G[u]) > 1:
                ap[u] = 1
            if len(G[p]) > 1:
                ap[p] = 1

        # 頂点vが始点となるbackedgeについて調べる
        cycle = 0
        for v in G0[u]:
            # tree edgeに従って根頂点に向かって上がっていく
            w = v
            while w != u and not used[w]:
                used[w] = 1
                w = P[w]
            # このchainはcycle
            if w == u:
                cycle = 1

        if cycle:
            if not first:
                # 2つ目以降のcycle chainである場合、頂点uは関節点
                ap[u] = 1
            first = 0

    A = [v for v in range(N) if ap[v]]
    return B, A


# 強連結成分分解
def scc(N, edges):
    M = len(edges)
    start = [0] * (N + 1)
    elist = [0] * M
    for e in edges:
        start[e[0] + 1] += 1
    for i in range(1, N + 1):
        start[i] += start[i - 1]
    counter = start[:]
    for e in edges:
        elist[counter[e[0]]] = e[1]
        counter[e[0]] += 1
    NG = [0, 0]
    visited = []
    low = [0] * N
    Ord = [-1] * N
    ids = [0] * N

    def dfs(v):
        low[v] = NG[0]
        Ord[v] = NG[0]
        NG[0] += 1
        visited.append(v)
        for i in range(start[v], start[v + 1]):
            to = elist[i]
            if Ord[to] == -1:
                dfs(to)
                low[v] = min(low[v], low[to])
            else:
                low[v] = min(low[v], Ord[to])
        if low[v] == Ord[v]:
            while (True):
                u = visited.pop()
                Ord[u] = N
                ids[u] = NG[1]
                if u == v:
                    break
            NG[1] += 1

    for i in range(N):
        if Ord[i] == -1:
            dfs(i)
    for i in range(N):
        ids[i] = NG[1] - 1 - ids[i]
    group_num = NG[1]
    counts = [0] * group_num
    for x in ids:
        counts[x] += 1
    groups = [[] for i in range(group_num)]
    for i in range(N):
        groups[ids[i]].append(i)
    return groups


class SCCGraph:
    """
    ref: https://github.com/not522/ac-library-python/blob/master/atcoder/scc.py
    
    ex:
    N, M = R()
    AB = Rs(M)
    scc = SCCGraph(N, AB)
    ans = scc.scc()
    print(len(ans))
    for a in ans:
        print(len(a), *a)

    """
    def __init__(
            self,
            n: int = 0,
            edges: typing.Optional[typing.List[typing.List[int]]] = None
    ) -> None:
        self._internal = _SCCGraph(n)
        if edges:
            for from_vertex, to_vertex in edges:
                self.add_edge(from_vertex, to_vertex)

    def add_edge(self, from_vertex: int, to_vertex: int) -> None:
        n = self._internal.num_vertices()
        assert 0 <= from_vertex < n
        assert 0 <= to_vertex < n
        self._internal.add_edge(from_vertex, to_vertex)

    def scc(self) -> typing.List[typing.List[int]]:
        return self._internal.scc()


class _CSR:
    def __init__(self, n: int, edges: typing.List[typing.Tuple[int,
                                                               int]]) -> None:
        self.start = [0] * (n + 1)
        self.elist = [0] * len(edges)

        for e in edges:
            self.start[e[0] + 1] += 1

        for i in range(1, n + 1):
            self.start[i] += self.start[i - 1]

        counter = deepcopy(self.start)
        for e in edges:
            self.elist[counter[e[0]]] = e[1]
            counter[e[0]] += 1


class _SCCGraph:
    '''
    Reference:
    R. Tarjan,
    Depth-First Search and Linear Graph Algorithms
    '''
    def __init__(self, n: int) -> None:
        self._n = n
        self._edges: typing.List[typing.Tuple[int, int]] = []

    def num_vertices(self) -> int:
        return self._n

    def add_edge(self, from_vertex: int, to_vertex: int) -> None:
        self._edges.append((from_vertex, to_vertex))

    def scc_ids(self) -> typing.Tuple[int, typing.List[int]]:
        g = _CSR(self._n, self._edges)
        now_ord = 0
        group_num = 0
        visited = []
        low = [0] * self._n
        order = [-1] * self._n
        ids = [0] * self._n

        sys.setrecursionlimit(max(self._n + 1000, sys.getrecursionlimit()))

        def dfs(v: int) -> None:
            nonlocal now_ord
            nonlocal group_num
            nonlocal visited
            nonlocal low
            nonlocal order
            nonlocal ids

            low[v] = now_ord
            order[v] = now_ord
            now_ord += 1
            visited.append(v)
            for i in range(g.start[v], g.start[v + 1]):
                to = g.elist[i]
                if order[to] == -1:
                    dfs(to)
                    low[v] = min(low[v], low[to])
                else:
                    low[v] = min(low[v], order[to])

            if low[v] == order[v]:
                while True:
                    u = visited[-1]
                    visited.pop()
                    order[u] = self._n
                    ids[u] = group_num
                    if u == v:
                        break
                group_num += 1

        for i in range(self._n):
            if order[i] == -1:
                dfs(i)

        for i in range(self._n):
            ids[i] = group_num - 1 - ids[i]

        return group_num, ids

    def scc(self) -> typing.List[typing.List[int]]:
        ids = self.scc_ids()
        group_num = ids[0]
        counts = [0] * group_num
        for x in ids[1]:
            counts[x] += 1
        groups: typing.List[typing.List[int]] = [[] for _ in range(group_num)]
        for i in range(self._n):
            groups[ids[1][i]].append(i)

        return groups


# ************ Tree ************
def topological_sorted_tree(XY, N, root=0):
    """topological sort of tree
    # ref: https://qiita.com/Kiri8128/items/cbaa021dbcb07b5fdb92

    Args:
        XY (list of lists): connection between nodes (0-indexed)
        N (int): number of nodes
        root (int, optional): root of tree. Defaults to 0.

    Returns:
        list, list, list, list: children (=edges without parent node), topologically sorted node, parent index, partial_size
        
    ex: https://atcoder.jp/contests/dp/tasks/dp_p
        N = r_int()
        XY = [R1() for _ in range(N-1)]
        children, topo_sort, parent, partial_size = topological_sorted_tree(XY, N)
        MOD = 10**9+7
        
        dpw = [1]*N
        dpb = [1]*N
        for i in topo_sort[::-1]:
            for child in children[i]:
                dpw[i]*=dpw[child]+dpb[child]
                dpw[i]%=MOD
                dpb[i]*=dpw[child]
                dpb[i]%=MOD
        print((dpw[0]+dpb[0])%MOD)
    """

    children = [list() for _ in range(N)]
    for x, y in XY:
        children[x].append(y)
        children[y].append(x)

    parent = [-1] * N  # parent[i] はiの親。iが根なら-1
    Q = deque([root])  # queue。根にするやつを最初に追加
    topo_sort = []  # トポロジカルソート
    while Q:
        i = deque.popleft(Q)
        topo_sort.append(i)
        for a in children[i]:
            if a == parent[i]: continue
            parent[a] = i
            children[a].remove(i)
            deque.append(Q, a)

    partial_size = [1] * N
    for i in topo_sort[:0:-1]:
        partial_size[parent[i]] += partial_size[i]
    return children, topo_sort, parent, partial_size


# 全方位木DP(rerooting)
def retooting(X, Topo, P, N, unit, merge, adj_bu, adj_td, adj_fin, root=0):
    """全方位DP
    # ref: https://qiita.com/Kiri8128/items/a011c90d25911bdb3ed3
    # ref: https://atcoder.jp/contests/dp/submissions/19898045

    Args:
        X (list): [description]
        Topo (list): [description]
        P (list): [description]
        N (int): [description]
        unit ([type]): [description]
        merge ([type]): function used to merge to dp.
        adj_bu ([type]): function used after merged.DPの遷移がf(i)=Σmerge(j:= iの子)+g(i)と表せるときのg(i)部分、みたいなイメージ
        adj_td ([type]): function used after merged.DPの遷移がf(i)=merge(j:= iの親)+g(i)と表せるときのg(i)部分
        adj_fin ([type]): function finally used
        root (int, optional): [description]. Defaults to 0.

    Returns:
        list: result of rerooting dp. 全方位木DPの結果

    ex: simple. ただし累積和を使わない実装はうまく行かない問題。 https://atcoder.jp/contests/dp/tasks/dp_v
        N, MOD = R()
        XY = [R1() for _ in range(N-1)]

        children, topo_sort, parent, partial_size = topological_sorted_tree(XY, N)
        dp = retooting(
                children, topo_sort, parent, N, unit=1, 
                merge = lambda a, b: a * b % MOD, 
                adj_bu = lambda a, i: a + 1, 
                adj_td = lambda a, i, p: a + 1, 
                adj_fin = lambda a, i: a
            )
        print(*dp)

    ex2: 頂点更新時に子の数が必要な場合 https://atcoder.jp/contests/abc160/tasks/abc160_f
        (ほぼ同じ問題として https://atcoder.jp/contests/tdpc/tasks/tdpc_tree)
        N = r_int()
        XY = [R1() for _ in range(N-1)]
        MOD = 10**9+7

        children, topo_sort, parent, partial_size = topological_sorted_tree(XY, N)
        comb = ModComb(N, MOD)

        # ダメなパターンが何割含まれるか、をDPで積み重ねていき、最後に階乗を加えることで、全部の組合せを出す。かなり頭が混乱しますね。
        # 例えば1-2, 2-3, 2-4, 2-5, 2-6のN=6の木で、2の部分での更新に注目するとき、2の下の部分の並べ方のうち、良いパターンは2が先頭に来て、5-6の順序が整っていることである。「5-6の順序が整っていること」は5の部分の更新ですでに見ているため、あたらに考慮すべき部分は1/5を掛けることである。それがadj_buである。
        # dpを積み重ねていくことで、全通り中の良いパターンの確率ができており、それに全通り（Nの階乗）をかけてあげることで、組合せ総数が出てくる。
        
        dp = retooting(
                children, topo_sort, parent, N, unit=1, 
                merge = lambda a, b: a * b % MOD,
                adj_bu = lambda a, i: a * comb.inv(partial_size[i]) % MOD,
                adj_td = lambda a, i, p: a * comb.inv(N-partial_size[i]) % MOD,
                adj_fin = lambda a, i: a * comb.fact[N-1] % MOD
            )

        print(*dp)

    ex3: 木の最長距離（直径） https://atcoder.jp/contests/arc022/tasks/arc022_3
        N = r_int()
        XY = [R1() for _ in range(N-1)]
        children, topo_sort, parent, partial_size = topological_sorted_tree(XY, N)
        dp = retooting(
                children, topo_sort, parent, N, unit=0, 
                merge = lambda a, b: max(a,b),
                adj_bu = lambda a, i: a + 1,
                adj_td = lambda a, i, p: a + 1,
                adj_fin = lambda a, i: a
            )

        mdp = max(dp)
        ans = []

        for i, d in enumerate(dp):
            if d == mdp:
                ans.append(i+1)
                break
        
        edges = [list() for _ in range(N)]
        for x, y in XY:
            edges[x].append(y)
            edges[y].append(x)
        arrived = [0]*N
        arrived[i] = 1
        tasks = deque([i])
        while tasks:
            task = tasks.popleft()
            for node in edges[task]:
                if not arrived[node]:
                    arrived[node] = 1
                    tasks.append(node)
        ans.append(task+1)
        print(*ans)
        
    """

    # Bottom-Up 部分
    ACC = [unit] * N  # acc[i](=頂点iのp方向以外からの(=葉方向からの)集約(調整前))
    res_BU = [0] * N  #  res_BU[i], acc[i]に調整を入れたもの
    for i in Topo[:0:-1]:  # root=0部分はここでは計算しない
        p = P[i]  # 親ノード
        res_BU[i] = adj_bu(ACC[i], i)  # bottom up関数で res_BU[i]を作成
        ACC[p] = merge(ACC[p], res_BU[i])  # 親の集約
    res_BU[Topo[0]] = adj_fin(ACC[Topo[0]], Topo[0])

    res = [i for i in res_BU]

    # Top-Down 部分
    AL = [unit] * N  # accum from left
    TD = [unit] * N  # 根方向の合計
    for i in Topo:
        # 左からDP（結果はALに格納）
        ac = TD[i]  # ac: accum, 親を含めて左から累積merge
        for j in X[i]:
            AL[j] = ac
            ac = merge(ac, res_BU[j])
        # 右からDP（結果はacに入れており、右からのDP）
        ac = unit  # 右側は親を含めないので、左と合わせることで対象とするi以外の累積が取れる。
        for j in X[i][::-1]:
            TD[j] = adj_td(merge(AL[j], ac), j, i)  # jに根方向合計を格納
            ac = merge(ac, res_BU[j])  # ac（右からのDP）を更新
            res[j] = adj_fin(merge(ACC[j], TD[j]), j)

    return res


# ************ 文字列検索 ************
class KMP:
    """文字列Sから文字列Tを検索する手法。一致先頭のindexを返す。
    別にクラスにしなくてよかったという説がある。
    ref: https://ikatakos.com/pot/programming_algorithm/string_search
    ref: https://atcoder.jp/contests/abc150/tasks/abc150_f
    >>> kmp = KMP("すごいはすけるすごいすごい", "すごい")
    >>> print(kmp.L)
    [0, 7, 10]
    >>> kmp = KMP("abcaabcabcaabcdbabcdbabcabcaabcdbabc", "abcaabcdbabc")
    >>> print(kmp.L)
    [7, 24]
    """
    def __init__(self, S: str, T: str):
        self.S = S
        self.T = T
        self.L = self.kmp()

    def make_kmp_table(self, t):
        i = 2
        j = 0
        m = len(t)
        tbl = [0] * (m + 1)
        tbl[0] = -1
        while i <= m:
            if t[i - 1] == t[j]:
                tbl[i] = j + 1
                i += 1
                j += 1
            elif j > 0:
                j = tbl[j]
            else:
                tbl[i] = 0
                i += 1
        return tbl

    def kmp(self):
        matched_indices = []
        tbl = self.make_kmp_table(self.T)
        i = 0
        j = 0
        n = len(self.S)
        m = len(self.T)
        while i + j < n:
            if self.T[j] == self.S[i + j]:
                j += 1
                if j == m:
                    matched_indices.append(i)
                    i += j - tbl[j]
                    j = tbl[j]
            else:
                i += j - tbl[j]
                if j > 0:
                    j = tbl[j]
        return matched_indices


# KMPのほうが良さそう？
import random


def rabin_karp_Rolling_Hash(s, t):
    """
    https://ikatakos.com/pot/programming_algorithm/string_search
    ハッシュ化にO(|S|+|T|), 検索にO(S)
    >>> print(rabin_karp_Rolling_Hash("スパゲティスパゲッティ", "スパゲ"))
    [0, 5]
    """
    def exe(x, m):
        th = 0
        for c in tt:
            th = (th * x + c) % m

        sh = 0
        for c in st[:l]:
            sh = (sh * x + c) % m
        xl = pow(x, l - 1, m)

        matched = set()
        if sh == th:
            matched.add(0)
        for i, (c0, c1) in enumerate(zip(st, st[l:]), start=1):
            sh = ((sh - c0 * xl) * x + c1) % m
            if sh == th:
                matched.add(i)

        return matched

    l = len(t)
    st = list(map(ord, s))
    tt = list(map(ord, t))
    # Xはなるべくst,ttの最大要素より大きくする
    # Mはとりあえず2^61-1(素数)を設定する
    xs = random.sample(range(10**9, 10**10), 3)
    ans = exe(xs[0], 2305843009213693951)
    ans.intersection_update(exe(xs[1], 2305843009213693951))
    ans.intersection_update(exe(xs[2], 2305843009213693951))
    return sorted(ans)


def count_repetition(S):
    """count repetition in S(str or list): O(NlogN)と思う。思い付きで実装したので別に早くはない。O(N)ありそうだがNlogN十分でしょう。
    ref: https://atcoder.jp/contests/abc150/tasks/abc150_f

    Args:
        S (str or list): target

    Returns:
        int: cnt of repetition in S
    
    >>> print(count_repetition([1,1,2,1,1,2,1,1,2]))
    3
    >>> print(count_repetition("112112112"))
    3
    >>> print(count_repetition("abcbbabc"))
    1
    >>> print(count_repetition("abcabc"))
    2
    """
    for i in make_divisors(len(S)):
        if i == 1:
            repetition_S = 1
            continue
        for j in range(i):
            if S[:(len(S) // i)] != S[(len(S) // i) * j:(len(S) // i) *
                                      (j + 1)]:
                break
        else:
            repetition_S = i
    return repetition_S


def Zalgorithm(s):
    """
    O(n)で文字列Sの各開始位置iに対して「SとS[i:]が先頭何文字まで一致するか？
    （最長共通接頭辞数）」を構築するアルゴリズム。
    TODO: あまり理解はしていない。
    
    ref(実装): https://jetbead.hatenablog.com/entry/20130503/1367517589
    ref: https://ikatakos.com/pot/programming_algorithm/string_search
    >>> Zalgorithm("やばいやばかったやばいや")
    [12, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0, 1]
    """
    ans = []
    ans.append(len(s))
    # ret = 0
    n = len(s)
    z = [0] * n
    L, R = 0, 0
    for i in range(1, n):
        if i > R:
            L, R = i, i
            while R < n and s[R - L] == s[R]:
                R += 1
            z[i] = R - L
            R -= 1
        else:
            k = i - L
            if z[k] < R - i + 1:
                z[i] = z[k]
            else:
                L = i
                while R < n and s[R - L] == s[R]:
                    R += 1
                z[i] = R - L
                R -= 1
        # ret = max(ret, z[i])
        ans.append(z[i])
    # return ret
    return ans


""" initialize variables and set inputs
# initialize variables
    # to initialize list, use [0] * n
    # to initialize two dimentional array:
        # ex) [[0] * N for _ in range(N)]
        # ex2) dp = [[0] * (N+1) for _ in range(W*2)]
# set inputs
    # put inputs between specific values (almost as quickly)
    # ex) S = [-INF] + [int(r()) for _ in range(A)] + [INF]
    # open(0).read() is sometimes useful:
    # ex) n, m, *x = map(int, open(0).read().split())
    #     min(x[::2]) - max(x[1::2])
    # ex2) *x, = map(int, open(0).read().split())
    #     don't forget to add comma after *x if only one variable is used
# preprocessing
    # transpose = [x for x in zip(*data)]
    # ex) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] => [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
    # flat = [flatten for inner in data for flatten in inner]
    # ex) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] => [1, 2, 3, 4, 5, 6, 7, 8, 9]
    # split: Point [〇 for _ in _ for _ in _]では左から順に評価されるが、[[〇 for _ in _] for _ in _]では外側から評価される
    # ex) KT = [[3, 1, 200, 1000], [5, 20, 30, 40, 50, 2]] K1, T11, T12, ...
    # K = [k for kt in KT for i, k in enumerate(kt) if i == 0]
    # T = [[k for i, k in enumerate(kt) if i != 0] for kt in KT]
    
# calculate and output
    # output pattern
    # ex1) print(*l) => when l = [2, 5, 6], printed 2 5 6
"""

# functions to read input
# TODO: なおsys.stdin.buffer.readline (read, readlines)のほうが多少早いことが多いらしい
# https://twitter.com/maspy_stars/status/1179226257982185472
r = lambda: sys.stdin.readline().strip()
rs = lambda N: [r() for _ in range(N)]
r_int = lambda: int(r())
r1_int = lambda: int(r()) - 1
r_float = lambda: float(r())
r_ints = lambda N: [r_int() for _ in range(N)]
r1_ints = lambda N: [r1_int() for _ in range(N)]

R = lambda: list(map(int, r().split()))
R_mod = lambda: list(map(ModInt, map(int, r().split())))
R1 = lambda: list(map(lambda x: int(x) - 1, r().split()))  # a,b = a-1,b-1の省略
Rs = lambda N: [R() for _ in range(N)]
R1s = lambda N: [R1() for _ in range(N)]
R1s_XYD = lambda N: [[x - 1, y - 1, z] for x, y, z in iter(
    R() for _ in range(N))]  # x, y, dでx,yだけ-1したい場合
R1s_S = lambda N, S, add=-1: [[
    x + add if i in set(S) else x for i, x in enumerate(R())
] for _ in range(N)]

R_str = lambda: list(r().split())
R1_S = lambda S, add=-1: [
    x + add if i in set(S) else x for i, x in enumerate(R())
]

R_map = lambda: map(int, r().split())
R_float = lambda: list(map(float, r().split()))


# R_tuple = lambda: tuple(map(int, r().split())) # not recommended because tuple looks slow in pypy(?)
def x10(S: str, n: int):
    """change float to int by *10**n

    Args:
        S (str): float
        n (int, optional): n of float(S)*10**n (number of shift).

    Returns:
        int: S*10**n
    """
    if "." not in S:
        return int(S) * 10**n
    return int("".join([S.replace(".", ""), "0" * (n - S[::-1].find("."))]))


Rx10 = lambda n: list(map(lambda s: x10(s, n), r().split()))

list2d = lambda a, b, v: [[v] * b for _ in range(a)]
list2d_mod = lambda a, b, v: [[ModInt(v) for _ in range(b)] for _ in range(a)]
list3d = lambda a, b, c, v: [[[v] * c for _ in range(b)]
                             for _ in range(a)]  # slow.
list3d_mod = lambda a, b, c, v: [[[ModInt(v) for _ in range(c)]
                                  for _ in range(b)]
                                 for _ in range(a)]  # slow.
list4d = lambda a, b, c, d, v: [[[[v] * d for _ in range(c)] for _ in range(b)]
                                for _ in range(a)]  # slow.
list4d_mod = lambda a, b, c, d, v: [[[[ModInt(v) for _ in range(d)]
                                      for _ in range(c)] for _ in range(b)]
                                    for _ in range(a)]  # slow.


class rr:
    r = lambda: sys.stdin.readline().strip()
    rs = lambda N: [rr.r() for _ in range(N)]
    r_int = lambda: int(rr.r())
    r1_int = lambda: int(rr.r()) - 1
    r_float = lambda: float(rr.r())
    r_ints = lambda N: [rr.r_int() for _ in range(N)]
    r1_ints = lambda N: [rr.r1_int() for _ in range(N)]

    R = lambda: list(map(int, rr.r().split()))
    R1 = lambda: list(map(lambda x: int(x) - 1,
                          rr.r().split()))  # a,b = a-1,b-1の省略
    Rs = lambda N: [rr.R() for _ in range(N)]
    R1s = lambda N: [rr.R1() for _ in range(N)]
    R1s_XYD = lambda N: [[x - 1, y - 1, z] for x, y, z in iter(
        rr.R() for _ in range(N))]  # x, y, dでx,yだけ-1したい場合
    R1s_S = lambda N, S, add=-1: [[
        x + add if i in set(S) else x for i, x in enumerate(rr.R())
    ] for _ in range(N)]

    R_str = lambda: list(rr.r().split())
    R1_S = lambda S, add=-1: [
        x + add if i in set(S) else x for i, x in enumerate(rr.R())
    ]

    R_map = lambda: map(int, rr.r().split())
    R_float = lambda: list(map(float, rr.r().split()))
    # R_tuple = lambda: tuple(map(int, rr.r().split())) # not recommended because tuple looks slow in pypy(?)
    @classmethod
    def x10(cls, S: str, n: int):
        """change float to int by *10**n

        Args:
            S (str): float
            n (int, optional): n of float(S)*10**n (number of shift).

        Returns:
            int: S*10**n
        """
        if "." not in S:
            return int(S) * 10**n
        return int("".join([S.replace(".", ""),
                            "0" * (n - S[::-1].find("."))]))

    Rx10 = lambda n: list(map(lambda s: rr.x10(s, n), rr.r().split()))


class List3d:
    def __init__(self, a, b, c, v):
        self.L = [v] * (a * b * c)
        self.a = a
        self.b = b
        self.c = c
        self.mul_a = b * c
        self.mul_b = c

    def update(self, a, b, c, v):
        self.L[a * self.mul_a + b * self.mul_b + c] = v

    def query(self, a, b, c):
        return self.L[a * self.mul_a + b * self.mul_b + c]


class List2d:
    def __init__(self, a, b, v):
        self.L = [v] * (a * b)
        self.a = a
        self.b = b
        self.mul_a = b

    def update(self, a, b, v):
        self.L[a * self.mul_a + b] = v

    def query(self, a, b):
        return self.L[a * self.mul_a + b]


def main(sample_file=''):
    """ how to treat input
    # single int: int(r())
    # single string: r()
    # single float: float(r())
    # line int: R()
    # line string: r().split()
    # line (str, int, int): [j if i == 0 else int(j) for i, j in enumerate(r().split())]
    # lines int: [R() for _ in range(n)]
    """

    # import numpy as np
    # for test
    if sample_file:
        sys.stdin = open(sample_file)

    # for creating random input
    import random

    # 問題の解き方
    # https://kimiyuki.net/blog/2016/06/21/how-to-solve-problems-in-competitive-programming/
    # https://algo-logic.info/how-to-think-cp/

    # 7で割れるか
    # a//10-(a%10)*2

    # OEIS
    # https://oeis.org/
    # https://kabukimining.hateblo.jp/entry/atcoder-OEIS

    # ----------------------------------
    # main

    # initialize
    ans = 1
    cnt = 0
    # pypyでdictに(a, b, c)みたいなの使うとTLE
    # https://atcoder.jp/contests/arc111/tasks/arc111_c

    # 考察コメント
    #

    # 犯罪/マラソン用
    # import time
    # time_sta = time.time()
    # a = time.time()-time_sta
    # if a > 1.8:
    #     print(-1)
    #     return

    N, Q = R()
    AB = R1s(N - 1)
    CD = R1s(Q)

    edges = [list() for _ in range(N)]
    for a, b in AB:
        edges[a].append(b)
        edges[b].append(a)
    depth = [-1] * N
    tasks = [[0, 0]]
    arrived = [0] * N
    while tasks:
        node, dep = tasks.pop()
        arrived[node] = 1
        depth[node] = dep
        dep += 1
        for next_node in edges[node]:
            if arrived[next_node]:
                continue
            tasks.append([next_node, dep])
    for c, d in CD:
        YesNo((depth[c] + depth[d]) % 2 == 0, "Town", "Road")

    #%%
    # end of main
    # ----------------------------------
    """memo: how to solve bit problems
    ref: https://primenumber.hatenadiary.jp/entry/2016/12/01/000000
    ビット列による部分集合表現 【ビット演算テクニック Advent Calendar 2016 1日目】
    
    https://atcoder.jp/contests/abc173/submissions/14966961
    for i in range(1<<h):
	    if (i >> x) & 1:
            hoge
    (i >> x) & 1 でxビット目のビット値を取得している

    https://atcoder.jp/contests/abc187/submissions/19255179
    i=110100110 のとき、j=110100110, 110100100, 110100010, ...を出力する方法
    for i in range(1<<N): # 各Sについて
        j = i
        while j:
            if dp[i] > dp[j] + dp[i^j]:
                dp[i] = dp[j] + dp[i^j]
            j -= 1 # これにより、例えばi=110100110のとき、j =110100101
            j &= i # これにより、j = 110100100となり、一番下に立っている1を消去できた
            
    bitDPで間違いやすいのが、for i in range(N)としてiを作成した際、集合Sとの和集合をとる際に[S|(1<<i)]とすべきところ[S|i]としやすいことと、print(dp[(1<<N)-1][0])とすべきところ、print(dp[1<<N-1][0]などと書きやすいこと。<<は計算順序的に遅いので、しっかり括弧を付けて優先的に計算されるように明示する。
    ex: https://atcoder.jp/contests/abc180/submissions/19837195
        dp = list2d(1<<N, N, INF) # 集合Sについて到着し, 開始地点がNで最後に0に到着する最短経路
        for i in range(N):
            dp[1<<i][i] = dist[i][0]
        for S in range(1<<N):
            for i in range(N): # 新しく追加する開始地点
                if (S>>i) & 1:
                    continue
                for j in range(N): # 追加前の開始地点
                    if (S>>j) & 1 == 0:
                        continue
                    dp[S|(1<<i)][i] = min(dp[S|(1<<i)][i], dp[S][j]+dist[i][j])    
        print(dp[(1<<N)-1][0])
    """


if __name__ == '__main__':
    main()
    # print('*** doctest start ***')
    # import doctest
    # doctest.testmod()
    # print('*** doctest end ***')
import sys

sys.setrecursionlimit(10**7)


class Tree:
    C, RL = {}, {}
    R, N, D, S, P, T = None, None, None, None, None, None
    TL = None

    def __init__(s, num):
        s.N = num

    def set(s, a, b):
        if a in s.C: s.C[a].append(b)
        else: s.C[a] = [b]
        if b in s.C: s.C[b].append(a)
        else: s.C[b] = [a]

    def makeRank(s, root):
        s.R = [0] * s.N  #各ノードのランク
        s.R[root] = 1
        s.RL[1] = [root]  #各ランクのノード
        s.S = {}  #各ノードの子ノード
        s.P = [-1] * s.N  #各ノードの親ノード
        s.D = 1
        while s.RL[s.D] != []:
            s.D += 1
            s.RL[s.D] = []
            for i in s.RL[s.D - 1]:
                for j in s.C[i]:
                    if s.R[j] == 0:
                        s.R[j] = s.D
                        s.RL[s.D].append(j)
                        if i not in s.S: s.S[i] = [j]
                        else: s.S[i].append(j)
                        s.P[j] = i

    def dfs(s, x, y, r):  #xからyまでの道O(M)
        if x == y:
            return [x]
        for i in s.C[x]:
            if i != r:
                t = s.dfs(i, y, x)
                if t != False:
                    return [x] + t
        return False

    def dist(s, x):  #最遠のノード,距離
        t = [-1] * s.N
        S = [x]
        ans = x
        ansn = 0
        t[x] = 0
        while S != []:
            k = S.pop()
            for i in s.C[k]:
                if t[i] == -1:
                    t[i] = t[k] + 1
                    S.append(i)
                    if t[i] > ansn:
                        ansn = t[i]
                        ans = i
        return ans, ansn

    def getDi(s, x=0):  #直径
        a, _ = s.dfs(x)
        b, ans = s.dfs(a)
        return ans

    def getDeep(s, x):  #xの子孫のうち一番深い深さ
        ans = 0
        if x in s.S:
            for i in s.S[x]:
                ans = max(ans, s.getDeep(i))
            return ans + 1
        else:
            return 0

    def getParent(s, x, n):  #xのn世代前の親
        if n == 0:
            return x
        if s.P[x] == -1:
            return -n
        return s.getParent(s.P[x], n - 1)

    def tour(s):  #オイラーツアー
        x = s.RL[1][0]
        s.T = []  #ツアー
        s.TL = [[] for _ in range(s.N)]  #各ノードの出現位置
        L = [x]
        V = [-1] * s.N
        while L:
            n = L.pop()
            if n < 0:
                x = n * -1 - 1
                s.TL[x].append(len(s.T))
                s.T.append(x)
                continue
            s.TL[n].append(len(s.T))
            s.T.append(n)
            if n in s.S:
                for x in (s.S[n]):
                    L.append(-(n + 1))
                    L.append(x)
        return s.T, s.TL


N, Q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(N - 1)]
cd = [list(map(int, input().split())) for _ in range(Q)]

T = Tree(N)
for a, b in ab:
    T.set(a - 1, b - 1)

T.makeRank(0)
V = T.R

for c, d in cd:
    c -= 1
    d -= 1
    n = V[c]
    m = V[d]
    if abs(n - m) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
A = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    A[a - 1].append(b - 1)
    A[b - 1].append(a - 1)
q = queue.Queue()
dis = [-1] * N
dis[0] = 0
q.put(0)
while not q.empty():
    t = q.get()
    for i in A[t]:
        if dis[i] == -1:
            dis[i] = 1 - dis[t]
            q.put(i)
for _ in range(Q):
    c, d = map(int, input().split())
    if dis[c - 1] == dis[d - 1]:
        print('Town')
    else:
        print('Road')
def LI():
    return list(map(int, input().split()))


from collections import deque

N, Q = LI()

START = 1

Past = [[] for i in range(N + 1)]
Fixed = [False for i in range(N + 1)]
Deep = [0 for i in range(N + 1)]
for i in range(N - 1):
    A, B = LI()
    Past[A].append(B)
    Past[B].append(A)

bits = 0
while (1 << bits) < N:
    bits += 1
par = [[0 for _ in range(N + 1)] for i in range(bits + 1)]

q = deque()
q.append(START)  #探索の初期値：スタートの値代入
Fixed[START] = True
Deep[START] = 1
while q:
    st = q.popleft()
    for to in Past[st]:
        if Fixed[to]:
            continue
        Fixed[to] = True
        Deep[to] = Deep[st] + 1
        par[0][to] = st
        q.append(to)

for k in range(bits):
    for v in range(1, N + 1):
        par[k + 1][v] = par[k][par[k][v]]


def lca(a, b):
    if a == b:
        return a
    if Deep[a] < Deep[b]:
        K = Deep[b] - Deep[a]
        for i in range(bits + 1):
            if (K >> i) & 1 == 1:
                b = par[i][b]
    if Deep[a] > Deep[b]:
        K = Deep[a] - Deep[b]
        for i in range(bits + 1):
            if (K >> i) & 1 == 1:
                a = par[i][a]
    if a == b:
        return a

    for i in range(bits, -1, -1):
        if par[i][a] != par[i][b]:
            a = par[i][a]
            b = par[i][b]

    return par[0][a]


for q in range(Q):
    c, d = LI()
    LCA = lca(c, d)
    path = Deep[c] + Deep[d] - 2 * Deep[LCA]
    if path % 2 == 0:
        print("Town")
    else:
        print("Road")
class SegTree:
    X_unit = float("inf")
    X_f = min

    def __init__(self, N):
        self.N = N
        self.X = [self.X_unit] * (N + N)

    def build(self, seq):
        for i, x in enumerate(seq, self.N):
            self.X[i] = x
        for i in range(self.N - 1, 0, -1):
            self.X[i] = self.X_f(self.X[i << 1], self.X[i << 1 | 1])

    def fold(self, L, R):
        L += self.N
        R += self.N
        vL = self.X_unit
        vR = self.X_unit
        while L < R:
            if L & 1:
                vL = self.X_f(vL, self.X[L])
                L += 1
            if R & 1:
                R -= 1
                vR = self.X_f(self.X[R], vR)
            L >>= 1
            R >>= 1
        return self.X_f(vL, vR)


def euler_tour(tree, root=1):
    N = len(tree) - 1
    seen = [-1] * (N + 1)
    parent = [0] * (N + 1)
    depth = [-1] * (N + 1)
    depth[parent[root]] = -1
    euler_order = []
    stack = [root]
    while stack:
        u = stack.pop()
        if u > 0:
            euler_order.append(u)
            depth[u] = depth[parent[u]] + 1
            stack.append(-u)
            seen[u] = 1
            for v in tree[u]:
                if seen[v] == -1:
                    parent[v] = u
                    stack.append(v)
                    seen[v] = 0
        else:
            euler_order.append(parent[-u])
            seen[-u] = 2
    euler_order.pop()
    first_appear = [-1] * (N + 1)
    for i, v in enumerate(euler_order):
        if first_appear[v] == -1:
            first_appear[v] = i
    return euler_order, first_appear, depth


#(depth, vertex)
def get_lca(a, b):
    pa, pb = first_appear[a], first_appear[b]
    if pa > pb:
        pa, pb = pb, pa
    return divmod(seg.fold(pa, pb + 1), offset)


def get_dist(a, b):
    d, c = get_lca(a, b)
    return depth[a] + depth[b] - 2 * d


def is_on_path(a, b, c):
    return dist(a, c) + dist(c, b) == dist(a, b)


def make_tree(N, edges):
    tree = [[] for _ in range(N + 1)]
    for a, b in edges:
        tree[a].append(b)
        tree[b].append(a)
    return tree


N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]

tree = make_tree(N, AB)
euler_order, first_appear, depth = euler_tour(tree)
offset = N + 1
E = [depth[v] * offset + v for v in euler_order]
seg = SegTree(len(E))
seg.build(E)

for _ in range(Q):
    c, d = map(int, input().split())
    d = get_dist(c, d)
    if d % 2:
        print("Road")
    else:
        print("Town")
from collections import defaultdict
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**9)


class Tree(object):
    """
    隣接リストによる無向グラフ
    頂点は1-indexed
    """
    def __init__(self):
        self.tree = defaultdict(list)

    def __len__(self):
        """ 頂点数 """
        return len(self.tree)

    def add_edge(self, src, dst, weight=1):
        self.tree[src].append((dst, weight))
        self.tree[dst].append((src, weight))

    def get_nodes(self):
        return self.tree.keys()

    def diameter(self):
        """ 木の直径を求める """
        def dfs(idx, par):
            ret = [0, idx]
            for e, w in self.tree[idx]:
                if e == par:
                    continue
                cost = dfs(e, idx)
                cost[0] += w
                ret = max(ret, cost)
            return ret

        p = dfs(1, -1)
        q = dfs(p[1], -1)
        return q[0]


def main():
    N, Q = map(int, input().split())
    G = Tree()

    for _ in range(N - 1):
        a, b = map(int, input().split())
        G.add_edge(a, b)

    used = set([1])
    P = [0] * N

    def dfs(node, p):
        used.add(node)
        P[node - 1] = p
        for nxt, w in G.tree[node]:
            if nxt not in used:
                dfs(nxt, -p)

    dfs(1, 1)

    for i in range(Q):
        c, d = map(int, input().split())
        print('Town' if P[c - 1] == P[d - 1] else 'Road')


if __name__ == '__main__':
    main()
def N():
    return int(input())


def L():
    return list(map(int, input().split()))


def NL(n):
    return [list(map(int, input().split())) for i in range(n)]


mod = pow(10, 9) + 7
#import numpy as np
import sys

sys.setrecursionlimit(2147483647)
import math
import bisect
import heapq
import re
from itertools import accumulate
from itertools import permutations
from itertools import combinations
from collections import Counter
from collections import deque
from collections import defaultdict
from decimal import Decimal

inf = float('inf')
dic = defaultdict(lambda: 0)

n, q = L()
ab = NL(n - 1)
cd = NL(q)

tree = [[] for i in range(n)]

for a, b in ab:
    tree[a - 1].append(b - 1)
    tree[b - 1].append(a - 1)

isVisit = [False] * n
q = deque([(0, 0)])
rank = [0] * n
i = 0
while q:
    now, dis = q.popleft()
    if isVisit[now]:
        continue
    isVisit[now] = True
    rank[now] = dis
    i += 1
    for to in tree[now]:
        q.append((to, dis + 1))

for c, d in cd:
    if (rank[c - 1] - rank[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
import queue

sys.setrecursionlimit(10**6)


def main(input, print):
    n, q = map(int, input().split())
    table = [[] for _ in range(n)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        table[a].append(b)
        table[b].append(a)
    color = [-1] * n
    color[0] = 0
    que = queue.Queue()
    que.put(0)
    while not que.empty():
        now = que.get()
        for next in table[now]:
            if color[next] == -1:
                color[next] = 1 - color[now]
                que.put(next)
    for i in range(q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        if (color[c] == color[d]):
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main(sys.stdin.readline, print)
class segtree:
    """
    Segment tree
    Store value as object type and optional function for binary operarion.
    "get" function return a value by binary operarion result. O(logN)
    "update" function update tree's a value. O(logN)

    Attributes
    ----------
    n : int
        Number of elements
    identity element_func : func
        identity_element for initialization
        if operator is * and identiry element is e, e * A = A and A * e = A
    binary_operation_func : func
        function for binary operation x and y
        function must have associative law
        if operator is *, (A * B) * C = A * (B * C)

    Methods
    -------
    update(i, x)
        update tree[i] value to x
    get(a, b)
        get value from [a, b)
        include a but not include b, return a merged value
    """
    def __init__(self, n: int, identity_element_func, binary_operation_func):
        """
        Constructer(Initialize parameter in this class)

        Parameters
        ----------
        n : int
            Number of elements
        identity_element_func : func
            identity element for initialization
            if operator is * and identiry element is e, e * A = A and A * e = A
        binary_operation_func : func
            function for binary operation x and y
            function must have associative law
            if operator is *, (A * B) * C = A * (B * C)
        """
        self.n = n
        self.identity = identity_element_func
        self.binary = binary_operation_func
        n2 = 1  # n2はnより大きい2の冪数
        while n2 < n:
            n2 <<= 1
        self.n2 = n2
        self.tree = [identity_element_func() for _ in range(n2 << 1)]

    def update(self, index: int, x: int):
        """
        Update segment-tree's a value and update segment-tree's tree

        Parameters
        ----------
        index : int
            index of update value
        x : int
            new value
        """
        index += self.n2
        self.tree[index] = self.binary(self.tree[index], x)
        while index > 1:
            # (index ^ 1) はiと1の排他的論理和(XOR)
            x = self.binary(x, self.tree[index ^ 1])
            index >>= 1  # 右ビットシフトで親ノードのインデックスへ移動
            self.tree[index] = self.binary(self.tree[index], x)

    def get(self, a: int, b: int) -> int:
        """
        Get a specific value by result of binary operation from interval [a, b)

        Parameters
        ----------
        a, b : int
            index of interval
            this is hald open interval, this interval include a but not b
        """
        result = self.identity()
        q = [(1, 0, self.n2)]
        while q:
            k, left, right = q.pop()
            if a <= left and right <= b:
                result = self.binary(result, self.tree[k])
                continue
            m = (left + right) // 2
            k <<= 1
            if a < m and left < b:
                q.append((k, left, m))
            if a < right and left < m:
                q.append((k + 1, m, right))
        return result


N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    edge[x].append(y)
    edge[y].append(x)  # 有向グラフならこの行は消す!!
INF = 10**18

first_visited_i_on_tour = [-1] * N
height_tour = segtree(N * 2, lambda: INF, min)
queue = [(0, 0)]
i = 0
while queue:
    now, depth = queue.pop()
    i += 1
    if first_visited_i_on_tour[now] != -1:
        continue
    first_visited_i_on_tour[now] = i
    height_tour.update(i, depth)
    for n_node in edge[now]:
        if first_visited_i_on_tour[n_node] != -1:
            continue
        queue.append((n_node, depth + 1))

for _ in range(Q):
    c, d = map(lambda a: int(a) - 1, input().split())
    lca = height_tour.get(first_visited_i_on_tour[c],
                          first_visited_i_on_tour[d])
    c = height_tour.get(first_visited_i_on_tour[c],
                        first_visited_i_on_tour[c] + 1)
    d = height_tour.get(first_visited_i_on_tour[d],
                        first_visited_i_on_tour[d] + 1)
    ans = c + d - 2 * lca
    if ans % 2:
        print("Road")
    else:
        print("Town")
import sys


# input = sys.stdin.readline
def mp():
    return map(int, input().split())


def lmp():
    return list(map(int, input().split()))


def mps(A):
    return [tuple(map(int, input().split())) for _ in range(A)]


import math
import bisect
from copy import deepcopy as dc
from itertools import accumulate
from collections import Counter, defaultdict, deque


def ceil(U, V):
    return (U + V - 1) // V


def modf1(N, MOD):
    return (N - 1) % MOD + 1


inf = int(1e20)
mod = int(1e9 + 7)
import heapq


def dijkstra(start, edge):
    # edge[i] = [(distance, j), ...]
    dist = [int(1e18)] * len(edge)
    dist[start] = 0
    q = [(0, start)]
    while q:
        c, u = heapq.heappop(q)
        if dist[u] < c: continue
        for v, nc in edge[u]:
            if (dist[u] + v) < dist[nc]:
                dist[nc] = dist[u] + v
                heapq.heappush(q, (dist[nc], nc))
    return dist


n, q = mp()
edge = [[] for i in range(n)]
for i in range(n - 1):
    a, b = mp()
    a -= 1
    b -= 1
    edge[a].append((1, b))
    edge[b].append((1, a))
u = dijkstra(0, edge)
for i in range(q):
    a, b = mp()
    if abs(u[a - 1] - u[b - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
E = [[] for n in range(N)]
for n in range(N - 1):
    a, b = map(int, input().split())
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)
Depth = [None for n in range(N)]
queue = deque([(0, 0)])
visited = [False for n in range(N)]
while queue:
    now, depth = queue.popleft()
    Depth[now] = depth
    visited[now] = True
    for e in E[now]:
        if not visited[e]:
            queue.append((e, depth + 1))
for q in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if Depth[c] % 2 == Depth[d] % 2:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
from collections import *


class LCA:
    def __init__(self, N, G):
        self.N = N
        self.G = G
        self.log_size = 22
        self.par = [[-1] * self.N for _ in range(self.log_size)]
        q = deque([0])
        self.dep = [-1] * self.N
        self.dep[0] = 0

        while q:
            v = q.popleft()

            for nv in self.G[v]:
                if self.dep[nv] == -1:
                    self.par[0][nv] = v
                    self.dep[nv] = self.dep[v] + 1
                    q.append(nv)

        for i in range(1, self.log_size):
            for v in range(self.N):
                if self.par[i - 1][v] >= 0:
                    self.par[i][v] = self.par[i - 1][self.par[i - 1][v]]

    def calc_lca(self, u, v):
        if self.dep[u] > self.dep[v]:
            u, v = v, u

        for i in range(self.log_size):
            if ((self.dep[v] - self.dep[u]) >> i) & 1:
                v = self.par[i][v]

        if u == v:
            return u

        for i in range(self.log_size - 1, -1, -1):
            if self.par[i][u] != self.par[i][v]:
                u, v = self.par[i][u], self.par[i][v]

        return self.par[0][u]

    def dist(self, u, v):
        return self.dep[u] + self.dep[v] - 2 * self.dep[self.calc_lca(u, v)]


N, Q = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

lca = LCA(N, G)

for _ in range(Q):
    c, d = map(int, input().split())
    dist = lca.dist(c - 1, d - 1)

    if dist % 2 == 0:
        print('Town')
    else:
        print('Road')
class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


N, Q = map(int, input().split())
adj = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)

lca = LCA(adj)
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    dist = lca.depth[c] + lca.depth[d] - 2 * lca.depth[lca.get(c, d)] + 1
    if dist % 2 == 1:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10000000)

n, q = map(int, input().split())
road = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    road[a].append(b)
    road[b].append(a)
qry = []
for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    qry.append([c, d])

flag = [False] * n
zeroorone = [False] * n


def re(x, color):
    if not flag[x]:
        flag[x] = True
        ncolor = not color
        zeroorone[x] = ncolor
        for y in road[x]:
            re(y, ncolor)


re(0, True)

for i, j in qry:
    if zeroorone[i] == zeroorone[j]:
        print('Town')
    else:
        print('Road')
from collections import deque
import sys
import math
import heapq
import random
import itertools


def gs():
    return sys.stdin.readline()


def gd():
    return float(sys.stdin.readline())


def gi():
    return int(sys.stdin.readline())


def gia():
    return list(map(int, sys.stdin.readline().split()))


def gsa():
    return sys.stdin.readline().split()


def eratoratenes(n):
    hurui = [True] * (n + 1)
    hurui[0] = False
    hurui[1] = False
    for i in range(2, n + 1):
        if (hurui[i] == False): continue
        if (i * i > n): break
        for j in range(2 * i, n + 1, i):
            hurui[j] = False


def zAlgo(S):
    n = len(S)
    if (n == 0): return []
    c = 0
    z = [0] * n
    for i in range(1, n):
        if (i + z[i - c] < c + z[c]):
            z[i] = z[i - c]
        else:
            j = max(0, c + z[c] - i)
            while (i + j < n and S[j] == S[i + j]):
                j += 1
            z[i] = j
            c = i

    return z


def floorSum(n, m, a, b):
    ans = 0
    if (a >= m):
        ans += (n - 1) * n * (a // m) // 2
        a %= m
    if (b >= m):
        ans += n * (b // m)
        b %= m

    yMax = (a * n + b) // m
    xMax = (yMax * m - b)
    if (yMax == 0): return ans
    ans += (n - (xMax + a - 1) // a) * yMax
    ans += floorSum(yMax, a, m, (a - xMax % a) % a)
    return ans


def ceil_pow2(n):
    x = 0
    while ((1 << x) < n):
        x += 1
    return x


def uclid(m, n):
    if (n == 0):
        return m
    else:
        return uclid(n, m % n)


#拡張ユークリッドの互除法
def invGcd(a, b):
    a %= b
    if a == 0: return b, 0
    s, t = b, a
    m0, m1 = 0, 1

    while (t):
        u = s // t
        s -= t * u
        m0 -= m1 * u
        s, t = t, s
        m0, m1 = m1, m0

    if m0 < 0: m0 += b // s
    return s, m0


#約数取得
def yakusu(n):
    l = []
    for i in range(1, n + 1):
        if (i * i > n):
            break
        if (n % i == 0):
            l.append(i)
            if (n / i != i):
                l.append(n // i)

    return l


def insuB(n):
    l = []
    i = 2
    while (i * i <= n):
        if (n % i == 0):
            l.append(i)
            n = n // i
        else:
            i += 1

    if (n != 1):
        l.append(n)

    return l


def insuBm(n):
    m = dict()
    i = 2
    while (i * i <= n):
        if (n % i == 0):
            v = m.get(i, 0)
            m[i] = v + 1
            n = n // i
        else:
            i += 1

    if (n != 1):
        v = m.get(i, 0)
        m[i] = v + 1

    return m


# s進数で表した時の文字列
def Nsin(n, s):
    if (n == 0):
        return "0"

    l = []
    while (n != 0):
        a = n % s
        l.append(str(a))
        n = (n - a) // s

    sb = ''.join(l)
    return sb[::-1]


KAIJO_DP = [0] * 4000000


def kaijo(n, mod):
    if (n <= 1):
        return 1
    if (KAIJO_DP[n] != 0):
        return KAIJO_DP[n]
    ans = n * kaijo(n - 1, mod)
    ans %= mod
    KAIJO_DP[n] = ans
    return ans


def combi(n, m, mod):
    if (n < m):
        return 0

    nk = kaijo(n, mod)
    mk = kaijo(m, mod)
    nmk = kaijo(n - m, mod)
    bunbo = nmk * mk
    bunbo %= mod
    bunbo = pow(bunbo, mod - 2, mod)
    ans = nk * bunbo
    ans %= mod
    return ans


def isP(n):
    if (n == 1):
        return False
    for i in range(2, math.floor(math.sqrt(n)) + 1):
        if (n % i == 0):
            return False
    return True


def nextCombination(sub):
    x = sub & (-sub)
    y = sub + x
    return (((sub & ~y) // x) >> 1) | y


def topologicalSort(G):
    result = []
    inn = [0] * len(G)

    for es in G:
        for e in es:
            inn[e] += 1

    deq = deque()
    for i in range(len(G)):
        if (inn[i] == 0):
            deq.append(i)

    while (len(deq) != 0):
        v = deq.popleft()
        result.append(v)
        es = G[v]
        for e in es:
            inn[e] -= 1
            if (inn[e] == 0):
                deq.append(e)

    return result


class FenwickTree:
    def __init__(self, n):
        self.N = n
        self.data = [0] * n

    def add(self, p, x):
        if (p < 0 or p >= self.N):
            return None

        p += 1
        while (p <= self.N):
            self.data[p - 1] += x
            p += p & -p

    def get(self, l, r):
        if (l < 0 or l > r or r > self.N):
            return -(1 << 64)

        return self._innerSum(r) - self._innerSum(l)

    def _innerSum(self, r):
        s = 0
        while (r > 0):
            s += self.data[r - 1]
            r -= r & -r

        return s


class FenwickTreeImos:
    def __init__(self, n):
        self.fw = FenwickTree(n + 1)

    def add(self, s, t, x):
        self.fw.add(s, x)
        self.fw.add(t, -x)

    def get(self, i):
        return self[i]

    def __getitem__(self, key):
        return self.fw.get(0, key + 1)


class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = [1] * n

    def find(self, n):
        if (n != self.parent[n]):
            self.parent[n] = self.find(self.parent[n])

        return self.parent[n]

    def union(self, n1, n2):
        r1 = self.find(n1)
        r2 = self.find(n2)
        if (self.rank[r1] > self.rank[r2]):
            self.parent[r2] = r1
            self.count[r1] = self.count[r1] + self.count[r2]
        elif (self.rank[r1] < self.rank[r2]):
            self.parent[r1] = r2
            self.count[r2] = self.count[r1] + self.count[r2]
        elif (r1 != r2):
            self.parent[r2] = r1
            self.rank[r1] += 1
            self.count[r1] = self.count[r1] + self.count[r2]

    def getRunk(self, n):
        return self.rank[n]

    def getCount(self, n):
        return self.count[self.find(n)]

    def getKindNum(self):
        ret = 0
        for i in range(len(self.parent)):
            if (self.parent[i] == i):
                ret += 1

        return ret

    def same(self, n1, n2):
        return self.find(n1) == self.find(n2)

    def grouping(self):
        m = dict()
        for i in range(len(self.parent)):
            p = self.find(i)
            l = m.get(p, [])
            l.append(i)
            m[p] = l
        return m


class Edge:
    def __init__(self, f, t, c):
        self._from = f
        self._to = t
        self._cost = c

    def getStart(self):
        return self._from

    def getEnd(self):
        return self._to

    def getDistance(self):
        return self._cost

    def setDistance(self, c):
        self._cost = c


class Graph:
    def __init__(self, n):
        self.gla = []
        self.prev = [-1] * n
        for i in range(n):
            self.gla.append([])

    def addEdge(self, u, v, l):
        e = Edge(u, v, l)
        self.gla[u].append(e)

    def removeEdge(self, u, v):
        l = self.gla[u]
        for edge in l:
            if (edge.getStart() == u and edge.getEnd() == v):
                l.remove(edge)

    def changeLength(self, u, v, d):
        l = self.gla[u]
        for edge in l:
            if (edge.getStart() == u and edge.getEnd() == v):
                edge.setDistance(d)
                break

    def getVertexNum(self):
        return len(self.gla)

    def getEdgeLength(self, u, v):
        l = self.gla[u]
        for edge in l:
            if (edge.getStart() == u and edge.getEnd() == v):
                return edge.getDistance()

        return 1 << 64

    def dijkstra(self, start):
        d = [1 << 64] * self.getVertexNum()
        d[start] = 0
        q = []
        heapq.heappush(q, (0, start))
        self.prev[start] = -1
        while (len(q) != 0):
            p = heapq.heappop(q)
            if (p[0] > d[p[1]]):
                continue
            el = self.gla[p[1]]
            for edge in el:
                to = edge.getEnd()
                fr = edge.getStart()
                cost = edge.getDistance()
                if (d[to] > d[fr] + cost):
                    d[to] = d[fr] + cost
                    self.prev[to] = fr
                    heapq.heappush(q, (d[to], to))

        return d

    def getPath(self, v):
        path = []
        while (v != -1):
            path.append(v)
            v = self.prev[v]

        path.reverse()
        return path


class StringUtil:
    def __init__(self, S):
        self.S = S
        self.n = len(S)
        self.rank = [-1] * (self.n + 1)
        self.k = 1

    def _compareSa(self, i, j):
        if (self.rank[i] != self.rank[j]):
            return self.rank[i] < self.rank[j]
        else:
            ri = -1
            rj = -1
            if (i + self.k <= self.n):
                ri = self.rank[i + self.k]
            if (j + self.k <= self.n):
                rj = self.rank[j + self.k]
            return ri < rj

    def _comkey(self, i):
        r1 = self.rank[i]
        r2 = self.rank[i + self.k] if i + self.k <= self.n else -1
        return (r1, r2)

    def makeSa(self):
        sa = [0] * (self.n + 1)
        for i in range(len(sa)):
            sa[i] = i
            if (i < self.n):
                self.rank[i] = ord(self.S[i])

        self.k = 1
        tmp = [0] * (self.n + 1)
        while (self.k <= self.n):
            sa.sort(key=lambda x: self._comkey(x))

            tmp[sa[0]] = 0
            for i in range(1, self.n + 1):
                tmp[sa[i]] = tmp[sa[i - 1]]
                if (self._compareSa(sa[i - 1], sa[i])):
                    tmp[sa[i]] += 1
            for i in range(self.n + 1):
                self.rank[i] = tmp[i]
            self.k *= 2

        return sa

    def makeLcp(self, sa):
        for i in range(self.n + 1):
            self.rank[sa[i]] = i

        h = 0
        lcp = [0] * self.n
        for i in range(self.n):
            j = sa[self.rank[i] - 1]
            if (h > 0): h -= 1
            while (j + h < self.n and i + h < self.n):
                if (self.S[j + h] != self.S[i + h]): break
                h += 1

            lcp[self.rank[i] - 1] = h

        return lcp


class SegTree:
    def __init__(self, v, op, e):
        self.n = len(v)
        self.log = ceil_pow2(self.n)
        self.size = 1 << self.log
        self.op = op
        self.e = e
        self.d = [e] * (2 * self.size)
        for i in range(self.n):
            self.d[self.size + i] = v[i]
        for i in range(self.size - 1, 0, -1):
            self._update(i)

    def setVal(self, p, x):
        p += self.size
        self.d[p] = x
        for i in range(1, self.log + 1):
            self._update(p >> i)

    def getVal(self, p):
        return self.d[p + self.size]

    def prod(self, l, r):
        sml = self.e
        smr = self.e
        l += self.size
        r += self.size
        while (l < r):
            if (l & 1 != 0):
                sml = self.op(sml, self.d[l])
                l += 1
            if (r & 1 != 0):
                r -= 1
                smr = self.op(self.d[r], smr)
            l >>= 1
            r >>= 1

        return self.op(sml, smr)

    def allProd(self):
        return self.d[1]

    def maxRight(self, l, f):
        if (l == self.n): return self.n
        l += self.size
        sm = self.e
        while True:
            while (l % 2 == 0):
                l >>= 1
            if (not f(self.op(sm, self.d[l]))):
                while (l < self.size):
                    l = 2 * l
                    if (f(self.op(sm, self.d[l]))):
                        sm = self.op(sm, self.d[l])
                        l += 1

                return l - self.size

            sm = self.op(sm, self.d[l])
            l += 1
            if ((l & -l) != l): break

        return self.n

    def minLeft(self, r, f):
        if (r == 0): return 0
        r += self.size
        sm = self.e
        while (True):
            r -= 1
            while (r > 1 and r % 2 == 1):
                r >>= 1
            if (not f(self.op(self.d[r], sm))):
                while (r < self.size):
                    r = 2 * r + 1
                    if (f(self.op(self.d[r], sm))):
                        sm = self.op(self.d[r], sm)
                        r -= 1

                return r + 1 - self.size

            sm = self.op(self.d[r], sm)
            if ((r & -r) != r): break

        return 0

    def _update(self, k):
        self.d[k] = self.op(self.d[2 * k], self.d[2 * k + 1])


class Ruiseki2d:
    def __init__(self, A):
        self.A = A
        self.H = len(A)
        self.W = len(A[0])
        self.S = [[0] * (self.W + 1) for i in range(self.H + 1)]
        for i in range(self.H):
            for j in range(self.W):
                self.S[i + 1][j + 1] = self.S[i + 1][j] + self.A[i][j]

        for i in range(self.H):
            for j in range(self.W + 1):
                self.S[i + 1][j] = self.S[i + 1][j] + self.S[i][j]

    def getSum(self, i, j, h, w):
        return self.S[i + h][j + w] - self.S[i][j + w] - self.S[
            i + h][j] + self.S[i][j]


class Gyoretu:
    def __init__(self, A, mod):
        self.N = len(A)
        self.A = A
        self.mod = mod
        E = [[0] * self.N for i in range(self.N)]
        for i in range(self.N):
            E[i][i] = 1

        self.Ap = [E, self.A]
        for i in range(60):
            lA = self.Ap[len(self.Ap) - 1]
            nA = self.multiA(lA, lA)
            self.Ap.append(nA)

    def multiA(self, A, B):
        ans = [[0] * self.N for i in range(self.N)]
        for i in range(self.N):
            for j in range(self.N):
                tv = 0
                for k in range(self.N):
                    tv += A[i][k] * B[k][j]
                    tv %= self.mod
                ans[i][j] = tv

        return ans

    def powA(self, p):
        ans = self.Ap[0]
        for i in range(len(self.Ap) - 1):
            if (((p >> i) & 1) == 1):
                ans = self.multiA(ans, self.Ap[i + 1])

        return ans


def main_():
    N, Q = gia()
    depth = [-1] * N
    G = [[] for i in range(N)]
    for i in range(N - 1):
        a, b = gia()
        a -= 1
        b -= 1
        G[a].append(b)
        G[b].append(a)

    depth[0] = 0
    deq = deque()
    deq.append(0)
    while (len(deq) > 0):
        v = deq.popleft()
        es = G[v]
        for i in range(len(es)):
            e = es[i]
            if (depth[e] >= 0): continue
            depth[e] = depth[v] + 1
            deq.append(e)

    for i in range(Q):
        c, d = gia()
        c -= 1
        d -= 1
        V = depth[c] + depth[d]
        if (V % 2 == 0):
            print("Town")
        else:
            print("Road")

    #print(ans)


main_()
from collections import deque

N, Q = map(int, input().split())
ab = [tuple(map(int, input().split())) for _ in range(N - 1)]
adjacent = [[] for _ in range(N + 1)]
for a, b in ab:
    adjacent[a].append(b)
    adjacent[b].append(a)
cd = [tuple(map(int, input().split())) for _ in range(Q)]

# ノード1からの距離の偶奇で二分木を塗り分け
dist = [-1] * (N + 1)
q = deque([1])
dist[1] = 0
while q:
    city = q.popleft()
    for n in adjacent[city]:
        if dist[n] < 0:
            dist[n] = 1 + dist[city]
            q.append(n)
# キューの処理
for c, d in cd:
    p = "Town" if (dist[c] + dist[d]) % 2 == 0 else "Road"
    print(p)
import sys

sys.setrecursionlimit(10**6)


class Tree:
    class Edge:
        def __init__(self, to, rev):
            self.to = to
            self.rev = rev

    def __init__(self, V):
        self.V = V
        self.G = [[] for _ in range(V)]
        self.p = [0] * V
        self.depth = [0] * V

    def addEdge(self, fm, to):
        self.G[fm].append(self.Edge(to, len(self.G[to])))
        self.G[to].append(self.Edge(fm, len(self.G[fm]) - 1))

    def setRoot(self, root):
        self.root = root
        self.setParent(root, -1, 0)

    def setParent(self, cur, parent, d):
        self.p[cur] = parent
        self.depth[cur] = d
        for e in self.G[cur]:
            if e.to != parent:
                self.setParent(e.to, cur, d + 1)

    def getDepth(self, p):
        return self.depth[p]


n, q = map(int, input().split())
tree = Tree(n)
for i in range(n - 1):
    a, b = map(int, input().split())
    tree.addEdge(a - 1, b - 1)
tree.setRoot(0)
for i in range(q):
    c, d = map(int, input().split())
    depth_diff = abs(tree.getDepth(c - 1) - tree.getDepth(d - 1))
    print("Town" if depth_diff % 2 == 0 else "Road")
class INPUT:
    def __init__(self):
        self._l = open(0).read().split()
        self._length = len(self._l)
        self._index = 0
        return

    def stream(self, k=1, f=int, f2=False):
        assert (-1 < k)
        if self._length == self._index or self._length - self._index < k:
            raise Exception("There is no input!")
        elif f != str:
            if k == 0:
                ret = list(map(f, self._l[self._index:]))
                self._index = self._length
                return ret
            if k == 1 and not f2:
                ret = f(self._l[self._index])
                self._index += 1
                return ret
            if k == 1 and f2:
                ret = [f(self._l[self._index])]
                self._index += 1
                return ret
            ret = []
            for _ in [0] * k:
                ret.append(f(self._l[self._index]))
                self._index += 1
            return ret
        else:
            if k == 0:
                ret = list(self._l[self._index:])
                self._index = self._length
                return ret
            if k == 1 and not f2:
                ret = self._l[self._index]
                self._index += 1
                return ret
            if k == 1 and f2:
                ret = [self._l[self._index]]
                self._index += 1
                return ret
            ret = []
            for _ in [0] * k:
                ret.append(self._l[self._index])
                self._index += 1
            return ret


pin = INPUT().stream
"""
pin(number[default:1],f[default:int],f2[default:False])
if number==0 -> return left all
listを変数で受け取るとき、必ずlistをTrueにすること。
"""
from collections import deque
from sys import setrecursionlimit

setrecursionlimit(1000000)


def main():
    N, Q = pin(2)
    E = [[] for _ in [0] * N]
    for _ in [0] * (N - 1):
        a, b = pin(2)
        E[a - 1].append(b - 1)
        E[b - 1].append(a - 1)
    dq = deque()
    dq.append(0)
    check = [False] * N
    G = [[] for _ in [0] * N]
    while dq:
        q = dq.pop()
        check[q] = True
        for i in E[q]:
            if check[i]:
                continue
            G[q].append(i)
            dq.append(i)
    S = []
    F = [0] * N
    depth = [0] * N

    def dfs(v, d):
        F[v] = len(S)
        depth[v] = d
        S.append(v)
        for w in G[v]:
            dfs(w, d + 1)
            S.append(v)
        return

    dfs(0, 0)
    INF = (N, None)
    M = 2 * N
    M0 = 2**(M - 1).bit_length()
    data = [INF] * (2 * M0)
    for i, v in enumerate(S):
        data[M0 - 1 + i] = (depth[v], i)
    for i in range(M0 - 2, -1, -1):
        data[i] = min(data[2 * i + 1], data[2 * i + 2])

    def _query(a, b):
        yield INF
        a += M0
        b += M0
        while a < b:
            if b & 1:
                b -= 1
                yield data[b - 1]
            if a & 1:
                yield data[a - 1]
                a += 1
            a >>= 1
            b >>= 1
        return

    def query(u, v):
        fu = F[u]
        fv = F[v]
        if fu > fv:
            fu, fv = fv, fu
        return S[min(_query(fu, fv + 1))[1]]

    for _ in [0] * Q:
        c, d = pin(2)
        c -= 1
        d -= 1
        u = query(c, d)
        t = 2 * depth[u] - depth[c] - depth[d]
        if t % 2 == 0:
            print("Town")
        else:
            print("Road")
    return


main()
import sys


def input():
    return sys.stdin.readline().strip()


def mapint():
    return list(map(int, input().split()))


sys.setrecursionlimit(10**9)

N, Q = mapint()
graph = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = mapint()
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

from collections import deque

deq = deque()
deq.append((0, -1))
dist = [0] * N
while deq:
    v, par = deq.pop()
    for nv in graph[v]:
        if nv == par:
            continue
        dist[nv] = dist[v] + 1
        deq.append((nv, v))

for _ in range(Q):
    a, b = mapint()
    a, b = a - 1, b - 1
    if abs(dist[a] - dist[b]) % 2 == 1:
        print("Road")
    else:
        print("Town")
n, q = map(int, input().split())
ed = [list() for i in range(n)]
for i in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    ed[a].append(b)
    ed[b].append(a)


def BFS(edge, s):
    from collections import deque

    dist = [-1] * n
    dist[s] = 0

    q = deque()
    q.append(s)

    while q:
        v = q.popleft()
        for i in edge[v]:
            if dist[i] != -1:
                continue
            dist[i] = dist[v] + 1
            q.append(i)

    return dist


ds = BFS(ed, 0)
for i in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if abs(ds[c] - ds[d]) % 2:
        print("Road")
    else:
        print("Town")
from collections import deque

N, Q = list(map(int, input().split()))

graph = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = list(map(int, input().split()))
    graph[a].append(b)
    graph[b].append(a)

depths = [-1 for _ in range(N + 1)]

queue = deque()
queue.append((1, 0))
while len(queue) > 0:
    (node, depth) = queue.pop()
    depths[node] = depth
    for child in graph[node]:
        if depths[child] >= 0:
            continue
        queue.append((child, depth + 1))

for query in range(Q):
    c, d = list(map(int, input().split()))
    if (depths[c] + depths[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

read = sys.stdin.read
sys.setrecursionlimit(10**6)
from collections import defaultdict


def main():
    def dfs(prev, v, di):
        dis[v] = di
        for nv in g[v]:
            if nv != prev:
                dfs(v, nv, di + 1)

    n, q = map(int, input().split())

    g = defaultdict(list)
    for _ in range(n - 1):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        g[a].append(b)
        g[b].append(a)
    dis = [0] * n
    dfs(-1, 0, 0)
    for _ in range(q):
        c, d = map(int, input().split())
        c, d = c - 1, d - 1
        d2 = dis[c] + dis[d]
        if d2 & 1:
            print('Road')
        else:
            print('Town')


if __name__ == '__main__':
    main()
import queue

N, Q = map(int, input().split())
E = {i: set() for i in range(1, N + 1)}
for _ in range(N - 1):
    a, b = map(int, input().split())
    E[a].add(b)
    E[b].add(a)

C = [0] * (N + 1)

_queue = queue.Queue()
C[1] = -1
_queue.put(1)
while not _queue.empty():
    x = _queue.get()
    for y in E[x]:
        if C[y] == 0:
            C[y] = C[x] * -1
            _queue.put(y)
#print(C)

for q in range(Q):
    c, d = map(int, input().split())
    if C[c] == C[d]:
        print("Town")
    else:
        print("Road")
from collections import deque


def dfs1():  # depthの決定
    stack = deque()
    stack.append((0, 0))  # (index, depth)
    while stack:
        cur, dep = stack.pop()
        for post in graph[cur]:
            if depth[post] == -1:
                stack.append((post, dep + 1))
                depth[post] = dep + 1


n, q = map(int, input().split())
graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

depth = [-1] * n
depth[0] = 0

dfs1()

CD = [list(map(int, input().split())) for _ in range(q)]

for c, d in CD:
    c -= 1
    d -= 1
    if (depth[c] - depth[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(1000000000)

n, nq = map(int, input().split())
g = [[] for _ in range(n)]
q = []
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

for _ in range(nq):
    q.append(list(map(int, input().split())))

color = [0 for _ in range(n)]


def dfs(x, cnt):
    if cnt % 2 == 1: color[x] = 1
    else: color[x] = -1
    for next in g[x]:
        if color[next] != 0: continue
        dfs(next, cnt + 1)


dfs(0, 1)

for x, y in q:
    if color[x - 1] == color[y - 1]: print('Town')
    else: print('Road')
import collections

INF = 10**10

N, Q = map(int, input().split())

G = [[] for _ in range(N)]
seen = [-1] * N
par = [-1] * N
todo = collections.deque()

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

todo.append(0)
seen[0] = 0
par[0] = 0

while len(todo) != 0:
    v = todo.popleft()
    for i in range(len(G[v])):
        if seen[G[v][i]] != -1:
            continue
        else:
            todo.append(G[v][i])
            seen[G[v][i]] = seen[v] + 1
            par[G[v][i]] = seen[G[v][i]] % 2

for i in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if par[c] == par[d]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())
G = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

import queue

que = queue.Queue()
que.put(0)
color = [-1] * n
color[0] = 0

while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print('Town')
    else:
        print('Road')
def l():
    return list(map(int, input().split()))


from queue import Queue

N, Q = l()
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = l()
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

que = Queue()
que.put(0)
odd_even = [-1] * N
odd_even[0] = 0
while not que.empty():
    v = que.get()
    for nv in G[v]:
        if odd_even[nv] != -1: continue
        odd_even[nv] = odd_even[v] ^ 1
        que.put(nv)
# print(odd_even)

for _ in range(Q):
    c, d = l()
    c -= 1
    d -= 1
    if odd_even[c] ^ odd_even[d]:
        print("Road")
    else:
        print("Town")
import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from heapq import heappush, heappop
from functools import reduce, lru_cache


def input():
    return sys.stdin.readline().strip()


def INT():
    return int(input())


def MAP():
    return map(int, input().split())


def LIST():
    return list(map(int, input().split()))


def TUPLE():
    return tuple(map(int, input().split()))


def ZIP(n):
    return zip(*(MAP() for _ in range(n)))


sys.setrecursionlimit(10**9)
INF = 10**9
mod = 10**9 + 7
#mod = 998244353
#from decimal import *
#import numpy as np
#decimal.getcontext().prec = 10


class SegmentTree:
    """Segment Tree (Point Update & Range Query)
    Query
        1. update(i, val): update i-th value(0-indexed) to val
        2. query(low, high): find f(value) in [low, high)
    Complexity
        time complexity: O(log n)
        space complexity: O(n)
    """
    def __init__(self, N, f, default):  #N:要素の個数(1-indexed)
        self.N = 1 << (N -
                       1).bit_length()  #N: treeの末端の葉の数(2^n 個 n= 0, 1, 2・・・)
        self.default = default
        self.f = f
        self.segtree = [self.default] * ((self.N << 1) - 1)  #接点の数は2*N-1

    @classmethod  #self.~ とする必要がなくなる
    def create_from_array(cls, arr, f, default):
        N = len(arr)
        self = cls(N, f, default)
        for i in range(N):
            self.segtree[self.N - 1 + i] = arr[i]
        for i in reversed(range(self.N - 1)):
            self.segtree[i] = self.f(self.segtree[(i << 1) + 1],
                                     self.segtree[(i << 1) + 2])
        return self

    def update(self, i, val):  # update  i:0-indexed
        i += self.N - 1  #末端の葉に対応する位置
        self.segtree[i] = val
        while i > 0:
            i = (i - 1) >> 1  #一つ上の接点へ
            self.segtree[i] = self.f(self.segtree[(i << 1) + 1],
                                     self.segtree[(i << 1) + 2])

    def query(self, low, high):  # query l, r: 0-indexed
        # query [l, r)
        low, high = low + self.N, high + self.N
        ret = self.default
        while low < high:
            if low & 1:
                ret = self.f(ret, self.segtree[low - 1])
                low += 1
            if high & 1:
                high -= 1
                ret = self.f(ret, self.segtree[high - 1])
            low, high = low >> 1, high >> 1
        return ret

    def get(self, k):  # get k-th value(0-indexed)
        return self.segtree[k + self.N - 1]

    def all(self):  # all range query
        return self.segtree[0]


N, Q = MAP()
ab = [LIST() for _ in range(N - 1)]
cd = [LIST() for _ in range(Q)]

graph = [[] for _ in range(N)]
for a, b in ab:
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

depth = [0] * (2 * N)

graph_go = [[] for _ in range(N)]
used = [0] * N
used[0] = 1
q = deque([0])
while q:
    p = q.pop()
    for node in graph[p]:
        if used[node]:
            continue
        used[node] = 1
        depth[node] = depth[p] + 1
        graph_go[p].append(node)
        q.append(node)

#print(graph)
#print(graph_go)

time = [0] * (2 * N)
when = [0] * N

used = [0] * N
used[0] = 1

q = deque([-1, 0])
t = -1
while q:
    t += 1
    p = q.pop()
    time[t] = p
    if p < 0:
        depth[p] = depth[-(p + 1)] - 1
    if p >= 0:
        when[p] = t
        for node in graph_go[p]:
            q.append(-node - 1)
            q.append(node)

depth[-1] = INF
#print("depth={}".format(depth))

#print("when={}".format(when))
#print("time={}".format(time))
lis = []
for x in time:
    lis.append(depth[x])

#print("lis= {}".format(lis))


def min_depth(A, B):
    global depth
    #print("###", A, B, depth[A], depth[B])
    if depth[int(A)] <= depth[int(B)]:
        return A
    else:
        return B


#print(min_depth(0, -3))

tree = SegmentTree.create_from_array(time, min_depth, -1)
#print(tree.segtree)

for c, d in cd:
    idx_c = when[c - 1]
    idx_d = when[d - 1]
    #print(idx_a, idx_b)
    LCA = tree.query(min(idx_c, idx_d), max(idx_c, idx_d) + 1)
    #print(LCA)

    if (depth[c - 1] + depth[d - 1] - 2 * depth[LCA]) % 2:
        print("Road")
    else:
        print("Town")
import sys

readline = sys.stdin.readline


class HLD:
    def __init__(self, Edge):
        self.N = len(Edge)
        self.nxt = [0] * self.N
        self.In = [0] * self.N
        self.Out = [0] * self.N
        self.order = []
        self.par = [-1] * self.N

        Cld = Edge[:]
        size = [1] * self.N
        used = set()
        num = [0] * self.N
        self.dist = [0] * self.N
        for i in range(self.N):
            if i in used:
                continue
            used.add(i)
            stack = [~i, i]
            while stack:
                vn = stack.pop()
                if vn >= 0:
                    for idx in range(len(Cld[vn])):
                        vf = Cld[vn][idx]
                        used.add(vf)
                        self.par[vf] = vn
                        num[vf] = idx
                        Cld[vf].remove(vn)
                        stack.append(~vf)
                        stack.append(vf)
                elif ~vn != i:
                    vn = ~vn
                    pn = self.par[vn]
                    size[pn] += size[vn]
                    if size[Cld[pn][0]] < size[vn]:
                        Cld[pn][0], Cld[pn][num[vn]] = Cld[pn][
                            num[vn]], Cld[pn][0]

            t = 0
            stack = [~i, i]
            while stack:
                vn = stack.pop()
                if vn >= 0:
                    self.order.append(vn)
                    self.In[vn] = t
                    t += 1
                    for vf in Cld[vn][::-1]:
                        self.nxt[vf] = self.nxt[vn] if Cld[vn][0] == vf else vf
                        stack.append(~vf)
                        stack.append(vf)
                        self.dist[vf] = 1 + self.dist[vn]
                else:
                    vn = ~vn
                    self.Out[vn] = t

    def pathv(self, u, v):
        while True:
            if self.In[u] > self.In[v]:
                u, v = v, u
            l = max(self.In[self.nxt[v]], self.In[u])
            r = 1 + self.In[v]
            yield l, r
            if self.nxt[u] == self.nxt[v]:
                return
            v = self.par[self.nxt[v]]

    def pathe(self, u, v):
        #辺の情報を子供に持たせる
        while True:
            if self.In[u] > self.In[v]:
                u, v = v, u
            if self.nxt[u] == self.nxt[v]:
                yield self.In[u] + 1, self.In[v] + 1
                return
            yield self.In[self.nxt[v]], self.In[v] + 1
            v = self.par[self.nxt[v]]

    def subtree(self, u):
        return self.In[u], self.Out[u]

    def lca(self, u, v):
        while True:
            if self.In[u] > self.In[v]:
                u, v = v, u
            if self.nxt[u] == self.nxt[v]:
                return u
            v = self.par[self.nxt[v]]


def parorder(Edge, p):
    N = len(Edge)
    par = [0] * N
    par[p] = -1
    stack = [p]
    order = []
    visited = set([p])
    ast = stack.append
    apo = order.append
    while stack:
        vn = stack.pop()
        apo(vn)
        for vf in Edge[vn]:
            if vf in visited:
                continue
            visited.add(vf)
            par[vf] = vn
            ast(vf)
    return par, order


def getcld(p):
    res = [[] for _ in range(len(p))]
    for i, v in enumerate(p[1:], 1):
        res[v].append(i)
    return res


N, Q = map(int, readline().split())
Edge = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, readline().split())
    a -= 1
    b -= 1
    Edge[a].append(b)
    Edge[b].append(a)

T = HLD(Edge)

Ans = [None] * Q
for qu in range(Q):
    c, d = map(int, readline().split())
    c -= 1
    d -= 1

    l = T.lca(c, d)

    dd = T.dist[c] + T.dist[d] - 2 * T.dist[l]
    Ans[qu] = "Town" if dd % 2 == 0 else "Road"

print("\n".join(map(str, Ans)))
from heapq import heappush, heappop

inf = 10**9

n, q = map(int, input().split())
graph = {}
for i in range(n):
    graph[i] = []
for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)


def f(s):
    que = [(0, s)]
    dist = [inf] * n
    dist[s] = 0
    while que:
        d, v = heappop(que)
        if dist[v] != d: continue
        for nv in graph[v]:
            nd = d + 1
            if dist[nv] <= nd: continue
            dist[nv] = nd
            heappush(que, (nd, nv))
    return dist


dist = f(0)

for _ in range(q):
    c, d = map(int, input().split())
    k = dist[c - 1] + dist[d - 1]
    if k % 2 == 0: print('Town')
    else: print('Road')
n, q = map(int, input().split())

f = [-1 for i in range(n)]
v = [list() for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    v[a].append(b)
    v[b].append(a)

que = [(0, 1)]
f[0] = 1
while (que):
    e = que.pop()
    for vv in v[e[0]]:
        if not f[vv] == -1 or not v[vv]:
            continue
        else:
            f[vv] = e[1] ^ 1
            que.append((vv, e[1] ^ 1))

for i in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if f[c] ^ f[d] == 1:
        print("Road")
    else:
        print("Town")
import queue

n, q = map(int, input().split())
eo = [0 for _ in range(n + 1)]
ab = [[] for _ in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    ab[a].append(b)
    ab[b].append(a)
qq = queue.Queue()
qq.put((1, 1))
while not qq.empty():
    s, p = qq.get()
    eo[s] = p
    for t in ab[s]:
        if eo[t] == 0:
            qq.put((t, -p))
for i in range(q):
    c, d = map(int, input().split())
    if eo[c] == eo[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
dist = [-1] * N
D = deque()
dist[0] = 0
D.append(0)
while D:
    v = D.popleft()
    for nv in G[v]:
        if dist[nv] == -1:
            dist[nv] = dist[v] + 1
            D.append(nv)
for i in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from sys import stdin

nii = lambda: map(int, input().split())
lnii = lambda: list(map(int, input().split()))
from collections import deque

n, q = nii()

tree = [[] for i in range(n)]
for i in range(n - 1):
    a, b = nii()
    a -= 1
    b -= 1
    tree[a].append(b)
    tree[b].append(a)

que = deque()
que.append(0)

col = [-1 for i in range(n)]

while que:
    x = que.popleft()
    for nx in tree[x]:
        if col[nx] != -1:
            continue
        que.append(nx)
        col[nx] = (col[x] + 1) % 2

for i in range(q):
    c, d = nii()
    c -= 1
    d -= 1
    if col[c] == col[d]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())

g = [[] for i in range(n)]
for i in range(n - 1):
    ai, bi = map(int, input().split())
    ai -= 1
    bi -= 1
    g[ai].append(bi)
    g[bi].append(ai)

# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)
#
# - construct
# prv[u] = v: 頂点uの一つ上の祖先頂点v
# - lca
# kprv[k][u] = v: 頂点uの2^k個上の祖先頂点v
# depth[u]: 頂点uの深さ (根頂点は0)

N = n
LV = (N - 1).bit_length()


def construct(prv):
    kprv = [prv]
    S = prv
    for k in range(LV):
        T = [0] * N
        for i in range(N):
            if S[i] is None:
                continue
            T[i] = S[S[i]]
        kprv.append(T)
        S = T
    return kprv


def lca(u, v, kprv, depth):
    dd = depth[v] - depth[u]
    if dd < 0:
        u, v = v, u
        dd = -dd

    # assert depth[u] <= depth[v]
    for k in range(LV + 1):
        if dd & 1:
            v = kprv[k][v]
        dd >>= 1

    # assert depth[u] == depth[v]
    if u == v:
        return u

    for k in range(LV - 1, -1, -1):
        pu = kprv[k][u]
        pv = kprv[k][v]
        if pu != pv:
            u = pu
            v = pv

    # assert kprv[0][u] == kprv[0][v]
    return kprv[0][u]


# BFS
infty = 10**10
depth = [infty for i in range(n)]
prev = [infty for i in range(n)]

prev[0] = 0
depth[0] = 0
from collections import deque

dq = deque()
dq.append(0)

while len(dq):
    u = dq.popleft()
    for v in g[u]:
        if depth[v] == infty:
            depth[v] = depth[u] + 1
            prev[v] = u
            dq.append(v)

kprv = construct(prev)

for i in range(q):
    ci, di = map(int, input().split())
    ci -= 1
    di -= 1
    lc = lca(ci, di, kprv, depth)
    dist = depth[ci] + depth[di] - depth[lc] * 2
    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python3
from collections import defaultdict, deque
from heapq import heappush, heappop
from bisect import bisect_left, bisect_right
import sys, random, itertools, math

sys.setrecursionlimit(10**5)
input = sys.stdin.readline
sqrt = math.sqrt


def LI():
    return list(map(int, input().split()))


def LF():
    return list(map(float, input().split()))


def LI_():
    return list(map(lambda x: int(x) - 1, input().split()))


def II():
    return int(input())


def IF():
    return float(input())


def S():
    return input().rstrip()


def LS():
    return S().split()


def IR(n):
    return [II() for _ in range(n)]


def LIR(n):
    return [LI() for _ in range(n)]


def FR(n):
    return [IF() for _ in range(n)]


def LFR(n):
    return [LI() for _ in range(n)]


def LIR_(n):
    return [LI_() for _ in range(n)]


def SR(n):
    return [S() for _ in range(n)]


def LSR(n):
    return [LS() for _ in range(n)]


mod = 1000000007
inf = 1e10


#solve
def solve():
    N, Q = LI()
    xy = LIR(N - 1)
    ab = LIR(Q)
    field = [[] for i in range(N)]

    for x, y in xy:
        field[x - 1].append(y - 1)
        field[y - 1].append(x - 1)

    takasa = [-1] * N
    takasa[0] = 0
    par = [[None for i in range(20)] for k in range(N)]
    q = deque()
    q.append(0)
    par[0][0] = 0
    while q:
        oya = q.pop()

        for ko in field[oya]:
            if takasa[ko] < 0:
                takasa[ko] = takasa[oya] + 1
                q.append(ko)
                par[ko][0] = oya

    for j in range(18):
        for i in range(N):
            par[i][j + 1] = par[par[i][j]][j]

    for a, b in ab:
        a -= 1
        b -= 1
        ans = takasa[a] + takasa[b] + 1

        if takasa[a] > takasa[b]:
            a, b = b, a

        for i in range(18):
            if (takasa[b] - takasa[a]) & 1 << i:
                b = par[b][i]

        if a == b:
            tmp = ans - 2 * takasa[a]
        else:
            for i in range(17, -1, -1):
                if par[a][i] != par[b][i]:
                    a = par[a][i]
                    b = par[b][i]

            tmp = ans - 2 * takasa[par[a][0]]
        if tmp & 1:
            print("Town")
        else:
            print("Road")
    return


#main
if __name__ == '__main__':
    solve()
import math
# import numpy as np
import itertools
# import queue
import bisect
from collections import deque, defaultdict
import heapq as hpq
from sys import stdin, setrecursionlimit
# from scipy.sparse.csgraph import dijkstra
# from scipy.sparse import csr_matrix
ipt = stdin.readline
# setrecursionlimit(10**7)
mod = 10**9 + 7
# mod = 998244353
dir = [(-1, 0), (0, -1), (1, 0), (0, 1)]
alp = "abcdefghijklmnopqrstuvwxyz"
INF = 1 << 32 - 1
# INF = 10**18


def main():
    n, qs = map(int, ipt().split())
    wy = [[] for i in range(n + 1)]
    for i in range(n - 1):
        a, b = map(int, ipt().split())
        wy[a].append(b)
        wy[b].append(a)

    d = [-1] * (n + 1)

    q = [1]
    d[1] = 0
    while q:
        qi = q.pop()
        di = d[qi] + 1
        for ni in wy[qi]:
            if d[ni] == -1:
                d[ni] = di
                q.append(ni)

    for i in range(qs):
        c, di = map(int, ipt().split())
        xm = d[c] + d[di]
        if xm % 2:
            print("Road")
        else:
            print("Town")

    return None


if __name__ == '__main__':
    main()
from collections import defaultdict
from collections import deque

n, q = map(int, input().split())

bi = defaultdict(int)

graph = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

bi[0] = 0
next_nodes = deque()
visited = set()

next_nodes.append(0)

while next_nodes:
    current = next_nodes.popleft()
    if bi[current] == 0:
        for next_node in graph[current]:
            if next_node in visited:
                pass
            else:
                next_nodes.append(next_node)
                visited.add(next_node)
                bi[next_node] = 1
    if bi[current] == 1:
        for next_node in graph[current]:
            if next_node in visited:
                pass
            else:
                next_nodes.append(next_node)
                visited.add(next_node)
                bi[next_node] = 0

for _ in range(q):
    c, d = map(int, input().split())
    if bi[c - 1] == bi[d - 1]:
        print('Town')
    else:
        print('Road')
import queue


def main():
    global N, distances

    N, Q = map(int, (input().split()))
    AB = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        AB[a - 1].append(b - 1)
        AB[b - 1].append(a - 1)

    colors = [-1] * N
    colors[0] = 0
    q = queue.Queue()
    q.put(0)

    while not q.empty():
        town_from = q.get()
        for town_to in AB[town_from]:
            if colors[town_to] == -1:
                colors[town_to] = 1 - colors[town_from]
                q.put(town_to)

    for _ in range(Q):
        c, d = map(int, input().split())
        if colors[c - 1] == colors[d - 1]:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
from collections import deque

N, q = map(int, input().split())
ab = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    ab[a - 1].append(b - 1)
    ab[b - 1].append(a - 1)

cd = [list(map(int, input().split())) for _ in range(q)]

prev = [None] * N
dep = [1 << 60 for _ in range(N)]
dep[0] = 0
l = deque([0])
while len(l) > 0:
    u = l.popleft()
    for v in ab[u]:
        if dep[u] + 1 < dep[v]:
            dep[v] = dep[u] + 1
            l.append(v)
            prev[v] = u

# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)
#
# - construct
# prv[u] = v: 頂点uの一つ上の祖先頂点v
# - lca
# kprv[k][u] = v: 頂点uの2^k個上の祖先頂点v
# depth[u]: 頂点uの深さ (根頂点は0)

LV = (N - 1).bit_length()


def construct(prv):
    kprv = [prv]
    S = prv
    for k in range(LV):
        T = [0] * N
        for i in range(N):
            if S[i] is None:
                continue
            T[i] = S[S[i]]
        kprv.append(T)
        S = T
    return kprv


def lca(u, v, kprv, depth):
    dd = depth[v] - depth[u]
    if dd < 0:
        u, v = v, u
        dd = -dd

    # assert depth[u] <= depth[v]
    for k in range(LV + 1):
        if dd & 1:
            v = kprv[k][v]
        dd >>= 1

    # assert depth[u] == depth[v]
    if u == v:
        return u

    for k in range(LV - 1, -1, -1):
        pu = kprv[k][u]
        pv = kprv[k][v]
        if pu != pv:
            u = pu
            v = pv

    # assert kprv[0][u] == kprv[0][v]
    return kprv[0][u]


kprev = construct(prev)
for c, d in cd:
    c -= 1
    d -= 1
    p = lca(c, d, kprev, dep)
    w = (dep[c] - dep[p]) + (dep[d] - dep[p])
    if w % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**6)
ml = lambda: list(map(int, input().split()))
mp = lambda: map(int, input().split())

N, Q = mp()
edge = list([] for _ in range(N))
dist = [-1] * N
visited = [0] * N
for i in range(N - 1):
    a, b = mp()
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)

q = [0]
visited[0] = 1
dist[0] = 0
while q:
    now = q.pop()
    for next in edge[now]:
        if not visited[next]:
            visited[next] = 1
            dist[next] = dist[now] + 1
            q.append(next)

for i in range(Q):
    c, d = mp()
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

tmp = [0] * N
tmp[0] = 1

que = queue.Queue()
que.put(0)

while not que.empty():
    t = que.get()
    for i in G[t]:
        if tmp[i] == 0:
            tmp[i] = tmp[t] * (-1)
            que.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if tmp[c - 1] == tmp[d - 1]:
        print("Town")
    else:
        print("Road")# -*- coding: UTF-8 -*-

import sys

input = sys.stdin.readline

N, Q = map(int, input().split())
adj = [[] for n in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    adj[a].append(b)
    adj[b].append(a)


def BFS(vnum, sv, adj):
    from collections import deque
    dist = [-1] * (vnum + 1)
    dist[sv] = 0
    que = deque([sv])
    while que:
        v = que.popleft()
        for x in adj[v]:
            if not dist[x] == -1:
                continue
            dist[x] = dist[v] + 1
            que.append(x)
    return dist[1:]


first_bfs = BFS(N, 1, adj)
for q in range(Q):
    c, d = map(int, input().split())
    if abs(first_bfs[c - 1] - first_bfs[d - 1]) % 2:
        print('Road')
    else:
        print('Town')
import sys

input = sys.stdin.buffer.readline
inputs = sys.stdin.buffer.readlines
sys.setrecursionlimit(10**6)
# '.'=46,'#'=35,'\n'=10
N, Q = map(int, input().split())

edges = [[] for i in range(1 + N)]
for i in range(N - 1):
    """#weighted->erase_,__,___=map(int,input().split())
    edges[_].append((__,___))
    edges[__].append((_,___))
    """
    _, __ = map(int, input().split())
    _ -= 1
    __ -= 1

    edges[_].append(__)
    edges[__].append(_)
    """
"""  #weighted->erase
LEVEL = [0] * (N + 1)
G = [[] for i in range(N + 1)]


def dfs(now, par=-1, c=0):
    LEVEL[now] = c
    for to in edges[now]:
        if to != par:
            G[now].append(to)
            dfs(to, now, c + 1)


dfs(0)

# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)

# Euler Tour の構築
S = []
F = [0] * N
depth = [0] * N


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in G[v]:
        dfs(w, d + 1)
        S.append(v)


dfs(0, 0)

# 存在しない範囲は深さが他よりも大きくなるようにする
INF = (N, None)

# LCAを計算するクエリの前計算
M = 2 * N
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


# LCAの計算 (外から呼び出す関数)
def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


def dist(x, y):
    return LEVEL[x] + LEVEL[y] - 2 * LEVEL[query(x, y)]


for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    print("Town") if dist(c, d) % 2 == 0 else print("Road")
def init_arg(num):
    return int(num) - 1


def II():
    return int(input())


def IS():
    return input()


def IL():
    return list(map(int, input().split()))


def IL_arg():
    return list(map(init_arg, input().split()))


def ILs(n):
    return [list(map(int, input().split())) for _ in range(n)]


tf = lambda boolean: "Yes" if boolean else "No"


def INF():
    return 1e10


def zeros1(n):
    return [0 for _ in range(n)]


def zeros2(n, m):
    return [[0 for _ in range(n)] for _ in range(m)]


import sys

sys.setrecursionlimit(2 * 10**9)

n, q = IL()

adjs = [[] for _ in range(n)]
reached = [0 for _ in range(n)]
colors = [INF() for _ in range(n)]
for _ in range(n - 1):
    a, b = IL()
    a -= 1
    b -= 1
    adjs[a].append(b)
    adjs[b].append(a)


def dfs(node, depth=1):
    reached[node] = 1
    colors[node] = depth % 2

    for adjnode in adjs[node]:
        # 未探索であれば
        if reached[adjnode] == 0:
            reached[adjnode] = 1
            dfs(adjnode, depth + 1)


dfs(0)
for _ in range(q):
    c, d = IL()
    c -= 1
    d -= 1
    if colors[c] == colors[d]:
        print("Town")
    else:
        print("Road")
from collections import deque
import sys

input = sys.stdin.readline


def main():
    N, Q = map(int, input().split())
    graph = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        graph[a].append(b)
        graph[b].append(a)

    fr = 0
    que = deque([fr])
    goneset = set([fr])
    count = [0] * N
    while True:
        fr = que.popleft()
        for to in graph[fr]:
            if to in goneset:
                continue
            count[to] = count[fr] + 1
            que.append(to)
            goneset.add(to)
        if len(que) == 0:
            break

    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        if count[c] % 2 == count[d] % 2: print('Town')
        else: print('Road')


if __name__ == "__main__":
    main()
from collections import deque

n, q = map(int, input().split())

m = n - 1

#隣接リストの初期化(1オリジンとするため0は使わない)
g = [[] for _ in range(n + 1)]
for _ in range(m):
    [a, b] = [int(x) for x in input().split()]
    g[a].append(b)
    g[b].append(a)
#print(g)

#深さを記録するリスト(1オリジンとするため0は使わない)
depth_vec = [-1 for _ in range(n + 1)]

# 1を根とする根付き木を作り、各頂点の深さを記録する
queue = deque()
queue.append((1, 0))  #1.伝播用確定
#print(queue)
while len(queue) > 0:
    (node, depth) = queue.pop()  #2.取り出し
    #print("node and depth is")
    #print(node,depth)
    depth_vec[node] = depth  #3.確定
    for child in g[node]:  #4.子ノードの一覧生成
        #print("child is")
        #print(child)
        #print("depth_vec[{}] is".format(child))
        #print(depth_vec[child])
        if depth_vec[child] >= 0:  #5.既に確定しているものは何もしない
            #print("continue")
            continue
        queue.append((child, depth + 1))  #6.子ノードの伝播用確定
        #print("queue is")
        #print(queue)

#print(g)
#print(depth_vec)

for i in range(q):
    [x, y] = [int(xx) for xx in input().split()]
    if (depth_vec[x] + depth_vec[y]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque


def bfs(N, g):
    m = [-1] * (N + 1)
    m[1] = 0
    q = deque()
    q.append(1)
    while len(q) > 0:
        node = q.popleft()
        for child in g[node].children:
            if m[child] > -1:
                continue
            m[child] = m[node] + 1
            q.append(child)
    return m


class Node:
    def __init__(self, n):
        self.n = n
        self.children = []


def main():
    N, Q = map(int, input().split())
    g = [Node(i) for i in range(N + 1)]
    for i in range(N - 1):
        a, b = map(int, input().split())
        g[a].children.append(b)
        g[b].children.append(a)

    memo = bfs(N, g)
    for i in range(Q):
        c, d = map(int, input().split())
        if memo[c] % 2 == memo[d] % 2:
            print('Town')
        else:
            print('Road')


main()
########失敗＃＃＃＃＃＃＃＃＃＃＃＃

from collections import deque

N, Q = map(int, input().split())
L = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(N - 1)]

AB = [[] for _ in range(N)]
for s, t in L:
    AB[s].append(t)
    # 無向グラフ⇔双方向と考える、これに気づけなかった・・・
    AB[t].append(s)
CD = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(Q)]

# 各街を偶数、奇数で色分けする←これに気づけなかった・・・
D = [-1] * N

dq = deque()
dq.append([0, 0])

while dq:
    cur, dis = dq.popleft()

    if D[cur] != -1:
        continue

    D[cur] = dis

    for t in AB[cur]:
        dq.append([t, (dis + 1) % 2])

for i, j in CD:
    if D[j] - D[i] == 0:
        print('Town')
    else:
        print('Road')
N, W = map(int, input().split())
graph = []
for i in range(N):
    graph.append([])

for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

from collections import deque

Q = deque()
Q.append(0)
dist = [-1] * N
dist[0] = 0
while len(Q) > 0:
    x = Q.popleft()
    for y in graph[x]:
        if dist[y] == -1:
            dist[y] = dist[x] + 1
            Q.append(y)

for i in range(W):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys, os

sys.setrecursionlimit(1000000)


def debug(*args, **kwargs):
    if os.getenv('DEBUG'):
        print(*args, **kwargs, file=sys.stderr)


def input():
    return sys.stdin.readline()[:-1]


def int0(s: str) -> int:
    return int(s) - 1


def main(_=0):
    N, Q = map(int, input().split())
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int0, input().split())
        G[a].append(b)
        G[b].append(a)

    color = [-1] * N

    def dfs(v, p, c):
        color[v] = c
        for u in G[v]:
            if u == p: continue
            dfs(u, v, c ^ 1)

    dfs(0, -1, 1)

    for _ in range(Q):
        c, d = map(int0, input().split())

        if color[c] == color[d]:
            print("Town")
        else:
            print("Road")


def main_lca(_=0):
    N, Q = map(int, input().split())
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int0, input().split())
        G[a].append(b)
        G[b].append(a)

    INF = 1001001001
    dist = [INF] * N
    dist[0] = 0
    P = [-1] * N

    def dfs(v, p, d):
        P[v] = d
        dist[v] = d
        for u in G[v]:
            if u == p: continue
            dfs(u, v, 1 + d)

    dfs(0, -1, 0)

    # doubling
    k = len(bin(max(dist))[2:])
    dbl = [[-1] * N for _ in range(k + 1)]
    for i in range(N):
        dbl[0][i] = P[i]
    for i in range(k):
        for j in range(N):
            if dbl[i][j] == -1: continue
            dbl[i + 1][j] = dbl[i][dbl[i][j]]

    ## (1) u, v の深さが同じになるまでお互い登っていく
    ## (2) 頂点が同じになる直前まで登っていく
    def lca(u, v):
        ## u のほうを深くする
        if dist[u] <= dist[v]:
            u, v = v, u
        if dist[u] != dist[v]:
            ## 深さの差
            d = dist[u] - dist[v]
            for i in range(k):
                if (d >> i) & 1:
                    u = dbl[i][u]
        if u == v: return u
        for i in range(k, -1, -1):
            if dbl[i][u] != dbl[i][v]:
                u, v = dbl[i][u], dbl[i][v]
        return dbl[0][u]

    # LCA がわかれば一瞬
    for _ in range(Q):
        c, d = map(int0, input().split())
        p = lca(c, d)
        D = 1 + dist[c] + dist[d] - (2 * dist[p])

        if D % 2 == 0:
            print("Road")
        else:
            print("Town")


def as_input(s: str) -> None:
    import io
    global input
    f = io.StringIO(s)
    input = lambda: f.readline().rstrip()
    return None


sample1 = """4 1
1 2
2 3
2 4
1 2
"""
sample2 = """5 2
1 2
2 3
3 4
4 5
1 3
1 5
"""
sample3 = """9 9
2 3
5 6
4 8
8 9
4 5
3 4
1 9
3 7
7 9
2 5
2 6
4 6
2 4
5 8
7 8
3 6
5 6
"""


def test():
    """
    >>> main(as_input(sample1))
    Road
    >>> main(as_input(sample2))
    Town
    Town
    >>> main(as_input(sample3))
    Town
    Road
    Town
    Town
    Town
    Town
    Road
    Road
    Road
    """
    pass


if __name__ == '__main__':
    main()
from collections import deque

n, Q = map(int, input().split())
e = [[] for i in range(n)]
for _ in range(n - 1):
    a, b = [int(x) - 1 for x in input().split()]
    e[a].append(b)
    e[b].append(a)

dis = [-1] * n
dis[0] = 0
q = deque([0])
while q:
    now = q.popleft()
    for nex in e[now]:
        if dis[nex] == -1:
            dis[nex] = dis[now] ^ 1
            q.append(nex)
for _ in range(Q):
    c, d = [int(x) - 1 for x in input().split()]
    if dis[c] == dis[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())

graph = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (n + 1)

que = deque()

que.append(1)
dist[1] = 0

while que:
    u = que.popleft()

    for j in graph[u]:
        if dist[j] == -1:
            dist[j] = dist[u] + 1
            que.append(j)

for j in range(q):
    c, d = map(int, input().split())

    if abs(dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
from collections import defaultdict
from math import inf

n, q = list(map(int, input().split()))
g = defaultdict(list)
for _ in range(n - 1):
    a, b = list(map(int, input().split()))
    g[a].append(b)
    g[b].append(a)
dist = [inf] * (n + 2)
dist[1] = 0

# iterative dfs
to_visit = [[1, -1]]
while to_visit:
    c, v = to_visit.pop()
    if v != -1:
        dist[c] = dist[v] + 1
    for u in g[c]:
        if u == v: continue
        to_visit.append([u, c])

for i in range(q):
    c, d = list(map(int, input().split()))
    distance = dist[c] + dist[d]
    if distance % 2 == 1:
        print("Road")
    else:
        print("Town")
n, q = map(int, input().split())

p = [0] * n
d = dict()
for i in range(n - 1):
    a, b = [int(x) - 1 for x in input().split()]
    if a in d:
        d[a].append(b)
    else:
        d[a] = [b]
    if b in d:
        d[b].append(a)
    else:
        d[b] = [a]

v = []
rp = 0
p[0] = 1
v.append(0)
while len(v) > rp:
    a = v[rp]
    rp += 1
    for b in d[a]:
        if p[b] == 0:
            p[b] = -p[a]
            v.append(b)

for i in range(q):
    c, d = [int(x) - 1 for x in input().split()]
    if p[c] == p[d]:
        print('Town')
    else:
        print('Road')
def bfs(s):
    col = 0
    q = [s]
    ch[s] = col
    while q != []:
        f = q[0]
        col = ch[f]
        for u in mat[f]:
            if ch[u] == None:
                ch[u] = 1 - col
                q.append(u)
        q.pop(0)


N, Q = list(map(int, input().split()))
mat = [[] for _ in range(N + 1)]
ch = [None for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = list(map(int, input().split()))
    mat[a].append(b)
    mat[b].append(a)

bfs(1)

for _ in range(Q):
    c, d = list(map(int, input().split()))
    if ch[c] == ch[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
Road = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    Road[a - 1].append(b - 1)
    Road[b - 1].append(a - 1)

Query = [list(map(int, input().split())) for _ in range(q)]

inf = 10**7

All_cost = []


def bfs(x):
    global cost
    cost = [inf] * n
    dp = [0] * n
    que = deque([x])
    cost[x] = 0
    dp[x] = 1
    while que:
        now = que.popleft()
        curr_cost = cost[now]
        next_cost = curr_cost + 1
        for y in Road[now]:
            if next_cost < cost[y]:
                que.append(y)
                dp[y] = dp[now]
                cost[y] = next_cost
            elif next_cost == cost[y]:
                dp[y] += dp[now]


bfs(0)

for c, d in Query:
    if (cost[c - 1] - cost[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
# -*- coding: utf-8 -*-
def main():
    N, Q = map(int, input().split())

    class LowestCommonAncestor:
        """ <O(nlog(n)), O(1)> """
        def __init__(self, G: "隣接リスト", root: "根"):
            self.n = len(G)
            self.tour = [0] * (2 * self.n - 1)
            self.depth_list = [0] * (2 * self.n - 1)
            self.id = [-1] * self.n
            self.dfs(G, root)
            self._rmq_init(self.depth_list)

        def _rmq_init(self, array):
            n = len(array)
            logn = n.bit_length()
            self.sparse_table = st = [[0] * (n + 1 - (1 << i))
                                      for i in range(logn)]
            st[0] = list(range(n))

            for i in range(logn - 1):
                s = st[i]
                t = st[i + 1]
                width = 1 << i
                for j in range(n + 1 - 2 * width):
                    first, second = s[j], s[j + width]
                    t[j] = first if array[first] < array[second] else second
            self.log = log = [0] * (n + 1)
            for i in range(2, n + 1):
                log[i] = log[i >> 1] + 1

        def _rmq_query(self, l: int, r: int) -> int:
            """min(array[l:r])を返す．O(1)"""
            b = self.log[r - l]
            s = self.sparse_table[b]
            first, second = s[l], s[r - (1 << b)]

            return first if self.depth_list[first] < self.depth_list[
                second] else second

        def dfs(self, G, root):
            """ 非再帰で深さ優先探索を行う """
            id = self.id
            tour = self.tour
            depth_list = self.depth_list
            v = root
            it = [0] * self.n
            parents = [-1] * self.n
            visit_id = 0
            depth = 0
            while v != -1:
                if id[v] == -1:
                    id[v] = visit_id
                tour[visit_id] = v
                depth_list[visit_id] = depth
                visit_id += 1
                g = G[v]
                if it[v] == len(g):
                    v = parents[v]
                    depth -= 1
                    continue
                if g[it[v]] == parents[v]:
                    it[v] += 1
                    if it[v] == len(g):
                        v = parents[v]
                        depth -= 1
                        continue
                    else:
                        child = g[it[v]]
                        parents[child] = v
                        it[v] += 1
                        v = child
                        depth += 1
                else:
                    child = g[it[v]]
                    parents[child] = v
                    it[v] += 1
                    v = child
                    depth += 1

        def lca(self, u: int, v: int) -> int:
            """ u と v の最小共通祖先を返す """
            l, r = self.id[u], self.id[v]
            if r < l:
                l, r = r, l
            q = self._rmq_query(l, r + 1)
            return self.tour[q]

        def dist(self, u: int, v: int) -> int:
            """ u と v の距離を返す """
            lca = self.lca(u, v)
            depth_u = self.depth_list[self.id[u]]
            depth_v = self.depth_list[self.id[v]]
            depth_lca = self.depth_list[self.id[lca]]
            return depth_u + depth_v - 2 * depth_lca

    es = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        es[a].append(b)
        es[b].append(a)

    lca = LowestCommonAncestor(es, 0)
    for i in range(Q):
        c, d = map(int, input().split())
        if lca.dist(c - 1, d - 1) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
def d_collision():
    import sys
    sys.setrecursionlimit(10**7)

    class LowestCommonAncestor(object):
        """木の最近共通祖先を求める"""
        def __init__(self, tree):
            """入力は木を二次元リストで表現したものであることを前提としている"""
            self.n = len(tree)
            self.tree = tree
            # parent[j][k]: 頂点 j から根に向かって 2**k 回進んで到達する頂点
            self.parent = [[] for _ in range(self.n)]
            # depth[j]: 根 (頂点 0) に対する頂点 j の深さ
            self.depth = [None] * self.n
            self.stack = []
            self._make_parent_table(0)

        def _make_parent_table(self, vertex):
            """parent と depth に値を格納"""
            recursion_time = len(self.stack)
            self.depth[vertex] = recursion_time

            # 親を (存在する限り) 2**k 回辿る
            k = 0
            while 2**k <= recursion_time:
                self.parent[vertex].append(self.stack[recursion_time - 2**k])
                k += 1

            self.stack.append(vertex)

            for next_vertex in self.tree[vertex]:
                if self.depth[next_vertex] is not None:
                    continue
                self._make_parent_table(next_vertex)
            self.stack.pop()

        def depth_from_root(self, v):
            return self.depth[v]

        def get_lca(self, u, v):
            """頂点 u, v の LCA を求める"""
            if self.depth[u] > self.depth[v]:  # より深い頂点を v とする
                u, v = v, u

            depth_add = self.depth[u] + self.depth[v]
            depth_diff = self.depth[v] - self.depth[u]

            # u と v が同じ深さになるまで v (深い方) を根に向かって登らせる
            while depth_diff > 0:
                k = 1
                while 2**k < depth_diff:
                    k += 1
                k -= 1

                v = self.parent[v][k]
                depth_diff -= 2**k

            # u と v が同じ頂点を指さないギリギリまで u, v を根に向かって登らせる
            # そこから 1 つ登った頂点は u, v の LCA である
            while u != v:
                k = 1
                length = len(self.parent[u])
                # 登ることができ，親が同じでない
                while length > k and self.parent[u][k] != self.parent[v][k]:
                    k += 1
                k -= 1
                u = self.parent[u][k]
                v = self.parent[v][k]
            return u

    N, Q = [int(_) for _ in input().split()]
    Roads = [[] for _ in range(N)]
    for _ in range(N - 1):
        x, y = [int(i) - 1 for i in sys.stdin.readline().split()]
        Roads[x].append(y)
        Roads[y].append(x)

    lowest_common_ancestor = LowestCommonAncestor(Roads)
    lca = lowest_common_ancestor.get_lca
    d = lowest_common_ancestor.depth_from_root
    ans = []
    add = ans.append

    for _ in range(Q):
        a, b = [int(i) - 1 for i in sys.stdin.readline().split()]
        l = lca(a, b)
        dist = d(a) + d(b) - 2 * d(l) + 1
        add('Road' if dist % 2 == 0 else 'Town')
    return '\n'.join(map(str, ans))


print(d_collision())
from queue import Queue
from collections import deque
import collections
import math
import sys

sys.setrecursionlimit(10000)


def comb(n, r):
    comb = 1
    r = min(r, n - r)
    for i in range(r):
        comb = comb * (n - i) // (i + 1)
    return comb


N, Q = map(int, input().split())
paths = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    paths[a].append(b)
    paths[b].append(a)

#bfs
q = collections.deque()
q.append(0)
visited = [False] * N
level = [0] * N
visited[0] = True
level[0] = 0
while len(q) != 0:
    node = q.popleft()
    for n in paths[node]:
        if not visited[n]:
            visited[n] = True
            q.append(n)
            level[n] = (level[node] + 1) % 2

for i in range(Q):
    c, d = map(int, input().split())
    if (level[c - 1] + level[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, m = map(int, input().split())
graph = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i in range(m):
    c, d = map(int, input().split())
    if dist[c] % 2 == dist[d] % 2:
        print('Town')
    else:
        print('Road')
import sys
from collections import deque

N, Q = map(int, sys.stdin.readline().rstrip().split())
V = [0] * N
E = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, sys.stdin.readline().rstrip().split())
    E[a - 1].append(b - 1)
    E[b - 1].append(a - 1)

q = deque()

q.append(0)
V[0] = 1
while q:
    u = q.popleft()
    if V[u] == 1:
        state = 2
    else:
        state = 1

    for v in E[u]:
        if V[v] == 0:
            V[v] = state
            q.append(v)

for q in range(Q):
    c, d = map(int, sys.stdin.readline().rstrip().split())
    if V[c - 1] == V[d - 1]:
        print("Town")
    else:
        print("Road")
import sys, os
from collections import deque, defaultdict
import math
import bisect

sys.setrecursionlimit(10**9)
INF = 1 << 64
MOD = 10**9 + 7


def main(f=sys.stdin):
    answer(deque(map(lambda s: s.rstrip(os.linesep), f.readlines())))


def dfs(r, l, i, t):
    for e in r[i]:
        if l[e] < 0:
            l[e] = t
            dfs(r, l, e, t + 1)


def answer(lines):
    # n = int(lines.popleft())
    # a, b = [int(s) for s in lines.popleft().split()]

    n, q = [int(s) for s in lines.popleft().split()]
    r = defaultdict(set)

    for i in range(n - 1):
        a, b = [int(s) - 1 for s in lines.popleft().split()]
        r[a].add(b)
        r[b].add(a)

    l = [-1] * n
    dfs(r, l, 0, 0)

    for i in range(q):
        c, d = [int(s) - 1 for s in lines.popleft().split()]
        print("Town" if l[c] % 2 == l[d] % 2 else "Road")


if 'debug' not in globals():
    main()
from collections import deque
import numpy as np

n, q = map(int, input().split())
data = [[] for i in range(n)]

for i in range(n - 1):
    x, y = map(int, input().split())
    data[x - 1].append(y - 1)
    data[y - 1].append(x - 1)

color = [-1] * n
color[0] = 0
d = deque()
d.append(0)

while len(d) != 0:
    v = d.popleft()

    for z in data[v]:
        if color[z] == -1:
            d.append(z)
            color[z] = 1 - color[v]

for i in range(q):
    x, y = map(int, input().split())
    if color[x - 1] == color[y - 1]:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
from collections import deque

n, q = map(int, input().split())
node = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    node[a - 1].append(b - 1)
    node[b - 1].append(a - 1)

num = [-1] * n
num[0] = 0
queue = deque([0])
while queue:
    x = queue.popleft()
    for y in node[x]:
        if num[y] == -1:
            num[y] = 1 - num[x]
            queue.append(y)

for i in range(q):
    c, d = map(int, input().split())
    print("Town" if num[c - 1] == num[d - 1] else "Road")
from collections import deque

N, Q = map(int, input().split())

edge = [[] for __ in range(N)]

for i in range(1, N):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)

que = deque()
que.append(0)
color = [-1] * N
color[0] = 0

while que:
    now = que.pop()
    for adj in edge[now]:
        if color[adj] == -1:
            color[adj] = 1 - color[now]
            que.append(adj)

for i in range(Q):
    c, d = map(int, input().split())
    ans = "Town"
    if color[c - 1] != color[d - 1]:
        ans = "Road"
    print(ans)
import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import Counter, deque, defaultdict
from functools import lru_cache, reduce
from heapq import heappush, heappop, heapify, heappushpop, _heappop_max, _heapify_max


def _heappush_max(heap, item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap) - 1)


def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item


from math import gcd as GCD

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


class Graph:
    def __init__(self,
                 V,
                 edges=False,
                 graph=False,
                 directed=False,
                 weighted=False):
        self.V = V
        self.directed = directed
        self.weighted = weighted
        if not graph:
            self.edges = edges
            self.graph = [[] for i in range(self.V)]
            if weighted:
                for i, j, d in self.edges:
                    self.graph[i].append((j, d))
                    if not self.directed:
                        self.graph[j].append((i, d))
            else:
                for i, j in self.edges:
                    self.graph[i].append(j)
                    if not self.directed:
                        self.graph[j].append(i)
        else:
            self.graph = graph
            self.edges = []
            for i in range(self.V):
                if self.weighted:
                    for j, d in self.graph[i]:
                        if self.directed or not self.directed and i <= j:
                            self.edges.append((i, j, d))
                else:
                    for j in self.graph[i]:
                        if self.directed or not self.directed and i <= j:
                            self.edges.append((i, j))

    def SS_BFS(self,
               s,
               bipartite_graph=False,
               linked_components=False,
               parents=False,
               unweighted_dist=False,
               weighted_dist=False):
        seen = [False] * self.V
        seen[s] = True
        if linked_components:
            lc = [s]
        if parents:
            ps = [None] * self.V
            ps[s] = s
        if unweighted_dist or bipartite_graph:
            uwd = [float('inf')] * self.V
            uwd[s] = 0
        if weighted_dist:
            wd = [float('inf')] * self.V
            wd[s] = 0
        queue = deque([s])
        while queue:
            x = queue.popleft()
            for y in self.graph[x]:
                if self.weighted:
                    y, d = y
                if not seen[y]:
                    seen[y] = True
                    queue.append(y)
                    if linked_components:
                        lc.append(y)
                    if parents:
                        ps[y] = x
                    if unweighted_dist or bipartite_graph:
                        uwd[y] = uwd[x] + 1
                    if weighted_dist:
                        wd[y] = wd[x] + d
        if bipartite_graph:
            bg = [[], []]
            for tpl in self.edges:
                i, j = tpl[:2] if self.weighted else tpl
                if type(uwd[i]) == float or type(uwd[j]) == float:
                    continue
                if not uwd[i] % 2 ^ uwd[j] % 2:
                    bg = False
                    break
            else:
                for x in range(self.V):
                    if type(uwd[x]) == float:
                        continue
                    bg[uwd[x] % 2].append(x)
        tpl = ()
        if bipartite_graph:
            tpl += (bg, )
        if linked_components:
            tpl += (lc, )
        if parents:
            tpl += (ps, )
        if unweighted_dist:
            tpl += (uwd, )
        if weighted_dist:
            tpl += (wd, )
        if len(tpl) == 1:
            tpl = tpl[0]
        return tpl

    def AP_BFS(self,
               bipartite_graph=False,
               linked_components=False,
               parents=False):
        seen = [False] * self.V
        if bipartite_graph:
            bg = [None] * self.V
            cnt = -1
        if linked_components:
            lc = []
        if parents:
            ps = [None] * self.V
        for s in range(self.V):
            if seen[s]:
                continue
            seen[s] = True
            if bipartite_graph:
                cnt += 1
                bg[s] = (cnt, s & 2)
            if linked_components:
                lc.append([s])
            if parents:
                ps[s] = s
            queue = deque([s])
            while queue:
                x = queue.popleft()
                for y in self.graph[x]:
                    if self.weighted:
                        y, d = y
                    if not seen[y]:
                        seen[y] = True
                        queue.append(y)
                        if bipartite_graph:
                            bg[y] = (cnt, bg[x][1] ^ 1)
                        if linked_components:
                            lc[-1].append(y)
                        if parents:
                            ps[y] = x
        if bipartite_graph:
            bg_ = bg
            bg = [[[], []] for i in range(cnt + 1)]
            for tpl in self.edges:
                i, j = tpl[:2] if self.weighted else tpl
                if not bg_[i][1] ^ bg_[j][1]:
                    bg[bg_[i][0]] = False
            for x in range(self.V):
                if bg[bg_[x][0]]:
                    bg[bg_[x][0]][bg_[x][1]].append(x)
        tpl = ()
        if bipartite_graph:
            tpl += (bg, )
        if linked_components:
            tpl += (lc, )
        if parents:
            tpl += (ps, )
        if len(tpl) == 1:
            tpl = tpl[0]
        return tpl

    def SS_DFS(self,
               s,
               bipartite_graph=False,
               cycle_detection=False,
               directed_acyclic=False,
               euler_tour=False,
               linked_components=False,
               parents=False,
               postorder=False,
               preorder=False,
               subtree_size=False,
               topological_sort=False,
               unweighted_dist=False,
               weighted_dist=False):
        seen = [False] * self.V
        finished = [False] * self.V
        if directed_acyclic or cycle_detection or topological_sort:
            dag = True
        if euler_tour:
            et = []
        if linked_components:
            lc = []
        if parents or cycle_detection or subtree_size:
            ps = [None] * self.V
            ps[s] = s
        if postorder or topological_sort:
            post = []
        if preorder:
            pre = []
        if subtree_size:
            ss = [1] * self.V
        if unweighted_dist or bipartite_graph:
            uwd = [float('inf')] * self.V
            uwd[s] = 0
        if weighted_dist:
            wd = [float('inf')] * self.V
            wd[s] = 0
        stack = [(s, 0)] if self.weighted else [s]
        while stack:
            if self.weighted:
                x, d = stack.pop()
            else:
                x = stack.pop()
            if not seen[x]:
                seen[x] = True
                stack.append((x, d) if self.weighted else x)
                if euler_tour:
                    et.append(x)
                if linked_components:
                    lc.append(x)
                if preorder:
                    pre.append(x)
                for y in self.graph[x]:
                    if self.weighted:
                        y, d = y
                    if not seen[y]:
                        stack.append((y, d) if self.weighted else y)
                        if parents or cycle_detection or subtree_size:
                            ps[y] = x
                        if unweighted_dist or bipartite_graph:
                            uwd[y] = uwd[x] + 1
                        if weighted_dist:
                            wd[y] = wd[x] + d
                    elif not finished[y]:
                        if (directed_acyclic or cycle_detection
                                or topological_sort) and dag:
                            dag = False
                            if cycle_detection:
                                cd = (y, x)
            elif not finished[x]:
                finished[x] = True
                if euler_tour:
                    et.append(~x)
                if postorder or topological_sort:
                    post.append(x)
                if subtree_size:
                    for y in self.graph[x]:
                        if y == ps[x]:
                            continue
                        ss[x] += ss[y]
        if bipartite_graph:
            bg = [[], []]
            for tpl in self.edges:
                i, j = tpl[:2] if self.weighted else tpl
                if type(uwd[i]) == float or type(uwd[j]) == float:
                    continue
                if not uwd[i] % 2 ^ uwd[j] % 2:
                    bg = False
                    break
            else:
                for x in range(self.V):
                    if type(uwd[x]) == float:
                        continue
                    bg[uwd[x] % 2].append(x)
        tpl = ()
        if bipartite_graph:
            tpl += (bg, )
        if cycle_detection:
            if dag:
                cd = []
            else:
                y, x = cd
                cd = self.Route_Restoration(y, x, ps)
            tpl += (cd, )
        if directed_acyclic:
            tpl += (dag, )
        if euler_tour:
            tpl += (et, )
        if linked_components:
            tpl += (lc, )
        if parents:
            tpl += (ps, )
        if postorder:
            tpl += (post, )
        if preorder:
            tpl += (pre, )
        if subtree_size:
            tpl += (ss, )
        if topological_sort:
            if dag:
                tp_sort = post[::-1]
            else:
                tp_sort = []
            tpl += (tp_sort, )
        if unweighted_dist:
            tpl += (uwd, )
        if weighted_dist:
            tpl += (wd, )
        if len(tpl) == 1:
            tpl = tpl[0]
        return tpl

    def AP_DFS(self,
               bipartite_graph=False,
               cycle_detection=False,
               directed_acyclic=False,
               euler_tour=False,
               linked_components=False,
               parents=False,
               postorder=False,
               preorder=False,
               topological_sort=False):
        seen = [False] * self.V
        finished = [False] * self.V
        if bipartite_graph:
            bg = [None] * self.V
            cnt = -1
        if directed_acyclic or cycle_detection or topological_sort:
            dag = True
        if euler_tour:
            et = []
        if linked_components:
            lc = []
        if parents or cycle_detection:
            ps = [None] * self.V
        if postorder or topological_sort:
            post = []
        if preorder:
            pre = []
        for s in range(self.V):
            if seen[s]:
                continue
            if bipartite_graph:
                cnt += 1
                bg[s] = (cnt, s & 2)
            if linked_components:
                lc.append([])
            if parents:
                ps[s] = s
            stack = [(s, 0)] if self.weighted else [s]
            while stack:
                if self.weighted:
                    x, d = stack.pop()
                else:
                    x = stack.pop()
                if not seen[x]:
                    seen[x] = True
                    stack.append((x, d) if self.weighted else x)
                    if euler_tour:
                        et.append(x)
                    if linked_components:
                        lc[-1].append(x)
                    if preorder:
                        pre.append(x)
                    for y in self.graph[x]:
                        if self.weighted:
                            y, d = y
                        if not seen[y]:
                            stack.append((y, d) if self.weighted else y)
                            if bipartite_graph:
                                bg[y] = (cnt, bg[x][1] ^ 1)
                            if parents or cycle_detection:
                                ps[y] = x
                        elif not finished[y]:
                            if directed_acyclic and dag:
                                dag = False
                                if cycle_detection:
                                    cd = (y, x)
                elif not finished[x]:
                    finished[x] = True
                    if euler_tour:
                        et.append(~x)
                    if postorder or topological_sort:
                        post.append(x)
        if bipartite_graph:
            bg_ = bg
            bg = [[[], []] for i in range(cnt + 1)]
            for tpl in self.edges:
                i, j = tpl[:2] if self.weighted else tpl
                if not bg_[i][1] ^ bg_[j][1]:
                    bg[bg_[i][0]] = False
            for x in range(self.V):
                if bg[bg_[x][0]]:
                    bg[bg_[x][0]][bg_[x][1]].append(x)
        tpl = ()
        if bipartite_graph:
            tpl += (bg, )
        if cycle_detection:
            if dag:
                cd = []
            else:
                y, x = cd
                cd = self.Route_Restoration(y, x, ps)
            tpl += (cd, )
        if directed_acyclic:
            tpl += (dag, )
        if euler_tour:
            tpl += (et, )
        if linked_components:
            tpl += (lc, )
        if parents:
            tpl += (ps, )
        if postorder:
            tpl += (post, )
        if preorder:
            tpl += (pre, )
        if topological_sort:
            if dag:
                tp_sort = post[::-1]
            else:
                tp_sort = []
            tpl += (tp_sort, )
        if len(tpl) == 1:
            tpl = tpl[0]
        return tpl

    def Tree_Diameter(self, weighted=False):
        def Farthest_Point(u):
            dist = self.SS_BFS(
                u, weighted_dist=True) if weighted else self.SS_BFS(
                    u, unweighted_dist=True)
            fp = 0
            for i in range(self.V):
                if dist[fp] < dist[i]:
                    fp = i
            return fp, dist[fp]

        u, d = Farthest_Point(0)
        v, d = Farthest_Point(u)
        return u, v, d

    def SCC(self):
        reverse_graph = [[] for i in range(self.V)]
        for tpl in self.edges:
            i, j = tpl[:2] if self.weighted else tpl
            reverse_graph[j].append(i)
        postorder = self.AP_DFS(postorder=True)
        scc = []
        seen = [False] * self.V
        for s in postorder[::-1]:
            if seen[s]:
                continue
            queue = deque([s])
            seen[s] = True
            lst = []
            while queue:
                x = queue.popleft()
                lst.append(x)
                for y in reverse_graph[x]:
                    if self.weighted:
                        y = y[0]
                    if not seen[y]:
                        seen[y] = True
                        queue.append(y)
            scc.append(lst)
        return scc

    def Build_LCA(self, s):
        self.euler_tour, self.parents, depth = self.SS_DFS(
            s, euler_tour=True, parents=True, unweighted_dist=True)
        self.dfs_in_index = [None] * self.V
        self.dfs_out_index = [None] * self.V
        for i, x in enumerate(self.euler_tour):
            if x >= 0:
                self.dfs_in_index[x] = i
            else:
                self.dfs_out_index[~x] = i
        self.ST = Segment_Tree(2 * self.V, lambda x, y: min(x, y),
                               float('inf'))
        lst = [None] * 2 * self.V
        for i in range(2 * self.V):
            if self.euler_tour[i] >= 0:
                lst[i] = depth[self.euler_tour[i]]
            else:
                lst[i] = depth[self.parents[~self.euler_tour[i]]]
        self.ST.Build(lst)

    def LCA(self, a, b):
        m = min(self.dfs_in_index[a], self.dfs_in_index[b])
        M = max(self.dfs_in_index[a], self.dfs_in_index[b])
        x = self.euler_tour[self.ST.Fold_Index(m, M + 1)]
        if x >= 0:
            return x
        else:
            return self.parents[~x]

    def Dijkstra(self, s, route_restoration=False):
        dist = [float('inf')] * self.V
        dist[s] = 0
        hq = [(0, s)]
        if route_restoration:
            parents = [None] * self.V
            parents[s] = s
        while hq:
            dx, x = heapq.heappop(hq)
            if dist[x] < dx:
                continue
            for y, dy in self.graph[x]:
                if dist[y] > dx + dy:
                    dist[y] = dx + dy
                    if route_restoration:
                        parents[y] = x
                    heapq.heappush(hq, (dist[y], y))
        if route_restoration:
            return dist, parents
        else:
            return dist

    def Bellman_Ford(self, s, route_restoration=False):
        dist = [float('inf')] * self.V
        dist[s] = 0
        if route_restoration:
            parents = [s] * self.V
        for _ in range(self.V - 1):
            for i, j, d in self.edges:
                if dist[j] > dist[i] + d:
                    dist[j] = dist[i] + d
                    if route_restoration:
                        parents[j] = i
                if not self.directed and dist[i] > dist[j] + d:
                    dist[i] = dist[j] + d
                    if route_restoration:
                        parents[i] = j
        negative_cycle = []
        for i, j, d in self.edges:
            if dist[j] > dist[i] + d:
                negative_cycle.append(j)
            if not self.directed and dist[i] > dist[j] + d:
                negative_cycle.append(i)
        if negative_cycle:
            is_negative_cycle = [False] * self.V
            for i in negative_cycle:
                if is_negative_cycle[i]:
                    continue
                else:
                    queue = deque([i])
                    is_negative_cycle[i] = True
                    while queue:
                        x = queue.popleft()
                        for y, d in self.graph[x]:
                            if not is_negative_cycle[y]:
                                queue.append(y)
                                is_negative_cycle[y] = True
                                if route_restoration:
                                    parents[y] = x
            for i in range(self.V):
                if is_negative_cycle[i]:
                    dist[i] = -float('inf')
        if route_restoration:
            return dist, parents
        else:
            return dist

    def Warshall_Floyd(self, route_restoration=False):
        dist = [[float('inf')] * self.V for i in range(self.V)]
        for i in range(self.V):
            dist[i][i] = 0
        if route_restoration:
            parents = [[j for j in range(self.V)] for i in range(self.V)]
        for i, j, d in self.edges:
            if dist[i][j] > d:
                dist[i][j] = d
                if route_restoration:
                    parents[i][j] = i
            if not self.directed and dist[j][i] > d:
                dist[j][i] = d
                if route_restoration:
                    parents[j][i] = j
        for k in range(self.V):
            for i in range(self.V):
                for j in range(self.V):
                    if dist[i][j] > dist[i][k] + dist[k][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
                        if route_restoration:
                            parents[i][j] = parents[k][j]
        for i in range(self.V):
            if dist[i][i] < 0:
                for j in range(self.V):
                    if dist[i][j] != float('inf'):
                        dist[i][j] = -float('inf')
        if route_restoration:
            return dist, parents
        else:
            return dist

    def Route_Restoration(self, s, g, parents):
        route = [g]
        while s != g and parents[g] != g:
            g = parents[g]
            route.append(g)
        route = route[::-1]
        return route

    def Kruskal(self):
        UF = UnionFind(self.V)
        sorted_edges = sorted(self.edges, key=lambda x: x[2])
        minimum_spnning_tree = []
        for i, j, d in sorted_edges:
            if not UF.Same(i, j):
                UF.Union(i, j)
                minimum_spnning_tree.append((i, j, d))
        return minimum_spnning_tree

    def Ford_Fulkerson(self, s, t):
        max_flow = 0
        residual_graph = [defaultdict(int) for i in range(self.V)]
        if self.weighted:
            for i, j, d in self.edges:
                if not d:
                    continue
                residual_graph[i][j] += d
                if not self.directed:
                    residual_graph[j][i] += d
        else:
            for i, j in self.edges:
                residual_graph[i][j] += 1
                if not self.directed:
                    residual_graph[j][i] += 1
        while True:
            parents = [None] * self.V
            parents[s] = s
            seen = [False] * self.V
            seen[s] = True
            queue = deque([s])
            while queue:
                x = queue.popleft()
                for y in residual_graph[x].keys():
                    if not seen[y]:
                        seen[y] = True
                        queue.append(y)
                        parents[y] = x
                        if y == t:
                            tt = t
                            while tt != s:
                                residual_graph[parents[tt]][tt] -= 1
                                residual_graph[tt][parents[tt]] += 1
                                if not residual_graph[parents[tt]][tt]:
                                    residual_graph[parents[tt]].pop(tt)
                                tt = parents[tt]
                            max_flow += 1
                            break
                else:
                    continue
                break
            else:
                break
        return max_flow

    def BFS(self, s):
        seen = [False] * self.V
        seen[s] = True
        queue = deque([s])

        while queue:
            x = queue.popleft()
            for y in self.graph[x]:
                if self.weighted:
                    y, d = y
                if not seen[y]:
                    seen[y] = True
                    queue.append(y)

        return

    def DFS(self, s):
        seen = [False] * self.V
        finished = [False] * self.V
        stack = [(s, 0)] if self.weighted else [s]

        while stack:
            if self.weighted:
                x, d = stack.pop()
            else:
                x = stack.pop()
            if not seen[x]:
                seen[x] = True
                stack.append((x, d) if self.weighted else x)

                for y in self.graph[x]:
                    if self.weighted:
                        y, d = y
                    if not seen[y]:
                        stack.append((y, d) if self.weighted else y)
            elif not finished[x]:
                finished[x] = True

        return


N, Q = map(int, readline().split())
edges = []
for _ in range(N - 1):
    a, b = map(int, readline().split())
    a -= 1
    b -= 1
    edges.append((a, b))
G = Graph(N, edges=edges)
dist = G.SS_BFS(0, unweighted_dist=True)
for _ in range(Q):
    c, d = map(int, readline().split())
    c -= 1
    d -= 1
    if dist[c] % 2 == dist[d] % 2:
        ans = 'Town'
    else:
        ans = 'Road'
    print(ans)
import sys


def dfs(prev, now, visited, flag):
    visited[now] = True
    for nxt in G[now]:
        if nxt == prev or visited[nxt]:
            continue
        res[nxt] = not flag
        dfs(now, nxt, visited, not flag)


sys.setrecursionlimit(10**6)

n, q = map(int, input().split())
a, b = zip(*[tuple(map(int, input().split())) for _ in range(n - 1)])
c, d = zip(*[tuple(map(int, input().split())) for _ in range(q)])

# 距離の偶奇が重要？
# 2色？に分ける

G = [[] for _ in range(n)]
for i in range(n - 1):
    G[a[i] - 1].append(b[i] - 1)
    G[b[i] - 1].append(a[i] - 1)

visited = [False] * n
res = [False] * n
dfs(0, 0, visited, False)
for i in range(q):
    if res[c[i] - 1] == res[d[i] - 1]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
paths = []
for n in range(N - 1):
    a, b = map(int, input().split())
    paths.append((a, b))
queries = []
for q in range(Q):
    a, b = map(int, input().split())
    queries.append((a, b))

graph = [[] for _ in range(N)]
for path in paths:
    a, b = path
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

color = [-1] * N
color[0] = 0
q = queue.Queue()
q.put(0)
while not q.empty():
    p = q.get()
    for i in graph[p]:
        if color[i] == -1:
            color[i] = 1 - color[p]
            q.put(i)
for q in queries:
    a, b = q
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())

G = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    A, B = map(int, input().split())
    G[A].append(B)
    G[B].append(A)

todo = deque([1])
seen = [-1] * (N + 1)
seen[1] = 0
while todo:
    v = todo.pop()
    for next in G[v]:
        if seen[next] == -1:
            seen[next] = seen[v] + 1
            todo.append(next)

for i in range(Q):
    c, d = map(int, input().split())
    if (seen[c] - seen[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys
from collections import deque

sys.setrecursionlimit(10**7)
N, M = map(int, input().split())
graph = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
d = deque()
d.append((0, 0))
depth = [-1] * N
while d:
    i, dep = d.popleft()
    if depth[i] > -1:
        pass
    else:
        depth[i] = dep
        for node in graph[i]:
            d.append((node, dep + 1))
for _ in range(M):
    c, d = map(int, input().split())
    if (depth[c - 1] + depth[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import defaultdict, deque

N, Q = map(int, input().split())
M = N - 1
d = defaultdict(list)
for i in range(M):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    d[a].append(b)
    d[b].append(a)

dist = [None] * N
q = deque()

s = 1 - 1  # スタート
q.append(s)
dist[s] = 0

while len(q) != 0:
    From = q.popleft()
    for To in d[From]:
        if dist[To] == None:
            q.append(To)
            dist[To] = dist[From] + 1
#print(dist)
for q in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())

G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
import queue

n, q = map(int, input().split())
g = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

que = queue.Queue()
color = [0] * n
color[0] = 1
que.put(0)

while not que.empty():
    t = que.get()
    for i in g[t]:
        if color[i] == 0:
            color[i] = -color[t]
            que.put(i)

for i in range(q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print('Town')
    else:
        print('Road')
import collections

N, Q = map(int, input().split())
lsg = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    lsg[a].append(b)
    lsg[b].append(a)
# c,dの距離が偶数か奇数か
d = collections.deque([0])
used = [False] * (N)
lscost = [float('INF')] * (N)
lscost[0] = 0
while d:
    v = d.popleft()
    if used[v]:
        continue
    used[v] = True
    for j in lsg[v]:
        if used[j]:
            continue
        if lscost[j] > lscost[v] + 1:
            lscost[j] = lscost[v] + 1
            d.append(j)
lsQ = [map(int, input().split()) for i in range(Q)]
for i in range(Q):
    c, d = lsQ[i]
    c -= 1
    d -= 1
    if lscost[c] % 2 == lscost[d] % 2:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = list(map(int, input().split()))
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = list(map(lambda x: int(x) - 1, input().split()))
    G[a].append(b)
    G[b].append(a)

D = [-1] * N
# [node, distance]
dq = deque()
dq.append([0, 0])
while dq:
    u, d = dq.popleft()
    D[u] = d
    for v in G[u]:
        if D[v] == -1:
            dq.append([v, d + 1])

for _ in range(Q):
    c, d = list(map(lambda x: int(x) - 1, input().split()))
    if (D[c] - D[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys
from collections import deque, defaultdict

N, Q = map(int, input().split())

edges = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)

INF = float("inf")
dist = {}
dist[0] = 0
visited = set()

q = deque()
q.append((0, 0))
while q:
    city, d = q.popleft()
    if city in visited:
        continue
    visited.add(city)

    for n_city in edges[city]:
        if n_city in visited:
            continue

        dist[n_city] = d + 1
        q.append((n_city, d + 1))

# print(dist)
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    dx = abs(dist[c] - dist[d])
    # print(c, d, dx)
    if dx % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
e = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    e[a - 1].append(b - 1)
    e[b - 1].append(a - 1)

q = deque()
dst = [-1] * N
q.append(0)
dst[0] = 0
while q:
    now = q.popleft()
    for nxt in e[now]:
        if dst[nxt] == -1:
            dst[nxt] = dst[now] + 1
            q.append(nxt)

for _ in range(Q):
    c, d = map(int, input().split())
    if (dst[c - 1] + dst[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
def LI():
    return list(map(int, input().split()))


n, q = LI()
edges = [[] * n for _ in range(n)]

for _ in range(n - 1):
    a, b = LI()
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)

Q = [LI() for _ in range(q)]

from collections import deque

val = [-1] * n
q = deque()
q.append(0)
val[0] = 0
while q:
    p = q.popleft()
    now = val[p]
    nxt = 1 - now
    for c in edges[p]:
        if val[c] != -1:
            continue
        val[c] = nxt
        q.append(c)

for c, d in Q:
    c -= 1
    d -= 1
    if val[c] == val[d]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(100000)

N, Q = map(int, input().split())

roads = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    roads[a - 1].append(b - 1)
    roads[b - 1].append(a - 1)

color = [-1] * N
color[0] = 0


def dfs(cur, col):
    for town in roads[cur]:
        if color[town] == -1:
            color[town] = 0 if col else 1
            dfs(town, color[town])


dfs(0, 0)
for i in range(Q):
    c, d = map(int, input().split())
    print("Town" if color[c - 1] == color[d - 1] else "Road")
N, Q = map(int, input().split())
E = {n + 1: [] for n in range(N)}
for i in range(1, N):
    a, b = map(int, input().split())
    E[a] += [b]
    E[b] += [a]
D, P = {1: 0}, [1]
while P:
    p = P.pop(0)
    for d in E[p]:
        if d in D: continue
        D[d] = D[p] + 1
        P += [d]
for _ in range(Q):
    c, d = map(int, input().split())
    print(D[c] % 2 == D[d] % 2 and 'Town' or 'Road')
import sys

# sys.setrecursionlimit(200005)
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep="\n")


def II():
    return int(sys.stdin.readline())


def LI():
    return list(map(int, sys.stdin.readline().split()))


def LLI(rows_number):
    return [LI() for _ in range(rows_number)]


def LI1():
    return list(map(int1, sys.stdin.readline().split()))


def LLI1(rows_number):
    return [LI1() for _ in range(rows_number)]


def SI():
    return sys.stdin.readline().rstrip()


inf = 10**16
md = 10**9 + 7
# md = 998244353


class LCA:
    # 頂点は0～n-1
    def __init__(self, to, root=0):
        self.to = to
        self.n = len(to)
        self.parents = [-1] * (self.n + 1)
        self.depth = [0] * self.n
        self.__dfs(root)
        self.max_level = max(self.depth).bit_length()
        self.ancestor = [self.parents] + [[-1] * (self.n + 1)
                                          for _ in range(self.max_level)]
        row0 = self.ancestor[0]
        for lv in range(self.max_level):
            row1 = self.ancestor[lv + 1]
            for u in range(self.n):
                row1[u] = row0[row0[u]]
            row0 = row1

    def __dfs(self, root):
        stack = [root]
        while stack:
            u = stack.pop()
            pu = self.parents[u]
            du = self.depth[u]
            for v in self.to[u]:
                if v == pu: continue
                self.parents[v] = u
                self.depth[v] = du + 1
                stack.append(v)

    # 最小共通祖先
    def anc(self, u, v):
        diff = self.depth[u] - self.depth[v]
        if diff < 0: u, v = v, u
        diff = abs(diff)
        lv = 0
        while diff:
            if diff & 1: u = self.ancestor[lv][u]
            lv, diff = lv + 1, diff >> 1
        if u == v: return u
        for lv in range(self.depth[u].bit_length() - 1, -1, -1):
            anclv = self.ancestor[lv]
            if anclv[u] != anclv[v]: u, v = anclv[u], anclv[v]
        return self.parents[u]

    def dist(self, u, v):
        w = self.anc(u, v)
        return self.depth[u] + self.depth[v] - self.depth[w] * 2


n, q = LI()
to = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = LI1()
    to[u].append(v)
    to[v].append(u)

lca = LCA(to)
for _ in range(q):
    c, d = LI1()
    cur = lca.dist(c, d)
    print("Road" if cur & 1 else "Town")
def main():
    import sys
    sys.setrecursionlimit(10**7)
    from collections import deque

    def input():
        return sys.stdin.readline()[:-1]

    n, q = map(int, input().split())
    road = [[] for _ in range(n)]

    for i in range(n - 1):
        a, b = map(int, input().split())
        road[a - 1].append(b - 1)
        road[b - 1].append(a - 1)

    d = deque()
    d.append(0)
    dist = [-1] * n
    dist[0] = 0

    while d:
        v = d.popleft()
        for i in road[v]:
            if dist[i] != -1:
                continue
            dist[i] = dist[v] + 1
            d.append(i)

    for i in range(q):
        c, d = map(int, input().split())
        if (dist[c - 1] - dist[d - 1]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
#解説を読んで挑戦
import queue

N, Q = map(int, input().split())
edge = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    edge[a].append(b)
    edge[b].append(a)

#頂点1からの距離の偶奇をBFSで求める

C = [0] * (N + 1)  # 頂点1からの距離の偶奇を求める
checked = [False] * (N + 1)

q = queue.Queue()
q.put(1)

while not (q.empty()):
    u = q.get()
    checked[u] = True
    for v in edge[u]:
        if checked[v] == False:
            C[v] = 1 - C[u] % 2
            q.put(v)

for _ in range(Q):
    c, d = map(int, input().split())
    if C[c] == C[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
chi = [[] for _ in [0] * N]
for _ in [0] * (N - 1):
    a, b = map(int, input().split())
    if b > a: a, b = b, a
    chi[b - 1].append(a)
    chi[a - 1].append(b)
inf = 10**10
d = [inf] * N
q = deque()
q.append(1)
d[0] = 0
while q:
    p = q.popleft()
    for np in chi[p - 1]:
        if d[p - 1] < d[np - 1]:
            d[np - 1] = d[p - 1] + 1
            q.append(np)
for _ in [0] * Q:
    ci, di = map(int, input().split())
    print(['Road', 'Town'][(d[ci - 1] - d[di - 1]) % 2 == 0])
import sys

sys.setrecursionlimit(999999999)

n, q = map(int, input().split())
E = [[] for i in range(n + 1)]
dis = [0 for i in range(n + 1)]


def dfs(u, fa):
    dis[u] = dis[fa] + 1
    for v in E[u]:
        if v == fa:
            continue
        dfs(v, u)


for i in range(1, n):
    x, y = map(int, input().split())
    E[x].append(y)
    E[y].append(x)

dfs(1, 0)

while q:
    q -= 1
    x, y = map(int, input().split())
    print("Road" if (dis[x] + dis[y]) & 1 else "Town")
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for i in range(N - 1)]
cd = [list(map(int, input().split())) for i in range(Q)]
f = [[] for i in range(N)]
for a, b in ab:
    f[a - 1].append(b - 1)
    f[b - 1].append(a - 1)
from collections import deque

d = deque()
d.append(0)
dp = [-1] * N
dp[0] = 0
while d:
    z = d.popleft()
    for i in f[z]:
        if dp[i] == -1:
            dp[i] = dp[z] + 1
            d.append(i)
for c, d in cd:
    if dp[c - 1] % 2 == dp[d - 1] % 2:
        print("Town")
    else:
        print("Road")
(n, q), *t = [map(int, t.split()) for t in open(0)]
d = [1] * n + [0]
s = [n]
e = [[] for _ in d]
for a, b in t[:-q]:
    e[a] += b,
    e[b] += a,
for v in s:
    for w in e[v]:
        s += [w] * d[w]
        d[w] = ~d[v]
for a, b in t[-q:]:
    print('RTooawdn'[d[a] == d[b]::2])
from collections import deque

n, Q = map(int, input().split())
g = [set() for i in range(n)]
for i in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    g[a].add(b)
    g[b].add(a)

depth = [-1] * n
depth[0] = 0
q = deque([0])
while q:
    at = q.pop()
    for i in g[at]:
        if depth[i] == -1:
            depth[i] = depth[at] + 1
            q.append(i)
for i in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print('Road') if abs(depth[c] - depth[d]) % 2 else print('Town')
from collections import deque
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**9)

N, Q = map(int, input().split())
adjL = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    adjL[a].append(b)
    adjL[b].append(a)
cds = [tuple(map(int, input().split())) for _ in range(Q)]


def bfsTree(vRoot):
    depths[vRoot] = 0
    QQQ = deque([vRoot])
    while QQQ:
        vNow = QQQ.popleft()
        vPar = pars[vNow]
        depth2 = depths[vNow] + 1
        for v2 in adjL[vNow]:
            if v2 == vPar: continue
            pars[v2] = vNow
            depths[v2] = depth2
            QQQ.append(v2)


numV = N  ###
vRoot = 0  ###

pars = [-1] * (numV)
depths = [-1] * (numV)

bfsTree(vRoot)

anss = []
for c, d in cds:
    c, d = c - 1, d - 1
    depth1, depth2 = depths[c], depths[d]
    if depth1 % 2 != depth2 % 2:
        anss.append('Road')
    else:
        anss.append('Town')

print('\n'.join(anss))
import bisect, copy, heapq, math, sys
from collections import *
from functools import lru_cache
from itertools import accumulate, combinations, permutations, product


def input():
    return sys.stdin.readline()[:-1]


def ruiseki(lst):
    return [0] + list(accumulate(lst))


def ceil(a, b):
    return -(-a // b)


def create_graph(N, edge):
    g = [[] for i in range(N)]
    for i, j in edge:
        i, j = i - 1, j - 1
        g[i].append(j)
        g[j].append(i)
    return g


sys.setrecursionlimit(5000000)
mod = pow(10, 9) + 7
INF = 1 << 100
al = [chr(ord('a') + i) for i in range(26)]
direction = [[1, 0], [0, 1], [-1, 0], [0, -1]]

n, q = map(int, input().split())
ab = [list(map(int, input().split())) for i in range(n - 1)]
cd = [list(map(int, input().split())) for i in range(q)]

g = create_graph(n, ab)

# print(g)


# O(E+Vlog(V))
def dijkstra(s):
    hq = [(0, s)]
    heapq.heapify(hq)  # リストを優先度付きキューに変換
    cost = [float('inf')] * n  # 行ったことのないところはinf
    cost[s] = 0  # 開始地点は0
    while hq:
        c, v = heapq.heappop(hq)
        if c > cost[v]:  # コストが現在のコストよりも高ければスルー
            continue
        for d, u in e[v]:
            tmp = d + cost[v]
            if tmp < cost[u]:
                cost[u] = tmp
                heapq.heappush(hq, (tmp, u))
    return cost


n, m = n, n - 1
e = [[] for _ in range(n)]
for _ in range(m):
    a, b = ab[_]
    a, b = a - 1, b - 1
    e[a].append((1, b))
    e[b].append((1, a))

ans = 0
for i in range(n):
    if len(g[i]) == 1:
        ans = dijkstra(i)
        break
# print(ans)

for i in range(q):
    c, d = cd[i]
    c, d = c - 1, d - 1
    if abs(ans[c] - ans[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
from collections import deque

n, q = map(int, input().split())
graph = [[] for _ in range(n + 1)]

for x in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1: continue
        dist[i] = dist[v] + 1
        d.append(i)

for x in range(q):
    c, d = map(int, input().split())
    if (dist[c] + dist[d]) % 2 == 0: print('Town')
    else: print('Road')
import sys

input = sys.stdin.readline

N, Q = map(int, input().split())

edge = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    edge[a].append(b)
    edge[b].append(a)
INF = 1 << 63
dist = [INF] * N
dist[0] = 0
visit = [0] * N
# 街0から奇数で到達できる街を1とする
q = [0]
while q:
    i = q.pop()
    if visit[i]: continue
    visit[i] = 1
    for to in edge[i]:
        dist[to] = min(dist[to], dist[i] + 1)
        q.append(to)
# print(dist)
# print(visit)
for i in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = lambda: sys.stdin.readline()[:-1]
ni = lambda: int(input())
na = lambda: list(map(int, input().split()))
sys.setrecursionlimit(10**7)
yes = lambda: print("yes")
Yes = lambda: print("Yes")
no = lambda: print("no")
No = lambda: print("No")
#######################################################################

n, q = na()
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = na()
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

d = [0]
dp = [-1 for i in range(n)]
dp[0] = 0
while d:
    e = d.pop()
    for i in g[e]:
        if dp[i] == -1:
            dp[i] = dp[e] ^ 1
            d.append(i)

for i in range(q):
    c, d = na()
    c -= 1
    d -= 1
    if dp[c] ^ dp[d]:
        print("Road")
    else:
        print("Town")
from collections import deque


def main():
    [N, Q] = [int(x) for x in input().split()]

    # グラフの初期化
    graph = [[] for _ in range(N + 1)]
    for _ in range(N - 1):
        [a, b] = [int(x) for x in input().split()]
        graph[a].append(b)
        graph[b].append(a)

    # 深さを記録するリスト
    depth_vec = [-1 for _ in range(N + 1)]

    # 1を根とする根付き木を作り、各頂点の深さを記録する
    queue = deque()
    queue.append((1, 0))
    while len(queue) > 0:
        (node, depth) = queue.pop()
        depth_vec[node] = depth
        for child in graph[node]:
            if depth_vec[child] >= 0:
                continue
            queue.append((child, depth + 1))

    # クエリに解答する
    for query in range(Q):
        [c, d] = [int(x) for x in input().split()]
        if (depth_vec[c] + depth_vec[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
n, q = map(int, input().split())
g = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)
from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * (n + 1)  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


answer = [0] * (n + 1)
b = bfs(1)
for i in range(1, len(b)):
    if b[i] % 2 == 0:
        answer[i] = True
    else:
        answer[i] = False

for i in range(q):
    c, d = map(int, input().split())
    if answer[c] == answer[d]:
        print('Town')
    else:
        print('Road')
class segtree:
    """
    Segment tree
    Store value as object type and optional function for binary operarion.
    "get" function return a value by binary operarion result. O(logN)
    "update" function update tree's a value. O(logN)

    Attributes
    ----------
    n : int
        Number of elements
    identity element_func : func
        identity_element for initialization
        if operator is * and identiry element is e, e * A = A and A * e = A
    binary_operation_func : func
        function for binary operation x and y
        function must have associative law
        if operator is *, (A * B) * C = A * (B * C)

    Methods
    -------
    update(i, x)
        update tree[i] value to x
    get(a, b)
        get value from [a, b)
        include a but not include b, return a merged value
    """
    def __init__(self, n: int, identity_element_func, binary_operation_func):
        """
        Constructer(Initialize parameter in this class)

        Parameters
        ----------
        n : int
            Number of elements
        identity_element_func : func
            identity element for initialization
            if operator is * and identiry element is e, e * A = A and A * e = A
        binary_operation_func : func
            function for binary operation x and y
            function must have associative law
            if operator is *, (A * B) * C = A * (B * C)
        """
        self.n = n
        self.identity = identity_element_func
        self.binary = binary_operation_func
        n2 = 1  # n2はnより大きい2の冪数
        while n2 < n:
            n2 <<= 1
        self.n2 = n2
        self.tree = [identity_element_func() for _ in range(n2 << 1)]

    def update(self, index: int, x: int):
        """
        Update segment-tree's a value and update segment-tree's tree

        Parameters
        ----------
        index : int
            index of update value
        x : int
            new value
        """
        index += self.n2
        self.tree[index] = self.binary(self.tree[index], x)
        while index > 1:
            # (index ^ 1) はiと1の排他的論理和(XOR)
            x = self.binary(x, self.tree[index ^ 1])
            index >>= 1  # 右ビットシフトで親ノードのインデックスへ移動
            self.tree[index] = self.binary(self.tree[index], x)

    def get(self, a: int, b: int) -> int:
        """
        Get a specific value by result of binary operation from interval [a, b)

        Parameters
        ----------
        a, b : int
            index of interval
            this is hald open interval, this interval include a but not b
        """
        result = self.identity()
        q = [(1, 0, self.n2)]
        while q:
            k, left, right = q.pop()
            if a <= left and right <= b:
                result = self.binary(result, self.tree[k])
                continue
            m = (left + right) // 2
            k <<= 1
            if a < m and left < b:
                q.append((k, left, m))
            if a < right and left < m:
                q.append((k + 1, m, right))
        return result


N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    edge[x].append(y)
    edge[y].append(x)  # 有向グラフならこの行は消す!!
INF = 10**18

height_tour = segtree(N * 2, lambda: INF, min)
first_seen_i_on_tour = [-1] * N

cnt = 0
queue = [(0, 0)]
while queue:
    now, depth = queue.pop()
    if first_seen_i_on_tour[now] != -1:
        continue
    cnt += 1
    first_seen_i_on_tour[now] = cnt
    height_tour.update(cnt, depth)
    for n_node in edge[now]:
        if first_seen_i_on_tour[n_node] != -1:
            continue
        queue.append((n_node, depth + 1))
    cnt += 1

for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    left, right = sorted([first_seen_i_on_tour[c], first_seen_i_on_tour[d]])
    lca = height_tour.get(left, right)
    ans = (height_tour.get(left, left + 1) +
           height_tour.get(right, right + 1) -
           2 * height_tour.get(lca, lca + 1))
    if ans % 2:
        print("Road")
    else:
        print("Town")
from sys import setrecursionlimit

setrecursionlimit(10**6)


def dfs(now, prev, d):
    depth[now] = d
    for nxt in edge[now]:
        if nxt != prev and depth[nxt] == -1:
            dfs(nxt, now, d + 1)


N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)

depth = [-1] * N
dfs(0, -1, 0)

res = []
for _ in range(Q):
    c, d = map(int, input().split())
    if (depth[c - 1] + depth[d - 1]) % 2 == 0:
        res.append('Town')
    else:
        res.append('Road')

print(*res, sep='\n')
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for i in range(N - 1)]
cd = [list(map(int, input().split())) for i in range(Q)]
data = [[] for i in range(N + 1)]
for i in range(N - 1):
    a = ab[i][0]
    b = ab[i][1]
    data[a].append(b)
    data[b].append(a)
dis1 = [-1] * (N + 1)
dis1[1] = 0
deque = [1]
while deque:
    x = deque.pop(0)
    for i in data[x]:
        if dis1[i] == -1:
            dis1[i] = dis1[x] + 1
            deque.append(i)
for i in range(Q):
    p = dis1[cd[i][0]] - dis1[cd[i][1]]
    if p % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
color = [-1] * N
color[0] = 0
d = deque([0])
while d:
    v = d.pop()
    for n in G[v]:
        if color[n] == -1:
            color[n] = 1 - color[v]
            d.append(n)
for _ in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
MOD = 10**9 + 7
INF = float('inf')
AZ = "abcdefghijklmnopqrstuvwxyz"

#############
# Functions #
#############


######INPUT######
def I(t):
    return t(input().strip())


def IM(t):
    return map(t, input().split())


def IL(t):
    return list(map(t, input().split()))


def ILs(t, n):
    return list(t(input()) for _ in range(n))


def ILL(t, n):
    return [list(map(t, input().split())) for _ in range(n)]


n, q = IM(int)
e = [INF for _ in range(n)]
e[0] = 0
edge = [[] for i in range(n)]

for i in range(n - 1):
    a, b = IM(int)
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)

s = [0]
while s:
    t = s.pop(0)
    for i in edge[t]:
        if e[i] == INF:
            e[i] = e[t] + 1
            s.append(i)

for i in range(q):
    c, d = IM(int)
    if (e[c - 1] % 2) == (e[d - 1] % 2):
        print('Town')
    else:
        print('Road')
from collections import defaultdict, deque


def solve(N, graph):
    # BFS
    queue = deque()
    for key, value in graph.items():
        if len(value) == 1:
            queue.append((key, BLUE))
            break
    while queue:
        size = len(queue)
        for i in range(size):
            curNode, color = queue.popleft()
            colorTable[curNode] = color
            for nei in graph[curNode]:
                graph[nei].remove(curNode)
                queue.append((nei, -color))


BLUE, RED = 1, -1
N, Q = map(int, input().split())

# Build graph
graph = defaultdict(list)
queries = []
for i in range(N - 1):
    A, B = map(int, input().split())
    graph[A].append(B)
    graph[B].append(A)

# Build color table
colorTable = [None] * (N + 1)
solve(N, graph)

# Return value
for i in range(Q):
    C, D = map(int, input().split())
    if colorTable[C] == colorTable[D]:
        print("Town")
    else:
        print("Road")
# https://raw.githubusercontent.com/cheran-senthil/PyRival/master/pyrival/data_structures/RangeQuery.py
class RangeQuery:
    def __init__(self, data, func=min):
        self.func = func
        self._data = _data = [list(data)]
        i, n = 1, len(_data[0])
        while 2 * i <= n:
            prev = _data[-1]
            _data.append(
                [func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])
            i <<= 1

    def query(self, start, stop):
        """func of data[start, stop)"""
        assert start < stop
        depth = (stop - start).bit_length() - 1
        return self.func(self._data[depth][start],
                         self._data[depth][stop - (1 << depth)])

    def __getitem__(self, idx):
        return self._data[0][idx]


class LCA:
    def __init__(self, graph, root):
        # O(N * log(N))
        N = len(graph)
        self.graph = graph
        self.root = root

        self.parent = [-1] * N
        self.depth = [-1] * N
        self.eulerTour = []  # length is 2 * (N - 1) + 1
        self.timeIn = [-1] * N  # timeIn[node] == eulerTour.index(node)
        self.timeOut = [-1] * N  # timeOut[node] == eulerTour.rindex(node)

        t = 0
        stack = [root]
        self.depth[root] = 0
        self.parent[root] = -1
        while stack:
            node = stack.pop()
            self.eulerTour.append(node)
            if self.timeIn[node] == -1:
                self.timeIn[node] = t
                for child in reversed(graph[node]):
                    if self.timeIn[child] == -1:
                        self.depth[child] = self.depth[node] + 1
                        self.parent[child] = node
                        stack.append(node)
                        stack.append(child)
            self.timeOut[node] = t
            t += 1
            # assert len(self.eulerTour) == t

        self.rmq = RangeQuery(self.timeIn[node] for node in self.eulerTour)

    def lca(self, u, v):
        # O(1)
        # Might also want to prevent inlining, see https://foss.heptapod.net/pypy/pypy/-/issues/1822#note_41573
        # for _ in range(1): pass
        a = self.timeIn[u]
        b = self.timeIn[v]
        if a > b:
            a, b = b, a
        return self.eulerTour[self.rmq.query(a, b + 1)]

    def isAncestor(self, u, v):
        # O(1)
        return self.timeIn[u] <= self.timeIn[v] and self.timeOut[
            v] <= self.timeOut[u]

    def getDist(self, u, v):
        # O(1)
        return self.depth[u] + self.depth[v] - 2 * self.depth[self.lca(u, v)]

    def isPath(self, a, b, c):
        # O(1)
        # Returns whether b is on the path between a and c
        return self.getDist(a, b) + self.getDist(b, c) == self.getDist(a, c)

    def getPath(self, u, v):
        # O(N)
        anc = self.lca(u, v)
        uPath = [u]
        while uPath[-1] != anc:
            uPath.append(self.parent[uPath[-1]])
        vPath = [v]
        while vPath[-1] != anc:
            vPath.append(self.parent[vPath[-1]])
        assert uPath[-1] == vPath[-1]
        uPath.pop()
        return uPath + vPath[::-1]

    def getSubTreeCount(self, u, p=None):
        # O(1)
        # Get the size of the subtree where u is the root with p as the parent
        # Note: p == None here means optional arg
        if p is None or p == self.parent[u]:
            numEdges = (self.timeOut[u] - self.timeIn[u]) // 2
            return numEdges + 1
        return len(self.graph) - self.getSubTreeCount(p)


N, Q = [int(x) for x in input().split()]
AB = [[int(x) - 1 for x in input().split()] for i in range(N - 1)]
CD = [[int(x) - 1 for x in input().split()] for i in range(Q)]

graph = [[] for i in range(N)]
for u, v in AB:
    graph[u].append(v)
    graph[v].append(u)

rootedTree = LCA(graph, 0)

for u, v in CD:
    d = rootedTree.getDist(u, v)
    if d % 2 == 1:
        print("Road")
    else:
        print("Town")
import queue
from collections import defaultdict as dd

N, Q = map(int, input().split())
ab = [map(int, input().split()) for _ in range(N - 1)]
cd = [map(int, input().split()) for _ in range(Q)]

tree = dd(set)
eo = [0] * N

for a, b in ab:
    tree[a - 1].add(b - 1)
    tree[b - 1].add(a - 1)

# DFS
q = queue.Queue()
q.put(0)
eo[0] = 1
while not q.empty():
    now = q.get()
    for i, nxt in enumerate(tree[now]):
        if eo[nxt] == 0:
            q.put(nxt)
            eo[nxt] = (eo[now]) % 2 + 1

for c, d in cd:
    if (eo[c - 1] + eo[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque
import sys

input = sys.stdin.readline


class Node(object):
    def __init__(self, index, nears):
        self.index = index
        self.nears = nears
        self.visit = -1


def main():
    n, q = map(int, input().split())
    g = [[] for _ in range(n)]

    for _ in range(n - 1):
        a, b = map(int, input().split())
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)

    nodes = []
    for i in range(n):
        nodes.append(Node(i, g[i]))

    queue = deque()
    queue.append(nodes[0])
    nodes[0].visit = 0

    while queue:
        node = queue.popleft()
        nears = node.nears
        x = node.visit + 1
        for near in nears:
            if nodes[near].visit == -1:
                nodes[near].visit = x
                queue.append(nodes[near])

    for _ in range(q):
        c, d = map(int, input().split())

        if nodes[c - 1].visit % 2 == nodes[d - 1].visit % 2:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
import sys
import copy

sys.setrecursionlimit(10000000)
import math
import bisect
from collections import deque


def input():
    return sys.stdin.readline()[:-1]


N, Q = map(int, input().split())
g = [[] for i in range(N)]
C = []
D = []
tmp = [2 for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a = a - 1
    b = b - 1
    g[a].append(b)
    g[b].append(a)

for i in range(Q):
    c, d = map(int, input().split())
    C.append(c - 1)
    D.append(d - 1)

que = deque([[0, 0]])
dist = [-1 for i in range(N)]
num = 0
dist[0] = 0
while que:
    tmp = que.popleft()
    jud = 0
    for i in g[tmp[0]]:
        if dist[i] == -1:
            dist[i] = tmp[1] + 1
            que.append([i, dist[i]])

#print(dist)

for i in range(Q):
    one = dist[C[i]]
    two = dist[D[i]]
    if abs(one - two) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
import numpy as np


def tocsr(n, E):
    E -= 1
    m = E.shape[0]
    E = np.vstack((E, E))
    E[m:, 0] = E[:m, 1]
    E[m:, 1] = E[:m, 0]
    m = E.shape[0]
    indices, indptr = np.empty(m, np.int64), np.zeros(n + 1, np.int64)
    for e in E[:, 0]:
        indptr[e + 1] += 1
    indptr = indptr.cumsum()
    cnt = indptr.copy()
    for i in range(m):
        e0, e1 = E[i]
        indices[cnt[e0]] = e1
        cnt[e0] += 1
    return indices, indptr


def solve(E, Q):
    Q -= 1
    n = E.shape[0] + 1
    indices, indptr = tocsr(n, E)
    dist = np.full(n, -1, np.int64)
    q = np.empty(2 * n, np.int64)
    head, tail = 0, 1
    q[0] = 0
    while head < tail:
        x = q[head]
        head += 1
        for i in range(indptr[x], indptr[x + 1]):
            y = indices[i]
            if dist[y] >= 0: continue
            dist[y] = dist[x] + 1
            q[tail] = y
            tail += 1
    q = Q.shape[0]
    ans = np.empty(q, np.bool_)
    for i in range(q):
        c, d = Q[i]
        ans[i] = (dist[c] - dist[d]) % 2 == 0
    return ans


def main():
    n, q = map(int, input().split())
    IN = np.fromstring(sys.stdin.read(), np.int64, sep=' ').reshape(-1, 2)
    E = IN[:n - 1]
    Q = IN[n - 1:]
    ans = np.where(solve(E, Q), 'Town', 'Road')
    print('\n'.join(ans.tolist()))


if __name__ == '__main__':
    if sys.argv[-1] == 'ONLINE_JUDGE':
        from numba.pycc import CC
        from numba import njit
        cc = CC('my_module')
        funcs_and_sigs = [('tocsr', 'UniTuple(i8[:], 2)(i8, i8[:,:])'),
                          ('solve', 'b1[:](i8[:,:], i8[:,:])')]
        d = globals()
        for fname, sig in funcs_and_sigs:
            func = d[fname]
            cc.export(func.__name__, sig)(func)
            d[fname] = njit(func)
        cc.compile()
        exit()
    from my_module import *
    main()
import sys
import heapq


def dijkstra(graph, start, n):
    INF = 10**18
    hq = [(start, 0)]
    heapq.heapify(hq)
    cost = [INF] * n
    cost[start] = 0
    while hq:
        v, c = heapq.heappop(hq)
        if c > cost[v]:  #更新なし
            continue
        for idx, d in graph[v]:
            if d + cost[v] < cost[idx]:
                cost[idx] = d + cost[v]
                heapq.heappush(hq, (idx, d + cost[v]))

    return cost


def main():
    n, q = map(int, input().split())
    city = [[] for _ in range(n)]

    for _ in range(n - 1):
        a, b = map(int, input().split())
        city[a - 1].append((b - 1, 1))
        city[b - 1].append((a - 1, 1))

    dist_start = dijkstra(city, 0, n)

    for i in range(q):
        c, d = map(int, input().split())
        dist_c = dist_start[c - 1]
        dist_d = dist_start[d - 1]

        if (dist_c + dist_d) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
from collections import deque


def bfs():
    cities_to_go = deque()
    cities_to_go.append(0)
    # 0 distance to the start point
    distances[0] = 0

    while len(cities_to_go) > 0:
        city_to_go = cities_to_go.popleft()
        for next_city in routes[city_to_go]:
            if distances[next_city] == -1:
                cities_to_go.append(next_city)
                distances[next_city] = distances[city_to_go] + 1


n, q = map(int, input().split())
routes = [[] for _ in range(n)]
# create routes
for _ in range(n - 1):
    a, b = map(int, input().split())
    routes[a - 1].append(b - 1)
    routes[b - 1].append(a - 1)
# calculate all distances from city 0
distances = [-1] * n
bfs()
# print based on query
for _ in range(q):
    c, d = map(int, input().split())
    if (distances[c - 1] - distances[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
def construct(prv):
    kprv = [prv]
    S = prv
    for k in range(lv):
        T = [0] * n
        for i in range(n):
            if S[i] is None:
                continue
            T[i] = S[S[i]]
        kprv.append(T)
        S = T
    return kprv


def lca(u, v, kprv, depth):
    dd = depth[v] - depth[u]
    if dd < 0:
        u, v = v, u
        dd = -dd

    # assert depth[u] <= depth[v]
    for k in range(lv + 1):
        if dd & 1:
            v = kprv[k][v]
        dd >>= 1

    # assert depth[u] == depth[v]
    if u == v:
        return u

    for k in range(lv - 1, -1, -1):
        pu = kprv[k][u]
        pv = kprv[k][v]
        if pu != pv:
            u = pu
            v = pv

    # assert kprv[0][u] == kprv[0][v]
    return kprv[0][u]


def distance(u, v, kprv, depth):
    return depth[u] + depth[v] - 2 * depth[lca(u, v, kprv, depth)]


n, q = map(int, input().split())
m = [[] for _ in [0] * n]  # 近傍
for _ in [0] * (n - 1):
    a, b = map(int, input().split())
    m[a - 1] += [b - 1]
    m[b - 1] += [a - 1]
depth = [0] * n
prv = [-1] * n  # 親
c = [[] for _ in [0] * n]  # 子供
prv[0] = (1 << 63)  # 根が 0
l = [0]  # 根が 0
order = [0] * n  # 深さ優先探索での順番
o = 0
while l:
    v = l.pop()
    order[v] = o
    o += 1
    for u in m[v]:
        if prv[u] < 0:
            prv[u] = v
            c[v] += [u]
            depth[u] = depth[v] + 1
            l += [u]
prv[0] = None
lv = (n - 1).bit_length()
kprv = construct(prv)
for _ in range(q):
    u, v = map(int, input().split())
    if distance(u - 1, v - 1, kprv, depth) % 2:
        print('Road')
    else:
        print('Town')
from collections import deque
from sys import stderr

INF = 1 << 60

N, Q = map(int, input().split())
edges = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    edges[a].append(b)
    edges[b].append(a)

depth = [INF] * (N + 1)
depth[1] = 0

s = deque([1])
while s:
    p = s.pop()
    for n in edges[p]:
        if depth[n] > depth[p] + 1:
            depth[n] = depth[p] + 1
            s.append(n)

for _ in range(Q):
    c, d = map(int, input().split())
    print("Road" if (depth[c] + depth[d]) % 2 else "Town", flush=False)
import sys

read = sys.stdin.buffer.read

n, q, *data = map(int, read().split())
ab = data[:(n - 1) * 2]
cd = data[(n - 1) * 2:]

links = [[] for _ in range(n)]
it = iter(ab)
for a, b in zip(it, it):
    a -= 1
    b -= 1
    links[a].append(b)
    links[b].append(a)

depth = [-1] * n
depth[0] = 0
stack = [0]
while stack:
    i = stack.pop()
    for j in links[i]:
        if depth[j] != -1:
            continue
        depth[j] = depth[i] + 1
        stack.append(j)

ans = []
it = iter(cd)
for c, d in zip(it, it):
    c -= 1
    d -= 1
    if (depth[c] + depth[d]) % 2 == 0:
        ans.append('Town')
    else:
        ans.append('Road')
print('\n'.join(ans))
import sys
import numpy as np
from numba import njit, i8

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines


def from_read(dtype=np.int64):
    return np.fromstring(read().decode(), dtype=dtype, sep=' ')


def from_readline(dtype=np.int64):
    return np.fromstring(readline().decode(), dtype=dtype, sep=' ')


def to_undirected(E, edge):
    G = np.vstack((E, E))
    G[edge:, 0] = G[:edge, 1]
    G[edge:, 1] = G[:edge, 0]
    key = G[:, 0] << 32 | G[:, 1]
    idx = np.argsort(key, kind="mergesort")
    return G[idx]


@njit
def euler_tour(N, G, root=1):
    assert len(G) == N + N - 2
    id = np.searchsorted(G[:, 0], np.arange(N + 2))
    parent = np.zeros(N + 1, np.int64)
    depth = np.zeros(N + 1, np.int64)
    stack, s = np.zeros(N + N, np.int64), 0
    stack[s], s = -root, s + 1
    stack[s], s = root, s + 1
    for i in range(N + N):
        v, s = stack[s - 1], s - 1
        if v < 0:
            continue
        for e in range(id[v + 1] - 1, id[v] - 1, -1):
            _, w = G[e, :2]
            if w == parent[v]: continue
            stack[s], s = -w, s + 1
            stack[s], s = w, s + 1
            parent[w] = v
            depth[w] = depth[v] + 1
    return parent, depth


@njit((i8, i8, i8[:, :], i8[:, :]), cache=True)
def solve(N, Q, G, query):
    parent, depth = euler_tour(N, G)
    doubling = np.zeros((20, N + 1), np.int64)
    doubling[0] = parent
    for i in range(20 - 1):
        for j in range(1, N + 1):
            doubling[i + 1, j] = doubling[i, doubling[i, j]]
    res = np.zeros(Q, np.int8)
    for q in range(Q):
        c, d = query[q]
        if depth[c] > depth[d]:
            c, d = d, c
        d1 = depth[c]
        d2 = depth[d]
        dd = d2 - d1
        for i in range(20):
            if (dd >> i) == 0: break
            if (dd >> i) & 1:
                d = doubling[i, d]
        if c == d:
            lca = c
        else:
            for i in range(20 - 1, -1, -1):
                if doubling[i, c] != doubling[i, d]:
                    c = doubling[i, c]
                    d = doubling[i, d]
            lca = parent[c]
        dist = d1 + d2 - 2 * depth[lca]
        if dist % 2 == 1: res[q] |= 1
    return res


def main():
    N, Q = from_readline()
    X = from_read()
    E = X[:N + N - 2].reshape(N - 1, 2)
    G = to_undirected(E, N - 1)
    query = X[N + N - 2:].reshape(Q, 2)
    res = solve(N, Q, G, query)
    for q in range(Q):
        if res[q]:
            print("Road")
        else:
            print("Town")


if __name__ == "__main__":
    main()
import sys

sys.setrecursionlimit(500000)
n, q = map(int, input().split())
adj = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)
c = [0] * q
d = [0] * q
for i in range(q):
    c[i], d[i] = map(int, input().split())
    c[i] -= 1
    d[i] -= 1
INF = 10**63
depth = [INF] * n
depth[0] = 0


def dfs(v):
    for w in adj[v]:
        if depth[w] == INF:
            depth[w] = depth[v] + 1
            dfs(w)


dfs(0)
for i in range(q):
    ans = depth[c[i]] - depth[d[i]]
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
from collections import deque

graph = [[] for _ in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)
while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for _ in range(q):
    c, d = map(int, input().split())
    if dist[c] % 2 == dist[d] % 2:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
g = [[] for _ in range(n)]
s = [-1 for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

queue = deque([[0, 0]])
while queue:
    now = queue.popleft()
    nowi = now[0]
    nows = now[1]
    s[nowi] = nows
    for i in g[nowi]:
        if (s[i] == -1):
            queue.append([i, (nows + 1) % 2])

for i in range(q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if (s[a] == s[b]):
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

# キューを使用
que = queue.Queue()
color = [-1] * N

# 先頭を0に固定
color[0] = 0
que.put(0)

# 各街を2色に塗る
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

# 色が同じならばTown, そうでないならRoadを出力
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    graph[a].append(b)
    graph[b].append(a)


# graph and n is necessary
def dfs(start):
    par = [-1] * n
    depth = [-1] * n
    euler = []
    stack = []
    stack.append(start)
    depth[start] = 0
    while stack:
        v = stack.pop()
        euler.append(v)
        d = depth[v]
        for u in graph[v]:
            if par[v] == u:
                continue
            par[u] = v
            depth[u] = d + 1
            stack.append(u)
    return par, depth


par, depth = dfs(0)
num = n.bit_length() + 1
doubling = [[-1] * (num) for _ in range(n)]

for i in range(n):
    doubling[i][0] = par[i]

for d in range(num - 1):
    nd = d + 1
    for i in range(n):
        if doubling[i][d] == -1:
            doubling[i][nd] = -1
        else:
            doubling[i][nd] = doubling[doubling[i][d]][d]


def query(a, b):
    def soroeru(a, b):
        if depth[a] == depth[b]:
            return a, b
        elif depth[a] < depth[b]:
            a, b = b, a
        delta = depth[a] - depth[b]
        assert delta > 0
        now = a
        for i in range(num):
            if (delta >> i) & 1:
                now = doubling[now][i]
        assert depth[now] == depth[b]
        return now, b

    a, b = soroeru(a, b)
    if a == b:
        return a
    for i in range(num)[::-1]:
        if doubling[a][i] != doubling[b][i]:
            a = doubling[a][i]
            b = doubling[b][i]
    return doubling[a][0]


for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    cc = query(c, d)
    dist = depth[d] + depth[c] - 2 * depth[cc]
    if dist % 2:
        print("Road")
    else:
        print("Town")
N, Q = map(int, input().split())
roads = [[] for _ in range(N + 1)]
queries = []

for _ in range(N - 1):
    a, b = map(int, input().split())
    roads[a].append(b)
    roads[b].append(a)

for _ in range(Q):
    queries.append(tuple(map(int, input().split())))

binary_map = [0 for _ in range(N + 1)]
visited = [False for _ in range(N + 1)]
visited[1] = True
stack = [1]

while len(stack) > 0:
    begin = stack.pop()
    for end in roads[begin]:
        if visited[end]:
            continue
        visited[end] = True
        binary_map[end] = binary_map[begin] ^ 1
        stack.append(end)

for c, d in queries:
    if binary_map[c] == binary_map[d]:
        print("Town")
    else:
        print("Road")
import sys, os, io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
from bisect import bisect_left, bisect_right
import math

alphabets = list('abcdefghijklmnopqrstuvwxyz')

#for deep recursion__________________________________________-
from types import GeneratorType


def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    c = dict(Counter(l))
    return list(set(l))
    # return c


def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1  # y = y/2
        x = (x * x) % p
    return res


#____________________GetPrimeFactors in log(n)________________________________________
def sieveForSmallestPrimeFactor():
    MAXN = 100001
    spf = [0 for i in range(MAXN)]
    spf[1] = 1
    for i in range(2, MAXN):
        spf[i] = i
    for i in range(4, MAXN, 2):
        spf[i] = 2
    for i in range(3, math.ceil(math.sqrt(MAXN))):
        if (spf[i] == i):
            for j in range(i * i, MAXN, i):
                if (spf[j] == j):
                    spf[j] = i
    return spf


def getPrimeFactorizationLOGN(x):
    spf = sieveForSmallestPrimeFactor()
    ret = list()
    while (x != 1):
        ret.append(spf[x])
        x = x // spf[x]
    return ret


#____________________________________________________________


def SieveOfEratosthenes(n):
    #time complexity = nlog(log(n))
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    return prime


def si():
    return input()


def divideCeil(n, x):
    if (n % x == 0):
        return n // x
    return n // x + 1


def ii():
    return int(input())


def li():
    return list(map(int, input().split()))


#__________________________TEMPLATE__________________OVER_______________________________________________________

if (os.path.exists('input.txt')):
    sys.stdin = open("input.txt", "r")
    sys.stdout = open("output.txt", "w")
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline


class RangeQuery:
    def __init__(self, data, func=min):
        self.func = func
        self._data = _data = [list(data)]
        i, n = 1, len(_data[0])
        while 2 * i <= n:
            prev = _data[-1]
            _data.append(
                [func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])
            i <<= 1

    def query(self, begin, end):
        depth = (end - begin).bit_length() - 1
        return self.func(self._data[depth][begin],
                         self._data[depth][end - (1 << depth)])


class LCA:
    def __init__(self, root, graph):
        self.time = [-1] * len(graph)
        self.path = [-1] * len(graph)
        P = [-1] * len(graph)
        t = -1
        dfs = [root]
        while dfs:
            node = dfs.pop()
            self.path[t] = P[node]
            self.time[node] = t = t + 1
            for nei in graph[node]:
                if self.time[nei] == -1:
                    P[nei] = node
                    dfs.append(nei)
        self.rmq = RangeQuery(self.time[node] for node in self.path)

    def __call__(self, a, b):
        if a == b:
            return a
        a = self.time[a]
        b = self.time[b]
        if a > b:
            a, b = b, a
        return self.path[self.rmq.query(a, b)]


n, qq = li()
graph = [[] for i in range(n)]
for i in range(n - 1):
    a, b = li()
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

lca = LCA(0, graph)

dis = [0] * n
q = [0]
vis = [False] * n
vis[0] = True
while q:
    node = q.pop(0)
    for kid in graph[node]:
        if vis[kid] == False:
            vis[kid] = True
            dis[kid] = 1 + dis[node]
            q.append(kid)
for i in range(qq):
    a, b = li()
    a -= 1
    b -= 1
    commonNode = lca.__call__(a, b)
    d = dis[a] + dis[b] - 2 * dis[commonNode]
    # print(d)
    if d % 2 == 1:
        print('Road')
    else:
        print("Town")
from collections import defaultdict

n, q = list(map(int, input().split()))
d = defaultdict(set)
dc = dict()
for i in range(n - 1):
    ai, bi = list(map(int, input().split()))
    d[ai].add(bi)
    d[bi].add(ai)

toexplore = [(1, 0)]

for t in toexplore:
    x, i = t
    if x in dc:
        continue
    dc[x] = i
    toexplore += [(y, 1 - i) for y in d[x]]

for i in range(q):
    ci, di = list(map(int, input().split()))
    if dc[ci] != dc[di]:
        print('Road')
    else:
        print('Town')
# クエリでない入力部分の前処理
N, Q = list(map(int, input().split()))
# 隣接リスト(A)を作成
A = [[] * 1 for _ in range(N)]
for i in range(N - 1):
    a, b = list(map(int, input().split()))
    A[a - 1].append(b - 1)
    A[b - 1].append(a - 1)
# 基準点からの通過辺数の偶奇で各点を分類
P = [None] * N  # 各点の基準点からの通過辺数の偶奇のリスト
e = 0  # 基準点からの通過辺数の偶奇
F = [0]  # 考察対象の点のリスト(初期値は基準点)
for i in range(N):
    F_n = []  # 次回ループでのF
    for p in F:
        P[p] = e
        F_n.extend(A[p])
    F = [j for j in F_n if P[j] == None]
    e = 1 - e

# クエリの処理
for i in range(Q):
    c, d = list(map(int, input().split()))
    if P[c - 1] == P[d - 1]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
ed = [list() for i in range(n)]
for i in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    ed[a].append(b)
    ed[b].append(a)


def BFS(edge, s):
    from collections import deque

    dist = [-1] * n
    dist[s] = 0

    q = deque()
    q.append(s)

    while q:
        v = q.popleft()
        for i in edge[v]:
            if dist[i] != -1:
                continue
            dist[i] = dist[v] + 1
            q.append(i)

    return dist


ds = BFS(ed, 0)
for i in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if abs(ds[c] - ds[d]) % 2:
        print("Road")
    else:
        print("Town")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
que.put(0)
color = [-1] * N
color[0] = 0
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print('Town')
    else:
        print('Road')
#n = int(input())
#s = input()
n, q = map(int, input().split())
# = list(map(int, input().split()))
#ab = [list(map(int, input().split())) for _ in range(n-1)]

from collections import deque

graph = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

ans = dist[1:]
#print(ans)

cd = [list(map(int, input().split())) for _ in range(q)]

for i in range(q):
    c = cd[i][0] - 1

    d = cd[i][1] - 1
    if ans[c] % 2 == ans[d] % 2:
        print('Town')
    else:
        print('Road')
from collections import defaultdict
from collections import deque

N, Q = list(map(int, input().split()))
G = defaultdict(lambda: [])

for i in range(N - 1):
    a, b = list(map(int, input().split()))
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

# G[v]: 頂点vに隣接する頂点list
# N: 頂点数

dist = [-1] * N
que = deque([0])
dist[0] = 0
while que:
    v = que.popleft()
    d = dist[v]
    for w in G[v]:
        if dist[w] > -1:
            continue
        dist[w] = d + 1
        que.append(w)

for _ in range(Q):
    c, d = list(map(int, input().split()))
    if dist[c - 1] % 2 == dist[d - 1] % 2:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
graph = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (N + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    diff = dist[c] - dist[d]
    if diff % 2 == 0:
        print("Town")
    else:
        print("Road")
###input()が遅いのでそれの対策
import sys
from collections import deque


def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


###input()対策終わり
N, Q = LI()
road = []
for i in range(N - 1):
    road.append(LI())
query = []
for i in range(Q):
    query.append(LI())


##########
def bfs(graph, start):
    arrive = [-1 for _ in range(N + 1)]
    stack = deque()
    stack.append(start)
    arrive[start] = 0
    while stack:
        target = stack.popleft()
        for i in graph[target]:
            if arrive[i] != -1:
                continue
            else:
                arrive[i] = arrive[target] + 1
                stack.append(i)
    return arrive


graph = [deque([]) for _ in range(N + 1)]

for i in range(N - 1):
    s, g = road[i]
    graph[g].append(s)
    graph[s].append(g)

##########
##木の直系を求める
result = bfs(graph, 1)
#print(result)
edge = result.index(max(result))

finalmap = bfs(graph, edge)
###########

for i in range(Q):
    start, goal = query[i]
    start_pos = finalmap[start]
    goal_pos = finalmap[goal]

    if (start_pos - goal_pos) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
import sys  #追加

sys.setrecursionlimit(500 * 500)  #追加
from collections import deque

n, q = map(int, input().split())
road = [[] * n for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)
d = deque()
d.append(0)
visit = [-1] * n
judge = 0


def dfs(v, judge):
    if visit[v] != -1:
        return
    visit[v] = judge
    for i in road[v]:
        dfs(i, 1 - judge)
    return


dfs(0, judge)
for i in range(q):
    c, d = map(int, input().split())
    if visit[c - 1] == visit[d - 1]:
        print("Town")
    else:
        print("Road")
class WeightedUnionFind():
    def __init__(self, n):
        self.par = [i for i in range(n)]
        self.rank = [0 for i in range(n)]
        # 親ノードとの重み
        self.diff_weight = [0 for i in range(n)]

    def find(self, x):
        if self.par[x] == x:
            return x
        # 親ノードはまだ上書きしない
        root = self.find(self.par[x])
        self.diff_weight[x] += self.diff_weight[self.par[x]]
        self.par[x] = root
        return self.par[x]

    def weight(self, x):
        """ x 根に対する重みを返す """
        self.find(x)
        return self.diff_weight[x]

    def diff(self, x, y):
        """ x と y の差分をとる """
        return self.weight(y) - self.weight(x)

    def unite(self, x, y, w):
        """ ノード x の下にノード y をつける。辺の重みは、w """
        # ただし、実際には、x の根と y の 根をくっつけるので、補正
        w += self.weight(x)
        w -= self.weight(y)
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return
        if self.rank[x] < self.rank[y]:
            # y の下に x をつけることになるので、重さは反転させる
            self.par[x] = y
            w = -w
            self.diff_weight[x] = w
        elif self.rank[y] < self.rank[x]:
            self.par[y] = x
            self.diff_weight[y] = w
        else:
            self.par[y] = x
            self.rank[x] += 1
            self.diff_weight[y] = w


N, Q = map(int, input().split())
uf = WeightedUnionFind(N)
for i in range(N - 1):
    a, b = map(int, input().split())  #a,b:つながっている辺
    uf.unite(a - 1, b - 1, 1)

for i in range(Q):
    c, d = map(int, input().split())  #a,b:つながっている辺
    if uf.diff(c - 1, d - 1) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**6)
N, Q = map(int, input().split())
graph = [[] for i in range(N)]
ans = [0] * N
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)


def dfs(v, pre, flag):
    ans[v] = flag
    for e in graph[v]:
        if e == pre: continue
        dfs(e, v, (flag + 1) % 2)


dfs(0, -1, 0)
#print(ans)
for _ in range(Q):
    c, d = map(int, input().split())
    if ans[c - 1] == ans[d - 1]: print("Town")
    else: print("Road")
import sys
from io import StringIO
import unittest
from collections import deque

INF = float('inf')


def resolve():
    n, q = list(map(int, input().split()))
    d = {}
    for _ in range(n - 1):
        a, b = list(map(int, input().split()))
        a -= 1
        b -= 1
        if a not in d:
            d[a] = []
        d[a].append(b)
        if b not in d:
            d[b] = []
        d[b].append(a)

    result = {}
    for i in range(n):
        result[i] = -1

    depth = 0
    queue = deque()
    queue.appendleft((0, 0))
    while queue:
        index, depth = queue.pop()
        if result[index] != -1:
            continue
        result[index] = depth

        for child in d[index]:
            queue.appendleft((child, depth + 1))

    # print(result)

    for _ in range(q):
        c, d = list(map(int, input().split()))
        c -= 1
        d -= 1
        if (result[c] + result[d]) % 2 == 0:
            print('Town')
        else:
            print('Road')


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """4 1
1 2
2 3
2 4
1 2"""
        output = """Road"""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """5 2
1 2
2 3
3 4
4 5
1 3
1 5"""
        output = """Town
Town"""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """9 9
2 3
5 6
4 8
8 9
4 5
3 4
1 9
3 7
7 9
2 5
2 6
4 6
2 4
5 8
7 8
3 6
5 6"""
        output = """Town
Road
Town
Town
Town
Town
Road
Road
Road"""
        self.assertIO(input, output)


if __name__ == "__main__":
    # unittest.main()
    resolve()
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

D = [-1] * n


def dfs(v, d=0):
    D[v] = d
    for u in G[v]:
        if D[u] > -1: continue
        D[u] = D[v] + 1
        dfs(u, d + 1)


dfs(0)

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print('Road' if (D[c] + D[d]) % 2 else 'Town')
n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

from collections import deque

P = [0] * n
dq = deque([0])
while dq:
    v = dq.popleft()
    for u in G[v]:
        if u == 0 or P[u] > 0: continue
        P[u] = P[v] + 1
        dq.append(u)

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print('Road' if (P[c] + P[d]) % 2 else 'Town')
from collections import deque


def bfs(V, edges):
    waiting = deque()
    done = [-1] * V
    done[0] = 0
    for n in edges[0]:
        waiting.append([n, 0])
    while len(waiting):
        cur = waiting.popleft()
        cur_node = cur[0]
        cur_dist = cur[1]
        if done[cur_node] == -1:
            done[cur_node] = cur_dist + 1
            for n in edges[cur_node]:
                if done[n] == -1:
                    waiting.append([n, cur_dist + 1])
    return done


N, Q = map(int, input().split())
e_list = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    e_list[a - 1].append(b - 1)
    e_list[b - 1].append(a - 1)
dist = bfs(N, e_list)

for i in range(Q):
    c, d = map(int, input().split())
    tmp = dist[c - 1] - dist[d - 1]
    if tmp % 2 == 1:
        print("Road")
    else:
        print("Town")
n, q = map(int, input().split())
g = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

from collections import deque


def bfs(u):
    que = deque([u])
    l = [None] * n
    l[u] = 0
    while que:
        v = que.popleft()
        for i in g[v]:
            if l[i] is None:
                l[i] = l[v] + 1
                que.append(i)
    return l


l = bfs(0)
for i in range(n):
    l[i] %= 2

for i in range(q):
    c, d = map(int, input().split())
    if l[c - 1] == l[d - 1]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split(' '))

visited = [0] * N
edges = [set() for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split(' '))
    edges[a - 1].add(b - 1)
    edges[b - 1].add(a - 1)

search = set([0])
visited[0] = 1
flag = 1

while True:
    flag *= -1
    nsearch = set()
    while len(search):
        a = search.pop()
        for p in edges[a]:
            if visited[p] == 0:
                visited[p] = flag
                nsearch.add(p)
    if nsearch == set():
        break
    search = nsearch

for i in range(Q):
    c, d = map(int, input().split(' '))
    result = visited[c - 1] * visited[d - 1]
    if result == 1:
        print('Town')
    else:
        print('Road')
import sys
from collections import deque


def Main():
    N, Q = map(int, sys.stdin.readline().strip().split())
    grid = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, sys.stdin.readline().strip().split())
        grid[a - 1].append(b - 1)
        grid[b - 1].append(a - 1)
    que = deque([0])
    seen = [-1] * N
    seen[0] = 0
    while que:
        v = que.popleft()
        for i in grid[v]:
            if seen[i] == -1:
                seen[i] = 1 - seen[v]
                que.append(i)
    for _ in range(Q):
        c, d = map(int, sys.stdin.readline().strip().split())
        if seen[c - 1] == seen[d - 1]:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    Main()
import sys
from collections import defaultdict
from itertools import groupby, permutations as pm, combinations as cm, product, combinations_with_replacement as cmrp

sys.setrecursionlimit(1000000)


def input():
    return sys.stdin.readline()[:-1]


def insp():
    return map(int, input().split())


def stsp():
    return input().split()


def solve():
    n, q = insp()
    graph = defaultdict(list)
    for i in range(n - 1):
        a, b = insp()
        graph[a].append(b)
        graph[b].append(a)

    qs = []
    for i in range(q):
        a, b = insp()
        qs.append((a, b))

    answers = ["Road"] * q
    start = 0
    stack = [1]
    dis = [0 for i in range(n + 1)]
    searched = [False for i in range(n + 1)]
    while stack:
        search = stack.pop()
        if searched[search]:
            continue
        searched[search] = True
        for t in graph[search]:
            dis[t] = (dis[search] + 1) % 2
            stack.append(t)

    for i, query in enumerate(qs):
        if dis[query[0]] == dis[query[1]]:
            answers[i] = "Town"

    print(*answers, sep="\n")
    return 0


if __name__ == "__main__":
    solve()
# region Template
# fmt: off
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)
from collections import Counter, deque, defaultdict


# from itertools import combinations, permutations, accumulate, groupby, product
# from bisect import bisect_left,bisect_right
# from heapq import heapify, heappop, heappush
# from math import floor, ceil ,factorial, gcd
# from operator import itemgetter
# from copy import deepcopy
def I():
    return int(input())


def MI():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


def SI():
    return input().rstrip()


def printns(x):
    print('\n'.join(x))


def printni(x):
    print('\n'.join(list(map(str, x))))


inf = 10**17
mod = 10**9 + 7
#mod =998244353


def INT():
    return int(sys.stdin.readline().rstrip())


def LINT():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def STR():
    return sys.stdin.readline().rstrip()


def LSTR():
    return list(sys.stdin.readline().rstrip().split())


# fmt: on
# endregion Template

N, Q = MI()
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = MI()
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1] * N
dist[0] = 0
que = deque([])
que.append(0)

while que:
    cur = que[0]
    que.popleft()
    for next in G[cur]:
        if dist[next] != -1:
            continue
        dist[next] = dist[cur] + 1
        que.append(next)

for _ in range(Q):
    c, d = MI()
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
T = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    T[a].append(b)
    T[b].append(a)

q = deque([(0, 0)])
used = [0] * N
C = [0] * N
while q:
    a, b = q.popleft()
    used[a] = 1
    for i in T[a]:
        if used[i] == 0:
            used[i] = 1
            C[i] = b + 1
            q.append((i, b + 1))

for i in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if abs(C[c] - C[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)

color = [-1] * N
stack = [0]
color[0] = 0
while stack:
    from_ = stack.pop()
    for to in edge[from_]:
        if (color[to] != -1):
            continue
        color[to] = color[from_] ^ 1
        stack.append(to)

for _ in range(Q):
    c, d = map(int, input().split())
    if (color[c - 1] == color[d - 1]):
        print("Town")
    else:
        print("Road")
from collections import deque


def main():
    n, q = map(int, input().split())
    graph = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = map(int, input().split())
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)

    dists = [-1 for _ in range(n)]
    dists[0] = 0

    reached = [False for _ in range(n)]

    d = deque()
    d.append(0)
    reached[0] = True

    for _ in range(n):
        v = d.pop()
        for i in graph[v]:
            if reached[i]:
                continue
            dists[i] = dists[v] + 1
            reached[i] = True
            d.append(i)
        if not d:
            break

    for _ in range(q):
        c, d = map(int, input().split())
        print("Road" if (dists[c - 1] + dists[d - 1]) % 2 else "Town")


if __name__ == "__main__":
    main()
from collections import defaultdict, deque
from heapq import heappop, heappush
import math
import sys
import itertools
import bisect
#sys.setrecursionlimit(10**9)
#import numpy as np
import decimal

INF = float('inf')


class UnionFind():
    def __init__(self, n):
        # classのお気持ち
        self.n = n
        #0~n-1の要素がありすべての要素の親は-1
        self.parents = [-1] * n

    def find(self, x):
        #xがどこにいるかを探している
        #親だったら自分を子だったら親を返す
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        #要素xとyを結合する
        #xとyの親を探す
        x = self.find(x)
        y = self.find(y)
        if x == y:
            #親が同じだったらそのまま
            return
        if self.parents[x] > self.parents[y]:
            x, y = y, x
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        #xが含まれるunionのサイズ
        return -self.parents[self.find(x)]

    def same(self, x, y):
        #xとyが同じunionであるかの判定
        return self.find(x) == self.find(y)

    def members(self, x):
        #xが含まれるunionのメンバー
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        #親の集合
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        #unionの数
        return len(self.roots())

    def all_group_members(self):
        group_members = defaultdict(list)
        for member in range(self.n):
            group_members[self.find(member)].append(member)
        return group_members

    def __str__(self):
        return '\n'.join(f'{r}: {m}'
                         for r, m in self.all_group_members().items())


def comb(n, r, mod):
    if r < 0 or n < r:
        return 0
    N = n
    fact = [1, 1]
    factinv = [1, 1]
    inv = [0, 1]
    for i in range(2, N + 1):
        fact.append((fact[-1] * i) % mod)
        inv.append((-inv[mod % i] * (mod // i)) % mod)
        factinv.append((factinv[-1] * inv[-1]) % mod)
    r = min(r, n - r)
    return fact[n] * factinv[r] * factinv[n - r] % mod


def is_prime(n):
    #nが素数であるかの判定
    if n == 1:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % k == 0:
            return False
    return True


def primes(n):
    #nまでの素数列挙
    #リストのその番目が1だったら素数(0から)
    nums = [0, 1] * (n // 2 + 1)
    if n % 2 == 0:
        nums.pop()
    nums[1] = 0
    nums[2] = 1
    for p in range(3, int(n**0.5) + 1, 2):
        if nums[p]:
            for q in range(p**2, n + 1, 2 * p):
                nums[q] = 0
    return nums


def soinsu(n):
    ans = []
    num = n
    for i in range(2, int(-(-n**0.5 // 1)) + 1):
        if num % i == 0:
            coun = 0
            while num % i == 0:
                coun += 1
                num //= i
            ans.append([i, coun])
    if num != 1:
        ans.append([num, 1])
    if ans == []:
        ans.append([n, 1])
    return ans


def arr_pow(A, p, mod):
    res = np.eye(A.shape[0], dtype=np.int64)
    while p:
        if p & 1:
            res = np.dot(res, A) % mod
        A = np.dot(A, A) % mod
        p >>= 1
    return res


def dijk(n, road, start):
    #(町の数,道路のリスト,出発地点)
    dist = [INF for _ in range(n + 1)]
    dist[start] = 0
    visit = [False for _ in range(n + 1)]
    hq = [(0, start)]  #(距離,場所)
    while hq:
        h = heappop(hq)
        dis = h[0]
        pla = h[1]
        if visit[pla]:
            continue
        visit[pla] = True
        for q in road[pla]:
            num = q[0]
            cost = q[1]
            if visit[num] == False:
                if dist[num] > dist[pla] + cost:
                    dist[num] = dist[pla] + cost
                    heappush(hq, (dist[pla] + cost, num))
    return dist


def arr_arr(A, B, mod):
    I, J, K = len(A), len(B[0]), len(B)
    c = [[0] * J for _ in range(I)]
    for i in range(I):
        for j in range(J):
            for k in range(K):
                c[i][j] += A[i][k] * B[k][j]
            c[i][j] %= mod
    return c


def arr_pow(x, n, mod):
    #行列の累乗
    #x^n
    y = [[0] * len(x) for _ in range(len(x))]
    for i in range(len(x)):
        y[i][i] = 1
    while n > 0:
        if n & 1:
            y = arr_arr(x, y, mod)
        x = arr_arr(x, x, mod)
        n >>= 1
    return y


def w_f(N, road):
    #ワ―シャルフロイド法
    #(街の数、道路のリスト)
    dist = [[INF for _ in range(N)] for _ in range(N)]
    for i in range(N):
        dist[i][i] = 0
    for i in range(N):
        for k in road[i + 1]:
            dist[i][k[0] - 1] = min(k[1], dist[i][k[0] - 1])
    for k in range(N):
        for i in range(N):
            for j in range(N):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    return dist


# ord('a') = 97 ord('z') = 122 ord('A') = 65 ord('Z') = 90

################################
#　　　目　　　　　　次　　　　　 #
################################

# class UnionFind
# find(x) xの親を返す(親だったら自分)
# union(x,y) xとyを結合する
# size(x) xが含まれるunionのサイズ
# same(x,y) xとyが同じかの判定
# members(x) xが含まれるunionのメンバー
# roots() 親の集合
# group_count() unionの数
# all_group_members　辞書型でunion全体を返す
#comb(n,r,mod) nCr (mod)
#is_prime(n) nが素数かの判定
#primes(n) nまでの整数列挙
#soinsu(n) nを素因数分解
#arr_pow(A, p, mod) 行列累乗
#dijk(n,road,start) ダイクストラn個の街road道のリストstart開始位置
#arr_arr(A,B,mod) 行列A*B
#w_f(N,road) ワ―シャルフロイド法

#################################
# ここからコードが始まったりする #
#################################

N, Q = map(int, input().split())
road = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    road[a].append(b)
    road[b].append(a)
dist = [-1 for _ in range(N + 1)]
visit = [False for _ in range(N + 1)]
dist[1] = 1
d = deque([1])
while d:
    q = d.popleft()
    visit[q] = True
    p = dist[q]
    for num in road[q]:
        if visit[num]:
            continue
        dist[num] = (p + 1) % 2
        d.append(num)
for _ in range(Q):
    c, d = map(int, input().split())
    if dist[c] == dist[d]:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

from collections import deque

s = 0
todo = deque([s])
seen = [False] * N
seen[s] = True
color = [True] * N

while len(todo) > 0:
    tmp = todo.popleft()
    for i in G[tmp]:
        if seen[i] == False:
            seen[i] = True
            todo.append(i)
            color[i] = (not color[tmp])

for _ in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
E = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    E[a].append(b)
    E[b].append(a)

D = [-1] * N
q = deque()
q.append((0, 0))
while q:
    a, d = q.popleft()
    D[a] = d

    for v in E[a]:
        if D[v] != -1:
            continue
        q.append((v, d + 1))

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if abs(D[c] - D[d]) % 2:
        print('Road')
    else:
        print('Town')
import sys

#Library Info(ACL for Python/Pypy) -> https://github.com/not522/ac-library-python


def input():
    return sys.stdin.readline().rstrip()


DXY = [(0, -1), (1, 0), (0, 1), (-1, 0)]  #L,D,R,Uの順番

sys.setrecursionlimit(500000)

INF = 1 << 64


def main():
    n, q = map(int, input().split())
    g = [[] for i in range(n)]
    for i in range(n - 1):
        u, v = map(int, input().split())
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)

    query = [tuple(map(int, input().split())) for i in range(q)]
    dist = [INF] * (n)
    dist[0] = 0

    def dfs(M):
        for adj in g[M]:
            if dist[adj] == INF:
                dist[adj] = dist[M] + 1
                dfs(adj)

    dfs(0)
    for u, v in query:
        u -= 1
        v -= 1
        if (dist[u] - dist[v]) % 2 != 0:
            print("Road")
        else:
            print("Town")
    return 0


if __name__ == "__main__":
    main()
from collections import deque


def cin():
    return list(map(int, input().split()))


n, q = cin()

graph = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = cin()
    graph[a].append(b)
    graph[b].append(a)

query = [cin() for _ in range(q)]

dist = [-1 for _ in range(n + 1)]
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i in range(q):
    distance = dist[query[i][0]] + dist[query[i][1]]
    if distance % 2 == 0:
        print('Town')
    else:
        print('Road')
import heapq

N, Q = map(int, input().split())
INF = float('inf')
G = [[] for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append([1, b - 1])
    G[b - 1].append([1, a - 1])


def dijkstra(N, start, goal, edge_list):
    Q = []
    #始点距離＝0, (dist, vertex)
    heapq.heappush(Q, (0, start))
    dist = [-1] * N
    dist[start] = 0
    while len(Q) > 0:
        d, v = heapq.heappop(Q)
        for nd, nv in edge_list[v]:
            if dist[nv] == -1 or dist[nv] > d + nd:
                dist[nv] = d + nd
                heapq.heappush(Q, (dist[nv], nv))

    return dist


cost = dijkstra(N, 0, N, G)

for i in range(Q):
    c, d = map(int, input().split())
    cost_c = cost[c - 1]
    cost_d = cost[d - 1]

    if abs(cost_c - cost_d) % 2 == 0:
        print('Town')
    else:
        print('Road')
(N, _), *r = [map(int, s.split()) for s in open(0)]
G = [[] for _ in [7] + r]
for a, b in r[:N - 1]:
    G[a] += b,
    G[b] += a,
V = [1] * N + [0]
q = [N]
while q:
    i = q.pop()
    for j in G[i]:
        q += [j] * V[j]
        V[j] = ~V[i]
for c, d in r[N - 1:]:
    print('RTooawdn'[V[c] == V[d]::2])
N, Q = list(map(int, input().split()))

edges = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = list(map(int, input().split()))
    edges[a].append(b)
    edges[b].append(a)

stack = [1]
dist = [-1] * (N + 1)
dist[1] = 0
while stack:
    v = stack.pop()
    for nv in edges[v]:
        if dist[nv] == -1:
            dist[nv] = dist[v] + 1
            stack.append(nv)

for _ in range(Q):
    c, d = list(map(int, input().split()))
    if (dist[c] + dist[d]) % 2:
        print("Road")
    else:
        print("Town")
#ABC_209
#D
from collections import deque

n, q = map(int, input().split())
R = [[] for _ in range(n)]  #経路情報
for _ in range(n - 1):
    r1, r2 = map(int, input().split())
    r1 -= 1
    r2 -= 1
    R[r1].append(r2)
    R[r2].append(r1)

query = list()  #クエリ情報
for _ in range(q):
    q1, q2 = map(int, input().split())
    q1 -= 1
    q2 -= 1
    query.append([q1, q2])

dist = [-1 for _ in range(n)]
Q = deque()
Q.append((0, 0))  #ノード0を視点として各ノードへの距離を計算する
#キューの中で距離の処理をしていく
while len(Q) > 0:
    (node, depth) = Q.popleft()
    if dist[node] == -1:
        dist[node] = depth
    for child in R[node]:
        if dist[child] == -1:
            Q.append((child, depth + 1))

for c, d in query:
    if dist[c] % 2 == 0 and dist[d] % 2 == 0:
        ans = "Town"
    elif dist[c] % 2 != 0 and dist[d] % 2 != 0:
        ans = "Town"
    else:
        ans = "Road"
    print(ans)
import sys

sys.setrecursionlimit(10**9)


def dfs(G, v, p, d):
    depth[v] = d
    for nv in G[v]:
        if nv == p: continue
        dfs(G, nv, v, d + 1)


n, q = map(int, input().split())
G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    G[a].append(b)
    G[b].append(a)

depth = [0] * n
dfs(G, 0, -1, 0)
for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if (depth[c] + depth[d]) % 2 == 0: print('Town')
    else: print('Road')
from collections import defaultdict  # , deque
from heapq import heappop, heappush

INF = 1 << 60
E = defaultdict(list)
n, q = map(int, input().split())
for _ in range(n - 1):
    i, j = map(int, input().split())
    i -= 1
    j -= 1
    E[i].append(j)
    E[j].append(i)
dist = [INF] * n
# que = deque([0])
que = [(0, 0)]
dist[0] = 0
while que:
    _, v = heappop(que)  # que.popleft()
    for u in E[v]:
        # if dist[u] == INF:
        #    que.append(v)
        if dist[u] > dist[v] + 1:
            dist[u] = dist[v] + 1
            heappush(que, (dist[u], u))
for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
# BFS
# DFS
import sys

sys.setrecursionlimit(20000000)
n, q = map(int, input().split())
a = [[] for i in range(n - 1)]
b = [[] for i in range(n - 1)]
c = [0] * q
d = [0] * q
g = [[] for i in range(n)]

for i in range(n - 1):
    a[i], b[i] = map(int, input().split())
    g[a[i] - 1].append(b[i] - 1)
    g[b[i] - 1].append(a[i] - 1)
for i in range(q):
    c[i], d[i] = map(int, input().split())

seen = [False for i in range(n)]
color = [-1 for i in range(n)]


def BFS(g, start):
    seen[start] = True

    for i in g[start]:
        if (seen[i] == False):
            seen[i] = True
            color[i] = 1 - color[start]
            BFS(g, i)


deep = [[] for i in range(n)]


def BFS_2(g, start):
    seen[start] = True

    for i in g[start]:
        if (seen[i] == False):
            seen[i] = True
            deep[i] = deep[start] + 1
            BFS_2(g, i)


color[0] = 0
deep[0] = 0
BFS_2(g, 0)

for i in range(q):
    if ((deep[c[i] - 1] + deep[d[i] - 1]) % 2 == 0):
        print('Town')
    else:
        print('Road')
import sys

input = sys.stdin.readline
from collections import defaultdict, deque


def II():
    return int(input())


def IS():
    return input().rstrip()


def MI():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


def MS():
    return input().rstrip().split()


def LS():
    return list(input().rstrip())


n, Q = MI()
d = defaultdict(list)
for i in range(n - 1):
    a, b = MI()
    a -= 1
    b -= 1
    d[a].append(b)
    d[b].append(a)


def biper(n: int, d: defaultdict(list)):
    seen = [0] * n
    parity = [0] * n
    q = deque()
    q.append((0, 0))
    while q:
        v, p = q.pop()
        if seen[v] == 0:
            seen[v] = 1
            parity[v] = p
        else:
            continue

        for to in d[v]:
            if seen[to] == 0:
                if p == 0:
                    q.appendleft((to, 1))
                else:
                    q.appendleft((to, 0))
            else:
                continue
    return parity


l = biper(n, d)
# print(l)

for i in range(Q):
    C, D = MI()
    C -= 1
    D -= 1
    if l[C] == l[D]:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())

neighbors = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    neighbors[a - 1].append(b - 1)
    neighbors[b - 1].append(a - 1)

queries = [list(map(int, input().split())) for _ in range(Q)]

# q state: (position, parent, depth)
q = deque()
q.append((0, -1, 0))

depths = [-1] * N
parents = [-1] * N

while len(q):
    i, parent, d = q.pop()
    depths[i] = d
    parents[i] = parent
    for j in neighbors[i]:
        if parent == j:
            continue
        q.append((j, i, d + 1))

for query in queries:
    c, d = query
    if (depths[c - 1] + depths[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")N, Q = map(int, input().split())

arr = {i: [] for i in range(N + 1)}

for i in range(1, N):
    a, b = map(int, input().split())
    arr[a].append(b)
    arr[b].append(a)

color = [-1] * (N + 1)
color[1] = 1
que = []
que.append(1)

while que:
    t = que.pop(0)
    for i in arr[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.append(i)

for _ in range(Q):
    a, b = map(int, input().split())
    if color[a] == color[b]:
        print('Town')
    else:
        print('Road')from collections import deque

N, Q = map(int, input().split())
ways = [[] for _ in range(N + 1)]
dist = [-1 for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    ways[a].append(b)
    ways[b].append(a)

stack = deque([1])
dist[1] = 0
while stack:
    t = stack.pop()
    for j in ways[t]:
        if dist[j] == -1:
            dist[j] = (dist[t] + 1) % 2
            stack.append(j)
for _ in range(Q):
    c, d = map(int, input().split())
    if dist[c] == dist[d]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
edges = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    edges[b].append(a)
    edges[a].append(b)

q = [(0, False)]
colors = [False] * N
visited = set()
while len(q) > 0:
    node = q.pop(0)
    colors[node[0]] = node[1]
    visited.add(node[0])
    for ne in edges[node[0]]:
        if ne in visited:
            continue
        q.append((ne, not node[1]))

for i in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if colors[c] == colors[d]:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(10**6)

N, Q = map(int, input().split())
E = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    E[a].append(b)
    E[b].append(a)

even_or_odd = [False for _ in range(N)]
# even => 0
used = set()
node = 0


def func(node, even):
    global E
    global even_or_odd
    global used
    for node2 in E[node]:
        if node2 in used:
            continue
        else:
            used.add(node2)
            even_or_odd[node2] = not even
            func(node2, not even)


func(0, True)

ans = []
for q in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if even_or_odd[c] == even_or_odd[d]:
        ans.append("Town")
    else:
        ans.append("Road")

for s in ans:
    print(s)
"""
INF = 10 ** 10

N, X = map(int, input().split())
A = (map(int, input().split()))
for idx, a in enumerate(A):
    if idx % 2 == 0:
        X -= a
    else:
        X -= a - 1
    if X < 0:
        exit(print("No"))
print("Yes")
"""
import sys

sys.setrecursionlimit(100000000)
input = sys.stdin.readline


#####segfunc#####
def segfunc(x, y):
    return min(x, y)
    # return min(x, y)
    # return max(x, y)
    # return x^y


#################

##### 単位元 #####
ide_ele = 10**10
# 最小値：float("inf")
# 最大値：float("inf")*(-1)
# Xor : 0
#################


class SegTree:
    """
    init(init_val, ide_ele): 配列init_valで初期化 O(N)
    update(k, x): k番目の値をxに更新 O(logN)
    query(l, r): 区間[l, r)をsegfuncしたものを返す O(logN)
    """
    def __init__(self, init_val, segfunc, ide_ele):
        """
        init_val: 配列の初期値
        segfunc: 区間にしたい操作
        ide_ele: 単位元
        n: 要素数
        num: n以上の最小の2のべき乗
        tree: セグメント木(1-index)
        """
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # 配列の値を葉にセット
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # 構築していく
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """
        k番目の値をxに更新
        k: index(0-index)
        x: update value
        """
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        """
        [l, r)のsegfuncしたものを得る
        l: index(0-index)
        r: index(0-index)
        """
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res


N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(int, input().split())
    graph[x - 1].append(y - 1)
    graph[y - 1].append(x - 1)

In = [0] * N
Out = [0] * N
Depth = []
Di = [0] * N
idx = 0


# オイラーツアー
def dfs(now, d=0, parent=-1):
    global idx
    # 行きがけ
    In[now] = idx
    idx += 1
    Depth.append(d)
    Di[now] = d

    for c in graph[now]:
        if c != parent:
            dfs(c, d + 1, now)
            Depth.append(d)
            idx += 1

    Out[now] = idx
    idx += 1
    Depth.append(d)


dfs(0)

sg = SegTree(Depth, segfunc, ide_ele)

for q in range(Q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    l = min(In[a], In[b])
    r = max(Out[a], Out[b])
    lca = sg.query(l, r + 1)
    if (Di[a] + Di[b] - 2 * lca) % 2 == 0:
        print("Town")
    else:
        print("Road")
INF = 1 << 30

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    G[a].append(b)
    G[b].append(a)

dist = [INF] * N
dist[0] = 0

# DFS
stack = [0]
seen = [False] * N
while stack:
    v = stack.pop()
    seen[v] = True
    for next_v in G[v]:
        if seen[next_v]:
            continue
        dist[next_v] = min(dist[next_v], dist[v] + 1)
        stack.append(next_v)

for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

que = queue.Queue()
n, q = map(int, input().split())
a = []
b = []
c = []
d = []

for i in range(n - 1):
    x, y = map(int, input().split())
    a.append(x)
    b.append(y)
for i in range(q):
    x, y = map(int, input().split())
    c.append(x)
    d.append(y)

f = [-1 for i in range(n)]
p = [[] for i in range(n)]

for i in range(n - 1):
    p[a[i] - 1].append(b[i] - 1)
    p[b[i] - 1].append(a[i] - 1)
f[0] = 0
que.put(0)

while not que.empty():
    po = que.get()
    for i in p[po]:
        if f[i] == -1:
            que.put(i)
            f[i] = f[po] + 1

for i in range(q):
    if f[c[i] - 1] % 2 == f[d[i] - 1] % 2:
        print('Town')
    else:
        print('Road')
import sys

input = sys.stdin.readline
import math
import copy
import bisect
import collections
from collections import deque
from collections import defaultdict

n, q = map(int, input().split())
tree = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    tree[a].append(b)
    tree[b].append(a)

que = deque([0])
dist = [-1] * n
dist[0] = 0
while que:
    check = que.popleft()
    for i in tree[check]:
        if dist[i] == -1:
            dist[i] = dist[check] + 1
            que.append(i)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
# 問題から結局ある一点からの距離を算出して、あるポイントからあるポイントまでの距離が
# 2で割れるかどうかを判定するだけだとわかる。
import sys

sys.setrecursionlimit(10**7)

N, Q = map(int, input().split())

roads = [[] for _ in range(N)]
dep = [0] * N
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    roads[a].append(b)
    roads[b].append(a)


# DFS
def dfs(x, last=-1):
    for to in roads[x]:
        if to == last:
            continue
        dep[to] = dep[x] + 1
        dfs(to, x)


dfs(0)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dep[c] % 2 == dep[d] % 2:
        print('Town')
    else:
        print('Road')
II = lambda: int(input())
MI = lambda: map(int, input().split())
OI = lambda: map(int, open(0).read().split())

#隣接リスト作成
N, Q = map(int, input().split())
G = [[] for _ in range(N)]  #隣接リスト
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

#DFS/BFS 非再帰
from collections import deque

i_init, v_init, v_yet = 0, 0, -1
D = deque()
D.appendleft([i_init, v_init])
V = [v_yet] * N
V[i_init] = v_init

#探索
while D:
    i, v = D.popleft()
    for j in G[i]:
        if V[j] == v_yet:
            v_new = 1 - v
            V[j] = v_new
            D.appendleft([j, v_new])

for _ in range(Q):
    a, b = map(int, input().split())
    print(('Road', 'Town')[V[a - 1] == V[b - 1]])
N, Q = map(int, input().split())


def nibutan_ijyou(NUM, MAT):
    MIN = 0
    MAX = len(MAT) - 1
    while True:
        TMP = (MIN + MAX) // 2
        if MAT[TMP][0] < NUM:
            MIN = TMP
        elif MAT[TMP][0] >= NUM:
            MAX = TMP
        if MAX - MIN <= 1:
            break
    if MAT[MIN][0] >= NUM:
        MAX = MIN
    return MAX  #,MAT[MIN]


root_mat = []
for i in range(N - 1):
    A, B = map(int, input().split())
    root_mat.append([A, B])
    root_mat.append([B, A])

root_mat.sort()

#print(root_mat)

floor_mat = [0] * (N + 1)
check = [[1, 0]]
while True:
    if check == []:
        break
    now = check[-1][0]
    floor = check[-1][1]
    check.pop(-1)
    tmp = nibutan_ijyou(now, root_mat)
    while True:
        if root_mat[tmp][0] == now:
            next = root_mat[tmp][1]
            if floor_mat[next] == 0 and next != 1:
                check.append([next, floor + 1])
                floor_mat[next] = floor + 1
        else:
            break
        tmp += 1
        if tmp >= len(root_mat):
            break

#print(floor_mat)

for i in range(Q):
    T1, T2 = map(int, input().split())
    if (floor_mat[T1] + floor_mat[T2]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
G = []
for _ in range(N):
    G.append([])

for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

D = [-1] * N


def search(s, g):
    Q = deque()
    Q.append([s, 0])
    while len(Q) > 0:
        q, d = Q.popleft()
        if D[q] != -1:
            continue

        D[q] = d
        #if q == g:
        #    return d
        for n in G[q]:
            Q.append([n, d + 1])


search(0, N - 1)
#print(D)

for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print('Town' if abs(D[c] - D[d]) % 2 == 0 else 'Road')
import sys

sys.setrecursionlimit(10**7)
input = sys.stdin.readline
f_inf = float('inf')
MOD = 10**9 + 7


class LowestCommonAncestor:
    """木のLCAを求める。構築：O(NlogN),クエリ：O(logN)"""
    def __init__(self, G, root=0):
        """
        :param G: 木の隣接リスト。[(コスト,頂点),(コスト,頂点)…]の形で渡す
        :param root: 木の根
        """
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.dist = [0] * self.n  # dist[v]:根からvの距離
        self.depth = [-1 if i != root else 0
                      for i in range(self.n)]  # depth[v]:頂点vの深さ
        self.parent = [[-1] * self.n
                       for _ in range(self.logn)]  # parent[k][v]:頂点vの2^k先の親
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for cost, v in self.G[u]:
                if self.depth[v] == -1:
                    self.dist[v] = self.dist[u] + cost
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get_lca(self, u, v):
        """uとvのLCAをO(logN)で求める"""
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        # LCAまでの距離を同じにする
        du, dv = self.depth[u], self.depth[v]
        for i in range(self.logn):
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        # 二分探索でLCAを求める
        if u == v:
            return u
        for i in range(self.logn - 1, -1, -1):
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]

    def get_dist(self, u, v):
        """uとvの距離をO(logN)で求める"""
        r = self.get_lca(u, v)
        return (self.dist[u] - self.dist[r]) + (self.dist[v] - self.dist[r])


def solve():
    n, q = map(int, input().split())
    edge = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        edge[a].append([1, b])
        edge[b].append([1, a])
    lca = LowestCommonAncestor(edge)
    for _ in range(q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        d = lca.get_dist(c, d)
        if d % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    solve()
import sys
from collections import defaultdict, deque


def main(f):
    global children, parity
    mod = 10**9 + 7
    N, Q = list(map(int, f.readline().split()))
    children = [[] for _ in range(N + 1)]
    parity = [None] * (N + 1)
    for i in range(1, N):
        a, b = list(map(int, f.readline().split()))
        children[a].append(b)
        children[b].append(a)

    q = deque()

    parity[1] = 1
    q.append(1)
    while q:
        i = q.popleft()
        for j in children[i]:
            if parity[j] == None:
                parity[j] = -parity[i]
                q.append(j)

    for i in range(1, Q + 1):
        c, d = list(map(int, f.readline().split()))
        if parity[c] == parity[d]:
            print('Town')
        else:
            print('Road')


main(sys.stdin)
import sys
import math
from collections import deque

sys.setrecursionlimit(1000000)
MOD = 10**9 + 7
input = lambda: sys.stdin.readline().strip()
NI = lambda: int(input())
NMI = lambda: map(int, input().split())
NLI = lambda: list(NMI())
SI = lambda: input()


def adjlist_nond_1to0(n, edges):
    res = [[] for _ in range(n)]
    for a, b in edges:
        a, b = a - 1, b - 1
        res[a].append(b)
        res[b].append(a)
    return res


def dfs(start, graph, seen):
    from collections import deque

    stack = deque()
    stack.append(start)
    seen[start] = 0

    while stack:
        now = stack.pop()
        now_c = seen[now]

        for goto in graph[now]:
            if seen[goto] in [0, 1]:
                continue
            stack.append(goto)
            seen[goto] = 1 - now_c

    return seen


def main():
    N, Q = NMI()
    edges = [NLI() for _ in range(N - 1)]
    graph = adjlist_nond_1to0(N, edges)
    querys = [NLI() for _ in range(Q)]

    colors = dfs(0, graph, [-1] * N)

    for c, d in querys:
        c, d = c - 1, d - 1
        if colors[c] == colors[d]:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
from collections import deque

N, Q = map(int, input().split())

G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

depth = [None for i in range(N)]

q = deque()
q.append(0)
depth[0] = 0

while q:
    v = q.popleft()
    for u in G[v]:
        if depth[u] is not None:
            continue
        depth[u] = depth[v] + 1
        q.append(u)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if depth[c] % 2 == depth[d] % 2:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]
cd = [list(map(int, input().split())) for _ in range(Q)]

path = [list() for _ in range(N + 1)]
for p in ab:
    path[p[0]].append(p[1])
    path[p[1]].append(p[0])

state = [-1] * (N + 1)

from collections import deque

q = deque()
q.append(1)

state[1] = 0

while len(q) > 0:
    now = q.popleft()

    for i in path[now]:
        if state[i] == -1:
            state[i] = (state[now] + 1) % 2
            q.append(i)

for query in cd:
    start = query[0]
    goal = query[1]
    if state[start] == state[goal]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
road = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)

query = []
for i in range(Q):
    query.append([int(x) - 1 for x in input().split()])

q = deque([0])
dis = [-1] * N
dis[0] = 0
while q:
    town = q.popleft()
    for i in road[town]:
        if dis[i] == -1:
            dis[i] = dis[town] + 1
            q.append(i)

for i in range(Q):
    if (dis[query[i][0]] - dis[query[i][1]]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
import math
import bisect
import random
from itertools import permutations, accumulate, combinations, product
import sys
import string
from bisect import bisect_left, bisect_right
from math import factorial, ceil, floor
from operator import mul
from functools import reduce

sys.setrecursionlimit(2147483647)
INF = 10**13


def LI():
    return list(map(int, sys.stdin.buffer.readline().split()))


def I():
    return int(sys.stdin.buffer.readline())


def LS():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()


def S():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8')


def IR(n):
    return [I() for i in range(n)]


def LIR(n):
    return [LI() for i in range(n)]


def SR(n):
    return [S() for i in range(n)]


def LSR(n):
    return [LS() for i in range(n)]


def SRL(n):
    return [list(S()) for i in range(n)]


def MSRL(n):
    return [[int(j) for j in list(S())] for i in range(n)]


mod = 1000000007


class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


n, q = LI()
G = [[] for _ in range(n)]
for x, y in LIR(n - 1):
    G[x - 1] += [y - 1]
    G[y - 1] += [x - 1]

lca = LCA(G)
for a, b in LIR(q):
    ans = lca.depth[a - 1] + lca.depth[b - 1] - 2 * lca.depth[lca.get(
        a - 1, b - 1)]
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
from bisect import bisect_left, bisect_right, insort_left, insort_right
from collections import Counter, defaultdict, deque
from copy import copy, deepcopy
from decimal import Decimal
from heapq import heapify, heappop, heappush
from itertools import combinations, permutations, combinations_with_replacement, product
from math import gcd, factorial, log2, ceil, floor, sin, asin, cos, acos, tan, atan, degrees
from pprint import pprint
from random import randrange
from sys import setrecursionlimit
from time import time

setrecursionlimit(10**9)
MOD = 10**9 + 7
INF = 10**18

N, Q = map(int, input().split())
#道の数のメモを作る？
#1からの距離を覚えておいてそれの差でいいんじゃないの？
road = [[] for _ in range(N)]
for n in range(N - 1):
    A, B = map(int, input().split())
    road[A - 1].append(B - 1)
    road[B - 1].append(A - 1)
dist_from0 = [0] * N
visited = [0] * N
visited[0] = 1
D = deque()
D.append([0, 0])
while D:
    now, dist = D.popleft()
    dist += 1
    dist_from0[now] = dist
    for next_town in road[now]:
        if visited[next_town] == 0:
            visited[next_town] = 1
            D.append([next_town, dist])
for q in range(Q):
    C, D = map(int, input().split())
    if abs(dist_from0[C - 1] - dist_from0[D - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
# #template# # # # # # # # # # # # # # # # # #
def iin():  #int
    return int(input())


def fin():  #float
    return float(input())


def xin(opt=False):  #map(opt->0-indexed)
    x = map(int, input().split())
    if opt:
        return map(lambda x: x - 1, x)
    return x


def lin(opt=False):  #list(opt->0-indexed)
    return list(xin(opt))


def qin(q):  #query or matrix
    return [lin() for i in range(q)]


def gin(h):  #grid
    return [list(input()) for i in range(h)]


def cin():  #char list
    return list(input())


def slin():  #string list
    return input().split()


def stin():  #string
    return input()


def llin():  #num+list
    return iin(), lin()


def xlin():  #xin()+lin()
    return xin(), lin()


def yn(b):
    print(["No", "Yes"][b])


def lpr(lis, chr=" "):
    print(chr.join(map(str, lis)))


def gpr(lis):
    for i in lis:
        lpr(i)


def mkm(n, m, num=0):
    return [[num] * m for i in range(n)]


def invpow(x, mod):
    return pow(x, mod - 2, mod)


def modd(a, b, mod):
    return (a * invpow(b, mod)) % mod


mod = 10**9 + 7
# # # # # # # # # # # # # # # # # # # # # # #
import sys

sys.setrecursionlimit(101000)
n, q = lin()
E = [[] for i in range(n)]
for i in range(n - 1):
    a, b = lin(1)
    E[a].append(b)
    E[b].append(a)
seen = [-1] * n
seen[0] = 0


def dfs(x):
    for i in E[x]:
        if seen[i] == -1:
            seen[i] = seen[x] ^ 1
            dfs(i)


dfs(0)
for i in range(q):
    c, d = lin(1)
    print(["Road", "Town"][seen[c] == seen[d]])
from collections import deque


def main():
    [N, Q] = [int(x) for x in input().split()]

    # グラフの初期化
    graph = [[] for _ in range(N + 1)]
    for _ in range(N - 1):
        [a, b] = [int(x) for x in input().split()]
        graph[a].append(b)
        graph[b].append(a)

    # 深さを記録するリスト
    depth_vec = [-1 for _ in range(N + 1)]

    # 1を根とする根付き木を作り、各頂点の深さを記録する
    queue = deque()
    queue.append((1, 0))
    while len(queue) > 0:
        (node, depth) = queue.pop()
        depth_vec[node] = depth
        for child in graph[node]:
            if depth_vec[child] >= 0:
                continue
            queue.append((child, depth + 1))

    # クエリに解答する
    for query in range(Q):
        [c, d] = [int(x) for x in input().split()]
        if (depth_vec[c] + depth_vec[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
import collections as cc
import bisect as bi
import heapq as hp
import math as mt
import itertools as it
import sys

input = sys.stdin.readline
I = lambda: list(map(int, input().split()))
mod = 10**9 + 7
n, q = I()
g = cc.defaultdict(list)
for i in range(n - 1):
    a, b = I()
    g[a].append(b)
    g[b].append(a)
st = [(1, -1)]
col = [0] * (n + 1)
while st:
    now, p = st.pop()
    for then in g[now]:
        if then != p:
            col[then] = 1 ^ col[now]
            st.append((then, now))
for i in range(q):
    x, y = I()
    print("TRoowand"[not col[x] == col[y]::2])
#author: ankan2526

import math, bisect, heapq, sys

#n,k=map(int,input().split())
n, q = map(int, input().split())
store = {}
for i in range(n - 1):
    x, y = map(int, input().split())
    if x not in store:
        store[x] = []
    if y not in store:
        store[y] = []
    store[x].append(y)
    store[y].append(x)
length = {1: 0}
done = set([1])
queue = [1]
x = 0
while queue:
    x ^= 1
    temp = []
    for i in queue:
        for j in store[i]:
            if j not in done:
                done.add(j)
                temp.append(j)
                length[j] = x
    queue = temp
for i in range(q):
    x, y = map(int, input().split())
    if length[x] ^ length[y]:
        print("Road")
    else:
        print("Town")
import sys

sys.setrecursionlimit(500000)
n, q = map(int, input().split())
adj = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)
c = [0] * q
d = [0] * q
for i in range(q):
    c[i], d[i] = map(int, input().split())
    c[i] -= 1
    d[i] -= 1
depth = [-1] * n


def dfs(v, e):
    depth[v] = e
    for w in adj[v]:
        if depth[w] == -1:
            dfs(w, e + 1)


dfs(0, 0)
for i in range(q):
    ans = depth[c[i]] - depth[d[i]]
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python3
# from typing import *

import sys
import io
import math
import collections
import decimal
import itertools
import bisect
import heapq


def input():
    return sys.stdin.readline()[:-1]


sys.setrecursionlimit(1000000)

# _INPUT = """4 1
# 1 2
# 2 3
# 2 4
# 1 2

# """
# sys.stdin = io.StringIO(_INPUT)

INF = 10**10

# class RunTree:
#     depth = []
#     eular_tour = []
#     in_time = []
#     _data = []
#     _N1 = 0
#     def __init__(self, G) -> None:
#         N = len(G)
#         self.eular_tour = []
#         self.in_time = [0] * N
#         self.depth = [-1] * N
#         seen = [False] * N
#         self._dfs(G, seen, 0, 0)
#         # Segment tree
#         self._N1 = 2 **(len(self.eular_tour)-1).bit_length()
#         self._data = [(-10**10, None)] * (2 * self._N1)
#         for i, v in enumerate(self.eular_tour):
#             self._data[self._N1+i] = (self.depth[v], v)
#         for i in reversed(range(1, self._N1)):
#             self._data[i] = min(self._data[2*i], self._data[2*i+1])
#     def _dfs(self, G, seen, p, depth):
#         seen[p] = True
#         self.in_time[p] = len(self.eular_tour)
#         self.depth[p] = depth
#         self.eular_tour.append(p)
#         for p1 in G[p]:
#             if p1 == p or seen[p1]:
#                 continue
#             self._dfs(G, seen, p1, depth+1)
#             self.eular_tour.append(p)
#     def get_lca(self, u, v):
#         l = self.in_time[u] + self._N1
#         r = self.in_time[v] + self._N1
#         if l > r:
#             l, r = r, l
#         r += 1
#         res = (10**10, None)
#         while l < r:
#             if l & 1:
#                 res = min(res, self._data[l])
#                 l += 1
#             if r & 1:
#                 res = min(res, self._data[r-1])
#                 r -= 1
#             l //= 2
#             r //= 2
#         return res[1]

# def dfs(parent, p, d):
#     depth[p] = d
#     for p1 in G[p]:
#         if p1 == parent:
#             continue
#         dfs(p, p1, d+1)

N, Q = map(int, input().split())
G = [list() for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

depth = [-1] * N
seen = [False] * N
q = collections.deque()
q.append(0)
seen[0] = True
depth[0] = 0
while q:
    p = q.pop()
    for p1 in G[p]:
        if seen[p1]:
            continue
        seen[p1] = True
        depth[p1] = depth[p] + 1
        q.appendleft(p1)

result = []
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    l = depth[c] + depth[d]
    if l % 2 == 0:
        result.append('Town')
    else:
        result.append('Road')
print('\n'.join(result))
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())

edge = [[] for _ in range(n)]
dep = [0] * n
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)


def dfs(x, last=-1):
    for to in edge[x]:
        if to == last:
            continue
        dep[to] = dep[x] + 1
        dfs(to, x)


dfs(0)

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dep[c] % 2 == dep[d] % 2:
        print('Town')
    else:
        print('Road')
#典型90 003
#木の直径は、任意の頂点sを選び、sからDFS/BFSを行い、最も遠い頂点uを探索する
#uからDFS/BFSを行い、最も遠い頂点vを探索する。uvの距離が答え

N, Q = map(int, input().split())

#隣接リストを使用
#FalseのN*0の二次元配列
graph = []
for i in range(0, N):

    #長さ0の一次元配列
    row = []
    graph.append(row)

#N-1本の辺を受け取る
for i in range(1, N):
    u, v = map(int, input().split())
    u -= 1
    v -= 1

    #uとvの間には辺がある
    graph[u].append(v)
    graph[v].append(u)

#根から各頂点に向かう。
#dequeを使えるようにする
from collections import deque


def bfs():
    #スタートからの最小移動回数dを管理する配列。値が負であれば未訪問
    d = [-1] * N

    #キューを用意し、スタートを入れる
    que = deque()
    que.append(s)
    d[s] = 0

    while que:
        #キューから取り出しながら探索
        p = que.popleft()
        #キューから取り出されたものの隣に行く。
        for i in graph[p]:
            if d[i] == -1:
                que.append(i)
                d[i] = d[p] + 1
    return d


s = 0
dist = bfs()

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dist[c] % 2 == dist[d] % 2:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())
edge = [[] for _ in range(n)]
dd = [0] * n

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)


def dfs(x, last=-1):
    for to in edge[x]:
        if to == last:
            continue
        dd[to] = dd[x] + 1
        dfs(to, x)


dfs(0)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dd[c] % 2 == dd[d] % 2:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(100000)

global city
global g


def search_d(c):
    global city
    global g
    for i in g[c]:
        if city[i] == -1:
            city[i] = 2 if city[c] == 1 else 1
            search_d(i)


def main():
    from sys import stdin
    readline = stdin.readline
    N, Q = map(int, input().split())
    list_graph = [[x - 1 for x in list(map(int,
                                           readline().split()))]
                  for _ in range(N - 1)]
    list_query = [[x - 1 for x in list(map(int,
                                           readline().split()))]
                  for _ in range(Q)]

    global city
    city = [-1] * N
    global g
    g = [[] * N for _ in range(N)]

    for e in list_graph:
        g[e[0]].append(e[1])
        g[e[1]].append(e[0])

    city[0] = 1
    search_d(0)

    for q in list_query:
        print("Town" if city[q[0]] == city[q[1]] else "Road")


if __name__ == '__main__':
    main()
N, Q = map(int, input().split())

G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

tmp = [0] * N
tmp[0] = 1
check = []
check.append(0)

while check:
    i = check.pop(0)
    for k in G[i]:
        if tmp[k] == 0:
            tmp[k] = tmp[i] * (-1)
            check.append(k)

for i in range(Q):
    c, d = map(int, input().split())
    if tmp[c - 1] == tmp[d - 1]:
        print("Town")
    else:
        print("Road")from collections import deque

N, Q = map(int, input().split())
E = [[] for _ in range(N)]
for _ in range(N - 1):
    A, B = map(int, input().split())
    E[A - 1].append(B - 1)
    E[B - 1].append(A - 1)

queue = deque([(0, 0)])
depth = [None] * N
while queue:
    d, q = queue.popleft()
    depth[q] = d

    for e in E[q]:
        if depth[e] is None: queue.append((d + 1, e))

for _ in range(Q):
    C, D = map(int, input().split())
    print('Town' if depth[C - 1] % 2 == depth[D - 1] % 2 else 'Road')
# -*- coding: utf-8 -*-
import sys
import queue

sys.setrecursionlimit(10000000)
input = sys.stdin.readline

from collections import defaultdict

N, Q = list(map(int, input().split()))
edges = defaultdict(list)
for _ in range(N - 1):
    a, b = list(map(lambda x: int(x) - 1, input().split()))
    edges[a].append(b)
    edges[b].append(a)

queries = [None] * Q
for i in range(Q):
    a, b = list(map(lambda x: int(x) - 1, input().split()))
    queries[i] = [a, b]

is_even = [False] * N
is_even[0] = True
visited = [False] * N
que = queue.Queue()
que.put((0, 0))  # index, distance
visited[0] = True
while not que.empty():
    index, distance = que.get()
    for to in edges[index]:
        if visited[to]:
            continue
        visited[to] = True
        is_even[to] = ((distance + 1) % 2 == 0)
        que.put((to, distance + 1))

for query in queries:
    a, b = query
    if is_even[a] == is_even[b]:
        print('Town')
    else:
        print('Road')
class HLDecomposition:
    def __init__(self, tree):
        self.tree = tree
        self.n = len(tree)
        self.par = [-1] * self.n
        self.size = [1] * self.n
        self.depth = [0] * self.n
        self.preorder = [0] * self.n
        self.head = [i for i in range(self.n)]
        self.k = 0

        for v in range(self.n):
            if self.par[v] == -1:
                self._dfs_pre(v)
                self._dfs_hld(v)

    def getitem(self, v):
        return self.preorder[v]

    def _dfs_pre(self, v):
        tree = self.tree
        stack = [v]
        order = [v]
        while stack:
            v = stack.pop()
            for chi_v in tree[v]:
                if chi_v == self.par[v]:
                    continue
                self.par[chi_v] = v
                self.depth[chi_v] = self.depth[v] + 1
                stack.append(chi_v)
                order.append(chi_v)

        for v in reversed(order):
            tree_v = tree[v]
            if len(tree_v) and tree_v[0] == self.par[v]:
                tree_v[0], tree_v[-1] = tree_v[-1], tree_v[0]
            for idx, chi_v in enumerate(tree_v):
                if chi_v == self.par[v]:
                    continue
                self.size[v] += self.size[chi_v]
                if self.size[chi_v] > self.size[tree_v[0]]:
                    tree_v[idx], tree_v[0] = tree_v[0], tree_v[idx]

    def _dfs_hld(self, v):
        stack = [v]
        while stack:
            v = stack.pop()
            self.preorder[v] = self.k
            self.k += 1
            if len(self.tree[v]) == 0:
                continue
            top = self.tree[v][0]
            for chi_v in reversed(self.tree[v]):
                if chi_v == self.par[v]:
                    continue
                if chi_v == top:
                    self.head[chi_v] = self.head[v]
                else:
                    self.head[chi_v] = chi_v
                stack.append(chi_v)

    def lca(self, u, v):
        while u != -1 and v != -1:
            if self.preorder[u] > self.preorder[v]:
                u, v = v, u
            if self.head[u] == self.head[v]:
                return u
            v = self.par[self.head[v]]
        return -1

    def distance(self, u, v):
        lca_uv = self.lca(u, v)
        if lca_uv == -1:
            return -1
        else:
            return self.depth[u] + self.depth[v] - 2 * self.depth[lca_uv]

    def range_vertex_path(self, u, v):
        while True:
            if self.preorder[u] > self.preorder[v]:
                u, v = v, u
            l = max(self.preorder[self.head[v]], self.preorder[u])
            r = self.preorder[v]
            yield l, r + 1
            if self.head[u] != self.head[v]:
                v = self.par[self.head[v]]
            else:
                return

    def range_edge_path(self, u, v):
        while True:
            if self.preorder[u] > self.preorder[v]:
                u, v = v, u
            if self.head[u] != self.head[v]:
                yield self.preorder[self.head[v]], self.preorder[v] + 1
                v = self.par[self.head[v]]
            else:
                if u != v:
                    yield self.preorder[u] + 1, self.preorder[v] + 1
                break

    def range_subtree(self, u):
        return self.preorder[u], self.preorder[u] + self.size[u]


import sys

input = sys.stdin.readline

n, q = map(int, input().split())
edge = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    edge[a].append(b)
    edge[b].append(a)

hl = HLDecomposition(edge)

for i in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    dist = hl.distance(c, d)
    if dist % 2:
        print("Road")
    else:
        print("Town")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**9)

n, q = map(int, input().split())
e = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    e[a].append(b)
    e[b].append(a)

r = [-1 for _ in range(n)]
que = [(0, 0)]
while (que):
    qq = []
    for v, x in que:
        if r[v] != -1:
            continue
        r[v] = x
        for u in e[v]:
            if r[u] != -1:
                continue
            qq.append((u, x + 1))
    que = qq[:]

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if r[c] % 2 == r[d] % 2:
        print('Town')
    else:
        print('Road')
def euler_tour(s):
    stack = [~s, s]
    t, d = 0, 0
    depth, first_visit, last_visit, tour = [0] * N, [0] * N, [0] * N, []
    parent, seen = [None] * N, [False] * N
    parent[s] = -1
    depth[s] = 0
    seen[s] = True

    while stack:
        u = stack.pop()
        if u >= 0:
            t += 1
            first_visit[u] = t
            tour.append(u)
            for v in G[u]:
                if seen[v]:
                    continue
                else:
                    seen[v] = True
                depth[v] = depth[u] + 1
                parent[v] = u
                stack.append(~v)
                stack.append(v)
        else:
            t += 1
            last_visit[u] = t
            tour.append(~u)
    return depth, first_visit, last_visit, tour


N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    A, B = map(int, input().split())
    A, B = A - 1, B - 1
    G[A].append(B)
    G[B].append(A)

depth, first_visit, last_visit, tour = euler_tour(0)
for i in range(Q):
    C, D = map(int, input().split())
    C, D = C - 1, D - 1
    if (depth[C] - depth[D]) % 2 == 0:
        print("Town")
    else:
        print("Road")N, Q = map(int, input().split())
G = [set() for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].add((b, 1))
    G[b].add((a, 1))

query = [tuple(map(int, input().split())) for i in range(Q)]


class LcaDoubling:
    def __init__(self, n, links, root=0):
        self.depths = [-1] * n
        self.distances = [-1] * n
        prev_ancestors = self._init_dfs(n, links, root)
        self.ancestors = [prev_ancestors]
        max_depth = max(self.depths)
        d = 1
        while d < max_depth:
            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]
            self.ancestors.append(next_ancestors)
            d <<= 1
            prev_ancestors = next_ancestors

    def _init_dfs(self, n, links, root):
        q = [(root, -1, 0, 0)]
        # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1
        direct_ancestors = [-1] * (n + 1)
        while q:
            v, p, dep, dist = q.pop()
            direct_ancestors[v] = p
            self.depths[v] = dep
            self.distances[v] = dist
            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)
        return direct_ancestors

    def get_lca(self, u, v):
        du, dv = self.depths[u], self.depths[v]
        if du > dv:
            u, v = v, u
            du, dv = dv, du
        tu = u
        tv = self.upstream(v, dv - du)
        if u == tv:
            return u
        for k in range(du.bit_length() - 1, -1, -1):
            mu = self.ancestors[k][tu]
            mv = self.ancestors[k][tv]
            if mu != mv:
                tu = mu
                tv = mv
        lca = self.ancestors[0][tu]
        assert lca == self.ancestors[0][tv]
        return lca

    def get_distance(self, u, v):
        lca = self.get_lca(u, v)
        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]

    def upstream(self, v, k):
        i = 0
        while k:
            if k & 1:
                v = self.ancestors[i][v]
            k >>= 1
            i += 1
        return v


X = LcaDoubling(N, G)
for a, b in query:
    a -= 1
    b -= 1
    if X.get_distance(a, b) % 2:
        print("Road")
    else:
        print("Town")
from collections import deque

n, q = map(int, input().split())
node_lst = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    node_lst[a].append(b)
    node_lst[b].append(a)
# print(node_lst)
depth_lst = [-1 for _ in range(n)]
dq = deque()
dq.append((0, 0))
while (len(dq) > 0):
    node, depth = dq.popleft()
    depth_lst[node] = depth
    for child in node_lst[node]:
        if depth_lst[child] >= 0: continue
        dq.append((child, depth + 1))
        # print("depth_lst:",depth_lst)

for _ in range(q):
    ans = 0
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    ans = depth_lst[c] + depth_lst[d]
    ans %= 2
    print(["Town", "Road"][ans])
import sys, math

sys.setrecursionlimit(10**6)
mod = 10**9 + 7
#mod = 998244353
input = lambda: sys.stdin.readline().rstrip()


def li():
    return list(map(int, input().split()))


N, Q = li()
graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = li()
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

from collections import deque


def dfs(start, num_node):
    stack = [start]
    seen = [False] * (num_node)
    seen[start] = 1
    while stack:
        x = stack.pop()
        for y in graph[x]:
            if seen[y]:
                continue
            stack.append(y)
            seen[y] = seen[x] + 1
    return seen


dist = dfs(0, N)
for _ in range(Q):
    a, b = li()
    a -= 1
    b -= 1
    if (dist[a] + dist[b]) % 2 == 1:
        print('Road')
    else:
        print('Town')
from collections import deque

n, q = map(int, input().split())
#print(n,q)

m = n - 1
#create adjacency list
g = [[] for _ in range(n + 1)]
#print(g)
for i in range(m):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)
#print(g)

#create depth_list
depth_list = [-1 for _ in range(n + 1)]
#print(depth_list)

#create rooted tree
dq = deque()
dq.append((1, 0))  #1. put first element(n,depth)
#print(len(q))
while len(dq) > 0:
    [a, d] = dq.pop()
    #print(a,d)
    depth_list[a] = d  # 2. confirm n's depth
    for child in g[a]:  #3. push child node
        if depth_list[child] >= 0:
            continue
        dq.append((child, d + 1))
#print(depth_list)

for i in range(q):
    a, b = map(int, input().split())
    if (depth_list[a] + depth_list[b]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

cd = [list(map(int, input().split())) for i in range(q)]
cd = [[x - 1, y - 1] for x, y in cd]
ds = [0] * n

import collections

q = collections.deque()
q.append((0, -1))
while q:
    x, y = q.popleft()
    if y != -1: ds[x] = ds[y] + 1
    for u in g[x]:
        if y != u:
            q.append((u, x))

for c, d in cd:
    if abs(ds[c] - ds[d]) % 2: print("Road")
    else: print("Town")
import sys

sys.setrecursionlimit(10**6)


def inp(dtype=int):
    return list(map(dtype, input().split()))


N, Q = inp()
a, b = zip(*[inp() for _ in range(N - 1)])

tree = [[] for _ in range(N + 1)]
for i, j in zip(a, b):
    tree[i].append(j)
    tree[j].append(i)

dist = [0 for _ in range(N + 1)]


def dfs(i=1, prev=0):
    for j in tree[i]:
        if j == prev:
            continue
        dist[j] = dist[i] + 1
        dfs(j, i)


dfs()
for _ in range(Q):
    c, d = inp()
    if (dist[c] - dist[d]) % 2:
        print("Road")
    else:
        print("Town")
# -*- coding: utf-8 -*-


class TreeDistance:
    def __init__(self, vertex_count, graph) -> None:
        self.dist = [0 for _ in range(vertex_count)]
        self._graph = graph
        self._visited = [False for _ in range(vertex_count)]

    def calc(self, start_vertex):
        self._bfs(start_vertex)

        return self.dist

    def _bfs(self, vertex):
        from collections import deque

        d = deque()
        d.append(vertex)
        self._visited[vertex] = True

        while d:
            di = d.popleft()

            for to in self._graph[di]:
                if self._visited[to]:
                    continue

                self._visited[to] = True
                self.dist[to] = self.dist[di] + 1
                d.append(to)


def main():
    from collections import deque
    import sys

    input = sys.stdin.readline

    n, q = map(int, input().split())
    graph = [[] for _ in range(n)]

    for _ in range(n - 1):
        ai, bi = map(int, input().split())
        ai -= 1
        bi -= 1

        graph[ai].append(bi)
        graph[bi].append(ai)

    td = TreeDistance(n, graph)
    dist = td.calc(0)

    for i in range(q):
        ci, di = map(int, input().split())
        ci -= 1
        di -= 1

        if abs(dist[ci] - dist[di]) % 2 == 1:
            print("Road")
        else:
            print("Town")


if __name__ == "__main__":
    main()
def int_sp():
    return map(int, input().split())


def li_int_sp():
    return list(map(int, input().split()))


def trans_li_int_sp():
    return list(map(list, (zip(*[li_int_sp() for _ in range(N)]))))


# おまじない
import sys
import pdb

sys.setrecursionlimit(1000000)
# 入力の読み込み
N, Q = map(int, input().split())
G = [[] for i in range(N)]
# G[i] は王国iから道路で直接繋がっている王国のリスト
for i in range(N - 1):
    A, B = map(int, input().split())
    G[A - 1].append(B - 1)
    G[B - 1].append(A - 1)

visited_time = [-1] * (N)  # 訪れる時間を記録
temp = [False] * (N)  # 訪れたかを記録


# dfs
def dfs(v, dist):
    if temp[v]: return  # 同じ頂点を2度以上調べないためのreturn
    temp[v] = True
    visited_time[v] = dist
    for vv in G[v]:
        dfs(vv, dist + 1)


ans = 0
# (スタート王国，訪れた時刻)
dfs(0, 0)

# 二部グラフ判定
for _ in range(Q):
    c, d = li_int_sp()
    if abs(visited_time[c - 1] - visited_time[d - 1]
           ) % 2 == 1:  #(奇数 and 奇数) or (偶数 and 偶数)なら街で出会う．それ以外なら道路で出会う．
        print('Road')
    else:
        print('Town')
n, q = map(int, input().split())  # nは頂点の数、mは辺の数

g = [[] for _ in range(n + 1)]  # 隣接リスト

for _ in range(n - 1):
    a, b = [int(x) for x in input().split()]
    g[a].append(b)
    g[b].append(a)  #無向のみ。有向では不要

from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * (n + 1)  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


y = bfs(1)

for i in range(q):
    p, q = map(int, input().split())
    if ((y[p] - y[q]) % 2):
        print("Road")
    else:
        print("Town")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
import numpy as np
from functools import *
import sys

sys.setrecursionlimit(100000)
input = sys.stdin.readline

from collections import defaultdict

d = defaultdict(int)


def array(size, init=0):
    return [[init for j in range(size[1])] for i in range(size[0])]


def acinput():
    return list(map(int, input().split(" ")))


def dfs(x, d):
    global dist, visited
    for n in L[x]:
        if not visited[n]:
            visited[n] = True
            dist[n] = d + 1
            dfs(n, d + 1)


N, Q = acinput()

L = [[] for i in range(N + 1)]
for i in range(N - 1):
    a, b = acinput()
    L[a].append(b)
    L[b].append(a)
    #print(a,b)

visited = [0] * (N + 1)
dist = [10**9] * (N + 1)
dfs(1, 0)

#print(L)
q = []
for i in range(Q):

    tmp = list(map(int, input().split(" ")))

    a = tmp[0]
    b = tmp[1]

    if (dist[b] - dist[a]) % 2 == 0:
        print("Town")
    else:
        print("Road")

#print(dp[R-1][C-1])
#print(np.array(dp))
n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

from collections import deque

dist = [-1] * n  # 頂点1からの最短距離distance
dist[0] = 0
d = deque()
d.append(0)

while d:
    v = d.popleft()
    for i in g[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

# print(*dist)

for j in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if abs(dist[d] - dist[c]) % 2 == 0:
        print('Town')
    else:
        print('Road')
#####################################
import atexit, io, sys, collections, math, heapq, fractions, copy, os, functools
import sys
import random
import collections

from io import BytesIO, IOBase

#####################################  python 3 START
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = "x" in file.mode or "r" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b"\n") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode("ascii"))
        self.read = lambda: self.buffer.read().decode("ascii")
        self.readline = lambda: self.buffer.readline().decode("ascii")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip("\r\n")
#####################################  python 3 END

n, qq = map(int, input().split())
adj = collections.defaultdict(list)
for _ in range(n - 1):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)
q = collections.deque([(1, 0, None)])
nadj = collections.defaultdict(list)
depth = [0 for _ in range(n + 1)]
while (q):
    u, d, parent = q.popleft()
    depth[u] = d
    for v in adj[u]:
        if v != parent:
            nadj[u].append(v)
            q.append((v, d + 1, u))

adj = nadj
t = []
first = {}


def euler(root, adj, t):
    if root not in first: first[root] = len(t)
    t.append((depth[root], root))
    for v in adj[root]:
        if v not in first: first[v] = len(t)
        t.append((depth[v], v))
        euler(v, adj, t)
        t.append((depth[v], v))


#euler(1, adj, t)
def tlca(u, v, root, adj):
    fi = min(first[u], first[v])
    li = max(first[u], first[v])
    return min(t[fi:li + 1])[1]


def lca(u, v, root, adj):
    if u == root:
        return u
    if v == root:
        return v
    if len(adj[root]) == 0:
        return 0
    temp = [lca(u, v, desc, adj) for desc in adj[root]]
    if sum(temp) == 0:
        return 0
    count = 0
    for val in temp:
        if val:
            count += 1
    if count == 1:
        for val in temp:
            if val:
                return val
    elif count == 2:
        return root
    return 0


def f(u, v, adj, depth):
    #l = lca(u,v,1,adj)

    #print (tlca(u,v,1,adj) == l)
    quantity = depth[u] + depth[v]
    #quantity += abs(depth[l] - depth[u])
    #quantity += abs(depth[l] - depth[v])
    return 'Road' if quantity % 2 else 'Town'


for _ in range(qq):
    u, v = map(int, input().split())
    print(f(u, v, adj, depth))
#D
from collections import deque

N, Q = map(int, input().split())
edges = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)

dist = [-1] * N


def bfs(x):
    que = deque([x])
    dist[x] = 0
    while que:
        v = que.popleft()
        d = dist[v]
        for w in edges[v]:
            if dist[w] > -1:
                continue
            dist[w] = d + 1
            que.append(w)


bfs(0)
#print(dist)
for i in range(Q):
    c, d = map(int, input().split())
    if (dist[d - 1] - dist[c - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

from collections import deque

m = n - 1

graph = [[] for _ in range(n + 1)]

for i in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i in range(q):
    x, y = map(int, input().split())
    ans = dist[y] - dist[x]
    if ans % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque, defaultdict


class Bfs:
    def __init__(self, graph):
        self.cache = dict()
        self.graph = graph

    def bfs(self, c: int, d: int):
        self.cache[(c, c)] = 0
        self.cache[(d, d)] = 0
        q = deque()
        q.append(c)
        searched = set()
        while q:
            v = q.popleft()
            searched.add(v)
            for n in self.graph[v]:
                if n not in searched:
                    self.cache[(c, n)] = self.cache[(c, v)] + 1
                    self.cache[(n, c)] = self.cache[(c, n)]
                    q.append(n)
        return self.cache

    def find(self, c: int, d: int, first):
        return abs(self.cache[(first, d)] - self.cache[(first, c)])


def main() -> int:
    N, Q = map(int, input().split())
    graph = defaultdict(list)
    for _ in range(N - 1):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)

    bfs = Bfs(graph)
    flag = True
    for _ in range(Q):
        c, d = map(int, input().split())
        if flag:
            bfs.bfs(c, d)
            first = c
            flag = False
        ret = bfs.find(c, d, first)
        # print(ret)
        # continue
        if ret % 2 == 1:
            print('Road')
        else:
            print('Town')


main()
import math
import sys

sys.setrecursionlimit(100000000)


def main():
    inf = math.inf
    n, q = map(int, input().split())
    graph = [[] for _ in range(n)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1  # 0-indexed
        graph[a].append(b)
        graph[b].append(a)

    depth = [-1 for _ in range(n)]
    start = 0
    visited = [False for _ in range(n)]
    make_depth(depth, graph, start, visited, 0)

    for j in range(q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        c_depth = depth[c]
        d_depth = depth[d]
        if abs(c_depth - d_depth) % 2 == 0:
            answer = "Town"
        else:
            answer = "Road"
        print(answer)


def make_depth(depth_lst, graph, here, visited, depth=0):
    depth_lst[here] = depth
    visited[here] = True

    for nxt in graph[here]:
        if visited[nxt]:
            continue
        make_depth(depth_lst, graph, nxt, visited, depth + 1)


if __name__ == '__main__':
    main()
from collections import deque

n = 0
m = 0


# input:Graph G and start vertex s
def bfs(G, s) -> list:
    # initialize
    que = deque()
    dist = [-1] * n
    dist[s] = 0
    que.append(s)

    while len(que) != 0:
        v = que.popleft()

        for x in G[v]:
            if dist[x] != -1:
                continue

            dist[x] = dist[v] + 1
            que.append(x)

    return dist


if __name__ == "__main__":
    n, q = map(int, input().split())
    ans_lis = []
    m = n - 1
    Graph = [[] for _ in range(n)]
    for i in range(m):
        a, b = map(int, input().split())
        # 1-start
        a -= 1
        b -= 1
        Graph[a].append(b)
        Graph[b].append(a)
    dis = bfs(Graph, 0)
    for j in range(q):
        fm, to = map(int, input().split())
        fm -= 1
        to -= 1
        dis_fm = dis[fm]
        dis_to = dis[to]
        if dis_fm % 2 == dis_to % 2:
            ans_lis.append("Town")
        else:
            ans_lis.append("Road")
    for j in ans_lis:
        print(j)
from sys import setrecursionlimit, stdin
import math

setrecursionlimit(10**7)
input = stdin.readline

N, Q = map(int, input().split())
path = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    path[a].append(b)
    path[b].append(a)

dist = [None] * (N + 1)
dist[1] = 0
length = 0


def dfs(n, length):
    length += 1
    for v in path[n]:
        if dist[v] == None or dist[v] > length:
            dist[v] = length
            dfs(v, length)


dfs(1, 0)
for i in range(1, N + 1):
    if dist[i] % 2:
        dist[i] = 1
    else:
        dist[i] = 0

for _ in range(Q):
    c, d = map(int, input().split())
    if dist[c] == dist[d]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())  # nは頂点の数、mは辺の数

g = [[] for _ in range(n + 1)]  # 隣接リスト

for _ in range(n - 1):
    a, b = [int(x) for x in input().split()]
    g[a].append(b)
    g[b].append(a)  #無向のみ。有向では不要

from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * (n + 1)  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


y = bfs(1)

for i in range(q):
    p, q = map(int, input().split())
    if ((y[p] - y[q]) % 2):
        print("Road")
    else:
        print("Town")
import heapq

n, q = map(int, input().split())
A, B, C, D = [], [], [], []

for _ in range(n - 1):
    a, b = map(int, input().split())
    A.append(a - 1)
    B.append(b - 1)

for _ in range(q):
    c, d = map(int, input().split())
    C.append(c - 1)
    D.append(d - 1)

e = [[] for _ in range(n)]
for i in range(n - 1):
    e[A[i]].append((1, B[i]))
    e[B[i]].append((1, A[i]))


def dijkstra(s):
    hq = [(0, s)]
    heapq.heapify(hq)  # リストを優先度付きキューに変換
    cost = [10**6 + 1] * n  # 行ったことのないところはinf
    cost[s] = 0  # 開始地点は0
    while hq:
        c, v = heapq.heappop(hq)
        if c > cost[v]:  # コストが現在のコストよりも高ければスルー
            continue
        for d, u in e[v]:
            tmp = d + cost[v]
            if tmp < cost[u]:
                cost[u] = tmp
                heapq.heappush(hq, (tmp, u))
    return cost


cost = dijkstra(0)

for i in range(q):
    if cost[C[i]] % 2 == cost[D[i]] % 2:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
road = dict()
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if a in road:
        road[a].append(b)
    else:
        road[a] = [b]

    if b in road:
        road[b].append(a)
    else:
        road[b] = [a]

visted = [False] * n
visted[0] = True
queue = deque()
color = [""] * n
color[0] = 'b'
queue.append(0)
while queue:
    town = queue.popleft()
    for des in road[town]:
        if visted[des] is False:
            if color[town] == 'b':
                color[des] = 'r'
                queue.append(des)
                visted[des] = True
            else:
                color[des] = 'b'
                queue.append(des)
                visted[des] = True
for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
def resolve():
    from collections import deque
    import numpy as np

    N, Q = map(int, input().split())

    # 各町を頂点として、リストで接続先の頂点を表現するグラフ
    G = [[] for i in range(N + 1)]

    # 各頂点の色
    # 0, 1: 色付き -1:色なし
    distance = [np.inf for i in range(N + 1)]

    # 町番号をインデックスとした接続先の町をリストで格納するテーブルを作成
    for i in range(N - 1):
        a, b = map(int, input().split())
        G[a].append(b)
        G[b].append(a)

    # bfsで全経路を探索し、2部グラフの各頂点に色をつける
    def bfs():
        start = 1
        q = deque()
        q.append(start)
        distance[start] = 0

        while q:
            x = q.popleft()
            for i in G[x]:
                if distance[i] == np.inf:
                    distance[i] = distance[x] + 1
                    q.append(i)

    bfs()

    # クエリを処理する
    for i in range(Q):
        c, d = map(int, input().split())

        if abs(distance[c] - distance[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


resolve()
import sys

sys.setrecursionlimit(10**5)  # 上限設定

N, Q = map(int, input().split())
tmpA = [list(map(int, input().split())) for _ in range(N - 1)]
A = [a[0] for a in tmpA]
B = [a[1] for a in tmpA]
tmpB = [list(map(int, input().split())) for _ in range(Q)]
C = [b[0] for b in tmpB]
D = [b[1] for b in tmpB]
"""変数初期化"""
route = []
dep = []
"""リスト系初期化"""
for _ in range(N):
    route.append([])
    dep.append(0)
"""ルートの初期化"""
for i in range(N - 1):
    route[A[i] - 1].append(B[i] - 1)
    route[B[i] - 1].append(A[i] - 1)


def dfs(x, parent=-1):
    """深さ優先探索"""
    for i in route[x]:
        if (i == parent):
            continue
        dep[i] = dep[x] + 1
        dfs(i, x)


dfs(0)

for i in range(Q):
    if ((dep[C[i] - 1] + dep[D[i] - 1]) % 2 == 0):
        print("Town")
    else:
        print("Road")
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
import math
import bisect
import random
from itertools import permutations, accumulate, combinations, product
import sys
import string
from bisect import bisect_left, bisect_right
from math import factorial, ceil, floor
from operator import mul
from functools import reduce

sys.setrecursionlimit(2147483647)
INF = 10**13


def LI():
    return list(map(int, sys.stdin.buffer.readline().split()))


def I():
    return int(sys.stdin.buffer.readline())


def LS():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()


def S():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8')


def IR(n):
    return [I() for i in range(n)]


def LIR(n):
    return [LI() for i in range(n)]


def SR(n):
    return [S() for i in range(n)]


def LSR(n):
    return [LS() for i in range(n)]


def SRL(n):
    return [list(S()) for i in range(n)]


def MSRL(n):
    return [[int(j) for j in list(S())] for i in range(n)]


mod = 1000000007


class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(int, input().split())
    G[x - 1] += [y - 1]
    G[y - 1] += [x - 1]

lca = LCA(G)
for _ in range(Q):
    c, d = map(int, input().split())
    common = lca.get(c - 1, d - 1)
    #頂点 a , b a,b を結ぶパスは、 c = l c a ( a , b ) c=lca(a,b) として、 a a から c c までは木を遡上し、
    # c c から b b まで下ることとなる。 根から各頂点への距離 d i s t [ v ] depth[v] を記録しておけば、
    # 簡単な計算で2点間距離を求めることができる。
    # depth[a]+depth[b]−2depth[c] 「 a a から根まで遡上し、根から b b まで下る、という経路の内、根～ c c の往復分が無駄である」と考えるとよい。
    if (lca.depth[c - 1] + lca.depth[d - 1] - 2 * lca.depth[common]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

MAXX = 10**6 + 1
sys.setrecursionlimit(MAXX)
input = sys.stdin.readline


class SegTree:  #1-indexセグ木
    def __init__(self, init_val, segfunc, ide_ele):
        """
        init_val: 配列の初期値
        segfunc: 区間にしたい操作
        ide_ele: default値
        """
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # 配列の値を葉にセット
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # 構築していく
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res


N, Q = map(int, input().split())
adj = [[] for _ in range(N + 2)]
for i in range(N - 1):
    a, b = map(int, input().split())
    adj[a].append(b)
    adj[b].append(a)

label = []
lvl = []
id = [0] * (N + 2)
count = 0


def dfs(v, parent, depth):
    global count
    count += 1
    label.append(v)
    lvl.append(depth)
    if id[v] <= 0:
        id[v] = count
    for u in adj[v]:
        if u == parent: continue
        dfs(u, v, depth + 1)
        count += 1
        label.append(v)
        lvl.append(depth)


dfs(1, 0, 0)
# #lcaを計算するため、訪れる順のstackをセグメント木に入れる
# treeid = []
# for v in label:
#     treeid.append(id[v]) #ノードIDから訪れる順に変換して格納
# tree = SegTree(treeid, min, MAXX)
#print(treeid)
for _ in range(Q):
    u, v = map(int, input().split())
    ll, rr = id[u] - 1, id[v] - 1  #ノードIDから訪れる順に変換
    # if ll > rr: ll, rr = rr, ll
    # lca_id = tree.query(ll, rr+1) #その区間の最小値がLCA
    # lca = label[lca_id-1] #LCAノードのID
    dist = lvl[ll] + lvl[rr]  #- 2*lvl[id[lca]-1]
    #print(u, v, lca, dist)
    if dist & 0x01 == 0:
        print('Town')
    else:
        print('Road')
(N, _), *r = [map(int, s.split()) for s in open(0)]
G = [[] for _ in range(N + 1)]
V = [1] * -~N
V[1] = 0
q = [1]
for a, b in r[:N - 1]:
    G[a] += b,
    G[b] += a,
while q:
    i = q.pop()
    for j in G[i]:
        if V[j] > 0:
            V[j] = ~V[i]
            q += j,
for c, d in r[N - 1:]:
    print('RTooawdn'[V[c] == V[d]::2])
from sys import setrecursionlimit

setrecursionlimit(10**6)


def rec(now: int, depth: int = -1):
    if this_node_depth_is_odd[now] != -1:
        return this_node_depth_is_odd[now]
    this_node_depth_is_odd[now] = depth % 2
    for n_node in edge[now]:
        if this_node_depth_is_odd[n_node] != -1:
            continue
        rec(n_node, depth + 1)
    return


N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    edge[x].append(y)
    edge[y].append(x)  # 有向グラフならこの行は消す!!

this_node_depth_is_odd = [-1] * N
rec(0)

for _ in range(Q):
    c, d = map(lambda a: int(a) - 1, input().split())
    if this_node_depth_is_odd[c] == this_node_depth_is_odd[d]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)
d = [None] * N
d[0] = 0
queue = [0]
l = 0
while l < len(queue):
    u = queue[l]
    l += 1
    for v in G[u]:
        if d[v] is None:
            d[v] = d[u] + 1
            queue.append(v)
for _ in range(Q):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    print('Town' if (d[u] + d[v]) % 2 == 0 else 'Road')
from collections import deque
from sys import stdin

readline = stdin.readline

INF = 10**15

N, Q = map(int, readline().split())

links = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, readline().split())
    links[a].append(b)
    links[b].append(a)

dp = [INF] * N
dp[0] = 0
q = deque([0])
while q:
    a = q.popleft()
    for b in links[a]:
        if dp[b] <= dp[a] + 1:
            continue
        dp[b] = dp[a] + 1
        q.append(b)

result = []
for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, readline().split())
    if abs(dp[c] - dp[d]) % 2 == 0:
        result.append('Town')
    else:
        result.append('Road')
print(*result, sep='\n')
# d
import queue

n, q = map(int, input().split())
ablist = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    ablist[a - 1].append(b - 1)
    ablist[b - 1].append(a - 1)

cdlist = []
for _ in range(q):
    c, d = map(int, input().split())
    cdlist.append([c - 1, d - 1])

# print(ablist)
# print(cdlist)
# n = 4
# q = 1
# ablist = [[1], [0, 2, 3], [1], [1]]
# cdlist = [[0, 1]]

que = queue.Queue()
color = [-1] * n
color[0] = 0  # 最初は色0
que.put(0)  # 探索リストはインデックス0から始める

while not que.empty():
    t = que.get()
    for i in ablist[t]:
        if color[i] == -1:
            # 今の色が0なら1、1なら0になる（この式こうなるのか）
            color[i] = 1 - color[t]
            # 探索すべきリストに今の街からつながってる街を加える（幅優先探索）
            que.put(i)

for c, d in cdlist:
    if color[c] == color[d]:
        ans = "Town"
    else:
        ans = "Road"
    print(ans)
import sys


def getInt():
    return map(int, sys.stdin.readline().strip().split())


def getIntList():
    return list(map(int, sys.stdin.readline().strip().split()))


def getString():
    return sys.stdin.readline().strip()


def printOne(n):
    return sys.stdout.write(str(n) + "\n")


def printList(n):
    return sys.stdout.write("".join(map(str, n)) + "\n")


n, q = getInt()
g = [[] for _ in range(n + 1)]
#print(g)
for _ in range(n - 1):
    a, b = getInt()
    g[a].append(b)
    g[b].append(a)
now = [1]
rank = [0] * (n + 1)
check = [False] * (n + 1)
countx = 0
#print(g)
check[1] = True
while len(now) > 0:
    #print(now)
    #print("---------")
    new = []
    for x in now:
        rank[x] = countx
        for y in g[x]:
            if not check[y]:
                check[y] = True
                new.append(y)
    countx += 1
    now = new
#print(rank)
for _ in range(q):
    a, b = getInt()
    if abs(rank[a] - rank[b]) % 2 == 0: print("Town")
    else: print("Road")
import sys, re
from math import ceil, floor, sqrt, pi, factorial, gcd
from copy import deepcopy
from collections import Counter, deque
from heapq import heapify, heappop, heappush
from itertools import accumulate, product, combinations, combinations_with_replacement
from bisect import bisect, bisect_left, bisect_right
from functools import reduce
from decimal import Decimal, getcontext


def i_input():
    return int(input())


def i_map():
    return map(int, input().split())


def i_list():
    return list(i_map())


def i_row(N):
    return [i_input() for _ in range(N)]


def i_row_list(N):
    return [i_list() for _ in range(N)]


def s_input():
    return input()


def s_map():
    return input().split()


def s_list():
    return list(s_map())


def s_row(N):
    return [s_input for _ in range(N)]


def s_row_str(N):
    return [s_list() for _ in range(N)]


def s_row_list(N):
    return [list(s_input()) for _ in range(N)]


def lcm(a, b):
    return a * b // gcd(a, b)


sys.setrecursionlimit(10**6)
INF = float('inf')
MOD = 10**9 + 7
num_list = []
str_list = []


# 深さ優先探索（pypyよりpythonのほうがよい）
def dfs(i, graph, dist, depth):
    depth += 1
    for j in graph[i]:
        if dist[j] == -1:
            dist[j] = depth
            dfs(j, graph, dist, depth)


def main():
    n, q = i_map()
    graph = [[] for _ in range(n)]

    for _ in range(n - 1):
        a, b = i_map()
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)

    query = i_row_list(q)
    dist = [-1] * n
    dist[0] = 0

    dfs(0, graph, dist, 0)

    for a, b in query:
        if (dist[a - 1] + dist[b - 1]) % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
from collections import deque

N, Q = map(int, input().split())
nx = [[] for _ in range(N)]
for _ in range(N - 1):
    ai, bi = map(lambda s: int(s) - 1, input().split())
    nx[ai].append(bi)
    nx[bi].append(ai)

d = [-1] * N
d[0] = 0
q = deque([0])
while q:
    v = q.popleft()
    for nv in nx[v]:
        if d[nv] != -1:
            continue
        d[nv] = d[v] + 1
        q.append(nv)

for _ in range(Q):
    ci, di = map(lambda s: int(s) - 1, input().split())
    print('Town' if (d[ci] - d[di]) % 2 == 0 else 'Road')
from collections import deque

n, Q = map(int, input().split())
graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
query = []
for _ in range(Q):
    c, d = map(int, input().split())
    query.append((c - 1, d - 1))
dist = [-1] * n
dist[0] = 0
q = deque([0])
while q:
    node = q.popleft()
    for c_node in graph[node]:
        if dist[c_node] >= 0:
            continue
        dist[c_node] = dist[node] + 1
        q.append(c_node)
for c, d in query:
    if (dist[c] + dist[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import defaultdict

n, q = map(int, input().split())
nei_dict = defaultdict(set)
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    nei_dict[a].add(b)
    nei_dict[b].add(a)

stack = [(0, -1, 0)]
max_t = -1
max_c = -1
visited = set()
while stack:
    curr_t, prev_t, curr_c = stack.pop()
    if curr_c > max_c:
        max_t = curr_t
        max_c = curr_c
    if curr_t in visited:
        continue
    visited.add(curr_t)
    for next_t in nei_dict[curr_c]:
        if next_t == prev_t:
            continue
        stack.append((next_t, curr_t, curr_c + 1))

stack = [(max_t, -1, 0)]
depth = [0 for _ in range(n)]
visited = set()
while stack:
    curr_t, prev_t, curr_d = stack.pop()
    if curr_t in visited:
        continue
    visited.add(curr_t)
    depth[curr_t] = curr_d
    for next_t in nei_dict[curr_t]:
        if next_t == prev_t:
            continue
        stack.append((next_t, curr_t, curr_d + 1))

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if abs(depth[c] - depth[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")# InlineImporter
import os as _os
import sys as _sys
from functools import lru_cache as _lru_cache
from importlib.abc import ExecutionLoader, MetaPathFinder
from importlib.machinery import ModuleSpec


class InlineImporter(ExecutionLoader, MetaPathFinder):

    version = None
    inlined_modules = {}
    namespace_packages = False

    @classmethod
    def find_spec(cls, fullname, path=None, target=None):
        """Find a spec for a given module.
        
        Because we only deal with our inlined module, we don't have to care about path or target.
        The import machinery also takes care of fully resolving all names, so we just have to deal with the fullnames.
        """
        if fullname in cls.inlined_modules:
            # We have inlined this module, so return the spec
            ms = ModuleSpec(fullname,
                            cls,
                            origin=cls.get_filename(fullname),
                            is_package=cls.is_package(fullname))
            ms.has_location = True
            if cls.namespace_packages and ms.submodule_search_locations is not None:
                for p in _sys.path:
                    ms.submodule_search_locations.append(
                        _os.path.join(p, _os.path.dirname(ms.origin)))
            return ms

        return None

    @staticmethod
    def _call_with_frames_removed(f, *args, **kwds):
        """remove_importlib_frames in import.c will always remove sequences
        of importlib frames that end with a call to this function

        Use it instead of a normal call in places where including the importlib
        frames introduces unwanted noise into the traceback (e.g. when executing
        module code)
        """
        return f(*args, **kwds)

    @classmethod
    def create_module(cls, spec):
        """Create a module using the default machinery."""
        return None

    @classmethod
    def exec_module(cls, module):
        """Execute the module."""
        code = cls.get_code(module.__name__)
        if code is None:
            raise ImportError(
                "cannot load module {!r} when get_code() returns None".format(
                    module.__name__))
        cls._call_with_frames_removed(exec, code, module.__dict__)

    @classmethod
    @_lru_cache(maxsize=None)
    def get_filename(cls, fullname):
        """Returns the 

        Raises ImportError if the module cannot be found.
        """
        if fullname not in cls.inlined_modules:
            raise ImportError

        mod = cls.inlined_modules[fullname]
        origin = fullname
        if mod[0]:
            origin = ".".join([origin, "__init__"])
        origin = ".".join([origin.replace(".", "/"), "py"])

        return origin

    @classmethod
    @_lru_cache(maxsize=None)
    def is_package(cls, fullname):
        if fullname not in cls.inlined_modules:
            raise ImportError

        return cls.inlined_modules[fullname][0]

    @classmethod
    def get_source(cls, fullname):
        if fullname not in cls.inlined_modules:
            raise ImportError

        return cls.inlined_modules[fullname][1]

    @classmethod
    def get_code(cls, fullname):
        """Method to return the code object for fullname.

        Should return None if not applicable (e.g. built-in module).
        Raise ImportError if the module cannot be found.
        """
        source = cls.get_source(fullname)
        if source is None:
            return None
        try:
            path = cls.get_filename(fullname)
        except ImportError:
            return cls.source_to_code(source)
        else:
            return cls.source_to_code(source, path)


InlineImporter.version = '0.0.4'
InlineImporter.inlined_modules = {
    'lib.array2d':
    (False,
     "import itertools\n\n\nclass Array2dView:\n    def __init__(self, arr, i_indices, j_indices):\n        self.arr = arr\n        self.i_indices = i_indices\n        self.j_indices = j_indices\n    \n    def _get_view(self, i, j):\n        i = self.i_indices[i]\n        j = self.j_indices[j]\n        return Array2dView(self.arr, i, j)\n\n    def get_ind(self, i, j):\n        return self.i_indices[i]+self.j_indices[j]\n    \n    def __getitem__(self, index):\n        i, j = index\n        try:\n            return self.arr[self.get_ind(i,j)]\n        except TypeError:\n            return self._get_view(i, j)\n    \n    def __setitem__(self, index, value):\n        i, j = index\n        try:\n            self.arr[self.get_ind(i,j)] = value\n        except TypeError:\n            x = self._get_view(i, j)\n            for i in x.i_indices:\n                for j in x.j_indices:\n                    self.arr[i+j] = value\n    \n    def __iter__(self):\n        for i in self.i_indices:\n            for j in self.j_indices:\n                yield self.arr[i+j]\n    \n    def __reversed__(self):\n        for i in reversed(self.i_indices):\n            for j in reversed(self.j_indices):\n                yield self.arr[i+j]\n    \n    def __str__(self):\n        m = max(len(str(v)) for v in self)\n        res = ['']*len(self.i_indices)\n        row = ['']*(len(self.j_indices)+2)\n        for ri,i in enumerate(self.i_indices):\n            if ri == 0:\n                row[0] = '['\n            else:\n                row[0] = ' '\n            if ri == len(self.i_indices)-1:\n                row[-1] = ']\\n'\n            for rj,j in enumerate(self.j_indices):\n                row[rj+1] = f'{str(self.arr[i+j]):>{m+1}}'\n            res[ri] = ''.join(row)\n        return '\\n'.join(res)\n    \n    def copy(self):\n        return Array2d(len(self.i_indices), len(self.j_indices), list(self))\n\n\nclass Array2d:\n    def __init__(self, n, m, arr):\n        self.n = n\n        self.m = m\n        self.arr = arr\n    \n    @classmethod\n    def full(cls, n, m, fill_value):\n        return cls(n, m, [fill_value]*(n*m))\n    \n    @classmethod\n    def from_list(cls, lst):\n        return cls(len(lst),\n                   len(lst[0]),\n                   list(itertools.chain.from_iterable(lst)))\n    \n    def _get_view(self, i, j):\n        i = tuple(range(0, self.n*self.m, self.m))[i]\n        j = tuple(range(self.m))[j]\n        return Array2dView(self.arr, i, j)\n\n    def get_ind(self, i, j):\n        return i*self.m+j\n\n    def __getitem__(self, index):\n        try:\n            return self.arr[self.get_ind(*index)]\n        except TypeError:\n            return self._get_view(*index)\n    \n    def __setitem__(self, index, value):\n        try:\n            self.arr[self.get_ind(*index)] = value\n        except TypeError:\n            x = self._get_view(*index)\n            for i in x.i_indices:\n                for j in x.j_indices:\n                    self.arr[i+j] = value\n    \n    def __iter__(self):\n        return iter(self.arr)\n    \n    def __reversed__(self):\n        return reversed(self.arr)\n    \n    def __str__(self):\n        m = max(len(str(v)) for v in self)\n        res = ['']*self.n\n        row = ['']*(self.m+2)\n        for i in range(self.n):\n            if i == 0:\n                row[0] = '['\n            else:\n                row[0] = ' '\n            if i == self.n-1:\n                row[-1] = ']\\n'\n            for j in range(self.m):\n                row[j+1] = f'{str(self.arr[i*self.m+j]):>{m+1}}'\n            res[i] = ''.join(row)\n        return '\\n'.join(res)\n\n    def __eq__(self, other):\n        return self.arr == other.arr\n    \n    def copy(self):\n        return self.__init__(self.n, self.m, self.arr[:])\n\n    @property\n    def t(self):\n        arr = [self.arr[0]]*(len(self.arr))\n        x = 0\n        for i in range(self.n):\n            for j in range(self.m):\n                arr[j*self.n + i] = self.arr[x]\n                x += 1\n        return self.__init__(self.m, self.n, arr)\n\n\ndef get_matrix(zero, one):\n    class Matrix(Array2d):\n        def __add__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot add matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return self.__init__(self.n, self.m, [x+y for x, y in zip(self.arr, other.arr)])\n\n        def __iadd__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] += v\n\n        def __sub__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot subtract matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return self.__init__(self.n, self.m, [x-y for x, y in zip(self.arr, other.arr)])\n\n        def __isub__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] -= v\n\n        def __mul__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            return self.__init__(self.n, self.m, [x*y for x, y in zip(self.arr, other.arr)])\n\n        def __imul__(self, other):\n            if self.m != other.m or self.n != other.m:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            for i, v in enumerate(other.arr):\n                self.arr[i] *= v\n\n        def __matmul__(self, other):\n            if self.m != other.n:\n                raise ValueError(f'Cannot dot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n\n            res = self.full(self.n, other.m, zero)\n\n            for i in range(self.n):\n                for j in range(other.m):\n                    c = zero\n                    for k in range(self.m):\n                        c += self[i, k]*other[k, j]\n                    res[i, j] = c\n            return res\n\n        def __imatmul__(self, other):\n            if self.m != other.n:\n                raise ValueError(f'Cannot multiply matrices ({self.n}, {self.m}) and ({other.n}, {other.m})')\n            if self is other or self.m != other.m:\n                return self @ other\n\n            row = [zero]*self.m\n            for i in range(self.n):\n                t = i*self.m\n                for j in range(self.m):\n                    row[j] = self.arr[j+t]\n                for j in range(other.m):\n                    c = zero\n                    for k in range(self.m):\n                        c += row[k]*other[k, j]\n                    self[i, j] = c\n            return self\n\n        def __pow__(self, power, modulo=None):\n            if self.n != self.m:\n                raise ValueError('pow is supported only for square matrix')\n            k = self.n\n            res = Matrix.full(k, k, zero)\n            for i in range(k):\n                res[i, i] = one\n\n            m = self\n            while power > 0:\n                if power & 1:\n                    res @= m\n                m @= m\n                power >>= 1\n            return res\n    return Matrix\n"
     ),
    'lib.array3d':
    (False,
     'class Array3d(list):\n    def __init__(self, n, m, p, arr):\n        list.__init__(self, arr)\n        self.n = n\n        self.m = m\n        self.p = p\n        self.mp = m*p\n\n    @classmethod\n    def full(cls, n, m, p, fill_value):\n        return cls(n, m, p, [fill_value] * (n * m * p))\n\n    def get_ind(self, i, j, k):\n        return i * self.mp + j * self.p + k\n\n    def __getitem__(self, index):\n        return list.__getitem__(self, self.get_ind(*index))\n\n    def __setitem__(self, index, value):\n        list.__setitem__(self, self.get_ind(*index), value)\n'
     ),
    'lib.benchmark':
    (False,
     '\nfrom time import perf_counter as timer\ndef simple_timeit(func, repeat=1000, warmup=100):\n    for i in range(warmup):\n        func(i)\n    start = timer()\n    for i in range(repeat):\n        func(i)\n    stop = timer()\n    return stop-start\n'
     ),
    'lib.data_structure':
    (False,
     'class DisjointSet:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n\n    def find(self, x):\n        stack = []\n        parent = self.parent\n        while parent[x] != x:\n            stack.append(x)\n            x = parent[x]\n        for y in stack:\n            parent[y] = x\n        return x\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n\n        if self.rank[xr] > self.rank[yr]:\n            self.parent[yr] = xr\n        elif self.rank[xr] < self.rank[yr]:\n            self.parent[xr] = yr\n        elif xr != yr:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n\n\nclass SegmentTree:\n    """\n    演算子は要素とセットでモノイドを形成するようなものでなければならない。\n    すなわち、結合律が成り立ち単位元が存在する必要がある。(ただし単位元は添加可能)\n    """\n\n    @classmethod\n    def all_identity(cls, operator, identity, size):\n        return cls(operator, identity, [identity] * (2 << (size - 1).bit_length()))\n\n    @classmethod\n    def from_initial_data(cls, operator, identity, data):\n        size = 1 << (len(data) - 1).bit_length()\n        temp = [identity] * (2 * size)\n        temp[size:size + len(data)] = data\n        data = temp\n\n        for i in reversed(range(size)):\n            data[i] = operator(data[2 * i], data[2 * i + 1])\n        return cls(operator, identity, data)\n\n    # これ使わずファクトリーメソッド使いましょうね\n    def __init__(self, operator, identity, data):\n        self.op = operator\n        self.id = identity\n        self.data = data\n        self.size = len(data) // 2\n\n    def _interval(self, a, b):\n        a += self.size\n        b += self.size\n        ra = self.id\n        rb = self.id\n\n        data = self.data\n        op = self.op\n        while a < b:\n            if a & 1:\n                ra = op(ra, data[a])\n                a += 1\n            if b & 1:\n                b -= 1\n                rb = op(data[b], rb)\n            a >>= 1\n            b >>= 1\n        return op(ra, rb)\n\n    def __getitem__(self, i):\n        if isinstance(i, slice):\n            return self._interval(\n                0 if i.start is None else i.start,\n                self.size if i.stop is None else i.stop)\n        elif isinstance(i, int):\n            return self.data[i + self.size]\n\n    def __setitem__(self, i, v):\n        i += self.size\n        data = self.data\n        op = self.op\n        while i:\n            data[i] = v\n            v = op(data[i ^ 1], v) if i & 1 else op(v, data[i ^ 1])\n            i >>= 1\n\n    def __iter__(self):\n        return iter(self.data[self.size:])\n\n\nclass LazySegmentTree:\n    """\n    op: 区間取得クエリでreduceする際に使う演算子\n    apply: 更新則の適用\n    comp: 更新則の合成\n    \n    range_query: reduce(op, (apply(x,m) for x,m in zip(X,M)))\n    \n    満たすべき性質:\n    \n    集合X (要素)\n    op[+]: X,X -> X\n    (X, op)はモノイド\n    \n    集合M (更新則)\n    comp[*]: M,M -> M\n    (M, compose)はモノイド\n    \n    apply[f(x,m,n)]: X,M,Z+ -> X\n    (Z+は区間長)\n    \n    f(x,e_M,n) = x\n    f(x,m*n,p) = f(f(x,m,p),n,p)\n    f(x,m,p)+f(y,m,q) = f(x+y,m,p+q)\n    \n    参考: https://algo-logic.info/segment-tree/#toc_id_3\n    """\n\n    @classmethod\n    def all_identity(cls, op, op_e, comp, comp_e, apply, size):\n        size = 1 << (size - 1).bit_length()\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            [op_e] * (2 * size),\n            [comp_e] * size\n        )\n\n    @classmethod\n    def from_initial_data(cls, op, op_e, comp, comp_e, apply, data):\n        size = 1 << (len(data) - 1).bit_length()\n        temp = [op_e] * (2 * size)\n        temp[size:size + len(data)] = data\n\n        for i in reversed(range(size)):\n            temp[i] = op(temp[2 * i], temp[2 * i + 1])\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            temp,\n            [comp_e] * size\n        )\n\n    # これ使わずファクトリーメソッド使いましょうね\n    def __init__(self, op, op_e, comp, comp_e, apply, data, lazy):\n        self.op = op\n        self.op_e = op_e\n        self.comp = comp\n        self.comp_e = comp_e\n        self.apply = apply\n        self.data = data\n        self.lazy = lazy\n        self.size = len(self.data) // 2\n        self.depth = self.size.bit_length() - 1\n        self._l_indices = [0] * self.depth\n        self._r_indices = [0] * self.depth\n\n    def _update_indices(self, i, l):\n        m = i // (i & -i)\n        i >>= 1\n        for k in range(self.depth):\n            l[k] = i if i < m else 0\n            i >>= 1\n\n    def _propagate_top_down(self):\n        data = self.data\n        lazy = self.lazy\n        apply = self.apply\n        comp = self.comp\n        comp_e = self.comp_e\n        k = self.size >> 1\n\n        for i, j in zip(reversed(self._l_indices), reversed(self._r_indices)):\n            if i > 0:\n                temp = lazy[i]\n                if temp != comp_e:\n                    lazy[i] = comp_e\n                    a = i << 1\n                    b = a | 1\n                    data[a] = apply(data[a], temp, k)\n                    data[b] = apply(data[b], temp, k)\n                    if k > 1:\n                        lazy[a] = comp(lazy[a], temp)\n                        lazy[b] = comp(lazy[b], temp)\n            if i < j:\n                temp = lazy[j]\n                if temp != comp_e:\n                    lazy[j] = comp_e\n                    a = j << 1\n                    b = a | 1\n                    data[a] = apply(data[a], temp, k)\n                    data[b] = apply(data[b], temp, k)\n                    if k > 1:\n                        lazy[a] = comp(lazy[a], temp)\n                        lazy[b] = comp(lazy[b], temp)\n            k >>= 1\n\n    def _propagate_bottom_up(self):\n        data = self.data\n        op = self.op\n        for i, j in zip(self._l_indices, self._r_indices):\n            if i < j:\n                data[j] = op(data[j << 1], data[j << 1 | 1])\n            if i > 0:\n                data[i] = op(data[i << 1], data[i << 1 | 1])\n\n    def update_interval(self, l, r, m):\n        lazy = self.lazy\n        data = self.data\n        comp = self.comp\n        apply = self.apply\n\n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n        k = 1\n        while l < r:\n            if l & 1:\n                data[l] = apply(data[l], m, k)\n                if k > 1:\n                    lazy[l] = comp(lazy[l], m)\n                l += 1\n            if r & 1:\n                r -= 1\n                data[r] = apply(data[r], m, k)\n                if k > 1:\n                    lazy[r] = comp(lazy[r], m)\n            l >>= 1\n            r >>= 1\n            k <<= 1\n        self._propagate_bottom_up()\n\n    def get_interval(self, l, r):\n        data = self.data\n        op = self.op\n\n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n\n        lx = self.op_e\n        rx = self.op_e\n        while l < r:\n            if l & 1:\n                lx = op(lx, data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                rx = op(data[r], rx)\n            l >>= 1\n            r >>= 1\n        return op(lx, rx)\n\n\nclass BinaryIndexedTree:\n    def __init__(self, size):\n        self.data = [0] * (size + 1)\n        self.msb = 1 << (size.bit_length() - 1)\n\n    def _add(self, i, w):\n        i += 1\n        while i < len(self.data):\n            self.data[i] += w\n            i += i & -i\n\n    def _get_sum(self, i):\n        res = 0\n        while i > 0:\n            res += self.data[i]\n            i -= i & -i\n        return res\n\n    def __getitem__(self, i):\n        """\n        [0,i)\n        """\n        if isinstance(i, slice):\n            a = self._get_sum(len(self.data) - 1 if i.stop is None else i.stop)\n            b = self._get_sum(0 if i.start is None else i.start)\n            return a - b\n        else:\n            return 0  # fake value\n\n    __setitem__ = _add\n\n    def bisect_left(self, v):\n        """\n        return smallest i s.t v <= sum[:i]\n        """\n        i = 0\n        k = self.msb\n        l = len(self.data)\n        while k > 0:\n            i += k\n            if i < l and self.data[i] < v:\n                v -= self.data[i]\n            else:\n                i -= k\n            k >>= 1\n        return i\n\n    def bisect_right(self, v):\n        """\n        return smallest i s.t v < sum[:i]\n        """\n        i = 0\n        k = self.msb\n        l = len(self.data)\n        while k > 0:\n            i += k\n            if i < l and self.data[i] <= v:\n                v -= self.data[i]\n            else:\n                i -= k\n            k >>= 1\n        return i\n\n    bisect = bisect_right\n'
     ),
    'lib.geometry':
    (False,
     "# 凸包ライブラリ。２点以下だとエラーでる\n# ConvexHull(points, qhull_options='QJ')\n"),
    'lib.graph':
    (False,
     'import itertools\nimport heapq as hq\nfrom random import randrange, shuffle\nfrom lib.misc import min2\nfrom lib.array2d import Array2d\n\nfrom typing import Union, Iterable, Any, Tuple, List\n\nINF = 2 ** 62\n\n\nclass BaseWeightedGraph:\n\n    def __init__(self, n_vertices):\n        self.n_vertices = n_vertices\n\n    def wadj(self, v):\n        """\n        Should return an iterator of vertices adjacent to v and edge weight\n        """\n        raise NotImplementedError\n\n    def adj(self, v):\n        """\n        Should return an iterator of vertices adjacent to v\n        """\n        return (u for u, w in self.wadj(v))\n\n    @property\n    def wedges(self):\n        """\n        Return an iterator of weighted edges (u,v,w)\n        """\n        return ((v, u, w) for v in range(self.n_vertices) for u, w in self.wadj(v))\n\n    def dist(self, s, t, inf=INF):\n        return dijkstra(self, s, t, inf)[t]\n\n    def warshall_floyd(self, inf=INF):\n        dist = Array2d.full(self.n_vertices, self.n_vertices, inf)\n        for u, v, w in self.wedges:\n            dist[u, v] = w\n        for i in range(self.n_vertices):\n            dist[i, i] = 0\n        for k in range(self.n_vertices):\n            for i in range(self.n_vertices):\n                for j in range(self.n_vertices):\n                    dist[i, j] = min2(dist[i, j], dist[i, k] + dist[k, j])\n        return dist\n\n\nclass WeightedGraph(BaseWeightedGraph):\n\n    def __init__(self, n_vertices, wedges, adj, weight, ind):\n        super().__init__(n_vertices)\n        self._adj = adj\n        self._weight = weight\n        self._ind = ind\n        self._wedges = wedges\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices, edges):\n        temp = [[] for _ in range(n_vertices)]\n        for u, v, w in edges:\n            temp[u].append((v, w))\n        adj = []\n        weight = []\n        ind = []\n        for u, l in enumerate(temp):\n            ind.append(len(adj))\n            for v, w in l:\n                adj.append(v)\n                weight.append(w)\n        ind.append(len(adj))\n        return cls(n_vertices, edges, adj, weight, ind)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices, edges):\n        temp = [[] for _ in range(n_vertices)]\n        for u, v, w in edges:\n            temp[u].append((v, w))\n            temp[v].append((u, w))\n        adj = []\n        weight = []\n        ind = []\n        for u, l in enumerate(temp):\n            ind.append(len(adj))\n            for v, w in l:\n                adj.append(v)\n                weight.append(w)\n        ind.append(len(adj))\n        return cls(n_vertices, edges, adj, weight, ind)\n\n    def wadj(self, v):\n        i, j = self._ind[v], self._ind[v + 1]\n        return zip(self._adj[i:j], self._weight[i:j])\n\n    @property\n    def wedges(self):\n        return self._wedges\n\n\nclass BaseGraph(BaseWeightedGraph):\n\n    def adj(self, v):\n        """\n        Should return an iterator of vertices adjacent to v\n        """\n        raise NotImplementedError\n\n    def wadj(self, v):\n        return ((u, 1) for u in self.adj(v))\n\n    def edges(self):\n        return ((v, u) for v in range(self.n_vertices) for u, w in self.adj(v))\n\n    def bfs(self, s, t=-1):\n        """\n        Returns a list of distance. If starts contains more than one vertex, returns the shortest distance from any of them\n        """\n        dist = [-1] * self.n_vertices\n\n        if isinstance(s, int):\n            q = [s]\n            dist[s] = 0\n        else:\n            q = list(s)\n            for v in q:\n                dist[v] = 0\n        for d in range(1, self.n_vertices):\n            nq = []\n            for v in q:\n                for u in self.adj(v):\n                    if dist[u] == -1:\n                        dist[u] = d\n                        nq.append(u)\n                    if u == t:\n                        return dist\n            q = nq\n        return dist\n\n    def dist(self, s, t, inf=INF):\n        return self.bfs(s, t)[t]\n\n\nclass Graph(BaseGraph):\n\n    def __init__(self, n_vertices, edges, adj, ind):\n        super().__init__(n_vertices)\n        self._adj = adj\n        self._ind = ind\n        self.edges = edges\n\n    @classmethod\n    def from_directed_edges(cls, n_vertices, edges):\n        temp = [[] for _ in range(n_vertices)]\n        for u, v in edges:\n            temp[u].append(v)\n        adj = []\n        ind = []\n        for u, l in enumerate(temp):\n            ind.append(len(adj))\n            for v in l:\n                adj.append(v)\n        ind.append(len(adj))\n        return cls(n_vertices, edges, adj, ind)\n\n    @classmethod\n    def from_undirected_edges(cls, n_vertices, edges):\n        temp = [[] for _ in range(n_vertices)]\n        for u, v in edges:\n            temp[u].append(v)\n            temp[v].append(u)\n        adj = []\n        ind = []\n        for u, l in enumerate(temp):\n            ind.append(len(adj))\n            for v in l:\n                adj.append(v)\n        ind.append(len(adj))\n        return cls(n_vertices, edges, adj, ind)\n\n    def adj(self, v):\n        return self._adj[self._ind[v]: self._ind[v + 1]]\n\n\nclass BaseRootedTree(BaseGraph):\n\n    def __init__(self, n_vertices, root_vertex=0):\n        super().__init__(n_vertices)\n        self.root = root_vertex\n\n    def parent(self, v):\n        raise NotImplementedError\n\n    def children(self, v):\n        raise NotImplementedError\n\n    def adj(self, v):\n        if self.root == v:\n            return self.children(v)\n        return itertools.chain(self.children(v), (self.parent(v),))\n\n    @property\n    def post_order(self):\n        """\n        bottom vertices first\n        """\n        return (~v for v in self.prepost_order if v < 0)\n\n    @property\n    def pre_order(self):\n        """\n        top vertices first\n        """\n        return (v for v in self.prepost_order if v >= 0)\n\n    @property\n    def prepost_order(self):\n        """\n        if v >= 0: it\'s pre-order entry\n        otherwise: it\'s post-order entry\n        """\n        try:\n            return self._prepost_order\n        except AttributeError:\n            order = [0] * (self.n_vertices * 2)\n            stack = [~self.root, self.root]\n            i = 0\n            for i in range(self.n_vertices * 2):\n                v = stack.pop()\n                order[i] = v\n                if v >= 0:\n                    for u in self.children(v):\n                        stack.append(~u)\n                        stack.append(u)\n            self._prepost_order = order\n            return order\n\n    @property\n    def prepost_indices(self, cache=False):\n        try:\n            return self._pre_ind, self._post_ind\n        except AttributeError:\n            pre_ind = [0] * self.n_vertices\n            post_ind = [0] * self.n_vertices\n            for i, t in enumerate(self.prepost_order):\n                if t >= 0:\n                    pre_ind[t] = i\n                else:\n                    post_ind[~t] = i\n            self._pre_ind = pre_ind\n            self._post_ind = post_ind\n            return pre_ind, post_ind\n\n    def depth(self, v):\n        try:\n            return self._depth[v]\n        except AttributeError:\n            depth = [0] * (self.n_vertices)\n            l = 0\n            for k in self.prepost_order:\n                if k >= 0:\n                    depth[k] = l\n                    l += 1\n                else:\n                    l -= 1\n            self._depth = depth\n            return depth[v]\n\n    @property\n    def height(self):\n        try:\n            return self._height\n        except AttributeError:\n            self._height = max(self.depth(v) for v in range(self.n_vertices)) + 1\n            return self._height\n\n    @property\n    def doubling(self):\n        try:\n            return self._dbl\n        except AttributeError:\n            d = self.height.bit_length()\n\n            dbl = Array2d.full(self.n_vertices, d, -1)\n            for v in self.pre_order:\n                u = self.parent(v)\n                dbl[v, 0] = u\n                for i in range(d - 1):\n                    u = dbl[u, i]\n                    if u < 0:\n                        break\n                    dbl[v, i + 1] = u\n            self._dbl = dbl\n            return dbl\n\n    def ancestor_of(self, v, k):\n        dbl = self.doubling\n        if k > self.depth(v):\n            return -1\n        i = 0\n        while k:\n            if k & 1:\n                v = dbl[v, i]\n            k //= 2\n            i += 1\n        return v\n\n    def lca(self, u, v):\n        lu, lv = self.depth(u), self.depth(v)\n        if lu > lv:\n            u = self.ancestor_of(u, lu - lv)\n        else:\n            v = self.ancestor_of(v, lv - lu)\n        if u == v:\n            return u\n\n        dbl = self.doubling\n        i = dbl.m - 1\n        while True:\n            while i >= 0 and dbl[u, i] == dbl[v, i]:\n                i -= 1\n            if i < 0:\n                return dbl[u, 0]\n            u, v = dbl[u, i], dbl[v, i]\n\n    def dist(self, u, v, inf=INF):\n        return self.depth(u) + self.depth(v) - 2 * self.depth(self.lca(u, v))\n\n    def solve_rerooting(self, merge, identity, finalize):\n        """\n        merge: (T,T) -> T, (T, merge)はモノイド\n        identity: 単位元\n        finalize: (T, V, V) -> T\n\n        以下の形で書けるdpは対応可能\n        dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u), u, v)\n        ただし(u,v)は辺\n        dp[u,v]: vを根とするuを含まないような部分木についての解\n        """\n\n        dp1 = [identity] * self.n_vertices\n        dp2 = [identity] * self.n_vertices\n\n        for v in self.post_order:\n            t = identity\n            for u in self.children(v):\n                dp2[u] = t\n                t = merge(t, finalize(dp1[u], v, u))\n            t = identity\n            for u in reversed(list(self.children(v))):\n                dp2[u] = merge(t, dp2[u])\n                t = merge(t, finalize(dp1[u], v, u))\n            dp1[v] = t\n        for v in self.pre_order:\n            if v == self.root:\n                continue\n            p = self.parent(v)\n            dp2[v] = finalize(merge(dp2[v], dp2[p]), v, p)\n            dp1[v] = merge(dp1[v], dp2[v])\n        return dp1\n\n\nclass RootedTree(BaseRootedTree):\n\n    @classmethod\n    def from_edges(cls, edges, root_vertex=0):\n        rt = cls(len(edges) + 1, root_vertex)\n        adj = [[] for _ in range(rt.n_vertices)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        rt._adj = adj\n        rt._edges = edges\n        return rt\n\n    @classmethod\n    def from_parent(cls, parent, root_vertex):\n        rt = cls(len(parent), root_vertex)\n        rt._parent = parent\n        return rt\n\n    @classmethod\n    def random(cls, n_vertices, root_vertex=0):\n        parent = [-1] * n_vertices\n        vertices = list(range(root_vertex)) + list(range(root_vertex + 1, n_vertices))\n        shuffle(vertices)\n        vertices.append(root_vertex)\n        for i, v in zip(reversed(range(n_vertices)), vertices[-2::-1]):\n            parent[v] = vertices[randrange(i, n_vertices)]\n        return cls.from_parent(parent, root_vertex)\n\n    def adj(self, v):\n        try:\n            return self._adj[v]\n        except AttributeError:\n            if v == self.root:\n                return self.children(v)\n            return itertools.chain(self.children(v), (self.parent(v),))\n\n    def parent(self, v):\n        try:\n            return self._parent[v]\n        except AttributeError:\n            parent = [0] * self.n_vertices\n            parent[self.root] = -1\n            stack = [self.root]\n            for _ in range(self.n_vertices):\n                k = stack.pop()\n                p = parent[k]\n                for u in self.adj(k):\n                    if u != p:\n                        parent[u] = k\n                        stack.append(u)\n            self._parent = parent\n            return parent[v]\n\n    def children(self, v):\n        try:\n            return self._children[v]\n        except AttributeError:\n            children = [[] for _ in range(self.n_vertices)]\n            for u in range(self.n_vertices):\n                p = self.parent(u)\n                if p >= 0:\n                    children[p].append(u)\n            self._children = children\n            return children[v]\n\n    @property\n    def edges(self):\n        try:\n            return self._edges\n        except AttributeError:\n            for v in range(self.n_vertices):\n                if v != self.root:\n                    yield (v, self.parent(v))\n\n\ndef scc(graph, rgraph):\n    n = graph.n_vertices\n    order = []\n    color = [0] * n\n    for v0 in range(n):\n        if color[v0]:\n            continue\n        color[v0] = -1\n        stack = [iter(graph.adj(v0))]\n        path = [v0]\n        while path:\n            for u in stack[-1]:\n                if color[u] == 0:\n                    color[u] = -1\n                    path.append(u)\n                    stack.append(iter(graph.adj(u)))\n                    break\n            else:\n                v = path.pop()\n                order.append(v)\n                stack.pop()\n\n    label = 0\n    for v0 in reversed(order):\n        if color[v0] >= 0:\n            continue\n        color[v0] = label\n        stack = [v0]\n        while stack:\n            v = stack.pop()\n            for u in rgraph.adj(v):\n                if color[u] < 0:\n                    color[u] = label\n                    stack.append(u)\n        label += 1\n    return label, color\n\n\ndef dijkstra(graph: BaseWeightedGraph, s: Union[int, Iterable[int]], t: Union[int, Iterable[int]] = -1,\n             inf: Any = 2 ** 62) -> Tuple[List[int], Any]:\n    """\n    Returns a list of distance. If starts contains more than one vertex, returns the shortest distance from any of them.\n    """\n    K = graph.n_vertices.bit_length()\n    MASK = (1 << K) - 1\n    dist = [inf] * graph.n_vertices\n\n    if isinstance(s, int):\n        q = [s]\n        dist[s] = 0\n    else:\n        q = list(s)\n        for v in q:\n            dist[v] = 0\n    if isinstance(t, int):\n        if t < 0:\n            t = []\n        else:\n            t = [t]\n    else:\n        t = set(t)\n\n    while q:\n        x = hq.heappop(q)\n        d, v = x >> K, x & MASK\n        if v in t:\n            return dist, d\n        if d > dist[v]:\n            continue\n        for u, w in graph.wadj(v):\n            if dist[u] > d + w:\n                dist[u] = d + w\n                hq.heappush(q, ((d + w) << K) | u)\n    return dist, None\n\n\ndef max_flow(graph: BaseWeightedGraph, s, t):\n    adj: List[List[int]] = [[] for _ in range(graph.n_vertices)]\n    weight: List[List[int]] = [[] for _ in range(graph.n_vertices)]\n    edge_id: List[List[int]] = [[] for _ in range(graph.n_vertices)]\n    for i, (u, v, w) in enumerate(graph.wedges):\n        if u != v:\n            adj[u].append(v)\n            weight[u].append(w)\n            edge_id[u].append(i)\n            adj[v].append(u)\n            weight[v].append(0)\n            edge_id[v].append(i)\n\n    rev = [0]*(i+1)\n    \n\ndef max_bipartite_matching(graph: BaseWeightedGraph):\n    pass'
     ),
    'lib.itertools':
    (False,
     '# それぞれの値values[i]が最大counts[i]回入ることを許す組み合わせ\ndef combinations_without_repetition(r, iterable=None, values=None, counts=None):\n\n  if iterable:\n    values, counts = zip(*Counter(iterable).items())\n\n  f = lambda i,c: chain.from_iterable(map(repeat, i, c))\n  n = len(counts)\n  indices = list(islice(f(count(),counts), r))\n  if len(indices) < r:\n    return\n  while True:\n    yield tuple(values[i] for i in indices)\n    for i,j in zip(reversed(range(r)), f(reversed(range(n)), reversed(counts))):\n      if indices[i] != j:\n        break\n    else:\n      return\n    j = indices[i]+1\n    for i,j in zip(range(i,r), f(count(j), counts[j:])):\n      indices[i] = j\n\n\n\n# それぞれの値values[i]がcounts[i]回入る順列\n# TODO\ndef permutations_without_repetition(r, iterable=None, values=None, counts=None):\n  from itertools import chain,repeat,islice,count\n  from collections import Counter\n\n  if iterable:\n    values, counts = zip(*Counter(iterable).items())\n\n  f = lambda i,c: chain.from_iterable(map(repeat, i, c))\n  n = len(counts)\n  indices = list(islice(f(count(),counts), r))\n  if len(indices) < r:\n    return\n  yield tuple(values[i] for i in indices)\n  while True:\n    for i,j in zip(reversed(range(r)), f(reversed(range(n)), reversed(counts))):\n      if indices[i] != j:\n        break\n    else:\n      return\n    j = indices[i]+1\n    for i,j in zip(range(i,r), f(count(j), counts[j:])):\n      indices[i] = j\n    yield tuple(values[i] for i in indices)'
     ),
    'lib.misc':
    (False,
     'from typing import List, Any, Callable, Sequence, Union, Tuple, TypeVar\n\nV = TypeVar(\'V\')\n\nimport sys\nfrom functools import reduce\nfrom itertools import accumulate\nfrom lib.data_structure import BinaryIndexedTree, DisjointSet\nimport bisect\n\n\ndef general_bisect(ng: int, ok: int, judge: Callable[[int], V]) -> int:\n    """\n    一般化した二分法。一般の単調関数の根をO(log L)で見つける。\n\n    :param ng: judge(ng)==Falseとなる値\n    :param ok: judge(ok)==Trueとなる値\n    :param judge: 真偽値を返す単調関数\n    :return: judge(x)==Trueが成り立つギリギリの値\n    """\n    while abs(ng - ok) > 1:\n        m = (ng + ok) // 2\n        if judge(m):\n            ok = m\n        else:\n            ng = m\n    return ok\n\n\ndef fibonacci_search(left: int, right: int, func: Union[Callable[[int], V], Sequence], inf: V = 2 ** 60) -> Tuple[\n    V, int]:\n    """\n    フィボナッチ探索法。極小値を一つだけ持つような関数の極小値をO(log L)で見つける。\n    探索は(left, right)の範囲で行われる。\n\n    :param left: 探索範囲の左端（含まない）\n    :param right: 探索範囲の右端（含まない）\n    :param func: 被最適化関数\n    :param inf: funcの上界\n    :return: (funcの極小値, 極小値を達成するfuncの引数)\n    """\n    try:\n        func = func.__getitem__\n    except AttributeError:\n        pass\n    f1, f2 = 1, 1\n    while f1 + f2 < right - left:\n        f1, f2 = f1 + f2, f1\n    l = left\n    m1 = func(l + f2)\n    m2 = func(l + f1)\n    while f1 > 2:\n        f1, f2 = f2, f1 - f2\n        if m1 > m2:\n            l += f1\n            m1 = m2\n            m2 = func(l + f1) if l + f1 < right else inf\n        else:\n            m2 = m1\n            m1 = func(l + f2)\n    if m1 < m2:\n        return m1, l + 1\n    else:\n        return m2, l + 2\n\n\ndef max2(x: V, y: V) -> V:\n    return x if x > y else y\n\n\ndef min2(x: V, y: V) -> V:\n    return x if x < y else y\n\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\n\n\ndef rerooting(rooted_tree, merge, identity, finalize):\n    """\n    merge: (T,T) -> T, (T, merge)はモノイド\n    identity: 単位元\n    finalize: (T, V, V) -> T\n\n    以下の形で書けるdpは対応可能\n    dp[u,v] = finalize(merge(dp[v,k] for k in adj[v] if k != u), u, v)\n    ただし(u,v)は辺 u->v\n    """\n    N = rooted_tree.n_vertices\n    parent = rooted_tree.parent\n    children = rooted_tree.children\n    order = rooted_tree.dfs_order\n\n    # from leaf to parent\n    dp_down = [None] * N\n    for v in reversed(order):\n        dp_down[v] = finalize(reduce(merge,\n                                     (dp_down[c] for c in children[v]),\n                                     identity), parent[v], v)\n\n    # from parent to leaf\n    dp_up = [None] * N\n    dp_up[0] = identity\n    for v in order:\n        if len(children[v]) == 0:\n            continue\n        temp = (dp_up[v],) + tuple(dp_down[u] for u in children[v]) + (identity,)\n        left = accumulate(temp[:-2], merge)\n        right = tuple(accumulate(reversed(temp[2:]), merge))\n        for u, l, r in zip(children[v], left, reversed(right)):\n            dp_up[u] = finalize(merge(l, r), u, v)\n\n    res = [None] * N\n    for v, l in enumerate(children):\n        res[v] = reduce(merge,\n                        (dp_down[u] for u in children[v]),\n                        identity)\n        res[v] = merge(res[v], dp_up[v])\n    return res, dp_up, dp_down\n\n\ndef longest_increasing_sequence(l, inf):\n    dp = [inf] * len(l)\n    for i, v in enumerate(l):\n        dp[bisect.bisect(dp, v)] = i\n\n    m = next(n for n in reversed(range(len(l))) if dp[n] < inf) + 1\n    return m\n\n\ndef zeta(data, merge):\n    """\n    （この関数はdataを上書きします）\n    Mはモノイド\n    data: 2^n -> M\n    output: 2^n -> M\n    merge: M -> M\n \n    ouput[i] = sum(data[j] for j in range(2^n) if i|j == i)\n    """\n    n = len(data)\n    while i < n:\n        j = i\n        while j < n:\n            data[j] = merge(data[j], data[j & ~i])\n            j = (j + 1) | i\n        i <<= 1\n    return data\n\n\ndef check_bipartiteness(n_vertices, edges):\n    ds = DisjointSet(2 * n_vertices)\n\n    for a, b in edges:\n        ds.union(a, b + n_vertices)\n        ds.union(b, a + n_vertices)\n\n    next_color = 0\n    color = [-1] * (2 * n_vertices)\n    for v in range(n_vertices):\n        ra = ds.find(v)\n        rb = ds.find(v + n_vertices)\n        if ra == rb:\n            return None\n        if color[ra] < 0:\n            color[ra] = next_color\n            color[rb] = next_color + 1\n            next_color += 2\n        color[v] = color[ra]\n        color[v + n_vertices] = color[rb]\n    return color[:n_vertices]\n\n\ndef small_range_duplicate(a):\n    MASK = (1 << 32) - 1\n    n = len(a)\n    left = [i - 1 for i in range(n + 1)]\n    right = [i + 1 for i in range(n + 1)]\n\n    sorted_ind = sorted((~v << 32) | i for i, v in enumerate(a))\n    t = 0\n    vi = sorted_ind[t]\n    i = vi & MASK\n    v = ~(vi >> 32)\n    while t < n:\n        j = i\n        l = left[i]\n        pi = l\n        pv = v\n        while v == pv and left[i] == pi:\n            pi = i\n            t += 1\n            if t >= n:\n                break\n            vi = sorted_ind[t]\n            i = vi & MASK\n            v = ~(vi >> 32)\n        r = right[pi]\n        right[l] = r\n        while j <= pi:\n            nj = right[j]\n            left[j] = l\n            right[j] = r\n            j = nj\n        left[r] = l\n\n    return left, right\n\n\ndef small_range(a):\n    N = len(a)\n    MASK = (1 << 32) - 1\n    left = [i - 1 for i in range(N + 1)]\n    right = [i + 1 for i in range(N + 1)]\n    sorted_ind = sorted((~v << 32) | i for i, v in enumerate(a))\n    for v in sorted_ind:\n        i = v & MASK\n        left[right[-i]] = left[-i]\n        right[left[-i]] = right[-i]\n\n    return left, right\n\n\ndef popcnt32(n):\n    n = n - ((n >> 1) & 0x55555555)\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n    return ((((n + (n >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24) & 0xff\n\n\ndef popcnt64(n):\n    n = n - ((n >> 1) & 0x5555555555555555)\n    n = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333)\n    n = (n + (n >> 4)) & 0x0f0f0f0f0f0f0f0f\n    return ((((n + (n >> 32)) & 0xffffffff) * 0x01010101) >> 24) & 0xff\n\n\ndef popcnt(n):\n    if n < 1 << 32:\n        return popcnt32(n)\n    elif n < 1 << 64:\n        return popcnt64(n)\n    else:\n        return sum(c == \'1\' for c in bin(n))\n\n\ndef reverse_bits32(x):\n    x = ((x & 0x55555555) << 1) | ((x & 0xAAAAAAAA) >> 1)\n    x = ((x & 0x33333333) << 2) | ((x & 0xCCCCCCCC) >> 2)\n    x = ((x & 0x0F0F0F0F) << 4) | ((x & 0xF0F0F0F0) >> 4)\n    x = ((x & 0x00FF00FF) << 8) | ((x & 0xFF00FF00) >> 8)\n    return ((x & 0x0000FFFF) << 16) | ((x & 0xFFFF0000) >> 16)\n\n\ndef count_inversions(l: List[Any]) -> int:\n    """\n    転倒数を計算する。in-placeでソートもする。\n\n    :param l: リスト\n    :return: 転倒数\n    """\n    bit = BinaryIndexedTree(len(l))\n    res = 0\n    for i, v in enumerate(l):\n        bit[v] += 1\n        res += bit[v + 1:]\n    return res\n\n\nclass BinaryTrie:\n    class Node:\n        def __init__(self):\n            self.zero = None\n            self.one = None\n            self.cnt = 0\n\n    def __init__(self, bits):\n        self.root = self.Node()\n        self.bits = bits\n\n    def add(self, v):\n        n = self.root\n        n.cnt += 1\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                if not n.one:\n                    n.one = self.Node()\n                n = n.one\n            else:\n                if not n.zero:\n                    n.zero = self.Node()\n                n = n.zero\n            n.cnt += 1\n\n    def remove(self, v):\n        n = self.root\n        n.cnt -= 1\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                n = n.one\n            else:\n                n = n.zero\n            n.cnt -= 1\n\n    def find_argminxor(self, v):\n        n = self.root\n        r = 0\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                if n.one and n.one.cnt > 0:\n                    n = n.one\n                    r |= 1 << d\n                else:\n                    n = n.zero\n            else:\n                if n.zero and n.zero.cnt > 0:\n                    n = n.zero\n                else:\n                    n = n.one\n                    r |= 1 << d\n        return r\n\n    def __contains__(self, v):\n        n = self.root\n        for d in reversed(range(self.bits)):\n            if (v >> d) & 1:\n                n = n.one\n            else:\n                n = n.zero\n            if not n or n.cnt == 0:\n                return False\n        return True\n'
     ),
    'lib.modint':
    (False,
     "from importlib.util import find_spec, module_from_spec\n\nmodints = {}\n\n\ndef get_modint(mod):\n    try:\n        return modints[mod]\n    except KeyError:\n        spec = find_spec('lib._modint')\n        module = module_from_spec(spec)\n        module.__dict__['MOD'] = mod\n        spec.loader.exec_module(module)\n        modints[mod] = module.ModInt\n        return modints[mod]"
     ),
    'lib.number_theory':
    (False,
     'from collections import Counter, defaultdict\nfrom math import sqrt, ceil, gcd\nfrom itertools import count\nfrom typing import Tuple\n\n\ndef sign(x):\n    return int(x > 0) - int(x < 0)\n\n\ndef egcd(a: int, b: int) -> Tuple[int,int,int]:\n    """\n    拡張ユークリッド法\n\n    :param a: 係数\n    :param b: 係数\n    :return: (x, y, gcd(a,b)). x, yはax+by=gcd(a,b)を満たす\n    """\n    s,ps,r,pr = 0,1,b,a\n    while r != 0:\n        q = pr//r\n        pr,r = r,pr-q*r\n        ps,s = s,ps-q*s\n    t = (pr-ps*a)//b\n    if pr > 0:\n        return ps, t, pr\n    return -ps, -t, -pr\n\n\ndef modinv(x: int, mod: int) -> int:\n    """\n    Z/(mod Z)上でのxの逆元\n\n    :param x: 整数\n    :param mod: 整数\n    :return: x * y % mod = 1を満たすy\n    """\n    s,ps,r,pr = 0,1,mod,x\n    while r != 0:\n        pr, (q, r) = r, divmod(pr, r)\n        ps, s = s, ps-q*s\n    if pr == 1:\n        return ps if ps >= 0 else ps + mod\n    raise ValueError("base is not invertible for the given modulus")\n\n\ndef modpow(x, k, mod):\n    """\n    Z/(mod Z)上でのxのk乗\n\n    :param x: 整数\n    :param k: 整数\n    :param mod: 整数\n    :return: x ** k % mod\n    """\n    if k < 0:\n        x = modinv(x, mod)\n        k = -k\n    r = 1\n    while k != 0:\n        if k & 1:\n            r = (r*x)%mod\n        x = (x*x)%mod\n        k >>= 1\n    return r\n\n# 素因数分解\ndef prime_factors(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            yield i\n    if n > 1:\n        yield n\n\ndef int_product(iterable):\n    x = 1\n    for y in iterable:\n        x *= y\n    return x\n\n# 約数列挙（O(sqrt(n))かかる）\ndef divisors(n):\n    for i in range(1,ceil(sqrt(n))+1):\n        j, r = divmod(n, i)\n        if not r:\n            yield i\n            if i != j:\n                yield j\n\n# 素数生成器\ndef generate_primes():\n    D = defaultdict(list)\n\n    q = 2\n    for q in count(2):\n        if q in D:\n            for p in D[q]:\n                D[p+q].append(p)\n            del D[q]\n        else:\n            yield q\n            D[q*q].append(q)\n\n\ndef totient_factors(n):\n    def it():\n        prev = -1\n        for p in prime_factors(n):\n            if p == prev:\n                yield p\n            else:\n                prev = p\n                for q in prime_factors(p - 1):\n                    yield q\n    return it()\n\n\ndef primitive_root(mod, phi_factors=None):\n    if phi_factors is None:\n        phi_factors = tuple(totient_factors(mod))\n    phi = int_product(phi_factors)\n    primes = set(phi_factors)\n    for i in range(2, mod):\n        for p in primes:\n            if modpow(i, (phi // p), mod) == 1:\n                break\n        else:\n            return i\n    else:\n        raise ValueError(f\'There is no primitive root for modulo {mod}\')\n\n\ndef lcm(nums):\n    m = 1\n    for n in nums:\n        m *= n//gcd(m,n)\n    return m\n\n\ndef chinese_remainder_theorem(reminders, mods, mods_lcm=-1):\n    """\n    returns x and lcm(reminders) s.t.\n    all(x%m == r for r,m in zip(reminders,mods))\n    """\n    s = 0\n    if mods_lcm < 0:\n        mods_lcm = lcm(mods)\n    for m,r in zip(mods, reminders):\n        p = mods_lcm//m\n        s += r * p * pow(p, -1, m)\n        s %= mods_lcm\n    return s, mods_lcm\n\n\ndef factorials_with_inv(k, mod):\n    """\n    0! ... k! とそれらのmod逆元を求めて返す\n    PyPyだとpowが動かないので注意！！！\n    """\n    fac = [1]*(k+1)\n    inv = [1]*(k+1)\n    t = 1\n    for i in range(1,k+1):\n        t = (t*i) % mod\n        fac[i] = t\n    t = modinv(t, mod)\n    for i in reversed(range(1,k+1)):\n        inv[i] = t\n        t = (t*i) % mod\n    return fac, inv\n\ndef extended_lucas_theorem(mod):\n    """\n    Returns a function (n,m) -> C(n,m)%mod\n    """\n    factors = tuple((p, q, p**q) for p,q in Counter(prime_factors(mod)).items())\n    facs = [[0]*k for p,q,k in factors]\n    invs = [[0]*k for p,q,k in factors]\n    for (p,q,k),fac,inv in zip(factors,facs,invs):\n        t = 1\n        for n in range(k):\n            if n % p != 0:\n                t *= n\n                t %= k\n            fac[n] = t\n        t = modinv(t, k)\n        for n in reversed(range(k)):\n            inv[n] = t\n            if n % p != 0:\n                t *= n\n                t %= k\n    \n    def helper(n, m):\n        l = n - m\n        if l < 0:\n            return 0\n        def reminders():\n            for (p,q,k),fac,inv in zip(factors,facs,invs):\n                a,b,c,e0,eq,i,r = n,m,l,0,-2,1,1\n                while a > 0:\n                    r *= fac[a%k]*inv[b%k]*inv[c%k]\n                    r %= k\n                    a,b,c = a//p,b//p,c//p\n                    if i == q:\n                        eq = e0\n                    e0 += a-b-c\n                    i += 1\n                if eq >= 0:\n                    eq += e0\n                if e0 >= q:\n                    r = 0\n                else:\n                    r *= p**e0\n                    r %= k\n                    if not (p == 2 and q >= 3) and (eq%2 == 1):\n                        r = -r\n                yield r\n        return chinese_remainder_theorem(reminders(), (m for _,_,m in factors), mod)[0]\n    return helper\n\n\ndef lucas_theorem(m,n,mod,comb):\n    cnt = 1\n    while n > 0:\n        m,mr = divmod(m,mod)\n        n,nr = divmod(n,mod)\n        if mr < nr:\n            return 0\n        cnt *= comb[mr][nr]\n        cnt %= mod\n    return cnt\n\n# C(n,m) is even iff (~n&m)>0\n\ndef floor_linear_sum(n,m,a,b):\n    """\n    returns sum((a*i+b)//m for i in range(n))\n    """\n    if b < 0:\n        t = (-b-1)//m+1\n        b += m*t\n        res = -t*n\n    else:\n        res = 0\n    while True:\n        if a >= m:\n            res += (n-1)*n*(a//m)//2\n            a %= m\n        if b >= m:\n            res += n * (b//m)\n            b %= m\n\n        y_max = (a*n+b)//m\n        if y_max == 0:\n            return res\n        nx_max = b - y_max*m\n        res += (n + nx_max//a)*y_max\n        n,m,a,b = y_max, a, m, nx_max%a\n'
     ),
    'lib.transform':
    (False,
     "from cmath import rect, pi\nfrom lib.misc import reverse_bits32\nfrom lib.number_theory import totient_factors, primitive_root, modinv, modpow\n\n\ndef fft(a, inverse=False):\n    one = complex(1.0)\n    n = (len(a) - 1).bit_length()\n    m = 2 ** n\n    a += [complex(0.0)] * (m - len(a))\n    pows = [rect(1.0, (-pi if inverse else pi) / (2 ** (n - 1)))]\n    for _ in range(n-1):\n        pows.append(pows[-1] ** 2)\n    pows.reverse()\n\n    shift = 32 - n\n    for i in range(m):\n        j = reverse_bits32(i) >> shift\n        if i < j:\n            a[i], a[j] = a[j], a[i]\n\n    for i in range(m):\n        b = 1\n        for w1 in pows:\n            if not i & b:\n                break\n            i ^= b\n            w = one\n            while not i & b:\n                s = a[i]\n                t = a[i | b] * w\n                a[i] = s + t\n                a[i | b] = s - t\n                w *= w1\n                i += 1\n            i ^= b\n            b <<= 1\n    if inverse:\n        c = 1 / m\n        for i in range(m):\n            a[i] *= c\n    return a\n\n\ndef ntt(a, mod, inverse=False):\n    if type(a[0]) is not int:\n        for i,v in enumerate(a):\n            a[i] = int(v)\n    n = (len(a) - 1).bit_length()\n    d2 = 0\n    r = 1\n    phi_factors = tuple(totient_factors(mod))\n    for p in phi_factors:\n        if p == 2:\n            d2 += 1\n        else:\n            r *= p\n    if d2 < n:\n        raise ValueError(f'Given array is too long: modulo {modint.mod} only support array length up to {2 ** d2}')\n\n    pr = primitive_root(mod, phi_factors)\n    if inverse:\n        pr = modinv(pr, mod)\n    pows = [modpow(pr, r * 2 ** (d2 - n), mod)]\n    for _ in range(n - 1):\n        pows.append(pows[-1] ** 2 % mod)\n    pows = tuple(reversed(pows))\n\n    m = 2 ** n\n    a += [0] * (m - len(a))\n\n    shift = 32 - n\n    for i in range(m):\n        j = reverse_bits32(i) >> shift\n        if i < j:\n            a[i], a[j] = a[j], a[i]\n\n    for i in range(m):\n        b = 1\n        for w1 in pows:\n            if not i & b:\n                break\n            i ^= b\n            w = 1\n            while not i & b:\n                j = i | b\n                s = a[i] % mod\n                t = a[j] * w % mod\n                a[i] = s + t\n                a[j] = s - t\n                w = (w * w1) % mod\n                i += 1\n            i ^= b\n            b <<= 1\n\n    if inverse:\n        c = modinv(m, mod)\n        for i, v in enumerate(a):\n            a[i] = (v * c) % mod\n    return a"
     ),
    'lib._modint':
    (False,
     'from lib.number_theory import modinv, modpow\n\nclass ModInt(int):\n    mod = MOD\n\n    def __new__(cls, n, f=1):\n        return int.__new__(cls, n % MOD if f else n)\n\n    def __neg__(self):\n        return ModInt(MOD - int(self) if self != 0 else 0, 0)\n\n    def __add__(self, other):\n        x = int(self) + int(other)\n        return ModInt(x if x < MOD else x - MOD, 0)\n\n    def __sub__(self, other):\n        x = int(self) - int(other)\n        return ModInt(x if x >= 0 else x + MOD, 0)\n\n    def __rsub__(self, other):\n        x = int(other) - int(self)\n        return ModInt(x if x >= 0 else x + MOD, 0)\n\n    def __mul__(self, other):\n        return ModInt(int(self) * int(other))\n\n    def __matmul__(self, other):\n        return ModInt(reduce(int(self) * int(other)), 0)\n\n    def __truediv__(self, other):\n        return self * ModInt(other).inv\n\n    def __rtruediv__(self, other):\n        return self.inv * other\n\n    __radd__ = __add__\n    __rmul__ = __mul__\n    __rmatmul__ = __matmul__\n\n    def __pow__(self, other, **kwargs):\n        return modpow(int(self), int(other), MOD)\n\n    @property\n    def inv(self):\n        return ModInt(modinv(int(self), MOD), 0)'
     ),
    'lib': (True, ''),
}
_sys.meta_path.insert(2, InlineImporter)

# Entrypoint
from lib.graph import RootedTree

n, q = map(int, input().split())
edges = [
    tuple(map(lambda x: int(x) - 1,
              input().split())) for _ in range(n - 1)
]

rt = RootedTree.from_edges(edges)
for _ in range(q):
    c, d = map(int, input().split())
    print('Town' if rt.dist(c - 1, d - 1) % 2 == 0 else 'Road')
# D - Collision
from collections import defaultdict
from collections import deque

N, Q = map(int, input().split())
edges = defaultdict(list)

for _ in range(N - 1):
    a, b = map(int, input().split())
    edges[a].append(b)
    edges[b].append(a)

dep = [-1] * (N + 1)
seen = [False] * (N + 1)

que = deque()
que.append((1, 0))

while len(que) > 0:
    v, d = que.pop()

    if not seen[v]:
        dep[v] = d
        seen[v] = True

        for e in edges[v]:
            que.append((e, d + 1))

for _ in range(Q):
    c, d = map(int, input().split())

    if (dep[c] + dep[d]) % 2 == 1:
        print('Road')
    else:
        print('Town')
#D
N, Q = map(int, input().split())
#AB=[list(map(int,input().split())) for i in range(N-1)]
#CD=[list(map(int,input().split())) for i in range(Q)]
AB = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    AB[a].append(b)
    AB[b].append(a)

from collections import deque
#print(AB)


def tree_length(x, n, graph):
    #頂点xから全頂点への距離をはかる。0-indexed
    #木は[[1,2],[0,3],...]のような形で与える
    dist = [-1] * n
    dist[x] = 0
    check = [False] * n
    dq = deque([x])
    for i in range(n):
        while len(dq) > 0:
            s = dq.popleft()
            check[s] = True
            for j in range(len(graph[s])):
                if check[graph[s][j]] == False:
                    dq.append(graph[s][j])
                if dist[graph[s][j]] == -1:
                    dist[graph[s][j]] = dist[s] + 1
    return dist


TL = tree_length(0, N, AB)
for i in range(Q):
    l, r = map(int, input().split())
    l -= 1
    r -= 1
    if (TL[l] + TL[r]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque


class LCA:
    "0-indexed"

    __slots__ = ["depth", "ancestor"]

    def __init__(self, adj):
        N = len(adj)
        parent = [-1] * N
        self.depth = [0] * N
        q = deque([0])
        while q:
            node = q.popleft()
            for next_node in adj[node]:
                if parent[node] != next_node:
                    parent[next_node] = node
                    q.append(next_node)
                    self.depth[next_node] = self.depth[node] + 1

        self.ancestor = [parent]  #self.ancestor[k][u]はuの2**k先の祖先。
        k = 1
        while (1 << k) < N:
            anc_k = [0] * N
            for u in range(N):
                if self.ancestor[-1][u] == -1:
                    anc_k[u] = -1
                else:
                    anc_k[u] = self.ancestor[-1][self.ancestor[-1][u]]
            self.ancestor.append(anc_k)
            k += 1

    def lca(self, u, v):
        if self.depth[u] < self.depth[v]:
            u, v = v, u
        for k, bit in enumerate(
                reversed(format(self.depth[u] - self.depth[v], 'b'))):
            if bit == '1':
                u = self.ancestor[k][u]
        if u == v:
            return u
        for anc in reversed(self.ancestor):
            if anc[u] != anc[v]:
                u = anc[u]
                v = anc[v]
        return self.ancestor[0][u]

    def dist(self, u, v):
        w = self.lca(u, v)
        return self.depth[u] + self.depth[v] - 2 * self.depth[w]


def main():
    import sys
    input = sys.stdin.buffer.readline

    N, Q = map(int, input().split())
    adj = [[] for _ in range(N)]
    for _ in range(N - 1):
        u, v = map(int, input().split())
        u -= 1
        v -= 1
        adj[u].append(v)
        adj[v].append(u)

    lca = LCA(adj)
    for _ in range(Q):
        u, v = map(int, input().split())
        u -= 1
        v -= 1
        print("Road" if lca.dist(u, v) % 2 else "Town")


if __name__ == "__main__":
    main()
import sys

input = sys.stdin.readline

N, Q = map(int, input().split())
EDGELIST = [[] for i in range(N)]

for i in range(N - 1):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    EDGELIST[x].append(y)
    EDGELIST[y].append(x)

# LCA(オイラーツアー＋Segment tree)

DEPTH = [-1] * (N + 1)
DEPTH[1] = 0

from collections import deque

QUE = deque([1])
QUE2 = deque()
EULER = []  # (i,j)で,(1からツアーで辿った点の深さ,そのindex)

USED = [0] * (N + 1)
while QUE:
    x = QUE.pop()
    EULER.append((DEPTH[x], x))
    if USED[x] == 1:
        continue
    for to in EDGELIST[x]:

        if USED[to] == 0:
            DEPTH[to] = DEPTH[x] + 1
            QUE2.append(to)
        else:
            QUE.append(to)
    QUE.extend(QUE2)
    QUE2 = deque()

    USED[x] = 1

MINP = [1 << 30] * (N + 1)
MAXP = [-1] * (N + 1)

for ind, (depth, p) in enumerate(EULER):
    MINP[p] = min(MINP[p], ind)
    MAXP[p] = max(MAXP[p], ind)

LEN = len(EULER)

seg_el = 1 << (LEN.bit_length())  # Segment treeの台の要素数
SEG = [(1 << 30, 0)] * (2 * seg_el
                        )  # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化

for i in range(LEN):  # Dを対応する箇所へupdate
    SEG[i + seg_el] = EULER[i]

for i in range(seg_el - 1, 0, -1):  # 親の部分もupdate
    SEG[i] = min(SEG[i * 2], SEG[i * 2 + 1])


def update(n, x, seg_el):  # A[n]をxへ更新（反映）
    i = n + seg_el
    SEG[i] = x
    i >>= 1  # 子ノードへ

    while i != 0:
        SEG[i] = min(SEG[i * 2], SEG[i * 2 + 1])
        i >>= 1


def getvalues(l, r):  # 区間[l,r)に関するminを調べる
    L = l + seg_el
    R = r + seg_el
    ANS = (1 << 30, 0)

    while L < R:
        if L & 1:
            ANS = min(ANS, SEG[L])
            L += 1

        if R & 1:
            R -= 1
            ANS = min(ANS, SEG[R])
        L >>= 1
        R >>= 1

    return ANS


def LCA(l, r):
    return getvalues(min(MINP[l], MINP[r]), max(MAXP[l], MAXP[r]) + 1)


for queries in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    L = LCA(c, d)[1]

    if c == L or d == L:
        dist = abs(DEPTH[c] - DEPTH[d])
    else:
        dist = abs(DEPTH[c] - DEPTH[L]) + abs(DEPTH[d] - DEPTH[L])

    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import defaultdict, deque, Counter
from heapq import heapify, heappop, heappush
import math
from copy import deepcopy
from itertools import combinations, permutations, product, combinations_with_replacement
from bisect import bisect_left, bisect_right

import sys


def input():
    return sys.stdin.readline().rstrip()


def getN():
    return int(input())


def getNM():
    return map(int, input().split())


def getList():
    return list(map(int, input().split()))


def getListGraph():
    return list(map(lambda x: int(x) - 1, input().split()))


def getArray(intn):
    return [int(input()) for i in range(intn)]


mod = 10**9 + 7
MOD = 998244353
sys.setrecursionlimit(10000000)
inf = float('inf')
eps = 10**(-10)
dy = [0, 1, 0, -1]
dx = [1, 0, -1, 0]

#############
# Main Code #
#############
"""
木の問題
dcを結ぶパス
"""

N, Q = getNM()
E = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = getNM()
    E[a - 1].append([b - 1, 1])
    E[b - 1].append([a - 1, 1])


def distance(n, edges, sta):
    ignore = [-1] * N  # 距離を求めたいときはfloat('inf')にする
    ignore[sta] = 0
    pos = deque([sta])

    while len(pos) > 0:
        u = pos.popleft()
        for i in edges[u]:
            if ignore[i[0]] == -1:
                ignore[i[0]] = ignore[u] + i[1]
                pos.append(i[0])
    return ignore


dis = distance(N, E, 0)
for _ in range(Q):
    c, d = getNM()
    if (dis[c - 1] + dis[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import queue

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
# print(color)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
(n, q), *t = [map(int, t.split()) for t in open(0)]
e = [[] for _ in t + t]
for a, b in t[:n - 1]:
    e[a] += b,
    e[b] += a,
d = [1] * n + [0]
q = [n]
for v in q:
    for w in e[v]:
        q += [w] * d[w]
        d[w] = ~d[v]
for a, b in t[n - 1:]:
    print('RTooawdn'[d[a] == d[b]::2])
from collections import deque
import numpy as np


def bfs(start, links):
    queue = deque()
    queue.append((start, 0))
    ans = [None for _ in range(len(links))]
    while len(queue) > 0:
        cur, distance = queue.popleft()
        if ans[cur] is not None:
            continue
        ans[cur] = distance
        candidates = [(place, distance + 1) for place in links[cur]
                      if ans[place] is None]
        queue.extend(candidates)

    return ans


n, q = map(int, input().split())
links = [list() for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    links[a - 1].append(b - 1)
    links[b - 1].append(a - 1)

temp_distances = bfs(0, links)
start = np.argmax(temp_distances)

distances = bfs(start, links)

for _ in range(q):
    c, d = map(int, input().split())
    if (distances[c - 1] - distances[d - 1]) % 2 != 0:
        print("Road")
    else:
        print("Town")
#!/usr/bin/env python
# coding: utf-8

# In[9]:

from collections import deque

# In[24]:

N, Q = map(int, input().split())
path = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)

# In[25]:

q = deque([[0, 0]])
mylst = [-1 for _ in range(N)]
while q:
    p, c = q.pop()
    mylst[p] = c
    nxt = path[p]
    for n in nxt:
        if mylst[n] != -1:
            continue
        if c == 0:
            nc = 1
        else:
            nc = 0
        q.append([n, nc])

# In[26]:

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if mylst[c] == mylst[d]:
        print("Town")
    else:
        print("Road")

# In[ ]:
N, Q = map(int, input().split())

V = [[] * N for i in range(0, N)]

for i in range(0, N - 1):
    A, B = map(int, input().split())
    A -= 1
    B -= 1
    V[A].append([B, A])
    V[B].append([A, B])

import collections

Visited = [-1] * N
Visited[0] = 0

import copy

d = copy.deepcopy(V[0])
q = collections.deque(d)

while q:
    d = q.popleft()
    A = d[0]
    B = d[1]
    if Visited[A] != -1:
        pass
    else:
        Visited[A] = Visited[B] + 1
        for i in range(0, len(V[A])):
            q.append(V[A][i])

for i in range(0, Q):
    C, D = map(int, input().split())
    if (Visited[C - 1] + Visited[D - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    A, B = map(lambda x: int(x) - 1, input().split())
    G[A].append(B)
    G[B].append(A)
Dist = [-1] * N
Dist[0] = 0
Queue = [0]
while Queue:
    V = Queue.pop()
    for v in G[V]:
        if Dist[v] != -1: continue
        Queue.append(v)
        Dist[v] = Dist[V] + 1
for _ in range(Q):
    A, B = map(lambda x: int(x) - 1, input().split())
    print('Road' if (Dist[A] + Dist[B]) % 2 else 'Town')from collections import Counter, defaultdict
import sys
import bisect
# sys.setrecursionlimit(10 ** 5 + 10)
# input = sys.stdin.readline
from math import factorial
import heapq, bisect
import math
import itertools
from copy import deepcopy
import queue
from collections import deque
import copy

import heapq


def main():
    node_num, q_num = map(int, input().split())
    data = [list(map(int, input().split())) for i in range(node_num - 1)]
    query = [list(map(int, input().split())) for i in range(q_num)]

    node_data = defaultdict(set)

    for i in range(node_num - 1):
        a, b = data[i]
        node_data[a].add(b)
        node_data[b].add(a)

    flg = [-1 for i in range(node_num + 1)]
    now_set = set()
    now_set.add(1)
    next_set = set()
    # potiton = [set(), set()]
    # potiton[0].add(1)
    flg[1] = 0
    while now_set:
        for node_ele in now_set:
            for next_ele in node_data[node_ele]:
                if flg[next_ele] != -1:
                    continue
                next_set.add(next_ele)
                flg[next_ele] = flg[node_ele] ^ 1
        now_set = next_set
        next_set = set()

    # print(flg)

    for i in range(q_num):
        c, d = query[i]
        if flg[c] == flg[d]:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
import copy

N, Q = map(int, input().split())

tree = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    tree[a].append(b)
    tree[b].append(a)

data = [[0, 0]]

Okinawa = 0
dist = 0
visited = [False] * N

while len(data) > 0:
    pos, depth = data.pop()
    visited[pos] = True
    if dist < depth:
        dist = copy.copy(depth)
        Okinawa = copy.copy(pos)
    for nxt in tree[pos]:
        if visited[nxt] == False:
            data.append([nxt, depth + 1])

data = [[Okinawa, 0]]

dist = [0] * N

visited = [False] * N

while len(data) > 0:
    pos, depth = data.pop()
    visited[pos] = True
    dist[pos] = depth
    for nxt in tree[pos]:
        if visited[nxt] == False:
            data.append([nxt, depth + 1])

for j in range(Q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if (dist[a] - dist[b]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys, math
from collections import deque, defaultdict
import operator as op
from functools import reduce
from itertools import permutations
import heapq

# sys.setrecursionlimit(10**6)
# OneDrive\Documents\codeforces

I = sys.stdin.readline

alpha = "abcdefghijklmnopqrstuvwxyz"

mod = 10**9 + 7
"""
x_move=[-1,0,1,0,-1,1,1,-1]
y_move=[0,1,0,-1,1,1,-1,-1]
"""


def ii():
    return int(I().strip())


def li():
    return list(map(int, I().strip().split()))


def mi():
    return map(int, I().strip().split())


def ncr(n, r):
    r = min(r, n - r)
    numer = reduce(op.mul, range(n, n - r, -1), 1)
    denom = reduce(op.mul, range(1, r + 1), 1)
    return numer // denom


def isPrime(n):
    if n <= 1:
        return False
    elif n <= 2:
        return True
    else:

        for i in range(2, int(n**.5) + 1):
            if n % i == 0:
                return False
        return True


def main():
    ans = ""
    n, num_of_queries = mi()
    d = defaultdict(list)
    for i in range(n - 1):
        u, v = mi()
        d[u].append(v)
        d[v].append(u)
    tmp = []
    for q in range(num_of_queries):
        u, v = mi()
        tmp.append((u, v))

    vis = [-1] * (n + 1)

    q = deque([(1, 0)])

    vis[1] = 0

    while q:
        x = q.popleft()
        for i in d[x[0]]:
            if vis[i] == -1:
                q.append((i, x[1] + 1))
                vis[i] = x[1] + 1

    for q in tmp:
        if abs(vis[q[0]] - vis[q[1]]) % 2:
            ans += "Road\n"
        else:
            ans += "Town\n"
    print(ans)


if __name__ == '__main__':
    main()
import sys
from sys import stdin
#import numba as nb
#from numba import b1, i4, i8, f8
from collections import defaultdict
from collections import Counter
from collections import deque
import heapq
#import networkx as nx
from itertools import combinations, permutations
import math
#import numpy as np


def main(n, q, ab, cd):
    dic = {i: set() for i in range(1, n + 1)}
    for i in range(n - 1):
        dic[ab[i][0]].add(ab[i][1])
        dic[ab[i][1]].add(ab[i][0])
    leng = [-1] * n
    qu = deque()
    qu.append(1)
    leng[0] = 0
    while len(qu) > 0:
        z = qu.popleft()
        for j in dic[z]:
            if leng[j - 1] == -1:
                qu.append(j)
                leng[j - 1] = leng[z - 1] + 1
    for i in range(q):
        if (leng[cd[i][0] - 1] + leng[cd[i][1] - 1]) % 2 == 0:
            print("Town")
        else:
            print("Road")
    return


input = sys.stdin.readline
#n=int(input())
#s=input()[:-1]
#t=input()[:-1]
#s2=input()[:-1]
#s3=input()[:-1]
#s=input()[:-1]
#a=list(map(int,input().split()))
#q=int(input())
#b=list(map(int,input().split()))
#c=list(map(int,input().split()))
n, q = map(int, input().split())
#c=list(map(int,input().split()))
#b=list(map(int,input().split()))
#a=set(map(int,input().split()))
#b=set(map(int,input().split()))
ab = [None for _ in range(n - 1)]
#ddn=gen_d(n,p)
#a=list()
#c=list()
for i in range(n - 1):
    #  k=int(input())
    ab[i] = list(map(int, input().split()))
cd = [None for _ in range(q)]
#ddn=gen_d(n,p)
#a=list()
#c=list()
for i in range(q):
    #  k=int(input())
    cd[i] = list(map(int, input().split()))
#  main(k,a,n)
#  s[i]=input()[:-1]
#  u,d=map(int,input().split())
#  s.append(ddn[u][d])
#print("\n".join(list(map(str, s))))
#  a[i]=input()[:-1]
#p=[None for _ in range(50)]
#for _ in range(31):
#  p[i]=list(map(int,input().split()))
#  s[i]=input()[:-1]
#  main(input()[:-1])
#q=int(input())
#x=list(map(int,input().split()))
#n=int(input())
#f=list(map(int,input().split()))
#z=main(n,m,q,wv,x)
#b=np.array(list(map(int,input().split()))).astype(int)
#for i in range(q):
#p=list(map(int,input().spln,xyit()))
#	l,r=map(int,input().split())
#	print(z[l-1][r-1])
main(n, q, ab, cd)
from collections import deque

N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    edge[x].append(y)
    edge[y].append(x)

# seen = [0] * N
# depth_from_root = {}
depth_from_root = [-1] * N
queue = deque([(0, 0)])
while queue:
    now, depth = queue.popleft()
    # if seen[now]:
    #     continue
    if depth_from_root[now] != -1:
        continue
    # seen[now] = 1
    depth_from_root[now] = depth
    for n_node in edge[now]:
        # if seen[n_node]:
        #     continue
        if depth_from_root[n_node] != -1:
            continue
        queue.append((n_node, depth + 1))

for _ in range(Q):
    c, d = map(lambda n: int(n) - 1, input().split())

    if abs(depth_from_root[c] - depth_from_root[d]) % 2:
        print("Road")
    else:
        print("Town")
from collections import deque

N, Q = map(int, input().split())
E = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    E[a].append(b)
    E[b].append(a)

d_from_1 = [None] * (N + 1)
que = deque([(1, 0, 0)])
for _ in range(N):
    v, p, d = que.popleft()
    d_from_1[v] = d
    for u in E[v]:
        if u != p:
            que.append((u, v, d + 1))

for _ in range(Q):
    c, d = map(int, input().split())
    dist = d_from_1[c] + d_from_1[d]
    if dist % 2 == 0:
        print('Town')
    else:
        print('Road')
import queue

N, Q = list(map(int, input().split()))

next_towns = [[] for i in range(N + 1)]

for i in range(N - 1):
    a, b = list(map(int, input().split()))
    next_towns[a].append(b)
    next_towns[b].append(a)

questions = []
for i in range(Q):
    question = list(map(int, input().split()))
    questions.append(question)

que = queue.Queue()

marker = [-1] * (N + 1)
marker[1] = 1
que.put(1)

while not que.empty():
    town = que.get()

    for next_town in next_towns[town]:
        if marker[next_town] == -1:
            marker[next_town] = 1 - marker[town]
            que.put(next_town)

for i in range(Q):
    if marker[questions[i][0]] == marker[questions[i][1]]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = [int(hoge) for hoge in input().split()]
NextList = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = [int(hoge) - 1 for hoge in input().split()]
    NextList[a].append(b)
    NextList[b].append(a)
isBlack = [-1 for _ in range(N)]
BFS = deque([0])  #queue,append,popleft
isBlack[0] = 0
while BFS:
    curpos = BFS.popleft()
    curcolor = isBlack[curpos]
    for togo in NextList[curpos]:
        if isBlack[togo] == -1:
            isBlack[togo] = 1 - curcolor
            BFS.append(togo)
for q in range(Q):
    c, d = [int(hoge) for hoge in input().split()]
    if isBlack[c - 1] == isBlack[d - 1]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())

roads = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    roads[a - 1].append(b - 1)
    roads[b - 1].append(a - 1)

color = [-1] * N
color[0] = 0

que = queue.Queue()
que.put(0)

while not que.empty():
    cur = que.get()
    for next in roads[cur]:
        if color[next] == -1:
            color[next] = 0 if color[cur] else 1
            que.put(next)

for i in range(Q):
    c, d = map(int, input().split())
    print("Town" if color[c - 1] == color[d - 1] else "Road")
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]
cd = [list(map(int, input().split())) for _ in range(Q)]

G = [[] for _ in range(N + 1)]
for a, b in ab:
    G[a].append(b)
    G[b].append(a)

dp = [10**9] * (N + 1)
from collections import *

que = deque([])
que.append(1)
dp[1] = 0
while que:
    x = que.popleft()
    for nx in G[x]:
        if dp[nx] > dp[x] + 1:
            dp[nx] = dp[x] + 1
            que.append(nx)

for c, d in cd:
    if (dp[c] % 2) == (dp[d] % 2):
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
edge = [[] for _ in range(N)]

color = [-1 for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)

q = deque()

color[0] = 0
q.append(0)

while len(q) > 0:
    node = q.popleft()
    for nx in edge[node]:
        if color[nx] < 0:
            color[nx] = (color[node] + 1) % 2
            q.append(nx)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if color[c] == color[d]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())
edge = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)
# print("edge:",edge)
from collections import deque

que = deque()
depth = [-1 for i in range(n)]
# depth[0]=0
que.append((0, 0))
# print("que:",que,"depth:",depth)
while len(que) > 0:

    node, dep = que.popleft()
    depth[node] = dep
    # print("q:",q)
    # tmp=0
    # print("Q:",q)
    # t=edge(q)
    # print(t)
    # tmp=0
    for child in edge[node]:
        if depth[child] < 0:
            que.append((child, dep + 1))
        else:
            continue

for j in range(q):
    ans = 0
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    ans += depth[a] + depth[b]
    ans %= 2
    print(["Town", "Road"][ans])
N, Query = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)
depth = [-1] * N
depth[0] = 0
Q = [0]
while Q:
    at = Q.pop()
    for n in G[at]:
        if depth[n] >= 0:
            continue
        depth[n] = depth[at] + 1
        Q.append(n)
#print(depth)
for _ in range(Query):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (depth[c] + depth[d]) % 2:
        print('Road')
    else:
        print('Town')
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())
edge = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    edge[a].append(b)
    edge[b].append(a)


def dfs(vs):
    for ve in edge[vs]:
        if even_odd[ve] > -1: continue
        even_odd[ve] = even_odd[vs] ^ 1
        dfs(ve)


even_odd = [-1] * n
even_odd[0] = 0
dfs(0)

for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if even_odd[c] == even_odd[d]: print("Town")
    else: print("Road")
n, Q = map(int, input().split())
g = [[] for i in range(n)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    g[u - 1].append(v - 1)
    g[v - 1].append(u - 1)
d = [0] * n
q = [[-1, 0]]
while q:
    par, ver = q.pop()
    for to in g[ver]:
        if par == to:
            continue
        d[to] = d[ver] + 1
        q.append([ver, to])
for _ in range(Q):
    u, v = map(int, input().split())
    if (d[u - 1] + d[v - 1]) % 2:
        print("Road")
    else:
        print("Town")
from collections import deque


def DFS(now_pos):
    Q = deque()
    Q.append(now_pos)
    cost[now_pos] = 0
    check[now_pos] = True
    while len(Q) > 0:
        pos = Q.popleft()
        for to in box[pos]:
            cost[to] = cost[pos] + 1
            if check[to] == False:
                check[to] = True
                Q.append(to)


N, Q = map(int, input().split())
box = [[] * (N + 2) for _ in range(N + 2)]
for i in range(N - 1):
    a, b = map(int, input().split())
    box[a].append(b)
    box[b].append(a)

cost = [0] * (N + 2)
check = [False] * (N + 2)
DFS(1)
for i in range(Q):
    c, d = map(int, input().split())
    num = cost[d] + cost[c]
    if num % 2 == 0:
        print("Town")
    else:
        print("Road")
from sys import stdin, stdout
from collections import *
from math import ceil, floor, log, gcd


def st():
    return list(stdin.readline().strip())


def li():
    return list(map(int, stdin.readline().split()))


def mp():
    return map(int, stdin.readline().split())


def inp():
    return int(stdin.readline())


def pr(n):
    return stdout.write(str(n) + "\n")


mod = 1000000007
INF = float('inf')

n, qu = mp()
d = defaultdict(list)
for i in range(n - 1):
    a, b = mp()
    d[a].append(b)
    d[b].append(a)
dis = [0 for i in range(n + 1)]
q = deque()
q.append(1)
v = [0 for i in range(n + 1)]
maxN = int(log(n, 2))
LCA = [[-1 for i in range(maxN + 1)] for j in range(n + 1)]
while q:
    a = q.popleft()
    v[a] = 1
    for i in d[a]:
        if not v[i]:
            v[i] = 1
            LCA[i][0] = a
            q.append(i)
            dis[i] = dis[a] + 1
for j in range(1, maxN + 1):
    for i in range(1, n + 1):
        if LCA[i][j - 1] != -1:
            p = LCA[i][j - 1]
            LCA[i][j] = LCA[p][j - 1]


def LcA(a, b):
    for i in range(maxN, -1, -1):
        if LCA[a][i] != -1 and LCA[a][i] != LCA[b][i]:
            a = LCA[a][i]
            b = LCA[b][i]
    return LCA[a][0]


ans = []
Q = [li() for i in range(qu)]


def EQUAL(a, b):
    x, y = dis[a], dis[b]
    z = abs(x - y)
    if z == 0:
        return a, b
    if x > y:
        while z:
            p = int(log(z, 2))
            a = LCA[a][p]
            z -= (1 << p)
    else:
        while z:
            p = int(log(z, 2))
            b = LCA[b][p]
            z -= (1 << p)

    return a, b


for i in Q:
    a, b = i
    x, y = EQUAL(a, b)
    if x == y:
        vp = dis[a] + dis[b] - (2 * dis[y])
        if vp % 2:
            ans.append('Road')
        else:
            ans.append('Town')
        continue
    z = LcA(x, y)
    vp = dis[a] + dis[b] - (2 * dis[z])
    if vp % 2:
        ans.append('Road')
    else:
        ans.append('Town')
pr('\n'.join(ans))
N, Q = map(int, input().split())
roads_and_towns = [tuple(map(int, input().split())) for _ in range(N - 1)]
queries = [tuple(map(int, input().split())) for _ in range(Q)]

adj_list = [[] for _ in range(N)]
for u, v in roads_and_towns:
    adj_list[u - 1].append(v - 1)
    adj_list[v - 1].append(u - 1)

colors = [-1 for _ in range(N)]

from collections import deque

bfs = deque([0])
colors[0] = 0
while bfs:
    cur = bfs.popleft()

    for nbr in adj_list[cur]:
        if colors[nbr] == -1:
            colors[nbr] = 1 - colors[cur]
            bfs.append(nbr)

for u, v in queries:
    if colors[u - 1] == colors[v - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, Q = map(int, input().split())
data = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    data[a].append(b)
    data[b].append(a)
double = [[-1 for _ in range(n + 1)] for _ in range(20)]
dist = [-1] * (n + 1)
dist[1] = 0
oya = [-1] * (n + 1)
oya[1] = 1
q = deque()
q.append(1)
while q:
    now = q.pop()
    for to in data[now]:
        if dist[to] != -1:
            continue
        dist[to] = dist[now] + 1
        oya[to] = now
        q.append(to)
for i in range(n + 1):
    double[0][i] = oya[i]
for i in range(1, 20):
    for j in range(1, n + 1):
        pre = double[i - 1][j]
        double[i][j] = double[i - 1][pre]


def LCA(a, b):
    if dist[a] == dist[b]:
        at = a
        bt = b
    else:
        sa = abs(dist[a] - dist[b])
        sa_bit = bin(sa)[2:]
        sa_bit = sa_bit[::-1]
        if dist[a] > dist[b]:
            at = a
            bt = b
            for i in range(len(sa_bit)):
                if sa_bit[i] == "1":
                    at = double[i][at]
        else:
            at = a
            bt = b
            for i in range(len(sa_bit)):
                if sa_bit[i] == "1":
                    bt = double[i][bt]
    if at == bt:
        return at
    for i in range(19, -1, -1):
        if double[i][at] == double[i][bt]:
            continue
        else:
            at = double[i][at]
            bt = double[i][bt]
    lca = oya[at]
    return lca


for i in range(Q):
    a, b = map(int, input().split())
    c = LCA(a, b)
    a_b_dist = dist[a] + dist[b] - (2 * dist[c])
    if a_b_dist % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

q = queue.Queue()
color = [-1] * N
color[0] = 0
q.put(0)

while not q.empty():
    t = q.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            q.put(i)

for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
# --- calc (dist-from-root, parent) of all the nodes ---
from collections import deque


def make_dist_pares(n, gl, root=0):
    q = deque([root])
    dist_pares = [(-1, -1)] * n
    dist_pares[root] = (0, root)
    while q:
        poped = q.popleft()
        dist = dist_pares[poped][0]
        pare_node = dist_pares[poped][1]
        for next_node in gl[poped]:
            if next_node != pare_node:
                q.append(next_node)
                dist_pares[next_node] = (dist + 1, poped)
    return dist_pares


# --- doubling (for calulating the parent) ---
from math import log2


def make_doubling(n, dist_pares):
    logn = int(log2(n)) + 1
    db = [[0] * n for _ in range(logn)]
    for ni in range(n):
        db[0][ni] = dist_pares[ni][1]
    for ki in range(logn - 1):
        for ni in range(n):
            db[ki + 1][ni] = db[ki][db[ki][ni]]
    return db


# --- doubling: find the lca and dist of/between the two nodes(a,b) ---
def calc_lca_dist(n, db, dist_pares, a, b):
    logn = int(log2(n)) + 1

    dist_a = dist_pares[a][0]
    dist_b = dist_pares[b][0]
    if dist_a > dist_b:
        dist_a, dist_b = dist_b, dist_a
        a, b = b, a

    # --- for depth-a == depth-b ---
    moved_a = a
    moved_b = b
    b_up = dist_b - dist_a
    for i in range(logn):
        if b_up & (1 << i) > 0:
            moved_b = db[i][moved_b]

    # --- search LCA ---
    dist = b_up
    for i in range(logn - 1, -1, -1):
        if db[i][moved_a] != db[i][moved_b]:
            moved_a = db[i][moved_a]
            moved_b = db[i][moved_b]
            # dist += 2*pow(2,i)
            dist += 2 * (1 << i)
    if moved_a != moved_b: dist += 2
    lca = db[0][moved_b]
    return lca, dist


# n=int(input())
n, q = map(int, input().split())
gl = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    gl[a].append(b)
    gl[b].append(a)

dist_pares = make_dist_pares(n, gl, 0)
db = make_doubling(n, dist_pares)

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    lca, dist = calc_lca_dist(n, db, dist_pares, c, d)
    if dist % 2 == 0:
        print('Town')
    else:
        print('Road')
import heapq

#ちょっとでもinputを速く
import sys

input = sys.stdin.readline

#再帰上限回数をすごくふやすよ　でもpythonであんまり再帰したくないね……
import sys
import resource

sys.setrecursionlimit(1000000)

n, q = map(int, input().split())

roads = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    roads[a - 1].append(b - 1)
    roads[b - 1].append(a - 1)

visited = [False for _ in range(n)]
dist = [0] * n


def visit(start):
    hq = [(start, 0)]
    heapq.heapify(hq)
    while hq:
        point, dis = heapq.heappop(hq)
        dist[point] = dis
        visited[point] = True
        for w in roads[point]:
            if not visited[w]:
                heapq.heappush(hq, (w, dis + 1))


visit(0)
for _ in range(q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2:
        print('Road')
    else:
        print('Town')
from collections import deque

N, Q = map(int, input().split())
V = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    V[a].append(b)
    V[b].append(a)

q = deque()
q.append(1)
dp = [-1 for _ in range(N + 1)]
dp[1] = 0
while q:
    now = q.popleft()
    for nxt in V[now]:
        if dp[nxt] == -1:
            q.append(nxt)
            dp[nxt] = (dp[now] + 1) % 2

for i in range(Q):
    c, d = map(int, input().split())
    if dp[c] == dp[d]:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(2**31 - 1)
N, Q = list(map(int, input().split()))
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a] += [b]
    G[b] += [a]

prev = [None] * N
depth = [0] * N
seen = set()


def dfs(v, d):
    seen.add(v)
    depth[v] = d
    for i in G[v]:
        if i in seen: continue
        prev[i] = v
        dfs(i, d + 1)


prev[0] = 0
dfs(0, 0)

LV = (N - 1).bit_length()


def construct(prv):
    kprv = [prv]
    S = prv
    for k in range(LV):
        T = [0] * N
        for i in range(N):
            if S[i] is None:
                continue
            T[i] = S[S[i]]
        kprv.append(T)
        S = T
    return kprv


def lca(u, v, kprv, depth):
    dd = depth[v] - depth[u]
    if dd < 0:
        u, v = v, u
        dd = -dd

    # assert depth[u] <= depth[v]
    for k in range(LV + 1):
        if dd & 1:
            v = kprv[k][v]
        dd >>= 1

    # assert depth[u] == depth[v]
    if u == v:
        return u

    for k in range(LV - 1, -1, -1):
        pu = kprv[k][u]
        pv = kprv[k][v]
        if pu != pv:
            u = pu
            v = pv

    # assert kprv[0][u] == kprv[0][v]
    return kprv[0][u]


dp = construct(prev)
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    lcaid = lca(c, d, dp, depth)
    dist = depth[c] + depth[d] - depth[lcaid] * 2
    if dist % 2 == 1:
        print("Road")
    else:
        print("Town")
import sys

INF = float('inf')
#10**20,2**63,float('inf')
MOD = 10**9 + 7
MOD2 = 998244353


#from collections import defaultdict
def II():
    return int(sys.stdin.readline())


def LI():
    return list(map(int, sys.stdin.readline().split()))


def LC():
    return list(input())


def IC():
    return [int(c) for c in input()]


def MI():
    return map(int, sys.stdin.readline().split())


N, Q = MI()
Graph = [[] for _ in range(N)]
for _ in range(N - 1):
    A, B = MI()
    A -= 1
    B -= 1
    Graph[A].append(B)
    Graph[B].append(A)
Color = [0] * N  # 頂点iの色(1 or -1)


# 頂点を1と-1で塗っていく
def dfs(s, c):
    Color[s] = c  # 頂点vをcで塗る
    for t in Graph[s]:
        # 隣接している頂点が同じ色ならFalse
        if Color[t] == c:
            return False
        # 隣接している頂点がまだ塗られていないなら-cで塗る
        if Color[t] == 0 and not dfs(t, -c):
            return False
    # すべての頂点を塗れたらTrue
    return True


sys.setrecursionlimit(10**6)  #再帰関数ではコメントにしないこと！！
dfs(0, 1)
for _ in range(Q):
    C, D = MI()
    C -= 1
    D -= 1
    if (Color[C] == Color[D]):
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
path = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)
depth = [10**6] * n
depth[0] = 0
queue = deque()
queue.append(0)
while len(queue):
    num = queue.popleft()
    for i in path[num]:
        if depth[i] == 10**6:
            depth[i] = depth[num] + 1
            queue.append(i)
for i in range(q):
    c, d = map(int, input().split())
    if (depth[c - 1] - depth[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
ab = [tuple(map(int, input().split())) for _ in range(N - 1)]
cd = [tuple(map(int, input().split())) for _ in range(Q)]

connect = [[] for _ in range(N)]
for a, b in ab:
    connect[a - 1].append(b - 1)
    connect[b - 1].append(a - 1)

INF = 10**10
cost = [INF] * N

from collections import deque

cost[0] = 0
queue = deque([(cost[0], 0)])
while queue:
    c, v = queue.popleft()

    for u in connect[v]:
        if cost[u] == INF:  # u is not visited
            cost[u] = c + 1
            queue.append((c + 1, u))

# print( cost )
for c, d in cd:
    if cost[c - 1] % 2 == cost[d - 1] % 2:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline


class LcaDoubling:
    """
    links[v] = { (u, w), (u, w), ... }  (u:隣接頂点, w:辺の重み)
    というグラフ情報から、ダブリングによるLCAを構築。
    任意の2頂点のLCAおよび距離を取得できるようにする
    """
    def __init__(self, n, links, root=0):
        self.depths = [-1] * n
        self.distances = [-1] * n
        prev_ancestors = self._init_dfs(n, links, root)
        self.ancestors = [prev_ancestors]
        max_depth = max(self.depths)
        d = 1
        while d < max_depth:
            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]
            self.ancestors.append(next_ancestors)
            d <<= 1
            prev_ancestors = next_ancestors

    def _init_dfs(self, n, links, root):
        q = [(root, -1, 0, 0)]
        direct_ancestors = [-1] * (n + 1
                                   )  # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1
        while q:
            v, p, dep, dist = q.pop()
            direct_ancestors[v] = p
            self.depths[v] = dep
            self.distances[v] = dist
            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)
        return direct_ancestors

    def get_lca(self, u, v):
        du, dv = self.depths[u], self.depths[v]
        if du > dv:
            u, v = v, u
            du, dv = dv, du
        tu = u
        tv = self.upstream(v, dv - du)
        if u == tv:
            return u
        for k in range(du.bit_length() - 1, -1, -1):
            mu = self.ancestors[k][tu]
            mv = self.ancestors[k][tv]
            if mu != mv:
                tu = mu
                tv = mv
        lca = self.ancestors[0][tu]
        assert lca == self.ancestors[0][tv]
        return lca

    def get_distance(self, u, v):
        lca = self.get_lca(u, v)
        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]

    def upstream(self, v, k):
        i = 0
        while k:
            if k & 1:
                v = self.ancestors[i][v]
            k >>= 1
            i += 1
        return v


n, q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

links = [set() for i in range(n)]
for x, y in ab:
    links[x - 1].add((y - 1, 1))
    links[y - 1].add((x - 1, 1))

lcad = LcaDoubling(n, links)

for c, d in cd:
    #print(lcad.get_distance(c-1,d-1))
    dist = lcad.get_distance(c - 1, d - 1)
    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
import math
from collections import deque, Counter
from itertools import product, combinations, permutations

n, q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

G = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = ab[i][0], ab[i][1]
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1] * n
goto = deque()
root = 0

dist[root] = 0
goto.append(root)

while (goto):
    v = goto.popleft()
    for next in G[v]:
        if dist[next] != -1:
            continue
        else:
            dist[next] = dist[v] + 1
            goto.append(next)

for query in cd:
    if (dist[query[1] - 1] - dist[query[0] - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
way = [[] for _ in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    way[a].append(b)
    way[b].append(a)
query = []
for i in range(q):
    query.append(list(map(int, input().split())))

#n = 9
#q = 9
#way = [[], [9], [3], [2, 4, 7], [8, 5, 3], [6, 4], [5], [3], [4, 9], [8, 1]]
#query = [[7, 9], [2, 5], [2, 6], [4, 6], [2, 4], [5, 8], [7, 8], [3, 6], [5, 6]]

ans = []
dist = [-1] * (n + 1)
d = deque()

dist[1] = 0
d.append(1)

while d:
    p = d.popleft()
    for next in way[p]:
        if dist[next] != -1:
            continue
        d.append(next)
        dist[next] = dist[p] + 1

for i in range(q):
    if (dist[query[i][0]] - dist[query[i][1]]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
from collections import deque

bitlen = ((10**5).bit_length()) + 1
input = sys.stdin.readline  #ちょっと高速化しないときつい


def befsearch(double, start, k):  #double行列内でstartからk個前の頂点を抽出
    piv = start
    for i in range(bitlen):
        if (k >> i) & 1:
            piv = double[i][piv]
            if piv == -1:  #根の根に到達してたらbreakしないとバグる(ゆるさねぇ)(l[-1]=l[len(l)-1])
                break
    return piv


N, Q = map(int, input().split())
tree = [[] for _ in range(N)]
dirtree = [[] for _ in range(N)]
#まずnondirtreeを構成
for i in range(N - 1):
    a, b = map(int, input().split())
    tree[a - 1].append(b - 1)
    tree[b - 1].append(a - 1)
d = deque()
depth = [0] * N
d.append(0)  #0を根とする
seen = [0] * N
double = [[-1 for _ in range(N)] for _ in range(bitlen)]

#根つき木dirtreeを構成
while len(d) > 0:
    v = d.popleft()
    seen[v] = 1
    for j in tree[v]:
        if (seen[j] == 0):
            dirtree[v].append(j)
            d.append(j)
            depth[j] = depth[v] + 1
            double[0][j] = v

#double[i][j]=「根つき木の頂点jから2**i回上に遡った時の点」としてダブリング、根(0)の根として-1を設定
for i in range(1, bitlen):
    for j in range(N):
        bef = double[i - 1][j]
        if bef == -1:
            double[i][j] = -1
        else:
            double[i][j] = double[i - 1][bef]

for _ in range(Q):
    a, b = map(int, input().split())
    a = a - 1
    b = b - 1
    da = depth[a]
    db = depth[b]

    #二点からLCAに遡るために必要な距離を二分探査
    #手順
    #1.両方の深さを浅い方に揃える
    #2.(ここで0遡ると絶対祖先にならず、無限に遡ると祖先になることを考えて)
    #3.祖先になる遡り数の最小を探査すればよいということになる


    def is_ok(arg):
        #片方深いのがある時は深さを浅い方に揃えてからbefsearch
        if da > db:
            pi = befsearch(double, a, arg + (da - db))
            pj = befsearch(double, b, arg)
        else:
            pi = befsearch(double, a, arg)
            pj = befsearch(double, b, arg + (db - da))
        return (pj == pi)  #祖先になるかの真理値

    def mgr_bisect(ng, ok):
        while (abs(ok - ng) > 1):
            mid = (ok + ng) // 2
            if is_ok(mid):
                ok = mid
            else:
                ng = mid
        return ok

    num = mgr_bisect(-1, 10**5 + 10)  #浅い点から祖先に到達するまでの最小距離をbisect
    #浅い方からnumだけ遡った点がLCA
    if depth[a] < depth[b]:
        pans = befsearch(double, a, num)
    else:
        pans = befsearch(double, b, num)
    pathlength = depth[a] + depth[b] - 2 * depth[pans]
    if pathlength % 2 == 0:
        print("Town")
    else:
        print("Road")
    #print(depth[a]+depth[b]-2*depth[pans]+1)           #2点の距離は(aの深さ)+(bの深さ)-2*(aとbのLCAの深さ)であり、それに1を足したものが明らかに答え
from collections import deque

n, q = map(int, input().split())
edge = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)
dis = [float("inf") for i in range(n)]
done = [0 for i in range(n)]
dep = [float("inf") for i in range(n)]
dep[0] = 0

bfs = deque()
bfs.append([0, 0])
while bfs:
    node, depth = bfs.popleft()
    dep[node] = depth
    done[node] = 1
    for i in edge[node]:
        if not done[i]:
            bfs.append([i, depth + 1])

for _ in range(q):
    x, y = map(int, input().split())
    ans = dep[x - 1] + dep[y - 1]
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
from heapq import heappush, heappop

INF = 10**9


def dijkstra(s, n, g):
    d = [INF] * n
    d[s] = 0
    hq = [(0, s)]
    while hq:
        p = heappop(hq)
        v = p[1]
        if d[v] < p[0]:
            continue
        for to, cost in g[v]:
            if d[to] > d[v] + cost:
                d[to] = d[v] + cost
                heappush(hq, (d[to], to))
    return d


n, q = map(int, input().split())
g = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append([b - 1, 1])
    g[b - 1].append([a - 1, 1])

dij = dijkstra(0, n, g)

for i in range(q):
    c, d = map(int, input().split())
    if (dij[c - 1] + dij[d - 1]) & 1:
        print("Road")
    else:
        print("Town")
from sys import setrecursionlimit

setrecursionlimit(10**7)

N, Q = [int(x) for x in input().split()]
to = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = [int(x) - 1 for x in input().split()]
    to[a].append(b)
    to[b].append(a)

depth = [-1] * N


def dfs(v, p, d):
    depth[v] = d
    for u in to[v]:
        if u == p: continue
        dfs(u, v, d + 1)


dfs(0, -1, 0)

for _ in range(Q):
    c, d = [int(x) - 1 for x in input().split()]
    ans = (depth[c] - depth[d]) % 2
    print('Road' if ans else 'Town')
import sys

input = sys.stdin.readline  # "\n"を含む


def solve(N, Q, Edge, Query):
    L = [[] * (N + 1) for _ in range(N + 1)]
    for a, b in Edge:
        L[a].append(b)
        L[b].append(a)

    Group = [0] * (N + 1)

    def dfs(start=1):
        par = [-1] * (N + 1)
        stack = [start]

        while stack:
            u = stack.pop()
            p = par[u]
            temp = Group[u] ^ 1
            for v in L[u]:
                if v == p: continue
                par[v] = u
                Group[v] = temp
                if len(L[v]) != 1:
                    stack.append(v)

    dfs()

    res = []
    for c, d in Query:
        if Group[c] == Group[d]:
            res.append("Town")
        else:
            res.append("Road")

    return res


def main():
    N, Q = map(int, input().split())
    Edge = [tuple(map(int, input().split())) for _ in range(N - 1)]
    Query = [tuple(map(int, input().split())) for _ in range(Q)]
    res = solve(N, Q, Edge, Query)
    print(*res, sep="\n")


if __name__ == "__main__":
    main()
import sys

sys.setrecursionlimit(200005)


def dfs(sommet, parent):
    global dist
    global adj
    for v in adj[sommet]:
        if v != parent:
            dist[v] = 1 + dist[sommet]
            dfs(v, sommet)


n, q = map(int, input().split())
adj = [[] for i in range(n + 1)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    adj[a] += [b]
    adj[b] += [a]

dist = [0] * (n + 1)

dfs(1, -1)
# ~ print("dist", dist)
for _ in range(q):
    a, b = map(int, input().split())
    r = dist[a] + dist[b]
    print("Town" if r % 2 == 0 else "Road")
import queue
# tree の depthで算出する方法を試す
# Query は複数飛んでくるので cache しないと間に合わない

N, Q = map(int, input().split())

# Edge は N-1 しかない
abn = [tuple(map(int, input().split())) for _ in range(N - 1)]
cdq = [tuple(map(int, input().split())) for _ in range(Q)]


def show2d(a2d):
    print("===show2d===")
    for i, a1d in enumerate(a2d):
        print(i + 1, a1d)


# It can Not be comlete.-> -root is always lesser than any leaves.-
# ex.) 1-3-2
tree = [set() for _ in range(N)]

for a, b in abn:

    a -= 1
    b -= 1

    # registor parent v
    tree[b].add(a)
    tree[a].add(b)

#if len(  list(filter(lambda a:a==-1,tree))  ) > 0:
#  print(abn)
#  show2d(tree)
#  raise ValueError()

#show2d(tree)
depth = [-1] * N
depth[0] = 0

Q = queue.Queue()
Q.put(0)

while not Q.empty():

    p = Q.get()

    for v in filter(lambda a: depth[a] == -1, tree[p]):
        depth[v] = depth[p] + 1
        Q.put(v)
        #print("d:",depth)

#print(depth)
for c, d in cdq:
    c -= 1
    d -= 1
    t = depth[c] + depth[d]

    print("Road" if t % 2 == 1 else "Town")
import sys

sys.setrecursionlimit(100000)
N, Q = map(int, input().split())

towns = [-1] * N

ways = [[] for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    ways[a - 1].append(b - 1)
    ways[b - 1].append(a - 1)


def DFS(town, zero_one):
    towns[town] = zero_one
    for to in ways[town]:
        if towns[to] != -1:
            continue
        DFS(to, (zero_one + 1) % 2)


DFS(0, 0)

for _ in range(Q):
    c, d = map(int, input().split())
    print("Town" if towns[c - 1] == towns[d - 1] else "Road")
import sys

sys.setrecursionlimit(10**6)

n, q = [int(_) for _ in input().split()]
adj = [[] for i in range(n)]

lvl = [0] * n

for i in range(n - 1):
    a, b = [int(_) for _ in input().split()]
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)

visited = [False] * n


def dfs(node):
    if visited[node]:
        return
    visited[node] = True
    for v in adj[node]:
        if not visited[v]:
            lvl[v] = lvl[node] + 1
            dfs(v)


dfs(0)

for i in range(q):
    u, v = [int(_) for _ in input().split()]
    print("Town" if (lvl[u - 1] - lvl[v - 1]) % 2 == 0 else "Road")
from typing import Deque


def solve_a():
    a, b = map(int, input().split())
    print(max(0, b - a + 1))


def solve_a_2nd():
    pass


def solve_b():
    n, x = map(int, input().split())
    a = map(int, input().split())
    print(['No', 'Yes'][x >= sum(a) - n // 2])


def solve_b_2nd():
    pass


def solve_c():
    n = map(int, input().split())
    c = sorted(map(int, input().split()))
    ans = 1
    for i, ci in enumerate(c):
        ans *= (ci - i)
        ans = min(ans, ans % (10**9 + 7))
    print(ans)


def solve_c_2nd():
    pass


def solve_d():
    n, q = map(int, input().split())
    nodes = [[] for _ in range(n + 1)]

    for _ in range(n - 1):
        a, b = map(int, input().split())
        nodes[a] += [b]
        nodes[b] += [a]

    bw = [-1] * (n + 1)
    bw[1] = 1
    stack = Deque([1])
    while (len(stack) != 0):
        now = stack.popleft()
        for child in nodes[now]:
            if (bw[child] == -1):
                bw[child] = (bw[now] + 1) % 2
                stack.append(child)

    for _ in range(q):
        c, d = map(int, input().split())
        if (bw[c] != bw[d]):
            print('Road')
        else:
            print('Town')


if __name__ == '__main__':
    # solve_a()
    # solve_b()
    # solve_c()
    solve_d()
    # solve_a_2nd()
    # solve_b_2nd()
    # solve_c_2nd()
n, q = map(int, input().split())

graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

group = [[], []]
town_color = [-1] * n
tmp = [[0, -1, 0]]
while tmp:
    v, past, color = tmp.pop()
    town_color[v] = color
    group[color].append(v + 1)
    for i in graph[v]:
        if i == past: continue
        tmp.append([i, v, color ^ 1])

# print(group[0])
# print(group[1])
# print(town_color)

for i in range(q):
    c, d = map(int, input().split())
    if town_color[c - 1] == town_color[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    A, B = map(int, input().split())
    G[A - 1].append(B - 1)
    G[B - 1].append(A - 1)

ans = []
route = [-1] * N
route[0] = 0
d = deque([0])
while d:
    check = d.popleft()
    for j in G[check]:
        if route[j] == -1:
            if route[check] == 0:
                route[j] = 1
            else:
                route[j] = 0
            d.append(j)

ans = []
for i in range(Q):
    c, d = map(int, input().split())
    if route[c - 1] == route[d - 1]:
        ans.append("Town")
    else:
        ans.append("Road")

for i in range(Q):
    print(ans[i])
from collections import deque

N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]
G = [[] for _ in range(N)]
dp = [-1] * N

for ab in AB:
    a, b = ab
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

Q = deque()
Q.append(0)
dp[0] = 0
while Q:
    q = Q.popleft()
    for g in G[q]:
        if dp[g] == -1:
            dp[g] ^= dp[q]
            Q.append(g)

for cd in CD:
    c, d = cd
    if dp[c - 1] == dp[d - 1]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())

from collections import deque

que = deque()

#いけるとこリスト
connect = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    connect[a].append(b)
    connect[b].append(a)

#いったとこリスト
visited = [False] * (N + 1)

counter = [-1] * (N + 1)

que.append(1)
visited[1] = True

while que:
    now = que.popleft()

    for to in connect[now]:
        if visited[to] == False:
            counter[to] += 1 - counter[now]
            visited[to] = True
            que.append(to)
#訪問済みリストを初期化
visited = [False] * (N + 1)

for i in range(Q):
    a, b = map(int, input().split())
    if counter[a] == counter[b]:
        print('Town')

    else:
        print('Road')
from collections import deque

n, m = map(int, input().split())

graph = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

dist = [-1] * n
dist[0] = 0

d = deque()
d.append(0)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

lis = [0] * n

for i in range(n):
    if dist[i] % 2 == 0:
        lis[i] = 1
    else:
        lis[i] = -1
out = [0] * m
for i in range(m):
    a, b = map(int, input().split())
    if lis[a - 1] == lis[b - 1]:
        out[i] = "Town"
    else:
        out[i] = "Road"
for i in out:
    print(i)
import queue

n, q = map(int, input().split())
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * n
color[0] = 0
que.put(0)
#キューからデータがなくなるまで取り出しを行う
while not que.empty():
    t = que.get()
    for i in g[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print('Town')
    else:
        print('Road')
import collections

N, Q = map(int, input().split())

adj = collections.defaultdict(list)
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    adj[a].append(b)
    adj[b].append(a)


def dfs():
    colors = [-1] * N
    q = [(0, 0)]  # (node, color)
    while q:
        node, color = q.pop()
        if colors[node] != -1: continue
        colors[node] = color
        for nd in adj[node]:
            q.append((nd, color ^ 1))
    return colors


colors = dfs()

for _ in range(Q):
    c, d = map(int, input().split())
    if colors[c - 1] == colors[d - 1]:
        print('Town')
    else:
        print('Road')
from sys import stdin
import sys

sys.setrecursionlimit(10**7)

n, q = map(int, stdin.readline().split())
edge = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, stdin.readline().split())
    a, b = a - 1, b - 1
    edge[a].append(b)
    edge[b].append(a)
colors = [0] * n


def dfs(v, color):
    #今いる点を着色
    colors[v] = color
    for to in edge[v]:
        if colors[to] == color:
            return False
        if colors[to] == 0 and not dfs(to, -color):
            return False
    return True


def is_bipartite():
    return dfs(0, 1)  # 頂点0を黒(1)で塗ってDFS開始


is_bipartite()

for _ in range(q):
    c, d = map(int, stdin.readline().split())
    s = colors[c - 1]
    t = colors[d - 1]

    if s == t:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())

g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    g[a].append(b)
    g[b].append(a)

query = []
for _ in range(q):
    x, y = map(int, input().split())
    query.append((x - 1, y - 1))

d = [0] * n
visited = set()
que = deque([0])
cnt = 0
while que:
    for _ in range(len(que)):
        cur = que.popleft()
        visited.add(cur)
        d[cur] = cnt
        for nxt in g[cur]:
            if nxt not in visited:
                que.append(nxt)
    cnt += 1

for x, y in query:
    if abs(d[x] - d[y]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
from collections import deque

N, Q = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    G[a].append(b)
    G[b].append(a)


def bfs():
    q = deque([0])
    seen = [-1] * N
    seen[0] = 0
    while q:
        i = q.popleft()
        for j in G[i]:
            if seen[j] != -1:
                continue
            seen[j] = seen[i] + 1
            q.append(j)
    return seen


dist = bfs()
for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if abs(dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from sys import stdin

input = stdin.readline
from collections import deque

N, Q = map(int, input().split())
tree = [[] for _ in range(N + 1)]
level = [0] * (N + 1)
for _ in range(N - 1):
    a, b = map(int, input().split())
    tree[a].append(b)
    tree[b].append(a)
visited = [False] * (N + 1)


def bfs(st):
    global level
    q = deque()
    q.append([st, 0])
    visited[st] = True
    while q:
        for _ in range(len(q)):
            now, lvl = q.popleft()
            for next in tree[now]:
                if not visited[next]:
                    q.append([next, lvl + 1])
                    level[next] = lvl + 1
                    visited[next] = True


bfs(1)


def solve(a, b):
    if abs(level[a] - level[b]) % 2 == 1:
        return 'Road'
    else:
        return 'Town'


for _ in range(Q):
    x, y = map(int, input().split())
    print(solve(x, y))
import math
import collections
import itertools
import copy
from collections import defaultdict, deque
import re
import heapq
from itertools import product
from functools import reduce
from operator import add, truediv
from operator import sub
from operator import mul
from heapq import heappush, heappop, heapify
import sys
import random
import bisect
from typing import List
import time
import random
#from scipy.sparse.csgraph import floyd_warshall  #呪文を唱える
#import numpy as np

sys.setrecursionlimit(10**7)  #再帰関数の呼び出し制限
INF = 10**30

MOD = 10**9 + 7

N, Q = (map(int, input().split()))

T = [[] for i in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    T[a].append([b, 1])
    T[b].append([a, 1])

d = [-1] * (N + 1)
q = deque([1])
d[1] = 0
while q:
    c = q.popleft()
    for i in T[c]:
        if d[i[0]] == -1:
            d[i[0]] = d[c] + i[1]
            q.append(i[0])
for _ in range(Q):
    x, y = map(int, input().split())
    if (d[x] + d[y]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)

INF = 1 << 60
MOD = 10**9 + 7
#MOD = 998244353


def main():
    N, Q = map(int, input().split())
    G = [[] * N for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        G[a].append(b)
        G[b].append(a)

    # N: 頂点数
    # G[v]: 頂点vの子頂点 (親頂点は含まない)

    # Euler Tour Technique
    S = []
    FS = [0] * N
    depth = [0] * N

    def dfs(v, p, d):
        depth[v] = d
        FS[v] = len(S)
        S.append(v)
        for w in G[v]:
            if w == p:
                continue
            dfs(w, v, d + 1)
            S.append(v)

    dfs(0, -1, 0)

    # Sparse Table
    L = len(S)
    lg = [0] * (L + 1)
    for i in range(2, L + 1):
        lg[i] = lg[i >> 1] + 1
    st = [None] * (lg[L] + 1)
    st0 = st[0] = S
    b = 1
    for i in range(lg[L]):
        st0 = st[i + 1] = [
            p if depth[p] <= depth[q] else q for p, q in zip(st0, st0[b:])
        ]
        b <<= 1

    # LCA O(1)
    def query(u, v):
        x = FS[u]
        y = FS[v]
        if x > y:
            x, y = y, x
        l = lg[y - x + 1]
        px = st[l][x]
        py = st[l][y - (1 << l) + 1]
        return px if depth[px] <= depth[py] else py

    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        node = query(c, d)
        dist = depth[c] + depth[d] - 2 * depth[node]
        if dist % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
import bisect, collections, copy, heapq, itertools, math, string
import sys


def I():
    return int(sys.stdin.readline().rstrip())


def MI():
    return map(int, sys.stdin.readline().rstrip().split())


def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def S():
    return sys.stdin.readline().rstrip()


def LS():
    return list(sys.stdin.readline().rstrip().split())


from collections import deque, defaultdict, Counter
import heapq
from functools import reduce
from itertools import permutations
import math


def main():
    n, Q = MI()
    data = [[] for _ in range(n + 1)]
    for _ in range(n - 1):
        a, b = MI()
        data[a].append(b)
        data[b].append(a)
    double = [[-1 for _ in range(n + 1)] for _ in range(20)]
    dist = [-1] * (n + 1)
    dist[1] = 0
    oya = [-1] * (n + 1)
    oya[1] = 1
    q = deque()
    q.append(1)
    while q:
        now = q.pop()
        for to in data[now]:
            if dist[to] != -1:
                continue
            dist[to] = dist[now] + 1
            oya[to] = now
            q.append(to)
    for i in range(n + 1):
        double[0][i] = oya[i]
    for i in range(1, 20):
        for j in range(1, n + 1):
            pre = double[i - 1][j]
            double[i][j] = double[i - 1][pre]

    def LCA(a, b):
        if dist[a] == dist[b]:
            at = a
            bt = b
        else:
            sa = abs(dist[a] - dist[b])
            sa_bit = bin(sa)[2:]
            sa_bit = sa_bit[::-1]
            if dist[a] > dist[b]:
                at = a
                bt = b
                for i in range(len(sa_bit)):
                    if sa_bit[i] == "1":
                        at = double[i][at]
            else:
                at = a
                bt = b
                for i in range(len(sa_bit)):
                    if sa_bit[i] == "1":
                        bt = double[i][bt]
        if at == bt:
            return at
        for i in range(19, -1, -1):
            if double[i][at] == double[i][bt]:
                continue
            else:
                at = double[i][at]
                bt = double[i][bt]
        lca = oya[at]
        return lca

    for i in range(Q):
        c, d = MI()
        x = LCA(c, d)
        c_d_dist = dist[c] + dist[d] - (2 * dist[x])
        if c_d_dist % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == "__main__":
    main()
from collections import deque

N, Q = map(int, input().split())
graph = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * N
# pre=[-1]*N
dist[0] = 0

q = deque()
q.append(0)

while q:
    v = q.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        else:
            dist[i] = dist[v] + 1
            # pre[i]=v
            q.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    if abs(dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
L = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    L[a].append(b)
    L[b].append(a)

dp = [-1 for _ in range(N)]
dp[0] = 0
que = [0]
bl = [1, 0]

for i in que:
    for j in L[i]:
        if dp[j] == -1:
            que.append(j)
            dp[j] = bl[dp[i]]

for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print('Town' if dp[c] == dp[d] else 'Road')
from collections import deque


def resolve():
    N, Q = map(int, input().split())
    G = [[] for i in range(N)]
    color = [0 for i in range(N)]
    for i in range(N - 1):
        a, b = map(int, input().split())
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)

    que = deque([0])
    color[0] = 1
    while len(que):
        p = que.popleft()
        for q in G[p]:
            if color[q] == 0:
                color[q] = -color[p]
                que.append(q)

    for i in range(Q):
        c, d = map(int, input().split())
        if color[c - 1] == color[d - 1]:
            print("Town")
        else:
            print("Road")


resolve()
import sys

sys.setrecursionlimit(10**7)
n, q = map(int, input().split())

g = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    g[a].append(b)
    g[b].append(a)

dis = [-1] * n


def dfs(pair, cnt):
    for chi in g[pair]:
        if dis[chi] == -1:
            dis[chi] = cnt + 1
            dfs(chi, cnt + 1)


dis[0] = 0
dfs(0, 0)

for i in range(q):
    c, d = map(int, input().split())
    c, d = dis[c - 1], dis[d - 1]
    if (c + d) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())

G = [[] for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
dist_mod = [-1] * N
dist_mod[0] = 0
que.put(0)

while not que.empty():
    t = que.get()
    for i in G[t]:
        if dist_mod[i] == -1:
            dist_mod[i] = 1 - dist_mod[t]
            que.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if dist_mod[c - 1] == dist_mod[d - 1]:
        print("Town")
    else:
        print("Road")
import math
import itertools
import bisect
from heapq import heappush, heappop
from sys import stdin
from collections import deque
from sys import setrecursionlimit
from functools import reduce
from collections import defaultdict

setrecursionlimit(10**7)
input = stdin.readline


def I():
    return int(input())


def IN():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


def LIN():
    return [list(map(int, input().split())) for _ in range(N)]


N, Q = IN()
road = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = IN()
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)

que = deque([])
que.append(0)

cnt = [0] * N
visited = [0] * N

while que:
    before = que.pop()
    if visited[before] == 1:
        continue
    visited[before] = 1

    for visit in road[before]:
        cnt[visit] = 1 - cnt[before]
        que.append(visit)

ans = [0] * Q
for k in range(Q):
    c, d = IN()
    if cnt[c - 1] == cnt[d - 1]:
        ans[k] = "Town"
    else:
        ans[k] = "Road"
print(*ans, sep="\n")
from queue import Queue
import math

N, Q = map(int, input().split())
AB = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(N - 1)]
CD = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(Q)]
graph = [[] for _ in range(N)]
for a, b in AB:
    graph[a].append(b)
    graph[b].append(a)

queue = Queue()
queue.put(0)
colors = [None for _ in range(N)]
colors[0] = 0

while not queue.empty():
    v = queue.get()
    for adj in graph[v]:
        if colors[adj] is None:
            if colors[v] == 0:
                colors[adj] = 1
            elif colors[v] == 1:
                colors[adj] = 0
            queue.put(adj)

for c, d in CD:
    if colors[c] == colors[d]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque


def BFS(start):
    dist = [-1] * N
    dist[start] = 0
    que = deque([start])
    while que:
        fr = que.popleft()
        for to in edge[fr]:
            if dist[to] == -1:
                dist[to] = dist[fr] + 1
                que.append(to)

    return dist


N, Q = map(int, input().split())
N_list = list(range(N))
edge = [[] for _ in N_list]
for i in [0] * (N - 1):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)
arr = BFS(0)
ma = [''] * N
for i in range(N):
    if arr[i] % 2 == 0:
        ma[i] = 'R'
    else:
        ma[i] = 'B'

for i in range(Q):
    c, d = map(int, input().split())
    if ma[c - 1] == ma[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import defaultdict
import queue
import sys

sys.setrecursionlimit(10**9)

#r = defaultdict(list)
n, q = map(int, input().split())
r = [[] for i in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    #r[a].append(b)
    #r[b].append(a)
    r[a].append(b)
    r[b].append(a)

tr = [-1] * (n + 1)


def dfs(parent, current):
    tr[current] = (tr[parent] + 1) % 2
    for v in r[current]:
        if tr[v] == -1:
            dfs(current, v)


dfs(0, 1)
for i in range(q):
    c, d = map(int, input().split())
    if tr[c] == tr[d]:
        print("Town")
    else:
        print("Road")
class LcaDoubling:
    """
    links[v] = { (u, w), (u, w), ... }  (u:隣接頂点, w:辺の重み)
    というグラフ情報から、ダブリングによるLCAを構築。
    任意の2頂点のLCAおよび距離を取得できるようにする
    """
    def __init__(self, n, links, root=0):
        self.depths = [-1] * n
        self.distances = [-1] * n
        prev_ancestors = self._init_dfs(n, links, root)
        self.ancestors = [prev_ancestors]
        max_depth = max(self.depths)
        d = 1
        while d < max_depth:
            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]
            self.ancestors.append(next_ancestors)
            d <<= 1
            prev_ancestors = next_ancestors

    def _init_dfs(self, n, links, root):
        q = [(root, -1, 0, 0)]
        direct_ancestors = [-1] * (n + 1
                                   )  # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1
        while q:
            v, p, dep, dist = q.pop()
            direct_ancestors[v] = p
            self.depths[v] = dep
            self.distances[v] = dist
            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)
        return direct_ancestors

    def get_lca(self, u, v):
        du, dv = self.depths[u], self.depths[v]
        if du > dv:
            u, v = v, u
            du, dv = dv, du
        tu = u
        tv = self.upstream(v, dv - du)
        if u == tv:
            return u
        for k in range(du.bit_length() - 1, -1, -1):
            mu = self.ancestors[k][tu]
            mv = self.ancestors[k][tv]
            if mu != mv:
                tu = mu
                tv = mv
        lca = self.ancestors[0][tu]
        assert lca == self.ancestors[0][tv]
        return lca

    def get_distance(self, u, v):
        lca = self.get_lca(u, v)
        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]

    def upstream(self, v, k):
        i = 0
        while k:
            if k & 1:
                v = self.ancestors[i][v]
            k >>= 1
            i += 1
        return v


N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]

edges = [[] for _ in range(N)]
for a, b in AB:
    a -= 1
    b -= 1
    edges[a].append([b, 1])
    edges[b].append([a, 1])

lca = LcaDoubling(N, edges)

for c, d in CD:
    c -= 1
    d -= 1

    x = lca.get_distance(c, d)
    if x % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline

N, Q = map(int, input().split())
EDGELIST = [[] for i in range(N)]

for i in range(N - 1):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    EDGELIST[x].append(y)
    EDGELIST[y].append(x)

# LCA(オイラーツアー＋Segment tree)

DEPTH = [-1] * (N + 1)
DEPTH[1] = 0

from collections import deque

QUE = deque([1])
QUE2 = deque()
EULER = []  # (i,j)で,(1からツアーで辿った点の深さ,そのindex)

USED = [0] * (N + 1)
while QUE:
    x = QUE.pop()
    EULER.append((DEPTH[x], x))
    if USED[x] == 1:
        continue
    for to in EDGELIST[x]:

        if USED[to] == 0:
            DEPTH[to] = DEPTH[x] + 1
            QUE2.append(to)
        else:
            QUE.append(to)
    QUE.extend(QUE2)
    QUE2 = deque()

    USED[x] = 1

MINP = [1 << 30] * (N + 1)
MAXP = [-1] * (N + 1)

for ind, (depth, p) in enumerate(EULER):
    MINP[p] = min(MINP[p], ind)
    MAXP[p] = max(MAXP[p], ind)

LEN = len(EULER)

seg_el = 1 << (LEN.bit_length())  # Segment treeの台の要素数
SEG = [(1 << 30, 0)] * (2 * seg_el
                        )  # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化

for i in range(LEN):  # Dを対応する箇所へupdate
    SEG[i + seg_el] = EULER[i]

for i in range(seg_el - 1, 0, -1):  # 親の部分もupdate
    SEG[i] = min(SEG[i * 2], SEG[i * 2 + 1])


def update(n, x, seg_el):  # A[n]をxへ更新（反映）
    i = n + seg_el
    SEG[i] = x
    i >>= 1  # 子ノードへ

    while i != 0:
        SEG[i] = min(SEG[i * 2], SEG[i * 2 + 1])
        i >>= 1


def getvalues(l, r):  # 区間[l,r)に関するminを調べる
    L = l + seg_el
    R = r + seg_el
    ANS = (1 << 30, 0)

    while L < R:
        if L & 1:
            ANS = min(ANS, SEG[L])
            L += 1

        if R & 1:
            R -= 1
            ANS = min(ANS, SEG[R])
        L >>= 1
        R >>= 1

    return ANS


def LCA(l, r):
    return getvalues(min(MINP[l], MINP[r]), max(MAXP[l], MAXP[r]) + 1)


for queries in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    L = LCA(c, d)[1]

    if c == L or d == L:
        dist = abs(DEPTH[c] - DEPTH[d])
    else:
        dist = abs(DEPTH[c] - DEPTH[L]) + abs(DEPTH[d] - DEPTH[L])

    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

N, Q = map(int, input().split())
sys.setrecursionlimit(N + 2)
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)
d = [None] * N


def dfs(u, p, depth):
    d[u] = depth % 2
    for v in G[u]:
        if p != v:
            dfs(v, u, depth + 1)


dfs(0, -1, 0)
for _ in range(Q):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    print('Town' if (d[u] + d[v]) % 2 == 0 else 'Road')
import sys

sys.setrecursionlimit(10**7)
input = sys.stdin.readline

from collections import deque


def main():  # for speed up
    # ノード数, エッジ数, 始点ノード
    n, q = map(int, input().split())
    # adj[s]: ノード s に隣接する(ノード, 重み)をリストで持つ
    adj = [[] for _ in range(n)]
    for _ in range(n - 1):
        s, t = map(int, input().split())
        adj[s - 1].append(t - 1)
        adj[t - 1].append(s - 1)

    dp = [-1] * n
    dqn = deque()
    dqn.append((0, 0))
    while dqn:
        (ii, depth) = dqn.popleft()
        dp[ii] = depth
        for jj in adj[ii]:
            if dp[jj] < 0:
                dqn.append((jj, depth + 1))

    for _ in range(q):
        s, t = map(int, input().split())
        if (dp[s - 1] + dp[t - 1]) % 2 == 0:
            print("Town")
        else:
            print("Road")


main()
#D
n, q = map(int, input().split())
g = [[] for _ in range(n)]
score = [0 for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * n  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


# 0からの各頂点の距離
distance = bfs(0)

for _ in range(q):
    c, d = map(int, input().split())
    if (distance[c - 1] + distance[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
from collections import deque

input = sys.stdin.readline

n, q = [int(x) for x in input().split()]  # nは頂点の数、mは辺の数
g = [[] for _ in range(n)]  # 隣接リスト
m = n - 1

for _ in range(m):
    a, b = [int(x) - 1 for x in input().split()]
    g[a].append(b)
    g[b].append(a)


def bfs(u):
    queue = deque([u])
    d = [None] * n  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


# 0からの各頂点の距離
queri = bfs(0)
for i in range(q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    dd = queri[a] - queri[b]
    if dd % 2 == 1:
        print("Road")
    else:
        print("Town")
import heapq

n, q = list(map(int, input().split()))

hq = []
heapq.heapify(hq)
mapDic = dict()
for i in range(n - 1):
    a, b = list(map(int, input().split()))
    if not (a in mapDic.keys()):
        mapDic[a] = set()
    mapDic[a].add(b)
    if not (b in mapDic.keys()):
        mapDic[b] = set()
    mapDic[b].add(a)

for f in mapDic[1]:
    heapq.heappush(hq, (1, f))

dic = dict()
while len(hq) > 0:
    cost, num = heapq.heappop(hq)
    if not (num in dic.keys()):
        dic[num] = cost
        cost += 1
        for num2 in mapDic[num]:
            heapq.heappush(hq, (cost, num2))
    else:
        continue

ansLis = []
for i in range(q):
    c, d = list(map(int, input().split()))
    dis = abs(dic[c] - dic[d])
    if dis % 2 == 0:
        ansLis.append("Town")
    else:
        ansLis.append("Road")

for i in range(q):
    print(ansLis[i])
from collections import deque

N, Q = map(int, input().split())
node = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    node[a].append(b)
    node[b].append(a)


def BFS(s):
    q = deque([])
    v = [False] * (N + 1)
    dis = [0] * (N + 1)
    color = [0] * (N + 1)
    color[s] = 1
    q.append(s)
    v[s] = True

    while q:
        x = q.popleft()
        for nx in node[x]:
            if not (v[nx]):
                dis[nx] = dis[x] + 1
                if dis[nx] % 2 == 0:
                    color[nx] = 1
                q.append(nx)
                v[nx] = True
    return dis, color


ans, color = BFS(1)

for _ in range(Q):
    c, d = map(int, input().split())
    if color[c] == color[d]:
        print('Town')
    else:
        print('Road')
from collections import deque

n, Q = map(int, input().split())
edges = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    edges[a - 1].append(b - 1)
    edges[b - 1].append(a - 1)

dist = [-1] * n
q = deque([0])
dist[0] = 0

while q:
    now = q.popleft()
    for nxt in edges[now]:
        if dist[nxt] == -1:
            dist[nxt] = dist[now] + 1
            q.append(nxt)

for _ in range(Q):
    c, d = map(int, input().split())
    if dist[c - 1] % 2 == dist[d - 1] % 2:
        print("Town")
    else:
        print("Road")#!/usr/bin/env python3


def main():
    from collections import deque

    n, q = map(int, input().split())

    v = [[] for _ in range(n + 1)]

    for i in range(n - 1):
        a, b = map(int, input().split())
        v[a].append(b)
        v[b].append(a)

    depth_vec = [-1 for _ in range(n + 1)]

    queue = deque()
    queue.append((1, 0))

    while len(queue) > 0:
        (node, depth) = queue.pop()
        depth_vec[node] = depth

        for child in v[node]:
            if depth_vec[child] >= 0:
                continue
            queue.append((child, depth + 1))

    for i in range(q):
        c, d = map(int, input().split())
        if (depth_vec[c] + depth_vec[d]) % 2 == 0:
            print('Town')
        else:
            print('Road')


main()
from collections import deque

N, Q = map(int, input().split())
graph = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

# 深さを記録
depths = [-1] * N
queue = deque()
queue.append((0, 0))  # 頂点0を根とする
while len(queue) > 0:
    (node, depth) = queue.pop()
    depths[node] = depth
    for child in graph[node]:
        if depths[child] >= 0:
            continue
        queue.append((child, depth + 1))

for i in range(Q):
    c, d = map(int, input().split())
    if (depths[c - 1] + depths[d - 1]) % 2:
        print("Road")
    else:
        print("Town")import sys
from collections import defaultdict, Counter, namedtuple, deque
import itertools
import functools
import bisect
import heapq
import math
from decimal import Decimal
import copy
import random

# from fractions import gcd

MOD = 10**9 + 7
# MOD = 998244353
# sys.setrecursionlimit(10**8)

n, q = map(int, input().split())
G = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

dis = [-1] * n
dis[0] = 0
que = deque([(0, 0)])
while que:
    e, d = que.popleft()
    for nxt in G[e]:
        if dis[nxt] != -1:
            continue
        dis[nxt] = d + 1
        que.append((nxt, d + 1))

# print(dis)

for i in range(q):
    c, d = map(int, input().split())
    if (dis[c - 1] + dis[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from sys import stdin

input = stdin.readline

n, q = map(int, input().split())

edges = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    edges[a - 1].append(b - 1)
    edges[b - 1].append(a - 1)

# DFS
root = 0
heights = [-1] * n
heights[root] = 0
todo = [root]
while todo:
    a = todo.pop()
    for b in edges[a]:
        if heights[b] == -1:
            heights[b] = heights[a] + 1
            todo.append(b)

ans = ['Town'] * q
for i in range(q):
    c, d = map(int, input().split())
    if heights[c - 1] + heights[d - 1] & 1:
        ans[i] = 'Road'
print(*ans, sep='\n')
import sys

input = sys.stdin.readline
from collections import deque


def read():
    N, Q = map(int, input().strip().split())
    G = [list() for i in range(N)]
    for i in range(N - 1):
        a, b = map(int, input().strip().split())
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)
    CD = []
    for i in range(Q):
        c, d = map(int, input().strip().split())
        CD.append((c - 1, d - 1))
    return N, G, CD


def solve(N, G, CD):
    depth = [-1 for i in range(N)]
    q = deque()
    depth[0] = 0
    q.append(0)
    while q:
        u = q.popleft()
        for v in G[u]:
            if depth[v] == -1:
                depth[v] = depth[u] + 1
                q.append(v)
    for c, d in CD:
        if (depth[c] + depth[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    inputs = read()
    outputs = solve(*inputs)
    if outputs is not None:
        print("%s" % str(outputs))
import collections
from collections import defaultdict
import math
from math import gcd
from collections import Counter

for _ in range(1):
    #for t in range(int(input())):

    #n = int(input())
    n, q1 = [int(x) for x in input().split()]
    #x1,x2,y1,y2,z1,z2=[int(c) for c in input().split()]
    #c=[int(x) for x in input().split()]
    adj = defaultdict(lambda: [])
    for i in range(n - 1):
        z = [int(x) for x in input().split()]
        adj[z[0] - 1].append(z[1] - 1)
        adj[z[1] - 1].append(z[0] - 1)

    c = [-1] * n
    c[0] = 0
    level = 0
    visited = defaultdict(lambda: False)
    #we know the graph is bipartile
    q = [0]
    visited[0] = True
    while len(q) > 0:
        z = []
        level = 1 - level
        for x in q:
            for y in adj[x]:
                if not visited[y]:
                    z.append(y)
                    visited[y] = True
                    c[y] = level

        q = z

    for i in range(q1):
        a, b = [int(x) for x in input().split()]
        a -= 1
        b -= 1
        if c[a] - c[b] % 2 == 0:
            print('Town')
        else:
            print("Road")

    #length of shortest path is : even -> Town
    #                         odd  -> Road
def dijkstra_heap(s):
    import heapq
    d = [float('inf')] * n
    used = [False] * n
    d[s] = 0
    used[s] = True
    edgelist = []
    for e in edge[s]:
        heapq.heappush(edgelist, e)
    while edgelist:
        minedge = heapq.heappop(edgelist)
        if used[minedge[1]]:
            continue
        v = minedge[1]
        d[v] = minedge[0]
        used[v] = True
        for e in edge[v]:
            if not used[e[1]]:
                heapq.heappush(edgelist, [e[0] + d[v], e[1]])
    return d


n, q = map(int, input().split())
edge = [[] for _ in range(n)]
for i in range(n - 1):
    x, y = map(int, input().split())
    edge[x - 1].append([1, y - 1])
    edge[y - 1].append([1, x - 1])
dist = dijkstra_heap(0)
query = []
for _ in range(q):
    c, d = map(int, input().split())
    query.append((c, d))

for (c, d) in query:
    tmp = abs(dist[c - 1] - dist[d - 1])
    if tmp % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys, re
from string import ascii_lowercase, ascii_uppercase, digits, hexdigits, octdigits
from operator import add, sub, mul, mod, xor
from math import ceil, floor, sqrt, pi, factorial, gcd, sin, cos, atan2, degrees, radians
from copy import deepcopy
from collections import Counter, deque, defaultdict
from heapq import heapify, heappop, heappush
from itertools import accumulate, product, combinations, combinations_with_replacement, permutations
from bisect import bisect, bisect_left, bisect_right
from functools import reduce
from decimal import Decimal, getcontext


# input = sys.stdin.readline
def i_input():
    return int(input())


def i_map():
    return map(int, input().split())


def i_list():
    return list(i_map())


def i_row(N):
    return [i_input() for _ in range(N)]


def i_row_list(N):
    return [i_list() for _ in range(N)]


def s_input():
    return input()


def s_map():
    return input().split()


def s_list():
    return list(s_map())


def s_row(N):
    return [s_input() for _ in range(N)]


def s_row_str(N):
    return [s_list() for _ in range(N)]


def s_row_list(N):
    return [list(s_input()) for _ in range(N)]


def lcm(a, b):
    return a * b // gcd(a, b)


sys.setrecursionlimit(10**6)
INF = float('inf')
MOD = 10**9 + 7
num_list = []
str_list = []

n, q = i_map()

edges = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = i_map()
    edges[a - 1].append((1, b - 1))
    edges[b - 1].append((1, a - 1))


def dijkstra(start: int, node_num: int, edge: list) -> list:
    d = [float("inf")] * node_num
    d[start] = 0
    #スタートをキューに入れる
    q = [(0, start)]

    while len(q) != 0:
        #キューの先頭を取得
        ci, i = heappop(q)
        if d[i] < ci:
            continue
        #キューの先頭から繋がっている頂点を探索
        for cj, j in edge[i]:
            if d[j] > d[i] + cj:
                d[j] = d[i] + cj
                heappush(q, (d[j], j))

    return d


result = dijkstra(0, n, edges)

for _ in range(q):
    c, d = i_map()
    tmp = abs(result[c - 1] - result[d - 1])
    print('Town' if tmp % 2 == 0 else 'Road')
import math, sys
#from itertools import permutations, combinations;import heapq,random;
from collections import defaultdict, deque
import bisect as bi


def yes():
    print('YES')


def no():
    print('NO')


#sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
def I():
    return (int(sys.stdin.readline()))


def In():
    return (map(int, sys.stdin.readline().split()))


def Sn():
    return sys.stdin.readline().strip()


#sys.setrecursionlimit(1500)
#import resource, sys
#resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))

sys.setrecursionlimit(10**7)


def dict(a):
    d = {}
    for x in a:
        if d.get(x, -1) != -1:
            d[x] += 1
        else:
            d[x] = 1
    return d


def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:
        return -1


def dfs(v, p, timer):
    timer[0] += 1
    tin[v] = timer[0]
    dp[v][0] = p
    for i in range(1, lo + 1):
        dp[v][i] = dp[dp[v][i - 1]][i - 1]
    cnt = 0
    for x in d[v]:
        if x != p:
            high[x] = high[v] + 1
            cnt += 1
            dfs(x, v, timer)
    timer[0] += 1
    tout[v] = timer[0]


def is_ancestor(u, v):
    return tin[u] <= tin[v] and tout[u] >= tout[v]


def lca(u, v):
    if is_ancestor(u, v):
        return u
    if is_ancestor(v, u):
        return v
    for i in range(lo, -1, -1):
        if not is_ancestor(dp[u][i], v):
            u = dp[u][i]
    return dp[u][0]


def main():
    try:
        global lo, n, ans, k, visit, d, dp, tin, tout, high, leaf_node
        n, nQ = In()
        visit = [False] * (n + 1)
        high = [-1] * (n + 1)
        tin = [-1] * (n + 1)
        tout = [-1] * (n + 1)
        d = defaultdict(list)

        for i in range(n - 1):
            a, b = In()
            d[a].append(b)
            d[b].append(a)
        timer = [0]

        lo = math.ceil(math.log(n, 2))
        dp = [[0 for i in range(lo + 1)] for j in range(n + 1)]
        high[1] = 0
        dfs(1, 1, timer)
        for i in range(nQ):
            v, u = In()
            z = lca(v, u)
            distance = high[u] - high[z] + high[v] - high[z]
            if distance % 2 == 0:
                print("Town")
            else:
                print("Road")
    except:
        pass


M = 998244353
P = 1000000007

if __name__ == '__main__':
    # for _ in range(I()):main()
    for _ in range(1):
        main()
#End#

#        ******************* All The Best *******************   #
(n, q), *t = [map(int, t.split()) for t in open(0)]
e = [[] for _ in t + t]
for a, b in t[:-q]:
    e[a] += b,
    e[b] += a,
d = [1] * n + [0]
s = [n]
for v in s:
    for w in e[v]:
        s += [w] * d[w]
        d[w] = ~d[v]
for a, b in t[-q:]:
    print('RTooawdn'[d[a] == d[b]::2])
from collections import deque

n, Q = map(int, input().split())
l = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    l[a].append(b)
    l[b].append(a)
s = [-1 for i in range(n)]
q = deque([0])
s[0] = 0
while len(q):
    x = q.popleft()
    for i in l[x]:
        if s[i] != -1:
            continue
        q.append(i)
        s[i] = s[x] + 1
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (s[c] - s[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
graph = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

ans = [-1 for i in range(N)]

d = deque([0])
ans[0] = 0
while d:
    i = d.pop()

    for j in graph[i]:
        if ans[j] == -1:
            ans[j] = (ans[i] + 1) % 2
            d.append(j)

for i in range(Q):
    c, d = map(int, input().split())
    if ans[c - 1] == ans[d - 1]:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
g = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)
query = []
for i in range(Q):
    c, d = map(int, input().split())
    query.append((c - 1, d - 1))
oe = [0] * N
from collections import deque

q = deque([])
q.append((0, 0))
done = [0] * N
while q:
    now, count = q.popleft()
    if not done[now]:
        done[now] = 1
        oe[now] = count
        for nv in g[now]:
            if not done[nv]:
                q.append((nv, (count + 1) % 2))

for c, d in query:
    if oe[c] + oe[d] == 1:
        print('Road')
    else:
        print('Town')
import sys

sys.setrecursionlimit(100000000)


def search(a, v, depth, d):
    for i in v[a]:
        v[i].remove(a)
        depth[i] = d + 1
        search(i, v, depth, d + 1)


N, M = map(int, input().split())
v = [[] for i in range(N)]
depth = [0] * N
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    v[a].append(b)
    v[b].append(a)
search(0, v, depth, 0)
for i in range(M):
    a, b = map(int, input().split())
    if (depth[a - 1] - depth[b - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
G = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = deque()
color = [-1 for i in range(n)]
color[0] = 0
que.append(0)
while not len(que) == 0:
    t = que.popleft()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.append(i)
for i in range(q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print('Town')
    else:
        print('Road')
from collections import defaultdict
import sys


def input():
    return sys.stdin.readline()[:-1]


class MyGraph:
    def __init__(self):

        # ノードの集合
        self.nodes = set()
        # 各ノードに隣接している(そこからたどり着ける)ノードの集合をまとめた辞書
        self.connections = defaultdict(set)

        # 0:未到達
        # 1:白
        # 2:黒
        self.color = defaultdict(int)

    def add_nodes(self, nodes):
        # 頂点の集合(またはリストなど)を加えます。
        for node in nodes:
            if node not in self.nodes:
                self.nodes.add(node)

    def add_edges(self, edges):
        # 辺を加えます。辺は(from , to )の形のタプルにすること。
        # 例：graph.add_edges([ (1,2) , (1,3) , (2,4) ])
        for f, t in edges:
            # f : from     t : to
            self.connections[f].add(t)
            self.connections[t].add(f)

    def nuriwake(self):
        start_node = 1

        job_stack = [start_node]
        self.color[start_node] = 1

        while job_stack:
            node = job_stack.pop()
            node_c = self.color[node]
            if node_c == 1:
                next_color = 2
            else:
                next_color = 1

            for next_node in self.connections[node]:
                if self.color[next_node] == 0:
                    self.color[next_node] = next_color
                    job_stack.append(next_node)


def main():
    n, q = tuple(map(int, input().split()))
    nodes = list(range(1, n + 1))
    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]

    g = MyGraph()
    g.add_nodes(nodes)
    g.add_edges(edges)
    g.nuriwake()

    ans = []
    for _ in range(q):
        c, d = tuple(map(int, input().split()))
        if g.color[c] == g.color[d]:
            ans.append('Town')
        else:
            ans.append('Road')

    print('\n'.join(ans))


if __name__ == '__main__':
    main()
import sys, math
from collections import deque, defaultdict
import operator as op
from functools import reduce
from itertools import permutations
import heapq

# sys.setrecursionlimit(10**6)
# OneDrive\Documents\codeforces

I = sys.stdin.readline

alpha = "abcdefghijklmnopqrstuvwxyz"

mod = 10**9 + 7
"""
x_move=[-1,0,1,0,-1,1,1,-1]
y_move=[0,1,0,-1,1,1,-1,-1]
"""


def ii():
    return int(I().strip())


def li():
    return list(map(int, I().strip().split()))


def mi():
    return map(int, I().strip().split())


def ncr(n, r):
    r = min(r, n - r)
    numer = reduce(op.mul, range(n, n - r, -1), 1)
    denom = reduce(op.mul, range(1, r + 1), 1)
    return numer // denom


def isPrime(n):
    if n <= 1:
        return False
    elif n <= 2:
        return True
    else:

        for i in range(2, int(n**.5) + 1):
            if n % i == 0:
                return False
        return True


def main():
    ans = ""
    n, num_of_queries = mi()
    d = defaultdict(list)
    for i in range(n - 1):
        u, v = mi()
        d[u].append(v)
        d[v].append(u)
    tmp = []
    for q in range(num_of_queries):
        u, v = mi()
        tmp.append((u, v))

    vis = [-1] * (n + 1)

    q = deque([(1, 0)])

    vis[1] = 0

    while q:
        x = q.popleft()
        for i in d[x[0]]:
            if vis[i] == -1:
                q.append((i, x[1] + 1))
                vis[i] = x[1] + 1

    for q in tmp:
        if abs(vis[q[0]] - vis[q[1]]) % 2:
            ans += "Road\n"
        else:
            ans += "Town\n"
    print(ans)


if __name__ == '__main__':
    main()
N, Q = map(int, input().split())
E = {n + 1: [] for n in range(N)}
for i in range(1, N):
    a, b = map(int, input().split())
    E[a] += [b]
    E[b] += [a]
D, P = {1: 0}, [1]
while P:
    p = P.pop(0)
    for d in E[p]:
        if d in D: continue
        P += [d]
        D[d] = D[p] + 1
for _ in range(Q):
    c, d = map(int, input().split())
    print(D[c] % 2 == D[d] % 2 and 'Town' or 'Road')
import queue

N, Q = map(int, input().split())

road = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)

que = queue.Queue()
tree = [-1] * N
tree[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in road[t]:
        if tree[i] == -1:
            tree[i] = 1 - tree[t]
            que.put(i)

q = []
for i in range(Q):
    c, d = map(int, input().split())
    q.append([c, d])

for c, d in q:
    if tree[c - 1] == tree[d - 1]:
        print('Town')
    else:
        print('Road')
import collections

n, q = map(int, input().split())
graph = [[] for i in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
flag = [False for i in range(n + 1)]
flag2 = [False for i in range(n + 1)]
queue = collections.deque([1])
while queue:
    test = queue.popleft()
    flag[test] = True
    for i in graph[test]:
        if flag[i] == False:
            queue.append(i)
            if flag2[test] == True:
                flag2[i] = False
            else:
                flag2[i] = True
for i in range(q):
    c, d = map(int, input().split())
    if flag2[c] == flag2[d]:
        print("Town")
    else:
        print("Road")N, q = map(int, input().split())
adj = [[] for _ in range(N)]
dist = [0] * N
for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    adj[a].append(b)
    adj[b].append(a)

start = 0
visited = {start}
Q = [start]

while Q:
    cur = Q.pop()
    for nex in adj[cur]:
        if nex in visited:
            continue
        else:
            visited.add(nex)
            dist[nex] = (dist[cur] + 1) % 2
            Q.append(nex)

for _ in range(q):
    a, b = map(lambda x: int(x) - 1, input().split())
    if dist[a] == dist[b]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())

tree = [[] for _ in range(N)]
ans = []

for _ in range(N - 1):
    a, b = map(int, input().split())
    tree[a - 1].append(b - 1)
    tree[b - 1].append(a - 1)


def bfs(u):
    queue = deque([u])
    d = [-1] * N
    d[u] = 0
    while queue:
        v = queue.popleft()
        for i in tree[v]:
            if d[i] != -1:
                continue
            d[i] = d[v] + 1
            queue.append(i)
    return d


dis = bfs(0)

for _ in range(Q):
    c, d = map(int, input().split())
    if (dis[c - 1] + dis[d - 1]) % 2 == 0:
        ans.append("Town")
    else:
        ans.append("Road")

print(*ans, sep="\n")
N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    A, B = map(lambda x: int(x) - 1, input().split())
    edge[A].append(B)
    edge[B].append(A)


def kinohukasa(edge, N, i):
    hukasa = [-1] * N
    stack = [i]
    hukasa[i] = 0
    while stack:
        at = stack.pop()
        for next in edge[at]:
            if hukasa[next] == -1:
                hukasa[next] = hukasa[at] + 1
                stack.append(next)
    return hukasa


deapth = kinohukasa(edge, N, 0)
for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (deapth[c] + deapth[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
from collections import deque

n, q = map(int, input().split())
ab = []
edge = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    ab.append([a - 1, b - 1])
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)
visited = [-1 for i in range(n)]
visited[ab[0][0]] = 0
que = deque()
que.append(ab[0][0])
while que:
    x = que.popleft()
    for i in edge[x]:
        if visited[i] == -1:
            visited[i] = visited[x] + 1
            que.append(i)
        else:
            continue
#print(visited)
for i in range(q):
    c, d = map(int, input().split())
    if (visited[c - 1] + visited[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**6)

G = [[] for _ in range(100100)]
check = [0 for _ in range(100100)]
col = [0 for _ in range(100100)]


def dfs(now, x):
    check[now] = 1
    col[now] = x
    for i in G[now]:
        if check[i] == 0:
            x ^= 1
            dfs(i, x)
            x ^= 1
    return


def main():
    n, q = map(int, input().split())
    for _ in range(n - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        G[a].append(b)
        G[b].append(a)
    dfs(0, 0)
    for _ in range(q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        print("Road" if col[c] != col[d] else "Town")
    return


main()
import queue

n, q = map(int, input().split())
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

color = [-1] * n
color[0] = 0
que = queue.Queue()
que.put(0)

while not que.empty():
    t = que.get()

    for i in g[t]:
        if color[i] != -1:
            continue

        color[i] = 1 - color[t]
        que.put(i)

for i in range(q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
ab = [[int(i) for i in input().split()] for _ in range(N - 1)]
cd = [[int(i) for i in input().split()] for _ in range(Q)]

vec = [[] for _ in range(N)]
for a, b in ab:
    a -= 1
    b -= 1
    vec[a].append(b)
    vec[b].append(a)

q = [0]
p = [-1] * N
while q:
    cur = q.pop()
    cp = p[cur]
    for nex in vec[cur]:
        if p[nex] != -1:
            continue

        q.append(nex)
        p[nex] = 1 - cp

for c, d in cd:
    c -= 1
    d -= 1
    if p[c] == p[d]:
        print('Town')
    else:
        print('Road')
import collections

n, m = map(int, input().split())

g = []
for _ in range(n + 1):
    g.append([])

for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

visited = [False] * (n + 1)
visited[1] = [True]
que = collections.deque([1])
dst = [0] * (n + 1)

while que:
    q = que.popleft()
    for i in g[q]:
        if visited[i] == False:
            visited[i] = True
            que.append(i)
            dst[i] = dst[q] + 1

for i in range(m):
    c, d = map(int, input().split())
    if abs(dst[c] - dst[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
from collections import defaultdict, deque


def main():
    n, q = [int(x) for x in input().split()]
    graph = defaultdict(list)
    for i in range(n - 1):
        u, v = [int(x) for x in input().split()]
        graph[u].append(v)
        graph[v].append(u)
    color = [-1] * (n + 1)
    color[1] = 0
    queue = deque([1])
    while queue:
        node = queue.popleft()
        for v in graph[node]:
            if color[v] == -1:
                color[v] = 1 - color[node]
                queue.append(v)

    for i in range(q):
        a, b = [int(x) for x in input().split()]
        if color[a] == color[b]: print('Town')
        else: print('Road')


(main())
from queue import Queue

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

color = [None] * N
queue = Queue()
color[0] = 0
queue.put(0)
while not queue.empty():
    t = queue.get()
    for s in G[t]:
        if color[s] is None:
            color[s] = 1 - color[t]
            queue.put(s)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print('Town')
    else:
        print('Road')
import sys
from collections import deque


def _s():
    return sys.stdin.readline().strip()


def _sa():
    return sys.stdin.readline().strip().split()


def _i():
    return int(sys.stdin.readline().strip())


def _ia():
    return map(int, sys.stdin.readline().strip().split())


def main():
    N, Q = _ia()
    EDGE = [[] for _ in range(N)]
    for _ in range(N - 1):
        ai, bi = _ia()
        EDGE[ai - 1].append(bi - 1)
        EDGE[bi - 1].append(ai - 1)

    walk = [-1] * N
    q = deque([[0, 0]])
    while q:
        p, cnt = q.popleft()
        if walk[p] >= 0:
            continue
        walk[p] = cnt % 2
        cnt1 = cnt + 1
        for nxt in EDGE[p]:
            q.append([nxt, cnt1])

    for _ in range(Q):
        ci, di = _ia()
        if walk[ci - 1] == walk[di - 1]:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
N, Q = map(int, input().split())
tree = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    tree[a - 1].append(b - 1)
    tree[b - 1].append(a - 1)
import sys

sys.setrecursionlimit(10**7)
D = [0] * N
from functools import lru_cache


@lru_cache
def dfs(t=0, d=0, p=-1):
    global D
    for u in tree[t]:
        if u == p:
            continue
        D[u] = (d + 1) % 2
        dfs(u, d + 1, t)


dfs()
for _ in range(Q):
    c, d = map(int, input().split())
    print('Road' if (D[c - 1] - D[d - 1]) % 2 == 1 else 'Town')
N, Q = map(int, input().split())
Tree = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    Tree[a - 1].append(b - 1)
    Tree[b - 1].append(a - 1)

stack = [(0, 0)]
color = [-1 for _ in range(N)]
while len(stack) != 0:
    x, c = stack.pop()
    if color[x] != -1:
        continue

    for p in Tree[x]:
        if c == 0:
            stack.append((p, 1))
        else:
            stack.append((p, 0))

    color[x] = c

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if color[c] == color[d]:
        print('Town')
    else:
        print('Road')
import queue

n, q = map(int, input().split())

edge = {}
for i in range(n):
    edge[i] = []

for i in range(n - 1):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)

# print(edge)

color = [-1 for i in range(n)]
color[0] = 0

visited = [False for i in range(n)]

# def dfs(v, even):
#     visited[v] = True

#     if even:
#         even_v[v] = True

#     for w in edge[v]:
#         if not visited[w]:
#             dfs(w, not even)

# dfs(0, True)

que = queue.Queue()
que.put(0)

while not que.empty():
    v = que.get()

    for w in edge[v]:
        if color[w] == -1:
            color[w] = 1 - color[v]
            que.put(w)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
def nearlist(n0):
    res = [[] for _ in range(n0)]
    for a, b in AB:
        res[a - 1].append(b - 1)
        res[b - 1].append(a - 1)
    return res


def bfs(s0, n0, near0):
    dist = [-1] * n0
    dist[s0] = 0
    que = [s0]

    for q in que:
        for i in near0[q]:
            if dist[i] > -1:
                continue
            dist[i] = dist[q] + 1
            que.append(i)
    return dist


def main():
    near = nearlist(N)
    dist = bfs(0, N, near)
    for c, d in CD:
        res = (dist[c - 1] - dist[d - 1]) % 2
        print('Road' if res else 'Town')


if __name__ == '__main__':
    N, Q = map(int, input().split())
    AB = [list(map(int, input().split())) for _ in range(N - 1)]
    CD = [list(map(int, input().split())) for _ in range(Q)]

    main()
n, q = map(int, input().split())
root = [[] for i in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    root[a].append(b)
    root[b].append(a)

d = [10**8] * (n + 1)
d[1] = 0

seen = [0] * (n + 1)
ind = [0] * (n + 1)


# record=[[] for i in range(n+1)] # 変数の情報記録
def tree_search(n, G, s, func1, func2, func3):
    #n...頂点の数
    #G...G[v]は頂点vから行ける頂点の配列
    #s...sが根
    #func1(now)...ある頂点に初めて訪れた時、その頂点のみでする処理。ない場合は0
    #func2(now,next)...nowからnextに移動する時に行う処理。ない場合は0
    #func3(now)...nowを去る時にする処理。なければ0

    search = [s]
    while search:
        now = search[-1]
        if seen[now] == 0 and func1 != 0: func1(now)
        seen[now] = 1
        if len(G[now]) > ind[now]:
            next = G[now][ind[now]]
            ind[now] += 1
            if seen[next] > 0: continue
            if func2 != 0: func2(now, next)
            search.append(next)
        else:
            if func3 != 0: func3(now)
            search.pop()


def f2(x, y):
    d[y] = d[x] + 1


tree_search(n, root, 1, 0, f2, 0)

for i in range(q):
    a, b = map(int, input().split())
    ans = d[a] - d[b]
    ans %= 2
    if ans == 0: print("Town")
    else: print("Road")
import sys

INF = float('inf')
#10**20,2**63,float('inf')
MOD = 10**9 + 7
MOD2 = 998244353


#from collections import defaultdict
def II():
    return int(sys.stdin.readline())


def LI():
    return list(map(int, sys.stdin.readline().split()))


def LC():
    return list(input())


def IC():
    return [int(c) for c in input()]


def MI():
    return map(int, sys.stdin.readline().split())


N, Q = MI()
Graph = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    A, B = MI()
    Graph[A].append(B)
    Graph[B].append(A)
Color = [0] * (N + 1)  # 頂点iの色(1 or -1)


# 頂点を1と-1で塗っていく
def dfs(s, c):
    Color[s] = c  # 頂点vをcで塗る
    for t in Graph[s]:
        # 隣接している頂点が同じ色ならFalse
        if Color[t] == c:
            return False
        # 隣接している頂点がまだ塗られていないなら-cで塗る
        if Color[t] == 0 and not dfs(t, -c):
            return False
    # すべての頂点を塗れたらTrue
    return True


sys.setrecursionlimit(10**6)  #再帰関数ではコメントにしないこと！！
dfs(1, 1)
for _ in range(Q):
    C, D = MI()
    if (Color[C] == Color[D]):
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)

Que = deque()
Que.append(0)
dist = [-1] * N
dist[0] = 0
while len(Que) > 0:
    i = Que.popleft()
    for j in edge[i]:
        if dist[j] != -1:
            continue
        dist[j] = dist[i] + 1
        Que.append(j)

for i in range(Q):
    c, d = map(int, input().split())
    d = abs(dist[c - 1] - dist[d - 1])
    if d % 2 == 0:
        print('Town')
    else:
        print('Road')
import math, itertools, fractions, heapq, collections, bisect, sys, queue, copy

sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7
dd = [(-1, 0), (0, 1), (1, 0), (0, -1)]
ddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]


def LI():
    return [int(x) for x in sys.stdin.readline().split()]


# def LF(): return [float(x) for x in sys.stdin.readline().split()]
def I():
    return int(sys.stdin.readline())


def F():
    return float(sys.stdin.readline())


def LS():
    return sys.stdin.readline().split()


def S():
    return input()


# dijkstra -- START --
def dijkstra(n, s, edge):
    d = [10**20] * n
    used = [False] * n
    d[s] = 0
    used[s] = True
    pq = []
    for e in edge[s]:
        heapq.heappush(pq, e)
    while pq:
        c, v = heapq.heappop(pq)
        if used[v]:
            continue
        d[v] = c
        used[v] = True
        for nc, nv in edge[v]:
            if not used[nv]:
                nd = nc + c
                if d[nv] > nd:
                    heapq.heappush(pq, [nd, nv])
    return d


# How to use -- START --
# Verify: https://atcoder.jp/contests/typical90/tasks/typical90_m
#
# edge=[[] for _ in range(n)]
# for _ in range(m):
#   x,y,cost=LI()
#   x-=1
#   y-=1
#   edge[x].append([cost,y])
#   edge[y].append([cost,x])
# st=0
# d=dijkstra(n,st,edge)
#
# How to use --- END ---
# dijkstra --- END ---

n, q = LI()
V = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = LI()
    a -= 1
    b -= 1
    V[a].append([1, b])
    V[b].append([1, a])

d = dijkstra(n, 0, V)
ans = []
for _ in range(q):
    c, dd = LI()
    c -= 1
    dd -= 1
    if abs(d[c] - d[dd]) % 2 == 0:
        ans.append('Town')
    else:
        ans.append('Road')

for x in ans:
    print(x)

# def main():

# main()
# print(main())
#!/usr/bin/env python3
import sys

sys.setrecursionlimit(200_000)


def solve(N, Q, AB, CD):
    edges = [[] for _ in range(N + 1)]
    for a, b in AB:
        edges[a].append(b)
        edges[b].append(a)

    depth = [None] * (N + 1)

    def dfs(cur, d):
        if depth[cur] is not None:
            return
        depth[cur] = d
        for nex in edges[cur]:
            dfs(nex, d + 1)

    dfs(1, 0)

    for c, d in CD:
        if abs(depth[c] - depth[d]) % 2 == 0:
            yield "Town"
        else:
            yield "Road"


def main():
    N, Q = map(int, input().split())
    AB = [tuple(map(int, input().split())) for _ in range(N - 1)]
    CD = [tuple(map(int, input().split())) for _ in range(Q)]
    print(*solve(N, Q, AB, CD), sep="\n")


if __name__ == '__main__':
    main()
# coding #

import math
import collections
import itertools
from collections import deque
import queue

# import numpy as np

import sys

sys.setrecursionlimit(10000)

n7 = 1000000007
res = float('inf')
ans = 0
flag = True

N, Q = list(map(int, input().split()))
G = [[] for i in range(N + 1)]

for i in range(N - 1):
    A, B = list(map(int, input().split()))
    G[A].append(B)
    G[B].append(A)

depth_vec = [-1 for _ in range(N + 1)]
q = deque()
q.append((1, 0))

while len(q) > 0:
    node, depth = q.pop()
    depth_vec[node] = depth
    for child in G[node]:
        if depth_vec[child] >= 0:
            continue
        q.append((child, depth + 1))

for query in range(Q):
    C, D = list(map(int, input().split()))
    if (depth_vec[C] + depth_vec[D]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]
cd = [list(map(int, input().split())) for _ in range(Q)]

edges = [set() for _ in range(N)]
for a, b in ab:
    edges[a - 1].add(b - 1)
    edges[b - 1].add(a - 1)

stack = [(True, 0)]
reached = [False] * N
reached[0] = True
evens = [True] * N
while stack:
    even, city = stack.pop()
    evens[city] = even
    for to in edges[city]:
        if reached[to]:
            continue
        reached[to] = True
        stack.append((not even, to))

for c, d in cd:
    if (evens[c - 1] + evens[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
class Tree():
    def __init__(self, n):
        self.n = n
        self.tree = [[] for _ in range(n)]
        self.root = None

    def add_edge(self, u, v):
        self.tree[u].append(v)
        self.tree[v].append(u)

    def set_root(self, r=0):
        self.root = r
        self.par = [None] * self.n
        self.dep = [0] * self.n
        self.height = [0] * self.n
        self.size = [1] * self.n
        self.ord = [r]
        stack = [r]
        while stack:
            v = stack.pop()
            for adj in self.tree[v]:
                if self.par[v] == adj: continue
                self.par[adj] = v
                self.dep[adj] = self.dep[v] + 1
                self.ord.append(adj)
                stack.append(adj)
        for v in self.ord[1:][::-1]:
            self.size[self.par[v]] += self.size[v]
            self.height[self.par[v]] = max(self.height[self.par[v]],
                                           self.height[v] + 1)

    def rerooting(self, op, e, merge, id):
        if self.root is None: self.set_root()
        dp = [e] * self.n
        lt = [id] * self.n
        rt = [id] * self.n
        inv = [id] * self.n
        for v in self.ord[::-1]:
            tl = tr = e
            for adj in self.tree[v]:
                if self.par[v] == adj: continue
                lt[adj] = tl
                tl = op(tl, dp[adj])
            for adj in self.tree[v][::-1]:
                if self.par[v] == adj: continue
                rt[adj] = tr
                tr = op(tr, dp[adj])
            dp[v] = tr
        for v in self.ord:
            if v == self.root: continue
            p = self.par[v]
            inv[v] = op(merge(lt[v], rt[v]), inv[p])
            dp[v] = op(dp[v], inv[v])
        return dp

    def euler_tour(self):
        if self.root is None: self.set_root()
        self.tour = []
        self.etin = [None for _ in range(self.n)]
        self.etout = [None for _ in range(self.n)]
        used = [0 for _ in range(self.n)]
        used[self.root] = 1
        stack = [self.root]
        while stack:
            v = stack.pop()
            if v >= 0:
                self.tour.append(v)
                stack.append(~v)
                if self.etin[v] is None:
                    self.etin[v] = len(self.tour) - 1
                for adj in self.tree[v]:
                    if used[adj]: continue
                    used[adj] = 1
                    stack.append(adj)
            else:
                self.etout[~v] = len(self.tour)
                if ~v != self.root:
                    self.tour.append(self.par[~v])

    def heavylight_decomposition(self):
        if self.root is None: self.set_root()
        self.hldid = [None] * self.n
        self.hldtop = [None] * self.n
        self.hldtop[self.root] = self.root
        self.hldnxt = [None] * self.n
        self.hldrev = [None] * self.n
        stack = [self.root]
        cnt = 0
        while stack:
            v = stack.pop()
            self.hldid[v] = cnt
            self.hldrev[cnt] = v
            cnt += 1
            maxs = 0
            for adj in self.tree[v]:
                if self.par[v] == adj: continue
                if maxs < self.size[adj]:
                    maxs = self.size[adj]
                    self.hldnxt[v] = adj
            for adj in self.tree[v]:
                if self.par[v] == adj or self.hldnxt[v] == adj: continue
                self.hldtop[adj] = adj
                stack.append(adj)
            if self.hldnxt[v] is not None:
                self.hldtop[self.hldnxt[v]] = self.hldtop[v]
                stack.append(self.hldnxt[v])

    def lca(self, u, v):
        while True:
            if self.hldid[u] > self.hldid[v]: u, v = v, u
            if self.hldtop[u] != self.hldtop[v]:
                v = self.par[self.hldtop[v]]
            else:
                return u

    def dist(self, u, v):
        lca = self.lca(u, v)
        return self.dep[u] + self.dep[v] - 2 * self.dep[lca]

    def range_query(self, u, v, edge_query=False):
        while True:
            if self.hldid[u] > self.hldid[v]: u, v = v, u
            if self.hldtop[u] != self.hldtop[v]:
                yield self.hldid[self.hldtop[v]], self.hldid[v] + 1
                v = self.par[self.hldtop[v]]
            else:
                yield self.hldid[u] + edge_query, self.hldid[v] + 1
                return

    def subtree_query(self, u):
        return self.hldid[u], self.hldid[u] + self.size[u]

    def _get_centroid_(self, r):
        self._par_[r] = None
        self._size_[r] = 1
        ord = [r]
        stack = [r]
        while stack:
            v = stack.pop()
            for adj in self.tree[v]:
                if self._par_[v] == adj or self.cdused[adj]: continue
                self._size_[adj] = 1
                self._par_[adj] = v
                ord.append(adj)
                stack.append(adj)
        if len(ord) <= 2: return r
        for v in ord[1:][::-1]:
            self._size_[self._par_[v]] += self._size_[v]
        sr = self._size_[r] // 2
        v = r
        while True:
            for adj in self.tree[v]:
                if self._par_[v] == adj or self.cdused[adj]: continue
                if self._size_[adj] > sr:
                    v = adj
                    break
            else:
                return v

    def centroid_decomposition(self):
        self._par_ = [None] * self.n
        self._size_ = [1] * self.n
        self.cdpar = [None] * self.n
        self.cddep = [0] * self.n
        self.cdord = [None] * self.n
        self.cdused = [0] * self.n
        cnt = 0
        stack = [0]
        while stack:
            v = stack.pop()
            p = self.cdpar[v]
            c = self._get_centroid_(v)
            self.cdused[c] = True
            self.cdpar[c] = p
            self.cddep[c] = self.cddep[v]
            self.cdord[c] = cnt
            cnt += 1
            for adj in self.tree[c]:
                if self.cdused[adj]: continue
                self.cdpar[adj] = c
                self.cddep[adj] = self.cddep[c] + 1
                stack.append(adj)

    def centroid(self):
        if self.root is None: self.set_root()
        sr = self.size[self.root] // 2
        v = self.root
        while True:
            for adj in self.tree[v]:
                if self.par[v] == adj: continue
                if self.size[adj] > sr:
                    v = adj
                    break
            else:
                return v

    def diam(self):
        if self.root is None: self.set_root()
        u = self.dep.index(max(self.dep))
        self.set_root(u)
        v = self.dep.index(max(self.dep))
        return u, v

    def get_path(self, u, v):
        if self.root != u: self.set_root(u)
        path = []
        while v != None:
            path.append(v)
            v = self.par[v]
        return path

    def longest_path_decomposition(self, make_ladder=True):
        assert self.root is not None
        self.lpdnxt = [None] * self.n
        self.lpdtop = [None] * self.n
        self.lpdtop[self.root] = self.root
        stack = [self.root]
        while stack:
            v = stack.pop()
            for adj in self.tree[v]:
                if self.par[v] == adj: continue
                if self.height[v] == self.height[adj] + 1:
                    self.lpdnxt[v] = adj
            for adj in self.tree[v]:
                if self.par[v] == adj or self.lpdnxt[v] == adj: continue
                self.lpdtop[adj] = adj
                stack.append(adj)
            if self.lpdnxt[v] is not None:
                self.lpdtop[self.lpdnxt[v]] = self.lpdtop[v]
                stack.append(self.lpdnxt[v])
        if make_ladder: self._make_ladder_()

    def _make_ladder_(self):
        self.ladder = [[] for _ in range(self.n)]
        for v in range(self.n):
            if self.lpdtop[v] != v: continue
            to = v
            path = []
            while to is not None:
                path.append(to)
                to = self.lpdnxt[to]
            p = self.par[v]
            self.ladder[v] = path[::-1]
            for i in range(len(path)):
                self.ladder[v].append(p)
                if p is None: break
                p = self.par[p]

    def level_ancestor(self, v, k):
        while v is not None:
            id = self.height[v]
            h = self.lpdtop[v]
            if len(self.ladder[h]) > k + id:
                return self.ladder[h][k + id]
            v = self.ladder[h][-1]
            k -= len(self.ladder[h]) - id - 1


import sys

input = sys.stdin.buffer.readline

N, Q = map(int, input().split())

t = Tree(N)

for _ in range(N - 1):
    a, b = map(int, input().split())
    t.add_edge(a - 1, b - 1)

t.heavylight_decomposition()

for _ in range(Q):
    c, d = map(int, input().split())
    l = t.dist(c - 1, d - 1)
    if l % 2 == 0:
        print('Town')

    else:
        print('Road')
n, q = map(int, input().split())
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)
from collections import deque

d = deque()
d.append(0)
l = [-1] * n
l[0] = 0
while d:
    now = d.popleft()
    for i in g[now]:
        if l[i] == -1:
            d.append(i)
            l[i] = 1 - l[now]
for i in range(q):
    c, d = map(int, input().split())
    if l[c - 1] == l[d - 1]:
        print("Town")
    else:
        print("Road")
# print(l)
# print(g)
from collections import deque

N, q = map(int, input().split())
X = [[] for i in range(N)]
for i in range(N - 1):
    x, y = map(int, input().split())
    x, y = x - 1, y - 1
    X[x].append(y)
    X[y].append(x)

P = [-1] * N
Q = deque([0])
R = []
D = [0] * N
while Q:
    i = deque.popleft(Q)
    R.append(i)
    for a in X[i]:
        if a != P[i]:
            P[a] = i
            D[a] = D[i] ^ 1
            X[a].remove(i)
            deque.append(Q, a)

for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    print("Road" if D[c] ^ D[d] else "Town")
from collections import deque

n, Q = map(int, input().split())
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

q = deque()
q.append(0)

d = [-1] * n
d[0] = 0

while q:
    v = q.popleft()
    for nv in g[v]:
        if d[nv] == -1:
            d[nv] = d[v] + 1
            q.append(nv)

for i in range(Q):
    C, D = map(int, input().split())
    C -= 1
    D -= 1
    if (d[C] + d[D]) % 2:
        print("Road")
    else:
        print("Town")from collections import deque

N, Q = map(int, input().split())
e = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    e[a].append(b)
    e[b].append(a)
cd = [list(map(int, input().split())) for _ in range(Q)]

flag = [0 for _ in range(N + 1)]
visited = [0 for _ in range(N + 1)]

q = deque()
q.append([1, 1])  #[街番号, flag]
flag[1] = 1

while q:
    t, f = q.popleft()
    if visited[t]:
        continue
    visited[t] = 1
    if f:
        flag[t] = 1
    else:
        flag[t] = 0
    for v in e[t]:
        if f:
            q.append([v, 0])
        else:
            q.append([v, 1])

for c, d in cd:
    if flag[c] == flag[d]:
        print("Town")
    else:
        print("Road")
#abc209_d
import sys, math, collections, itertools, heapq, functools, bisect

input = sys.stdin.readline
sys.setrecursionlimit(10**7)
m = 10**9 + 7


def intm1(num):
    return int(num) - 1


intfunc = [int, intm1]


def II(i=0):
    return intfunc[i](input())


def LII(i=0):
    return list(map(intfunc[i], input().split()))


def SI():
    return input().rstrip()


def LSI():
    return list(input().rstrip().split())


inf = float("inf")


def yes():
    return print("Yes")


def no():
    return print("No")


#abc209_d

N, Q = LII()
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = LII(1)
    edge[a].append(b)
    edge[b].append(a)

point = [inf] * N
point[0] = 0
q = collections.deque()
q.append(0)
while q:
    now = q.popleft()
    for ed in edge[now]:
        if point[ed] > point[now] + 1:
            q.append(ed)
            point[ed] = point[now] + 1

for _ in range(Q):
    a, b = LII(1)
    c = abs(point[a] - point[b])
    if c % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)


def bfs(x):
    d = [-1] * N
    d[x] = 0
    queue = deque([x])
    while queue:
        x = queue.popleft()
        for y in graph[x]:
            if d[y] < 0:
                d[y] = d[x] + 1
                queue.append(y)
    return d


ans = bfs(1)
for i in range(Q):
    c, d = map(int, input().split())
    if abs(ans[c - 1] - ans[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import defaultdict
import queue


class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def even_or_odd_BFS(self, n):
        even_or_odd_list = [None] * (n + 1)
        e_or_o = "even"
        even_or_odd_list[1] = e_or_o
        que = queue.Queue()
        que.put(1)

        while not que.empty():
            e_or_o = "odd" if e_or_o == "even" else "even"
            qs = que.qsize()
            for _ in range(qs):
                r = que.get()
                for x in self.graph[r]:
                    if even_or_odd_list[x] == None:
                        even_or_odd_list[x] = e_or_o
                        que.put(x)
        return even_or_odd_list


n, q = map(int, input().split())
g = Graph()
for _ in range(n - 1):
    u, v = map(int, input().split())
    g.add_edge(u, v)
    g.add_edge(v, u)

even_or_odd_list = g.even_or_odd_BFS(n)

for _ in range(q):
    u, v = map(int, input().split())
    if even_or_odd_list[u] == even_or_odd_list[v]: print("Town")
    else: print("Road")
from collections import deque


def solve(n, q, ab_list, cd_list):
    g = [[] for _ in range(n + 1)]
    for a, b in ab_list:
        g[a].append(b)
        g[b].append(a)

    color = [-1] * (n + 1)
    color[1] = 1
    queue = deque([1])
    while len(queue):
        p = queue.popleft()
        for q in g[p]:
            if color[q] == -1:
                color[q] = 1 - color[p]
                queue.append(q)
    res = []
    for c, d in cd_list:
        if color[c] == color[d]:
            res.append("Town")
        else:
            res.append("Road")
    return res


def main():
    n, q = map(int, input().split())
    ab_list = [tuple(map(int, input().split())) for _ in range(n - 1)]
    cd_list = [tuple(map(int, input().split())) for _ in range(q)]
    res = solve(n, q, ab_list, cd_list)
    for r in res:
        print(r)


def test():
    assert solve(4, 1, [(1, 2), (2, 3), (2, 4)], [(1, 2)]) == ["Road"]
    assert solve(5, 2, [(1, 2), (2, 3), (3, 4), (4, 5)],
                 [(1, 3), (1, 5)]) == ["Town", "Town"]


if __name__ == "__main__":
    test()
    main()
import heapq

n, q = map(int, input().split())
edges = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)

INF = 10**20
Q = []
heapq.heappush(Q, (0, 0))
visited = [False] * n
visited[0] = True
dist = [INF] * n
dist[0] = 0
while len(Q) > 0:
    d, point = heapq.heappop(Q)
    for c in edges[point]:
        dd = d + 1
        if not visited[c] and dist[c] > dd:
            heapq.heappush(Q, (dd, c))
            dist[c] = dd
            visited[c] = True

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    dx = abs(dist[d] - dist[c])
    if dx % 2 == 0:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
CHECKED = [-1 for i in range(N + 1)]
ROOT = [[] for i in range(N + 1)]

for i in range(N - 1):
    a, b = map(int, input().split())
    ROOT[a].append(b)
    ROOT[b].append(a)

queue = [1]
CHECKED[1] = 0

#幅優先探索
while not queue == []:
    now = queue.pop(0)
    for n in ROOT[now]:
        if CHECKED[n] == -1:
            CHECKED[n] = CHECKED[now] + 1
            queue.append(n)

cd = []

for j in range(Q):
    c, d = map(int, input().split())
    cd.append([c, d])

for k in cd:
    if (CHECKED[k[0]] - CHECKED[k[1]]) % 2 == 0:
        print("Town")
    else:
        print("Road")
#from itertools import product
#from itertools import combinations
#from collections import Counter
#from collections import defaultdict
#from collections import deque # deque([iterable[, maxlen]])
#from heapq import heapify, heappop, heappush # func(heapifiedlist, item)
# sadness lies below
#from bisect import bisect_left, bisect_right, insort # func(sortedlist, item)
#from sys import setrecursionlimit

from sys import stdin, stderr

input = stdin.readline


def dbp(*args, **kwargs):  # calling with dbp(locals()) is perfectly cromulent
    pass  # print(*args, file=stderr, **kwargs)


def get_int_list():
    return [int(x) for x in input().strip().split()]


def do_thing():
    N, Q = get_int_list()
    g = [[] for v in range(N)]
    for r in range(N - 1):
        a, b = get_int_list()
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)
    dbp(g)
    rbv = [None] * N
    q = [(0, True)]
    while q:
        v, rb = q.pop()
        if rbv[v] != None:
            continue
        rbv[v] = rb
        for cv in g[v]:
            if rbv[cv] == None:
                q.append((cv, not rb))
    dbp(rbv)

    outl = []
    for q in range(Q):
        c, d = get_int_list()
        dbp(c - 1, d - 1, rbv[c - 1], rbv[d - 1])
        if rbv[c - 1] != rbv[d - 1]:
            outl.append('Road')
        else:
            outl.append('Town')

    return '\n'.join(outl)


def multicase():
    maxcc = int(input().strip())
    for cc in range(maxcc):
        print(do_thing())


if __name__ == "__main__":
    #multicase()
    print(do_thing())
def resolve():
    import sys
    sys.setrecursionlimit(2147483647)
    INF = float("inf")
    MOD = 10**9 + 7
    input = sys.stdin.readline

    class LCA:
        """
        construct: O(NlogN)
        query: O(logN)
        """
        def __init__(self, edges, root=0):
            """
            :param list of (list of int) edges:
            :param int root=0:
            """
            self.edges = edges
            self.n = len(edges)  # n=|V|
            self.logn = (self.n - 1).bit_length()  # logn=ceil(log2(n))
            self.depths = [-1] * self.n
            self.parents = [[-1] * self.n for _ in range(self.logn)]
            # construct
            self.__dfs(-1, root, 0)
            self.__doubling()

        def __dfs(self, par, cur, dep):
            self.depths[cur] = dep
            self.parents[0][cur] = par
            for v in self.edges[cur]:
                if self.depths[v] == -1:  # 深さ-1＝訪れていない(rootから連結な部分しか探索しない)
                    self.__dfs(cur, v, dep + 1)

        def __doubling(self):
            for i in range(1, self.logn):
                for v in range(self.n):
                    if self.parents[
                            i - 1][v] == -1:  # 親が存在しないとき。-1を通すとlistの末尾を取得してしまう
                        continue
                    self.parents[i][v] = self.parents[i -
                                                      1][self.parents[i -
                                                                      1][v]]

        def get(self, u, v):  # u,vのLCAを返す
            dd = self.depths[v] - self.depths[u]
            if dd < 0:  # vの方が深いようにする
                u, v = v, u
                dd *= -1
            for i in range(self.logn):
                if dd & (1 << i):
                    v = self.parents[i][v]

            if v == u: return v  # 高さ揃えた時点で一致してたら終わり

            # そうでなければ上から二分探索
            for i in reversed(range(self.logn)):
                pu, pv = self.parents[i][u], self.parents[i][v]
                if pu != pv:
                    u, v = pu, pv
            return self.parents[0][u]

    # input
    n, Q = map(int, input().split())
    edges = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = map(lambda x: int(x) - 1, input().split())
        edges[u].append(v)
        edges[v].append(u)
    lca = LCA(edges)
    for _ in range(Q):
        u, v = map(lambda x: int(x) - 1, input().split())
        if (lca.depths[u] + lca.depths[v] -
                2 * lca.depths[lca.get(u, v)]) % 2 == 0:
            print("Town")
        else:
            print("Road")


resolve()
from collections import deque

n, q = map(int, input().split())

#グラフ
l = [[] for i in range(n)]
#次の目的地管理
dq = deque()
#スタートからの距離と訪問/未訪問を同時管理
dist = [-1] * n

for i in range(n - 1):
    a, b = map(int, input().split())
    l[a - 1].append(b - 1)
    l[b - 1].append(a - 1)

#幅優先探索はゴールだけに結果を求めるのではなく、
#スタート地点からの最短距離をスタート地点以外のすべての頂点について記録し、
#あとからゴール地点を検索する
dq.append(0)
dist[0] = 0
while len(dq) > 0:
    s = dq.popleft()
    for j in l[s]:
        if dist[j] == -1:
            dist[j] = dist[s] + 1
            dq.append(j)

for i in range(q):
    c, d = map(int, input().split())
    if dist[c - 1] % 2 == dist[d - 1] % 2:
        print('Town')
    else:
        print('Road')
import collections

n, q = map(int, input().split())

g = []
for _ in range(n + 1):
    g.append([])

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

visited = [False] * (n + 1)
visited[1] = True

queue = collections.deque([1])
dist = [0] * (n + 1)

while queue:
    flag = False
    que = queue.popleft()

    for k in g[que]:
        if visited[k]:
            continue
        else:
            visited[k] = True
            dist[k] += dist[que] + 1
            queue.append(k)

    if flag:
        break

for j in range(q):
    c, d = map(int, input().split())
    e = dist[c] - dist[d]
    if e % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, QQ = map(int, input().split())

graph = []
for i in range(N + 1):
    graph.append([])

for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

cd = []
for i in range(QQ):
    c, d = map(int, input().split())
    cd.append([c, d])

Q = deque()
Q.append(1)
memo = [-1] * (N + 1)
TF = [False] * (N + 1)
TF[0] = True
memo[1] = 0
TF[1] = True

while len(Q) > 0:
    tmp = Q.popleft()
    for z in graph[tmp]:
        if not TF[z]:
            TF[z] = True
            memo[z] = memo[tmp] + 1
            Q.append(z)

for x, y in cd:
    if abs(memo[y] - memo[x]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
roads = [[] for _ in range(n)]
que = deque()

for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    roads[a].append(b)
    roads[b].append(a)

dist = [-1] * n
que.append(0)
dist[0] = 0
while len(que) > 0:
    now = que.popleft()
    for i in roads[now]:
        if dist[i] != -1: continue
        dist[i] = dist[now] + 1
        que.append(i)

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append((1, b - 1))
    graph[b - 1].append((1, a - 1))
ans = [0] * (N)
import heapq

hq = [(0, 0)]
g = [float('inf')] * N
g[0] = 0
while hq:
    cost, v = heapq.heappop(hq)
    if cost > g[v]:
        continue
    for dd, u in graph[v]:
        tmp = dd + g[v]
        if tmp < g[u]:
            g[u] = tmp
            heapq.heappush(hq, (tmp, u))
for i in range(N):
    if g[i] % 2 == 1:
        ans[i] = 1
dd = [0] * Q
for i in range(Q):
    c, d = map(int, input().split())
    c = c - 1
    d = d - 1
    if ans[c] != ans[d]:
        dd[i] = 1
for i in range(Q):
    if dd[i] == 0:
        print('Town')
    else:
        print('Road')
import sys
from collections import defaultdict, deque

n, q = map(int, sys.stdin.buffer.readline().split())

graph = defaultdict(list)

for _ in range(n - 1):
    a, b = map(int, sys.stdin.buffer.readline().split())
    a, b = a - 1, b - 1
    graph[a].append(b)
    graph[b].append(a)

colors = [-1] * n
colors[0] = 0

que = deque([0])
while que:
    v = que.popleft()
    for w in graph[v]:
        if colors[w] == -1:
            colors[w] = 1 - colors[v]
            que.append(w)

for _ in range(q):
    c, d = map(int, sys.stdin.buffer.readline().split())
    c, d = c - 1, d - 1
    if colors[c] == colors[d]:
        print('Town')
    else:
        print('Road')
from sys import setrecursionlimit

setrecursionlimit(10**6)


def dfs(pos, pre):
    for i in G[pos]:
        if i == pre:
            continue
        dist[i] = dist[pos] ^ 1
        dfs(i, pos)


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)
dist = [0] * N
dfs(0, 0)
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dist[c] == dist[d]:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
con = [set() for i in range(n + 1)]

for i in range(n - 1):
    _a, _b = map(int, input().split())
    con[_a].add(_b)
    con[_b].add(_a)

dq = deque()
dist = [0 for i in range(n + 1)]
for i in con[i]:
    dq.append(i)
    dist[i] = 1

while len(dq) != 0:
    k = dq.popleft()
    for i in con[k]:
        if dist[i] == 0 or dist[i] > dist[k] + 1:
            dq.append(i)
            dist[i] = dist[k] + 1

for i in range(q):
    _c, _d = map(int, input().split())
    if (dist[_c] + dist[_d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
def BFS_starting_from_one(s, Adj):  #if nodes start from one
    level = {s: 0}
    parent = {s: None}
    i = 1
    frontier = [s]
    while frontier:
        next1 = []
        for u in frontier:
            for v in Adj[u - 1]:  #only change from BFS
                if v not in level:
                    level[v] = i
                    parent[v] = u
                    next1.append(v)
        frontier = next1
        i += 1
    return level


n, q = map(int, input().split())
adj_list = [[] for j in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    adj_list[a].append(b)
    adj_list[b].append(a)
adj_list.pop(0)
for i in range(n):
    adj_list[i].sort()
ans = BFS_starting_from_one(1, adj_list)
for i in range(q):
    c, d = map(int, input().split())
    distance = abs(ans[d] - ans[c])
    if distance % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = (int(x) for x in input().split())
town = []
root = [[] for i in range(n)]
dis = [-1 for i in range(n)]
dis[0] = 0

for i in range(n - 1):
    a, b = (int(x) for x in input().split())
    root[a - 1].append(b)
    root[b - 1].append(a)
for i in range(q):
    c, d = (int(x) for x in input().split())
    town.append((c, d))
dis = [-1 for i in range(n)]
dis[0] = 0

for i in range(len(root[0])):
    if i == 0:
        que = deque([[root[0][i], 0]])
    else:
        que.appendleft([root[0][i], 0])
while que:
    go, dist = que.pop()
    dis[go - 1] = dist + 1
    for i in root[go - 1]:
        if dis[i - 1] == -1:
            que.appendleft([i, dist + 1])
for c, d in town:
    if (dis[c - 1] - dis[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**7)
N, Q = map(int, input().split())
es = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    es[a - 1].append(b - 1)
    es[b - 1].append(a - 1)

colors = [0 for i in range(N)]


def dfs(v, color):
    #今いる点を着色
    colors[v] = color
    #今の頂点から行けるところをチェック
    for to in es[v]:
        #同じ色が隣接してしまったらFalse
        if colors[to] == color:
            return False
        #未着色の頂点があったら反転した色を指定し、再帰的に調べる
        if colors[to] == 0 and not dfs(to, -color):
            return False
    #調べ終わったら矛盾がないのでTrue
    return colors


z = dfs(0, 1)

for i in range(Q):
    c, d = map(int, input().split())
    if z[c - 1] == z[d - 1]:
        print('Town')
    else:
        print('Road')
#!/usr/bin/env python3
from collections import deque


def wfs(num):
    q = deque([[num, 0]])
    while q:
        k, d = q.popleft()
        for i in G[k]:
            if depth[i] == -1:
                depth[i] = d + 1
                q.append([i, depth[i]])
    return


N, Q = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a] += [b]
    G[b] += [a]

depth = [-1] * N
depth[0] = 0

wfs(0)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    delta = abs(depth[c] - depth[d]) % 2

    if delta == 0:
        print("Town")
    else:
        print("Road")
from collections import deque
import sys

sys.setrecursionlimit(10**9)
# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)
N, Q = map(int, input().split(" "))
KK = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split(" "))
    KK[a - 1].append(b - 1)
    KK[b - 1].append(a - 1)

G = [[] for _ in range(N)]
D = [-1] * N
D[0] = 0
q = deque([0])
C = set()
C.add(0)
while q:
    p = q.popleft()
    for i in KK[p]:
        if i not in C:
            q.append(i)
            C.add(i)
            G[p].append(i)
            D[i] = D[p] + 1

# Euler Tour の構築
S = []
F = [0] * N
depth = [0] * N


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in G[v]:
        dfs(w, d + 1)
        S.append(v)


dfs(0, 0)

# 存在しない範囲は深さが他よりも大きくなるようにする
INF = (N, None)

# LCAを計算するクエリの前計算
M = 2 * N
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


# LCAの計算 (外から呼び出す関数)
def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for i in range(Q):
    c, d = map(int, input().split(" "))
    ans = D[c - 1] + D[d - 1] - 2 * D[query(c - 1, d - 1)]
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
N, Q = map(int, input().split())


class DSU:
    def __init__(self, N: int) -> None:
        self.par = list(range(N))
        self.sz = [1] * N

    def find(self, x: int) -> int:
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]

    def unite(self, x: int, y: int) -> bool:
        x, y = self.find(x), self.find(y)
        if x == y:
            return False
        if self.sz[x] < self.sz[y]:
            x, y = y, x
        self.par[y] = x
        self.sz[x] += self.sz[y]
        return True


dsu = DSU(N * 2)

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    dsu.unite(a, b + N)
    dsu.unite(b, a + N)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dsu.find(c) == dsu.find(d):
        print("Town")
    else:
        print("Road")
from collections import deque


def bfs(c, d):
    queue = deque([c])
    dis[c] = 0
    while queue:
        # print(queue)
        v = queue.popleft()
        for i in road[v]:
            if dis[i] == None:
                queue.append(i)
                dis[i] = dis[v] + 1
                # road[v].remove(i)


n, q = map(int, input().split())
road = [[] for _ in range(n)]
for i in range(n - 1):
    ab = list(map(int, input().split()))
    road[ab[0] - 1].append(ab[1] - 1)
    road[ab[1] - 1].append(ab[0] - 1)
ans = []
# print(road)
dis = [None] * n
bfs(0, n)
# print(dis)
for i in range(q):
    cd = list(map(int, input().split()))
    c = cd[0] - 1
    d = cd[1] - 1
    if (dis[c] + dis[d]) % 2 != 0:
        ans.append(True)
    else:
        ans.append(False)
for i in ans:
    if i:
        print("Road")
    else:
        print("Town")
def main():
    import sys
    input = sys.stdin.readline
    from collections import defaultdict, deque
    n, q = map(int, input().split())

    G = defaultdict(list)
    for _ in range(n - 1):
        a, b = map(int, input().split())
        G[a].append(b)
        G[b].append(a)

    # BFS
    dist = {}
    que = deque()
    dist[1] = 0
    que.append(1)
    while len(que) > 0:
        v = que.popleft()
        for x in G[v]:
            if x in dist:
                continue
            dist[x] = dist[v] + 1
            que.append(x)

    for _ in range(q):
        c, d = map(int, input().split())
        t = dist[c] - dist[d]
        print('Town' if t % 2 == 0 else 'Road')


main()
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

D = [-1] * n


def dfs(v, d=0):
    D[v] = d
    for u in G[v]:
        if D[u] == -1: dfs(u, d + 1)


dfs(0)

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print('Road' if (D[c] + D[d]) % 2 else 'Town')
n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

from collections import deque

P = [-1] * n
P[0] = 0
dq = deque([0])
while dq:
    v = dq.popleft()
    for u in G[v]:
        if P[u] >= 0: continue
        P[u] = P[v] + 1
        dq.append(u)

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print('Road' if (P[c] + P[d]) % 2 else 'Town')
#!/usr/bin/env python3
from collections import deque

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

s = 0
dist = [-1] * N
que = deque()
que.append(s)
dist[s] = 0
while que:
    i = que.popleft()
    for j in G[i]:
        if dist[j] == -1:
            dist[j] = 1 - dist[i]
            que.append(j)

for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if dist[c] == dist[d]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
e = [[] for _ in range(n)]

import heapq


def dijkstra(s):
    hq = [(0, s)]
    heapq.heapify(hq)
    cost = [float('inf')] * n
    cost[s] = 0

    while hq:
        c, v = heapq.heappop(hq)
        if c > cost[v]:
            continue
        for d, u in e[v]:
            tmp = d + cost[v]
            if tmp < cost[u]:
                cost[u] = tmp
                heapq.heappush(hq, (tmp, u))
    return cost


for i in range(n - 1):
    a, b = map(int, input().split())
    e[a - 1].append((1, b - 1))
    e[b - 1].append((1, a - 1))

dist = dijkstra(0)

for j in range(q):
    c, d = map(int, input().split())
    x = abs(dist[c - 1] - dist[d - 1])
    if x % 2 == 1:
        print('Road')
    else:
        print('Town')
n, q = map(int, input().split())
connected = {i: [] for i in range(n)}

for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    connected[a].append(b)
    connected[b].append(a)

que = [(-1, 0, [0, 0])]  # previous, now, rank
ranks = [[] for _ in range(n)]

while len(que) >= 1:
    previous, now, rank = que.pop()
    ranks[now] = rank
    next_town = [t for t in connected[now] if t != previous]
    if len(next_town) == 1:
        next_t = next_town[0]
        rank_n = rank.copy()
        rank_n[-1] += 1
        que.append((now, next_t, rank_n))
    elif len(next_town) >= 2:
        for i, next_t in enumerate(next_town):
            rank_i = rank.copy()
            rank_i += [i, 1]
            que.append((now, next_t, rank_i))


def calc_distance(rank1, rank2):
    # rank1 <= rank2 にする
    if len(rank1) > len(rank2):
        rank1, rank2 = rank2, rank1

    dist = -1
    while dist < 0:
        if rank1[:2] == rank2[:2]:
            if len(rank1) == 2:
                rank1 = [0, 0]
            else:
                rank1 = rank1[2:]
            rank2 = rank2[2:]
        elif rank1[0] != rank2[0]:
            dist = sum(rank1[1::2]) + sum(rank2[1::2])
        elif rank1[0] == rank2[0]:
            dist = abs(sum(rank1[1::2]) - sum(rank2[1::2]))
    return (dist)


for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    dist = calc_distance(ranks[c], ranks[d])
    if dist % 2 == 0:
        print('Town')
    else:
        print('Road')
#
# abc209 d
#
import sys
from io import StringIO
import unittest
import collections


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """4 1
1 2
2 3
2 4
1 2"""
        output = """Road"""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """5 2
1 2
2 3
3 4
4 5
1 3
1 5"""
        output = """Town
Town"""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """9 9
2 3
5 6
4 8
8 9
4 5
3 4
1 9
3 7
7 9
2 5
2 6
4 6
2 4
5 8
7 8
3 6
5 6"""
        output = """Town
Road
Town
Town
Town
Town
Road
Road
Road"""
        self.assertIO(input, output)


def resolve():
    N, Q = map(int, input().split())
    AB = [list(map(int, input().split())) for _ in range(N - 1)]
    CD = [list(map(int, input().split())) for _ in range(Q)]

    G = [[] for _ in range(N)]
    for a, b in AB:
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)

    D = [-1] * N
    q = collections.deque()
    D[0] = 0
    q.append(0)
    while q:
        p = q.popleft()
        for np in G[p]:
            if D[np] != -1:
                continue
            D[np] = D[p] + 1
            q.append(np)

    for c, d in CD:
        if abs(D[c - 1] - D[d - 1]) % 2:
            print("Road")
        else:
            print("Town")


if __name__ == "__main__":
    # unittest.main()
    resolve()
import sys

sys.setrecursionlimit(10**9)
N, Q = map(int, input().split())
L = [[] * N for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    L[a - 1].append(b - 1)
    L[b - 1].append(a - 1)

town_color = [-1] * N
town_color[0] = 0


def func(n):
    for l in L[n]:
        if town_color[l] == -1:
            if town_color[n] == 0:
                town_color[l] = 1
            else:
                town_color[l] = 0
            func(l)
        else:
            continue


for l in L[0]:
    town_color[l] = 1
    func(l)

for _ in range(Q):
    c, d = map(int, input().split())
    if town_color[c - 1] == town_color[d - 1]:
        print('Town')
    else:
        print('Road')
def main():
    from collections import deque
    import sys
    input = sys.stdin.readline

    N, Q = map(int, input().split())

    G = tuple(list() for _ in range(N))
    for _ in range(N - 1):
        a, b = (int(x) - 1 for x in input().split())
        G[a].append(b)
        G[b].append(a)

    dist = [None] * N
    dist[0] = 0

    dq = deque()
    dq.append(0)
    while dq:
        v = dq.popleft()
        du = dist[v] ^ 1
        for u in G[v]:
            if dist[u] is not None:
                continue
            dist[u] = du
            dq.append(u)

    ans = []
    for _ in range(Q):
        c, d = (int(x) - 1 for x in input().split())
        if dist[c] == dist[d]:
            ans.append("Town")
        else:
            ans.append("Road")
    print(*ans, sep='\n')


if __name__ == "__main__":
    main()

# 距離偶数なら町、奇数なら道
# region Template
# fmt: off
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)
from collections import Counter, deque, defaultdict


# from itertools import combinations, permutations, accumulate, groupby, product
# from bisect import bisect_left,bisect_right
# from heapq import heapify, heappop, heappush
# from math import floor, ceil ,factorial, gcd
# from operator import itemgetter
# from copy import deepcopy
def I():
    return int(input())


def MI():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


def SI():
    return input().rstrip()


def printns(x):
    print('\n'.join(x))


def printni(x):
    print('\n'.join(list(map(str, x))))


inf = 10**17
mod = 10**9 + 7
#mod =998244353


def INT():
    return int(sys.stdin.readline().rstrip())


def LINT():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def STR():
    return sys.stdin.readline().rstrip()


def LSTR():
    return list(sys.stdin.readline().rstrip().split())


# fmt: on
# endregion Template

N, Q = MI()
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = MI()
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1] * N
dist[0] = 0
que = deque([])
que.append(0)

while que:
    cur = que[0]
    que.popleft()
    for next in G[cur]:
        if dist[next] != -1:
            continue
        dist[next] = dist[cur] + 1
        que.append(next)

for _ in range(Q):
    c, d = MI()
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, K = map(int, input().split())

L = [[] for i in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    L[a].append(b)
    L[b].append(a)


class LCA_doubling:
    """
    parent: ダブリングテーブル
    depth: 元の深さ
    """
    def __init__(self, g, root):  #g: graph
        def dfs(root):
            n = len(g)
            parent = self.parent[0]
            q = [root]
            while q:
                v = q.pop()
                for c in g[v]:
                    if c != parent[v]:
                        self.depth[c] = self.depth[v] + 1
                        parent[c] = v
                        q.append(c)

        def doubling_make_table(N, logN, Table):
            for i in range(1, logN):
                for j, Tiij in enumerate(Table[i - 1]):
                    if Tiij != -1:
                        Table[i][j] = Table[i - 1][Tiij]

        N = len(g)
        self.logN = len(bin(N))
        self.parent = [[-1] * N for _ in range(self.logN)]
        self.depth = [0] * (N)  #ノードの深さ
        dfs(root)  #root を根とする木と見て計算
        doubling_make_table(N, self.logN, self.parent)  #ダブリングのテープル構築

    def getLCA(self, u, v):  #u,vのLCAを返す
        if self.depth[u] > self.depth[v]: u, v = v, u  #vが深い
        dd = self.depth[v] - self.depth[u]
        for k in range(self.logN - 1, -1, -1):
            if (dd >> k) & 1: v = self.parent[k][v]
        if u == v: return u
        for k in range(self.logN - 1, -1, -1):
            if self.parent[k][u] != self.parent[k][v]:
                u, v = self.parent[k][u], self.parent[k][v]
        return self.parent[0][u]

    def getdepth(self, u):  #uの深さを返す
        return self.depth[u]


root = 1
LCA = LCA_doubling(L, root)
#print(LCA.parent)
#print(LCA.depth[1])
for k in range(K):
    a, b = map(int, input().split())
    B = LCA.getLCA(a, b)
    #print(B)
    cnt = LCA.depth[a] - (LCA.depth[B]) + LCA.depth[b] - (LCA.depth[B])
    if cnt % 2 == 1:
        print("Road")
    else:
        print("Town")
(n, q), *t = [map(int, t.split()) for t in open(0)]
*e, = eval('[],' * -~n)
for a, b in t[:n - 1]:
    e[a] += b,
    e[b] += a,
d = [0, 0] + [-1] * n
q = [1]
for v in q:
    for w in e[v]:
        if d[w] < 0:
            d[w] = d[v] + 1
            q += w,
for a, b in t[n - 1:]:
    print('TRoowand'[d[a] - d[b] & 1::2])
import bisect, collections, copy, heapq, itertools, math, sys

sys.setrecursionlimit(10**7)


def I():
    return int(sys.stdin.readline().rstrip())


def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def S():
    return sys.stdin.readline().rstrip()


def LS():
    return list(sys.stdin.readline().rstrip().split())


n, q = LI()
ab = [LI() for i in range(n - 1)]

cd = [LI() for i in range(q)]

length = [-1 for i in range(n)]
path = [[] for i in range(n)]
for i in range(n - 1):
    a, b = ab[i][0] - 1, ab[i][1] - 1
    path[a].append(b)
    path[b].append(a)

que = collections.deque()
que.append((0, 0))

while len(que) > 0:
    now, step = que.popleft()
    length[now] = step
    for i in path[now]:
        if length[i] != -1: continue
        que.append((i, step + 1))

for i in range(q):
    c, d = cd[i][0] - 1, cd[i][1] - 1

    if (length[c] + length[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(200000000)
n, q = map(int, input().split())
graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)
s = [0] * n


def DFS(i):
    s[i] = 1
    for ni in graph[i]:
        if not s[ni]:
            return DFS(ni)
    return i


x = DFS(0)
d = [float('inf')] * n
d[x] = 0


def dfs(i):
    for ni in graph[i]:
        if d[ni] == float('inf'):
            d[ni] = d[i] + 1
            dfs(ni)


dfs(x)
for _ in range(q):
    p, q = map(int, input().split())
    p -= 1
    q -= 1
    if (d[p] - d[q]) % 2:
        print('Road')
    else:
        print('Town')
from sys import stdin
from collections import deque

readline = stdin.readline
n, q = map(int, readline().split())
graph = [[] for _ in range(n)]
visited = [-1] * n
for i in range(n - 1):
    a, b = map(int, readline().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
stack = deque([])
stack.append([0, -1])
visited[0] = 1
while stack:
    v, p = stack.pop()
    if visited[v] == -1:
        if p != -1:
            if visited[p] == 0:
                visited[v] = 1
            else:
                visited[v] = 0
    for e in graph[v]:
        if e == p:
            continue
        stack.append([e, v])
for j in range(q):
    c, d = map(int, readline().split())
    if visited[c - 1] == visited[d - 1]:
        print('Town')
    else:
        print('Road')
#!/usr/bin/env python3
import sys
import queue

ROAD = "Road"
TOWN = "Town"


def solve(N: int, Q: int, A: "List[int]", B: "List[int]", C: "List[int]",
          D: "List[int]"):
    G = [[] for _ in range(N)]
    for i in range(N - 1):
        G[A[i] - 1].append(B[i] - 1)
        G[B[i] - 1].append(A[i] - 1)
    color = [-1 for _ in range(N)]
    color[0] = 0
    que = queue.Queue()
    que.put(0)
    while not que.empty():
        i = que.get()
        for j in G[i]:
            if color[j] == -1:
                color[j] = 1 - color[i]
                que.put(j)
    for i in range(Q):
        if color[C[i] - 1] == color[D[i] - 1]:
            print(TOWN)
        else:
            print(ROAD)


# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    # Failed to predict input format
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))
    Q = int(next(tokens))
    A = []
    B = []
    C = []
    D = []
    for i in range(N - 1):
        A.append(int(next(tokens)))
        B.append(int(next(tokens)))
    for j in range(Q):
        C.append(int(next(tokens)))
        D.append(int(next(tokens)))
    solve(N, Q, A, B, C, D)


if __name__ == '__main__':
    main()
# D after contest
from collections import deque, defaultdict

N, Q = map(int, input().split())

edges = defaultdict(list)
for _ in range(N - 1):
    a, b = map(int, input().split())
    edges[a].append(b)
    edges[b].append(a)


def bfs(start):
    q = deque()
    q.append(start)
    # 訪問済み、または、これから訪れる頂点部分集合
    C = set()
    C.add(start)
    distances[start] = 0

    while q:
        v = q.popleft()
        for each in edges[v]:
            if each not in C:
                C.add(each)
                q.append(each)
                distances[each] = distances[v] + 1


# 最短経路リスト
distances = [-1] * (N + 1)
# スタート地点からの最短距離をもれなく更新
bfs(1)

while Q:
    Q -= 1
    c, d = map(int, input().split())
    print('Town' if abs(distances[c] - distances[d]) % 2 == 0 else 'Road')
import sys

sys.setrecursionlimit(10**9)

N, Q = map(int, input().split())
links = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    links[a].append(b)
    links[b].append(a)

D = [0] * N
import queue

que = queue.deque()
que.append((0, -1))
while que:
    x, par = que.pop()
    for nx in links[x]:
        if nx == par:
            continue

        D[nx] = D[x] + 1
        que.append((nx, x))

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if D[c] % 2 == D[d] % 2:
        print("Town")
    else:
        print("Road")
import sys  #PyPy3
import queue  #PyPy3

input = sys.stdin.readline
import copy  #PyPy3
from itertools import product  #PyPy3
from itertools import accumulate  #PyPy3
# for i in list(product([0,1], repeat=n)):
import math  #PyPy3
import collections  #PyPy3
import statistics as st  #PyPy3

#li = sorted(li, reverse=True, key=lambda x: x[1])  #[1]に注目してソート

sys.setrecursionlimit(2 * 10**6)  #再帰の上限をUP

n, q = map(int, input().split())
li = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    li[a - 1].append(b - 1)
    li[b - 1].append(a - 1)

INF = 100100100100
d = [INF] * n


def bfs():
    que = queue.Queue()
    que.put(0)
    d[0] = 0

    while not que.empty():
        u = que.get()
        for i in li[u]:
            if d[i] != INF:
                continue
            else:
                d[i] = d[u] + 1
                que.put(i)


bfs()

for i in range(q):
    s, g = map(int, input().split())
    if (d[s - 1] + d[g - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
ab = []
neighbors = [[] for i in range(n)]
for i in range(n - 1):
    ab.append(list(map(int, input().split())))
for i in range(n - 1):
    neighbors[ab[i][0] - 1].append(ab[i][1] - 1)
    neighbors[ab[i][1] - 1].append(ab[i][0] - 1)
cd = []
for i in range(q):
    cd.append(list(map(int, input().split())))

colors = [None] * n
que = deque()

que.append(0)
colors[0] = "blue"

while que:
    item = que.pop()
    for neighbor in neighbors[item]:
        if not colors[neighbor]:
            if colors[item] == "blue":
                colors[neighbor] = "red"
            if colors[item] == "red":
                colors[neighbor] = "blue"
            que.append(neighbor)
            neighbors[neighbor].remove(item)

for i in range(q):
    if colors[cd[i][0] - 1] == colors[cd[i][1] - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque


def bfs(G, s):
    Q = deque([])
    dist = [-1] * N
    dist[s] = 0
    for u in G[s]:
        dist[u] = 1
        Q.append(u)

    while Q:
        u = Q.popleft()
        for v in G[u]:
            if dist[v] != -1:
                continue
            dist[v] = dist[u] + 1
            Q.append(v)

    return dist


N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    A, B = map(int, input().split())
    A, B = A - 1, B - 1
    G[A].append(B)
    G[B].append(A)

dist = bfs(G, 0)
for i in range(Q):
    C, D = map(int, input().split())
    C, D = C - 1, D - 1
    if (dist[C] - dist[D]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from sys import stdin
import math

n, q, *indata = map(int, stdin.read().split())
g = [[] for i in range(n + 1)]
offset = 0
for i in range(n - 1):
    s, t = indata[offset + 2 * i], indata[offset + 2 * i + 1]
    g[s].append(t)
    g[t].append(s)

maxd = int(math.floor(math.log2(n + 1))) + 1
par = [[-1 for i in range(maxd)] for i in range(n + 1)]
depth = [0 for i in range(n + 1)]

check = [0 for i in range(n + 1)]

que = [(1, 0, -1)]
while que:
    now, d, p = que.pop()
    par[now][0] = p
    depth[now] = d
    check[now] = True
    for i in g[now]:
        if not check[i]:
            que.append((i, d + 1, now))

#dfs(1,0,-1)

for i in range(1, maxd):
    for j in range(1, n + 1):
        par[j][i] = par[par[j][i - 1]][i - 1]


def lca(u, v):
    difd = depth[u] - depth[v]
    if difd < 0:
        u, v = v, u
        difd = -difd
    bitnum = 0
    while difd > 0:
        if difd & 1:
            u = par[u][bitnum]
        bitnum += 1
        difd = difd >> 1
    if u == v:
        return u
    else:
        for i in range(maxd):
            if par[u][maxd - i - 1] != par[v][maxd - i - 1]:
                u = par[u][maxd - i - 1]
                v = par[v][maxd - i - 1]
        return par[u][0]


offset += (n - 1) * 2
for i in range(q):
    s, t = indata[offset + 2 * i], indata[offset + 2 * i + 1]
    kari = depth[lca(s, t)]
    ans = depth[s] + depth[t] - kari * 2
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10000000)

N, Q = map(int, input().split())

neighbor = {}
visited = [-1]
for i in range(N - 1):
    tmpA, tmpB = map(int, input().split())
    if tmpA - 1 not in neighbor.keys():
        neighbor[tmpA - 1] = []
    if tmpB - 1 not in neighbor.keys():
        neighbor[tmpB - 1] = []
    neighbor[tmpA - 1].append(tmpB - 1)
    neighbor[tmpB - 1].append(tmpA - 1)
    visited.append(-1)

#print(neighbor)
#print(visited)


def dfs(pos, flg):
    #print(pos, visited[pos])
    visited[pos] = flg
    for i in neighbor[pos]:
        #print(i, visited[i])
        if visited[i] == -1:
            dfs(i, 1 - flg)


dfs(0, 0)

#print(visited)

for i in range(Q):
    tmpC, tmpD = map(int, input().split())
    if visited[tmpC - 1] == visited[tmpD - 1]:
        print("Town")
    else:
        print("Road")

#print(visited)
from collections import deque

n, q = map(int, input().split())
P = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    P[a - 1].append(b - 1)
    P[b - 1].append(a - 1)


def bfs(u):
    queue = deque([u])
    d = [None] * n
    d[u] = 0
    while queue:
        v = queue.popleft()
        for i in P[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


L = bfs(0)

for i in range(q):
    c, d = map(int, input().split())
    print("Town" if (L[c - 1] - L[d - 1]) % 2 == 0 else "Road")
import sys

sys.setrecursionlimit(20000000)
n, q = map(int, input().split())
a = [[] for i in range(n - 1)]
b = [[] for i in range(n - 1)]
c = [0] * q
d = [0] * q
g = [[] for i in range(n)]

for i in range(n - 1):
    a[i], b[i] = map(int, input().split())
    g[a[i] - 1].append(b[i] - 1)
    g[b[i] - 1].append(a[i] - 1)
for i in range(q):
    c[i], d[i] = map(int, input().split())

seen = [False for i in range(n)]
color = [-1 for i in range(n)]


def BFS(g, start):
    seen[start] = True

    for i in g[start]:
        if (seen[i] == False):
            seen[i] = True
            color[i] = 1 - color[start]
            BFS(g, i)


deep = [[] for i in range(n)]


def BFS_2(g, start):
    seen[start] = True

    for i in g[start]:
        if (seen[i] == False):
            seen[i] = True
            deep[i] = deep[start] + 1
            BFS_2(g, i)


color[0] = 0
deep[0] = 0
BFS_2(g, 0)

for i in range(q):
    if ((deep[c[i] - 1] + deep[d[i] - 1]) % 2 == 0):
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
e = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    e[a].append(b)
    e[b].append(a)

depth = [-1] * n
depth[0] = 0
dq = deque([0])
while dq:
    x = dq.popleft()
    for v in e[x]:
        if depth[v] != -1:
            continue
        else:
            depth[v] = depth[x] + 1
            dq.append(v)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if depth[c] % 2 == depth[d] % 2:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
connections = [[] for _ in range(N)]
# print(len(connections))
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    connections[a].append(b)
    connections[b].append(a)
# print(connections)
roads = [10**5 for _ in range(N)]
roads[0] = 0
dist = 1
towns = connections[0]
while len(towns) > 0:
    nxt = list()
    # print(towns)
    for i in towns:
        if dist < roads[i]:
            nxt.append(i)
        roads[i] = min(roads[i], dist)
    # print("nxt", nxt)
    towns = list()
    for i in nxt:
        towns.extend(connections[i])
    dist += 1
# print(roads)
for j in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    print("Town" if (roads[c] + roads[d]) % 2 == 0 else "Road")
import queue

n, q = map(int, input().split())

G = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()

C = [0] * n
C[0] = 1

que.put(0)

while not que.empty():
    t = que.get()
    for i in G[t]:
        if C[i] == 0:
            C[i] = -C[t]
            que.put(i)

for i in range(q):
    a, b = map(int, input().split())
    print("Town" if C[a - 1] * C[b - 1] == 1 else "Road")
from collections import deque

n, Q = map(int, input().split())
graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

# print(graph)
dist = [-1] * n
q = deque()
q.append(0)
dist[0] = 0
while q:
    v = q.popleft()
    for i in graph[v]:
        if dist[i] != -1: continue
        dist[i] = dist[v] + 1
        q.append(i)
# print(dist)
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[d] - dist[c]) % 2 == 0:
        print('Town')
    else:
        print('Road')
    # print(dist[c], dist[d])
N, Q = list(map(int, input().split()))
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = list(map(lambda x: int(x) - 1, input().split()))
    G[a].append(b)
    G[b].append(a)

from collections import deque

dq = deque()
dq.append([0, 0])
D = [-1] * N
while dq:
    u, d = dq.popleft()
    D[u] = d
    for v in G[u]:
        if D[v] == -1:
            dq.append([v, d + 1])

for _ in range(Q):
    c, d = list(map(lambda x: int(x) - 1, input().split()))
    if (D[c] - D[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

from collections import deque

graph = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * n
dist[0] = 0

d = deque()
d.append(0)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i in range(q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
G = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
inf = 10**10
d = [inf] * n
from collections import deque

Q = deque()
Q.append(0)
d[0] = 0
while Q:
    pos = Q.popleft()
    for i in G[pos]:
        if d[i] == inf:
            d[i] = d[pos] + 1
            Q.append(i)

for _ in range(q):
    s, t = map(int, input().split())
    if d[s - 1] % 2 == d[t - 1] % 2:
        print('Town')
    else:
        print('Road')
inpl = lambda: list(map(int, input().split()))
output = ['Town', 'Road']
N, Q = inpl()
edges = [set() for _ in range(N)]
for _ in range(N - 1):
    a, b = inpl()
    a -= 1
    b -= 1
    edges[a].add(b)
    edges[b].add(a)
cd = []
for _ in range(Q):
    c, d = inpl()
    c -= 1
    d -= 1
    cd.append((c, d))

pool = [(0, 0)]
depth = [0] * N
parent = [-1] * N
while pool:
    x, dep = pool.pop()
    depth[x] = dep
    for y in edges[x]:
        if y == parent[x]:
            continue
        else:
            parent[y] = x
            pool.append((y, dep + 1))

for c, d in cd:
    print(output[(depth[c] + depth[d]) % 2])
n, q = map(int, input().split())

p = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    p[a - 1].append(b - 1)
    p[b - 1].append(a - 1)

s = [0]
v = [False] * n
v[s[0]] = True
l = [0] * n
while s:
    ss = s.pop(0)
    for sss in p[ss]:
        if v[sss] == False:
            s.append(sss)
            v[sss] = True
            l[sss] = l[ss] + 1

for _ in range(q):
    c, d = map(int, input().split())
    ll = abs(l[c - 1] - l[d - 1])

    if ll % 2 == 0:
        print("Town")
    else:
        print("Road")
n, Q = map(int, input().split())

dist = [-1] * (n + 1)
g = [[] for i in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

q = [1]
dist[1] = 0
while q:
    now = q.pop()
    for next in g[now]:
        if dist[next] == -1:
            q.append(next)
            dist[next] = dist[now] + 1

for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import itertools as iter
import collections as coll
import heapq as hq
import bisect as bis
from decimal import Decimal as dec
from copy import deepcopy as dcopy
import math
import sys

sys.setrecursionlimit(10**6)


def input():
    return sys.stdin.readline().rstrip()


def getN():
    return int(input())


def getNs():
    return map(int, input().split())


def getList():
    return list(map(int, input().split()))


def strinps(n):
    return [input() for _ in range(n)]


pi = 3.141592653589793
mod = 10**9 + 7
MOD = 998244353
INF = math.inf
dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]
"""
Main Code
"""

n, q = getNs()
route = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = getNs()
    a -= 1
    b -= 1
    route[a].append(b)
    route[b].append(a)
query = [getList() for _ in range(q)]
time = [INF] * n
que = [(1, 0)]
while (que):
    t, v = que.pop()
    time[v] = t
    for nv in route[v]:
        if (time[nv] > t + 1):
            que.append((t + 1, nv))

for c, d in query:
    c -= 1
    d -= 1
    if ((time[c] - time[d]) & 1):
        print("Road")
    else:
        print("Town")
class SegTree:
    def __init__(self, init_val, ide_ele, segfunc):
        self.n = len(init_val)
        self.num = 2**(self.n - 1).bit_length()
        self.ide_ele = ide_ele
        self.segfunc = segfunc
        self.seg = [ide_ele] * 2 * self.num
        # set_val
        for i in range(self.n):
            self.seg[i + self.num] = init_val[i]
        # built
        for i in range(self.num - 1, 0, -1):
            self.seg[i] = self.segfunc(self.seg[2 * i], self.seg[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.seg[k] = x
        while k:
            k = k >> 1
            self.seg[k] = self.segfunc(self.seg[2 * k], self.seg[2 * k + 1])

    def query(self, l, r):
        if r <= l:
            return self.ide_ele
        l += self.num
        r += self.num
        res = self.ide_ele
        while l < r:
            if r & 1:
                r -= 1
                res = self.segfunc(res, self.seg[r])
            if l & 1:
                res = self.segfunc(res, self.seg[l])
                l += 1
            l = l >> 1
            r = r >> 1
        return res


def segfunc(x, y):
    if x <= y:
        return x
    else:
        return y


ide_ele = 10**18


class LCA:
    def __init__(self, g, root):
        # g: adjacency list
        # root
        self.n = len(g)
        self.root = root

        s = [self.root]
        self.parent = [-1] * self.n
        self.child = [[] for _ in range(self.n)]
        visit = [-1] * self.n
        visit[self.root] = 0
        while s:
            v = s.pop()
            for u in g[v]:
                if visit[u] == -1:
                    self.parent[u] = v
                    self.child[v].append(u)
                    visit[u] = 0
                    s.append(u)

        # Euler tour
        tank = [self.root]
        self.eulerTour = []
        self.left = [0] * self.n
        self.right = [-1] * self.n
        self.depth = [-1] * self.n

        eulerNum = -1
        de = -1

        while tank:
            v = tank.pop()
            if v >= 0:
                eulerNum += 1
                self.eulerTour.append(v)
                self.left[v] = eulerNum
                self.right[v] = eulerNum
                tank.append(~v)
                de += 1
                self.depth[v] = de
                for u in self.child[v]:
                    tank.append(u)
            else:
                de -= 1
                if ~v != self.root:
                    self.eulerTour.append(self.parent[~v])
                    eulerNum += 1
                    self.right[self.parent[~v]] = eulerNum

        #A = [self.depth[e] for e in self.eulerTour]
        A = [0] * (2 * self.n - 1)
        for i, e in enumerate(self.eulerTour):
            A[i] = self.depth[e] * (2 * self.n - 1) + i
        self.seg = SegTree(A, ide_ele, segfunc)

    def getLCA(self, u, v):
        # u, v: 0-indexed
        p = min(self.left[u], self.left[v])
        q = max(self.right[u], self.left[v]) + 1
        m = self.seg.query(p, q)
        return self.eulerTour[m % (2 * self.n - 1)]


import sys
import io, os
#input = sys.stdin.buffer.readline
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n, q = map(int, input().split())
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    g[a].append(b)
    g[b].append(a)

lca = LCA(g, 0)


def dist(u, v):
    l = lca.getLCA(u, v)
    res = lca.depth[u] + lca.depth[v] - 2 * lca.depth[l]
    return res


for j in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    x = dist(c, d)
    if x % 2 == 1:
        print('Road')
    else:
        print('Town')
from collections import deque

n, q = map(int, input().split())
ct = [[] for _ in range(n)]

inz = lambda x: int(x) - 1

for i in range(n - 1):
    a, b = map(inz, input().split())
    ct[a].append(b)
    ct[b].append(a)

dst = [-1] * n
dst[0] = 0
nxt = deque()
nxt.append(0)

while nxt:
    pos = nxt.popleft()
    for i in ct[pos]:
        if dst[i] == -1:
            dst[i] = dst[pos] + 1
            nxt.append(i)

for i in range(q):
    c, d = map(inz, input().split())
    if abs(dst[c] - dst[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
from collections import deque

n, Q = map(int, input().split())
G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)
dist = [0] * n
q = deque([(0, 0, -1)])
while q:
    step, i, par = q.popleft()
    for j in G[i]:
        if j == par: continue
        dist[j] = step + 1
        q.append((step + 1, j, i))
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2:
        print("Road")
    else:
        print("Town")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print('Town')
    else:
        print('Road')
from heapq import heappush, heappop, heapify

import sys

sys.setrecursionlimit(2147483647)
INF = float('inf')


def LI():
    return list(map(int, sys.stdin.readline().split()))


def LLI():
    return list(map(lambda x: int(x) - 1, sys.stdin.readline().split()))


def I():
    return int(sys.stdin.readline())


def LS():
    return sys.stdin.readline().rstrip().split()


def S():
    return sys.stdin.readline().rstrip()


def IR(n):
    return [I() for i in range(n)]


def LIR(n):
    return [LI() for i in range(n)]


def SR(n):
    return [S() for i in range(n)]


def LSR(n):
    return [LS() for i in range(n)]


def SRL(n):
    return [list(S()) for i in range(n)]


def MSRL(n):
    return [[int(j) for j in list(S())] for i in range(n)]


mod = 1000000007


def main():
    N, Q = LI()
    g = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = LLI()
        g[a].append((1, b))
        g[b].append((1, a))
    cost, _ = dijkstra(0, g)
    for _ in range(Q):
        c, d = LLI()
        v = abs(cost[c] - cost[d])
        if v % 2 == 0:
            print('Town')
        else:
            print('Road')


def dijkstra(s, g):
    # g：グラフ
    #   i番目の要素：ノードiに接続されたノードのリスト（各ノードをタプル(iとjの間のコストc, ノードj)で表現）
    hq = [(0, s)]
    heapify(hq)  # リストを優先度付きキューに変換
    cost = [INF] * len(g)  # 行ったことのないところはinf
    cost[s] = 0  # 開始地点は0
    prev = [-1] * len(g)
    while hq:
        c, v = heappop(hq)
        if c > cost[v]:  # コストが現在のコストよりも高ければスルー
            continue
        for d, u in g[v]:
            tmp = d + cost[v]
            if tmp < cost[u]:
                cost[u] = tmp
                heappush(hq, (tmp, u))
                prev[u] = v
    return cost, prev


if __name__ == '__main__':
    main()
"""
参考
https://atcoder.jp/contests/abc014/submissions/20037022
"""

from collections import deque


class LowestCommonAncestor:
    def __init__(self, G: "隣接リスト", root: "根"):
        self.n = len(G)
        self.tour = [0] * (2 * self.n - 1)
        self.depth_list = [0] * (2 * self.n - 1)
        self.id = [-1] * self.n
        self.dfs(G, root)
        self._rmq_init(self.depth_list)

    def _rmq_init(self, arr):
        n = self.mod = len(arr)
        self.seg_len = 1 << (n - 1).bit_length()
        self.seg = [self.n * n] * (2 * self.seg_len)
        seg = self.seg
        for i, e in enumerate(arr):
            seg[self.seg_len + i] = n * e + i
        for i in range(self.seg_len - 1, 0, -1):
            seg[i] = min(seg[2 * i], seg[2 * i + 1])

    def _rmq_query(self, l, r):
        """最小値となるindexを返す"""
        l += self.seg_len
        r += self.seg_len
        res = self.n * self.mod
        seg = self.seg
        while l < r:
            if r & 1:
                r -= 1
                res = min(res, seg[r])
            if l & 1:
                res = min(res, seg[l])
                l += 1
            l >>= 1
            r >>= 1
        return res % self.mod

    def dfs(self, G, root):
        id = self.id
        tour = self.tour
        depth_list = self.depth_list
        v = root
        it = [0] * self.n
        parents = [-1] * self.n
        visit_id = 0
        depth = 0
        while v != -1:
            if id[v] == -1:
                id[v] = visit_id
            tour[visit_id] = v
            depth_list[visit_id] = depth
            visit_id += 1
            g = G[v]
            if it[v] == len(g):
                v = parents[v]
                depth -= 1
                continue
            if g[it[v]] == parents[v]:
                it[v] += 1
                if it[v] == len(g):
                    v = parents[v]
                    depth -= 1
                    continue
                else:
                    child = g[it[v]]
                    parents[child] = v
                    it[v] += 1
                    v = child
                    depth += 1
            else:
                child = g[it[v]]
                parents[child] = v
                it[v] += 1
                v = child
                depth += 1

    def lca(self, u: int, v: int) -> int:
        """ u と v の最小共通祖先を返す """
        l, r = self.id[u], self.id[v]
        if r < l:
            l, r = r, l
        q = self._rmq_query(l, r + 1)
        return self.tour[q]

    def dist(self, u: int, v: int) -> int:
        """ u と v の距離を返す """
        lca = self.lca(u, v)
        depth_u = self.depth_list[self.id[u]]
        depth_v = self.depth_list[self.id[v]]
        depth_lca = self.depth_list[self.id[lca]]
        return depth_u + depth_v - 2 * depth_lca


n, q = map(int, input().split())
ab = [list(map(int, input().split())) for i in range(n - 1)]
cd = [list(map(int, input().split())) for i in range(q)]

V = [[] for i in range(n + 1)]
for a, b in ab:
    V[a].append(b)
    V[b].append(a)

lca = LowestCommonAncestor(V, 1)

for c, d in cd:
    if lca.dist(c, d) % 2 == 0:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python3

import sys

sys.setrecursionlimit(100000)


class Node:
    def __init__(self, node_id):
        self.node_id = node_id
        self.neighbors = set()

    def get_next_set(self, already_visited):
        return self.neighbors - already_visited


class Graph:
    def __init__(self, N):
        self.nodes = {}
        for n in range(N):
            self.nodes[n] = Node(n)

    def add_edge(self, a, b):
        self.nodes[a].neighbors.add(b)
        self.nodes[b].neighbors.add(a)


def dfs(g, node_id, steps, answer, already_visited):
    """グラフgをnode_idを始点として深さ優先探索した結果をanswerに保存する。"""
    answer[node_id] = steps
    already_visited.add(node_id)
    next_set = g.nodes[node_id].get_next_set(already_visited)
    if len(next_set) == 0:
        return
    else:
        for next in next_set:
            dfs(g, next, steps + 1, answer, already_visited)


# Generated by 2.5.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    N, Q = list(map(int, input().split()))

    all_towns = set([n for n in range(N)])
    a = [0 for n in range(N - 1)]
    b = [0 for n in range(N - 1)]
    c = [0 for q in range(Q)]
    d = [0 for q in range(Q)]

    for n in range(N - 1):
        row = list(map(int, input().split()))
        a[n] = row[0] - 1
        b[n] = row[1] - 1

    for q in range(Q):
        row = list(map(int, input().split()))
        c[q] = row[0] - 1
        d[q] = row[1] - 1

    g = Graph(N)
    for n in range(N - 1):
        g.add_edge(a[n], b[n])

    answer = {}
    dfs(g, node_id=0, steps=0, answer=answer, already_visited=set())

    for q in range(Q):
        if (answer[c[q]] + answer[d[q]]) % 2 == 0:
            print("Town")
        else:
            print("Road")
    pass


if __name__ == '__main__':
    main()
import queue

N, Q = map(int, input().split())
g = [[] * N for i in range(N)]
for _ in range(N - 1):
    i, j = map(int, input().split())
    g[i - 1].append(j - 1)
    g[j - 1].append(i - 1)

que = queue.Queue()
color = [-1] * N
color[0] = 0

que.put(0)
while not que.empty():
    t = que.get()
    for i in g[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for _ in range(Q):
    i, j = map(int, input().split())
    if color[i - 1] == color[j - 1]:
        print("Town")
    else:
        print("Road")
def bipartite(E):
    '''
    Input:
    E: the adjacency list of the graph
    Output:
    If the graph is bipartite, return [[U_1, U_2] (the parts of the bipartite graph) for each component].
    Else, return None.
    '''
    N = len(E)
    color = [None] * N
    part = []
    for x in range(N):
        if color[x] is not None: continue
        stack = [(x, 0)]  # color x with 0
        parts = [[], []]
        while stack:
            v, c = stack.pop()
            if color[v] is not None:  # consistent
                continue
            color[v] = c
            parts[c].append(v)
            for u in E[v]:
                if color[u] is None:  # not visited yet
                    stack.append(
                        (u,
                         c ^ 1))  # paint u with different color from v's one
                elif color[u] != c:  # consistent
                    continue
                else:  # inconsistent
                    return None
        part.append(parts)
    return part


N, Q = map(int, input().split())
E = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    E[a].append(b)
    E[b].append(a)

color = [None] * N
stack = [(0, 0)]
parts = [[], []]
while stack:
    v, c = stack.pop()
    if color[v] is not None:  # consistent
        continue
    color[v] = c
    parts[c].append(v)
    for u in E[v]:
        if color[u] is None:  # not visited yet
            stack.append(
                (u, c ^ 1))  # paint u with different color from v's one

U1, U2 = parts
U1, U2 = set(U1), set(U2)

for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if (c in U1 and d in U1) or (c in U2 and d in U2):
        print('Town')
    else:
        print('Road')
from string import ascii_lowercase
from decimal import Decimal
from random import randrange, choice, randint
import time
from heapq import heappop, heappush
from copy import copy
from bisect import bisect_right, bisect_left
from sys import stdin
from functools import reduce
from math import e, sqrt, gcd, pi, factorial, ceil, floor, sin
from itertools import permutations
from collections import defaultdict, deque, Counter
from enum import Enum, auto
import sys

sys.setrecursionlimit(1000000)

n, q = map(int, input().split())
to = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    to[a - 1].append(b - 1)
    to[b - 1].append(a - 1)

colors = [-1 for _ in range(n)]

que = deque([(0, 0)])
while que:
    node, color = que.popleft()
    colors[node] = color
    for next_node in to[node]:
        if colors[next_node] == -1:
            que.append((next_node, color ^ 1))

# def dfs(now, c):
#     assert c in [0, 1]
#     colors[now] = c
#     for next in to[now]:
#         if colors[next] == -1:
#             dfs(next, c ^ 1)

# dfs(0, 0)
assert -1 not in colors

for _ in range(q):
    c, d = map(int, input().split())
    if colors[c - 1] == colors[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]

graph = [[] for _ in range(N)]
for a, b in AB:
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

colors = [0 for _ in range(N)]
colors[0] = 1
Q = deque()
Q.append(0)
while len(Q) > 0:
    i = Q.popleft()
    for j in graph[i]:
        if colors[j] == 0:
            colors[j] = (-1) * colors[i]
            Q.append(j)
for c, d in CD:
    c -= 1
    d -= 1
    if colors[c] == colors[d]:
        print("Town")
    else:
        print("Road")
# -*- coding: utf-8 -*-
import math
import collections
import bisect
import itertools
import heapq
import os
from collections import defaultdict, deque, Counter
import sys
import copy
import string
from pprint import pprint
from decimal import Decimal
import re

sys.setrecursionlimit(10**9)
readline = sys.stdin.readline
INF = float("INF")


def read_ints():
    return map(lambda x: int(x), readline().split())


def read_int():
    return int(readline())


def read_int_array():
    return list(read_ints())


def read_str():
    return readline().rstrip(os.linesep)


def read_str_array(size):
    return [read_str() for _ in [0] * size]


def read_int_arrays(size):
    return [read_int_array() for _ in [0] * size]


N, Q = read_ints()

connect = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = read_ints()
    connect[a - 1].append(b - 1)
    connect[b - 1].append(a - 1)

dists = [0] * N
D = 0

yet = [True] * N  # 無向グラフの場合、子から親に戻らないようにするのに必要
parents = [0]
yet[0] = False
while parents:
    next_parents = []
    for parent in parents:
        dists[parent] = D
        children = connect[parent]
        for child in children:
            if yet[child]:
                next_parents.append(child)
                yet[child] = False
    parents = next_parents
    D += 1

for _ in range(Q):
    c, d = read_ints()
    c_dist = dists[c - 1]
    d_dist = dists[d - 1]
    if (c_dist - d_dist) % 2 == 0:
        print("Town")
    else:
        print("Road")
import os, sys, time, collections, math, pprint, itertools as it, operator as op, bisect as bs, functools as fn

maxx, localsys, mod = 1 << 60, 0, int(1e9 + 7)
nCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)
ceil = lambda n, x: (n + x - 1) // x
osi, oso = '/home/priyanshu/Documents/cp/input.txt', '/home/priyanshu/Documents/cp/output.txt'
if os.path.exists(osi):
    sys.stdin = open(osi, 'r')
    sys.stdout = open(oso, 'w')

input = sys.stdin.readline


def maps():
    return map(int, input().split())


from queue import Queue


#THINK ABOUT THE EDGE CASES ..........
def BFS(s, d, n):
    q, c = [s], 0
    color = {}
    color[s] = 0
    while q:
        s = q.pop(0)
        for v in d[s]:
            if v not in color:
                q.append(v)
                color[v] = color[s] ^ 1
    return color


n, queries = maps()
graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = maps()
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
color = BFS(0, graph, n)
for _ in range(queries):
    a, b = maps()
    if color[a - 1] != color[b - 1]:
        print('Road')
    else:
        print('Town')
# Rishabh Rao (https://github.com/rishabhrao)

import sys

MOD = 1000000007


def inp():
    return sys.stdin.readline().strip()


def ii():
    return int(inp())


def iis():
    return [int(i) for i in inp().split()]


n, q = iis()

undir_nodes = [[] for _ in range(n + 1)]
node_depths = [0 for _ in range(n + 1)]
visited_nodes = [0 for _ in range(n + 1)]

for _ in range(n - 1):
    u, v = iis()
    undir_nodes[u].append(v)
    undir_nodes[v].append(u)

stack_of_nodes = [1]
len_stack = 1
while len_stack:
    curr = stack_of_nodes.pop()
    len_stack -= 1
    visited_nodes[curr] = 1
    for child in undir_nodes[curr]:
        if not visited_nodes[child]:
            node_depths[child] = node_depths[curr] + 1
            stack_of_nodes.append(child)
            len_stack += 1

for _ in range(q):
    c, d = iis()
    print("Road" if abs(node_depths[c] - node_depths[d]) % 2 else "Town")
from queue import Queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)


def dfs(G):
    que = Queue()
    color = [-1] * N  # color is "0" or "1"
    color[0] = 0
    que.put(0)  # init
    while not que.empty():
        e = que.get()
        for v in G[e]:  # edge(e,v)
            if color[v] == -1:
                color[v] = 1 - color[e]
                que.put(v)
    return color


color = dfs(G)
for _ in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
import sys
import logging
from typing import List, Tuple


def convert_to_tree(undirected_graph: List[List[int]],
                    root: int) -> Tuple[List[List[int]], List[int]]:
    n = len(undirected_graph)

    depths = [-1] * n
    depths[root] = 0

    neighbors_directed: List[List[int]] = [[] for _ in range(n)]
    stack = [root]
    while stack:
        si = stack.pop()

        for adj in undirected_graph[si]:
            if depths[adj] != -1:
                continue
            stack.append(adj)
            depths[adj] = depths[si] + 1
            neighbors_directed[si].append(adj)

    return neighbors_directed, depths


class LowestCommonAncestor:
    """
    ancestors[i][j] = ノードjの2**i個上の祖先

    前処理: O(V log V)
    クエリ: O(log V)

    https://algo-logic.info/lca/

    Verified by
    - https://atcoder.jp/contests/abc014/tasks/abc014_4
    """
    def __init__(self, tree: List[List[int]], depths: List[int], root: int):
        self.n_nodes = len(tree)
        self.depths = depths
        self.root = root

        depth_max = max(self.depths)
        self.h = 1
        while (1 << self.h) < depth_max:
            self.h += 1

        ancestors = [[-1] * self.n_nodes for _ in range(self.h)]

        for i, neighbors in enumerate(tree):
            for j in neighbors:
                ancestors[0][j] = i

        for k in range(self.h - 1):
            for j in range(self.n_nodes):
                if ancestors[k][j] >= 0:
                    ancestors[k + 1][j] = ancestors[k][ancestors[k][j]]
                else:
                    ancestors[k + 1][j] = -1

        self.ancestors = ancestors

    def query(self, u, v) -> int:
        if self.depths[u] < self.depths[v]:
            u, v = v, u

        for k in range(self.h):
            if ((self.depths[u] - self.depths[v]) >> k) & 1:
                u = self.ancestors[k][u]

        if u == v:
            lca = u
        else:
            for k in reversed(range(self.h)):
                if self.ancestors[k][u] != self.ancestors[k][v]:
                    u = self.ancestors[k][u]
                    v = self.ancestors[k][v]
            lca = self.ancestors[0][u]

        return lca


def main():
    n, n_queries = map(int, input().split())
    undirected_tree = [[] for _ in range(n)]
    for _ in range(n - 1):
        ai, bi = map(int, input().split())
        ai -= 1
        bi -= 1
        undirected_tree[ai].append(bi)
        undirected_tree[bi].append(ai)

    root = 0
    tree, depths = convert_to_tree(undirected_tree, root)

    lca = LowestCommonAncestor(tree, depths, root)

    for _ in range(n_queries):
        ci, di = map(int, input().split())
        ci -= 1
        di -= 1
        lca_i = lca.query(ci, di)
        ans = depths[ci] + depths[di] - 2 * depths[lca_i]
        if ans % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    loglevel = "DEBUG" if "--debug" in sys.argv else "WARNING"
    numeric_level = getattr(logging, loglevel, None)
    log_format = "%(levelname)s (%(asctime)s.%(msecs)d): %(message)s"
    logging.basicConfig(level=numeric_level,
                        format=log_format,
                        datefmt="%I:%M:%S")

    main()
import types

_atcoder_code = """
# Python port of AtCoder Library.

__version__ = '0.0.1'
"""

atcoder = types.ModuleType('atcoder')
exec(_atcoder_code, atcoder.__dict__)

_atcoder__bit_code = """
def _ceil_pow2(n: int) -> int:
    x = 0
    while (1 << x) < n:
        x += 1

    return x


def _bsf(n: int) -> int:
    x = 0
    while n % 2 == 0:
        x += 1
        n //= 2

    return x
"""

atcoder._bit = types.ModuleType('atcoder._bit')
exec(_atcoder__bit_code, atcoder._bit.__dict__)

_atcoder_segtree_code = """
import typing

# import atcoder._bit


class SegTree:
    def __init__(self,
                 op: typing.Callable[[typing.Any, typing.Any], typing.Any],
                 e: typing.Any,
                 v: typing.Union[int, typing.List[typing.Any]]) -> None:
        self._op = op
        self._e = e

        if isinstance(v, int):
            v = [e] * v

        self._n = len(v)
        self._log = atcoder._bit._ceil_pow2(self._n)
        self._size = 1 << self._log
        self._d = [e] * (2 * self._size)

        for i in range(self._n):
            self._d[self._size + i] = v[i]
        for i in range(self._size - 1, 0, -1):
            self._update(i)

    def set(self, p: int, x: typing.Any) -> None:
        assert 0 <= p < self._n

        p += self._size
        self._d[p] = x
        for i in range(1, self._log + 1):
            self._update(p >> i)

    def get(self, p: int) -> typing.Any:
        assert 0 <= p < self._n

        return self._d[p + self._size]

    def prod(self, left: int, right: int) -> typing.Any:
        assert 0 <= left <= right <= self._n
        sml = self._e
        smr = self._e
        left += self._size
        right += self._size

        while left < right:
            if left & 1:
                sml = self._op(sml, self._d[left])
                left += 1
            if right & 1:
                right -= 1
                smr = self._op(self._d[right], smr)
            left >>= 1
            right >>= 1

        return self._op(sml, smr)

    def all_prod(self) -> typing.Any:
        return self._d[1]

    def max_right(self, left: int,
                  f: typing.Callable[[typing.Any], bool]) -> int:
        assert 0 <= left <= self._n
        assert f(self._e)

        if left == self._n:
            return self._n

        left += self._size
        sm = self._e

        first = True
        while first or (left & -left) != left:
            first = False
            while left % 2 == 0:
                left >>= 1
            if not f(self._op(sm, self._d[left])):
                while left < self._size:
                    left *= 2
                    if f(self._op(sm, self._d[left])):
                        sm = self._op(sm, self._d[left])
                        left += 1
                return left - self._size
            sm = self._op(sm, self._d[left])
            left += 1

        return self._n

    def min_left(self, right: int,
                 f: typing.Callable[[typing.Any], bool]) -> int:
        assert 0 <= right <= self._n
        assert f(self._e)

        if right == 0:
            return 0

        right += self._size
        sm = self._e

        first = True
        while first or (right & -right) != right:
            first = False
            right -= 1
            while right > 1 and right % 2:
                right >>= 1
            if not f(self._op(self._d[right], sm)):
                while right < self._size:
                    right = 2 * right + 1
                    if f(self._op(self._d[right], sm)):
                        sm = self._op(self._d[right], sm)
                        right -= 1
                return right + 1 - self._size
            sm = self._op(self._d[right], sm)

        return 0

    def _update(self, k: int) -> None:
        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])
"""

atcoder.segtree = types.ModuleType('atcoder.segtree')
atcoder.segtree.__dict__['atcoder'] = atcoder
atcoder.segtree.__dict__['atcoder._bit'] = atcoder._bit
exec(_atcoder_segtree_code, atcoder.segtree.__dict__)
SegTree = atcoder.segtree.SegTree

#!/usr/bin/env python3
# from atcoder.segtree import SegTree
from functools import reduce
from typing import *

ODDS = "Road"
EVEN = "Town"

INF = float("inf")


class ArgminData(NamedTuple):
    value: int
    index: int  # type: ignore


class EulerTour:
    def __init__(
        self,
        adj: List[List[int]],
        root: int = 0,
    ) -> None:
        self.N = len(adj)
        self.adj = adj
        self.root = root
        self.build()
        self.post_build()
        self.build_seg()

    def build(self) -> None:
        self.tour: List[int] = list()
        self.visited = [False] * self.N
        # prev[root] == rootにするか-1にするか迷う
        self.prev = [self.root] * self.N
        stack = [~self.root, self.root]
        while stack:
            src = stack.pop()
            if src >= 0:
                self.visited[src] = True
                self.tour.append(src)
                for dst in reversed(self.adj[src]):
                    if self.visited[dst]: continue
                    stack.append(~dst)
                    stack.append(dst)
                    self.prev[dst] = src
            else:
                self.tour.append(src)

    def post_build(self) -> None:
        self.enter = [-1] * self.N
        self.exit = [-1] * self.N
        self.tour_depth = [-1] * (2 * self.N)
        d = -1
        assert len(self.tour) == 2 * self.N
        for i in range(2 * self.N):
            if self.tour[i] >= 0:
                self.enter[self.tour[i]] = i
                d += 1
            else:
                self.exit[~self.tour[i]] = i
                d -= 1
            self.tour_depth[i] = d

    def build_seg(self) -> None:
        e = ArgminData(INF, -1)
        v = [ArgminData(self.tour_depth[i], i) for i in range(2 * self.N)]
        self.seg = SegTree(min, e, v)  # Range Min Query

    def LCA_depth(self, u: int, v: int) -> int:
        iu, iv = self.enter[u], self.enter[v]
        iu, iv = min(iu, iv), max(iu, iv)
        ans = self.seg.prod(iu, iv + 1).value
        return ans

    def depth(self, u: int) -> int:
        return self.tour_depth[self.enter[u]]

    def distance(self, u: int, v: int) -> int:
        return self.depth(u) + self.depth(v) - 2 * self.LCA_depth(u, v)

    def LCA(self, u: int, v: int) -> Tuple[bool, int]:
        iu, iv = self.enter[u], self.enter[v]
        iu, iv = min(iu, iv), max(iu, iv)
        index = self.seg.prod(iu, iv + 1).index
        current = self.tour[index]
        flag = current >= 0
        if flag:
            #            print(f"\x1b[31m[+]{self.prev[current]}->{current}\x1b[m")
            return flag, current
        else:
            #            print(f"\x1b[31m[-]{self.prev[~current]}->{current}\x1b[m")
            return flag, self.prev[~current]


# def solve(N: int, Q: int, a: List[int], b: List[int], c: List[int], d: List[int]) -> List[str]:
def solve(N, Q, a, b, c, d):
    adj = [list() for _ in range(N)]
    for i in range(N - 1):
        adj[a[i]].append(b[i])
        adj[b[i]].append(a[i])
    ET = EulerTour(adj, 0)
    for u, v in zip(c, d):
        dist = ET.distance(u, v)
        if dist % 2 == 1:
            print(ODDS)
        else:
            print(EVEN)


# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    N, Q = map(int, input().split())
    a = [None for _ in range(N - 1)]
    b = [None for _ in range(N - 1)]
    c = [None for _ in range(Q)]
    d = [None for _ in range(Q)]
    for i in range(N - 1):
        a[i], b[i] = map(int, input().split())
        a[i] -= 1
        b[i] -= 1
    for i in range(Q):
        c[i], d[i] = map(int, input().split())
        c[i] -= 1
        d[i] -= 1
    solve(N, Q, a, b, c, d)


if __name__ == '__main__':
    main()
def PaintColor(color):
    if color == "r":
        return "b"
    else:
        return "r"


import queue as q

N, Q = map(int, input().split())

G = [[] for _ in range(N)]

for _ in range(N - 1):
    ai, bi = map(int, input().split())
    G[ai - 1].append(bi - 1)
    G[bi - 1].append(ai - 1)

q = q.Queue()
color = ["w"] * N

q.put(0)
now_color = "r"
color[0] = now_color

while q.qsize():
    v = q.get()
    now_color = PaintColor(color[v])
    for vv in G[v]:
        if color[vv] == "w":
            color[vv] = now_color
            q.put(vv)
"""
for i in range(N):
    print("Town" + str(i+1) + ": " + color[i])
"""

Query = []
for _ in range(Q):
    ci, di = map(int, input().split())
    ci -= 1
    di -= 1
    Query.append([ci, di])

for i in range(Q):
    if color[Query[i][0]] == color[Query[i][1]]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
connected = {i: [] for i in range(n)}

for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    connected[a].append(b)
    connected[b].append(a)

que = [(-1, 0, 0)]  # previous, now, color
colors = [-1] * n

while len(que) >= 1:
    prev, pos, col = que.pop()
    colors[pos] = col
    next_town = [t for t in connected[pos] if t != prev]
    next_col = (col + 1) % 2
    for t in next_town:
        que.append((pos, t, next_col))

for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1

    if colors[c] == colors[d]:
        print('Town')
    else:
        print('Road')
from heapq import heappush, heappop

N, Q = map(int, input().split())
edges = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    edges[a - 1] += [b - 1]
    edges[b - 1] += [a - 1]

# 根 0 から BFS して, 0からの距離を図る
dist = [float("inf")] * N
dist[0] = 0

confirm = [False] * N  # 頂点までの距離が確定しているか
# hq は [頂点kまでの最短距離, 頂点k] を要素に持つ
# ヒープキューのソートキーにするため、最短距離が第一変数
hq = [(0, 0)]
# ダイクストラ法
while hq:
    d, v = heappop(hq)
    if confirm[v]:
        continue
    confirm[v] = True
    for w in edges[v]:
        if not confirm[w] and d + 1 < dist[w]:
            dist[w] = d + 1
            heappush(hq, (dist[w], w))

for q in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2:
        print("Road")
    else:
        print("Town")
n, q = map(int, input().split())
tree = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    tree[a].append(b)
    tree[b].append(a)
color = [None] * n
from collections import deque

dq = deque()
dq.append(0)
dist = [-1] * n
dist[0] = 1
while dq:
    now = dq.popleft()
    for next in tree[now]:
        if dist[next] != -1: continue
        dist[next] = dist[now] + 1
        dq.append(next)
for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    c2 = dist[c] % 2
    d2 = dist[d] % 2
    if c2 ^ d2: print('Road')
    else: print('Town')
class LowestCommonAncestor:
    """ <O(n), O(log(n))> """
    def __init__(self, G: "隣接リスト", root: "根"):
        self.n = len(G)
        self.tour = [0] * (2 * self.n - 1)
        self.depth_list = [0] * (2 * self.n - 1)
        self.id = [-1] * self.n
        self.dfs(G, root)
        self._rmq_init(self.depth_list)

    def _rmq_init(self, arr):
        n = self.mod = len(arr)
        self.seg_len = 1 << (n - 1).bit_length()
        self.seg = [self.n * n] * (2 * self.seg_len)
        seg = self.seg
        for i, e in enumerate(arr):
            seg[self.seg_len + i] = n * e + i
        for i in range(self.seg_len - 1, 0, -1):
            seg[i] = min(seg[2 * i], seg[2 * i + 1])

    def _rmq_query(self, l, r):
        """最小値となるindexを返す"""
        l += self.seg_len
        r += self.seg_len
        res = self.n * self.mod
        seg = self.seg
        while l < r:
            if r & 1:
                r -= 1
                res = min(res, seg[r])
            if l & 1:
                res = min(res, seg[l])
                l += 1
            l >>= 1
            r >>= 1
        return res % self.mod

    def dfs(self, G, root):
        """ 非再帰で深さ優先探索を行う """
        id = self.id
        tour = self.tour
        depth_list = self.depth_list
        v = root
        it = [0] * self.n
        parents = [-1] * self.n
        visit_id = 0
        depth = 0
        while v != -1:
            if id[v] == -1:
                id[v] = visit_id
            tour[visit_id] = v
            depth_list[visit_id] = depth
            visit_id += 1
            g = G[v]
            if it[v] == len(g):
                v = parents[v]
                depth -= 1
                continue
            if g[it[v]] == parents[v]:
                it[v] += 1
                if it[v] == len(g):
                    v = parents[v]
                    depth -= 1
                    continue
                else:
                    child = g[it[v]]
                    parents[child] = v
                    it[v] += 1
                    v = child
                    depth += 1
            else:
                child = g[it[v]]
                parents[child] = v
                it[v] += 1
                v = child
                depth += 1

    def lca(self, u: int, v: int) -> int:
        """ u と v の最小共通祖先を返す """
        l, r = self.id[u], self.id[v]
        if r < l:
            l, r = r, l
        q = self._rmq_query(l, r + 1)
        return self.tour[q]

    def dist(self, u: int, v: int) -> int:
        """ u と v の距離を返す """
        lca = self.lca(u, v)
        depth_u = self.depth_list[self.id[u]]
        depth_v = self.depth_list[self.id[v]]
        depth_lca = self.depth_list[self.id[lca]]
        return depth_u + depth_v - 2 * depth_lca


import sys

input = sys.stdin.readline
from array import array

n, q = map(int, input().split())
es = [array("i") for _ in range(n)]
for i in range(n - 1):
    start, end = map(int, input().split())
    start -= 1
    end -= 1
    es[start].append(end)
    es[end].append(start)

lca = LowestCommonAncestor(es, 0)

res = [""] * q
for i in range(q):
    c, d = map(int, input().split())
    k = lca.dist(c - 1, d - 1)
    if k % 2:
        res[i] = "Road"
    else:
        res[i] = "Town"

print(*res, sep="\n")
import sys

sys.setrecursionlimit(1000000)


def dfs(n, graph, parent, dists, dist):
    for i in graph[n]:
        if parent == i:
            continue
        dists[i] = dist
        dfs(i, graph, n, dists, dist + 1)


def main():
    n, q = map(int, input().split())
    graph = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = map(int, input().split())
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)

    dists = [-1 for _ in range(n)]
    dists[0] = 0

    dfs(0, graph, -1, dists, 1)

    for _ in range(q):
        c, d = map(int, input().split())
        print("Road" if (dists[c - 1] + dists[d - 1]) % 2 else "Town")


if __name__ == "__main__":
    main()
n, q = map(int, input().split())
path = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)
kyori = [-1 for i in range(n)]
kyori[0] = 0
now = [0]
for i in range(10**5):
    next = []
    for p in now:
        for go in path[p]:
            if kyori[go] == -1:
                kyori[go] = i + 1
                next.append(go)
    now = next
for i in range(q):
    c, d = map(int, input().split())
    if kyori[c - 1] % 2 == kyori[d - 1] % 2:
        print("Town")
    else:
        print("Road")
from collections import deque
import sys

sys.setrecursionlimit(10000000)

N, Q = map(int, input().split())
a, b = [
    list(map((-1).__add__, i))
    for i in zip(*[list(map(int,
                            input().split())) for _ in range(N - 1)])
]
c, d = [
    list(map((-1).__add__, i))
    for i in zip(*[list(map(int,
                            input().split())) for _ in range(Q)])
]

to = [[] for _ in range(N)]
for i in range(N - 1):
    to[a[i]].append(b[i])
    to[b[i]].append(a[i])

stack = deque()
stack.append(0)

use = [False] * N
use[0] = True

G = [[] for _ in range(N)]

while stack:
    u = stack.pop()
    for v in to[u]:
        if use[v]:
            continue
        G[u].append(v)
        stack.append(v)
        use[v] = True

# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)

# Euler Tour の構築
S = []
F = [0] * N
depth = [0] * N


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in G[v]:
        dfs(w, d + 1)
        S.append(v)


dfs(0, 0)

# 存在しない範囲は深さが他よりも大きくなるようにする
INF = (N, None)

# LCAを計算するクエリの前計算
M = 2 * N
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


# LCAの計算 (外から呼び出す関数)
def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for i in range(Q):
    k = query(c[i], d[i])
    dist = depth[c[i]] + depth[d[i]] - 2 * depth[k]
    if dist % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
G = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = deque()
color = [-1] * N
color[0] = 0
que.appendleft(0)
while que:
    t = que.popleft()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.append(i)

C = []
D = []

for i in range(Q):
    c, d = map(int, input().split())
    C.append(c)
    D.append(d)

for i in range(Q):
    if color[C[i] - 1] == color[D[i] - 1]:
        print("Town")
    else:
        print("Road")
class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.__dfs()
        self.__doubling()

    def __dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def __doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
ans = []
tree = LCA(graph)
for _ in range(Q):
    a, b = map(int, input().split())
    t = tree.depth[a - 1] + tree.depth[b - 1] - 2 * tree.depth[tree.get(
        a - 1, b - 1)]
    ans.append("Town" if t % 2 == 0 else "Road")
print(*ans, sep="\n")
# おまじない
import sys

sys.setrecursionlimit(10000)

import math
import itertools
import queue
from collections import deque
# a, b, c, k = map(int, input().split())
# a = list(map(int, input().split()))
# s = input()
# n = int(input())
# a = map(int, input().split())
# array2 = [[False] * n for i in range(n)]

n, q = map(int, input().split())

ab = []
for i in range(n - 1):
    ai, bi = map(int, input().split())
    abi = (ai, bi)
    ab.append(abi)

cd = []
for i in range(q):
    ci, di = map(int, input().split())
    cdi = (ci, di)
    cd.append(cdi)

graph = [[] for _ in range(n + 1)]

for abi in ab:
    ai, bi = abi[0], abi[1]
    graph[ai].append(bi)
    graph[bi].append(ai)

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

# print(dist[1:])
dist_2 = dist[1:]

color = [0] * n
for i, di in enumerate(dist_2):
    if di % 2 == 0:
        color[i] = 2
    else:
        color[i] = 1

for cdi in cd:
    ci = cdi[0] - 1
    di = cdi[1] - 1
    color_c = color[ci]
    color_d = color[di]
    if color_c == color_d:
        print("Town")
    else:
        print("Road")
def divisors(M):
    d = []
    i = 1
    while M >= i**2:
        if M % i == 0:
            d.append(i)
            if i**2 != M:
                d.append(M // i)
        i = i + 1
    return d


def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f


def eratosthenes(n):
    res = [0 for i in range(n + 1)]
    prime = set([])
    for i in range(2, n + 1):
        if not res[i]:
            prime.add(i)
            for j in range(1, n // i + 1):
                res[i * j] = 1
    return prime


def factorization(n):
    res = []
    for p in prime:
        if n % p == 0:
            while n % p == 0:
                n //= p
            res.append(p)
    if n != 1:
        res.append(n)
    return res


def euler_phi(n):
    res = n
    for x in range(2, n + 1):
        if x**2 > n:
            break
        if n % x == 0:
            res = res // x * (x - 1)
            while n % x == 0:
                n //= x
    if n != 1:
        res = res // n * (n - 1)
    return res


def ind(b, n):
    res = 0
    while n % b == 0:
        res += 1
        n //= b
    return res


def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1


def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)


def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i * i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2**20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret


def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p] + 1):
                newres.append(d * p**j)
        res = newres
    res.sort()
    return res


def xorfactorial(num):
    if num == 0:
        return 0
    elif num == 1:
        return 1
    elif num == 2:
        return 3
    elif num == 3:
        return 0
    else:
        x = baseorder(num)
        return (2**x) * ((num - 2**x + 1) % 2) + function(num - 2**x)


def xorconv(n, X, Y):
    if n == 0:
        res = [(X[0] * Y[0]) % mod]
        return res
    x = [X[i] + X[i + 2**(n - 1)] for i in range(2**(n - 1))]
    y = [Y[i] + Y[i + 2**(n - 1)] for i in range(2**(n - 1))]
    z = [X[i] - X[i + 2**(n - 1)] for i in range(2**(n - 1))]
    w = [Y[i] - Y[i + 2**(n - 1)] for i in range(2**(n - 1))]
    res1 = xorconv(n - 1, x, y)
    res2 = xorconv(n - 1, z, w)
    former = [(res1[i] + res2[i]) * inv for i in range(2**(n - 1))]
    latter = [(res1[i] - res2[i]) * inv for i in range(2**(n - 1))]
    former = list(map(lambda x: x % mod, former))
    latter = list(map(lambda x: x % mod, latter))
    return former + latter


def merge_sort(A, B):
    pos_A, pos_B = 0, 0
    n, m = len(A), len(B)
    res = []
    while pos_A < n and pos_B < m:
        a, b = A[pos_A], B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res


class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]] != stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)


class WeightedUnionFind():
    def __init__(self, N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self, v, pv):
        stack = [(v, pv)]
        new_parent = self.parent[pv]
        while stack:
            v, pv = stack.pop()
            self.parent[v] = new_parent
            for nv, w in self.edge[v]:
                if nv != pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv, v))

    def unite(self, x, y, w):
        if not self.flag:
            return
        if self.parent[x] == self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]] > self.size[self.parent[y]]:
            self.edge[x].append((y, -w))
            self.edge[y].append((x, w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y, x)
        else:
            self.edge[x].append((y, -w))
            self.edge[y].append((x, w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x, y)


class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d


#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0] * N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i + j < N and s[j] == s[i + j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i + k < N and k + Z_alg[k] < j:
            Z_alg[i + k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg


class BIT():
    def __init__(self, n, mod=0):
        self.BIT = [0] * (n + 1)
        self.num = n
        self.mod = mod

    def query(self, idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx & (-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self, idx, x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx & (-idx)
        return


class dancinglink():
    def __init__(self, n, debug=False):
        self.n = n
        self.debug = debug
        self._left = [i - 1 for i in range(n)]
        self._right = [i + 1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self, k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L != -1:
            if R != self.n:
                self._right[L], self._left[R] = R, L
            else:
                self._right[L] = self.n
        elif R != self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self, idx, k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res == -1:
                break
            k -= 1
        return res

    def right(self, idx, k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res == self.n:
                break
            k -= 1
        return res


class SparseTable():
    def __init__(self, A, merge_func, ide_ele):
        N = len(A)
        n = N.bit_length()
        self.table = [[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func = merge_func

        for i in range(N):
            self.table[i][0] = A[i]

        for j in range(1, n):
            for i in range(0, N - 2**j + 1):
                f = self.table[i][j - 1]
                s = self.table[i + 2**(j - 1)][j - 1]
                self.table[i][j] = self.merge_func(f, s)

    def query(self, s, t):
        b = t - s + 1
        m = b.bit_length() - 1
        return self.merge_func(self.table[s][m], self.table[t - 2**m + 1][m])


class BinaryTrie:
    class node:
        def __init__(self, val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self, key, val):
        pos = self.root
        for i in range(29, -1, -1):
            pos.max = max(pos.max, val)
            if key >> i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max, val)

    def search(self, M, xor):
        res = -10**15
        pos = self.root
        for i in range(29, -1, -1):
            if pos is None:
                break

            if M >> i & 1:
                if xor >> i & 1:
                    if pos.right:
                        res = max(res, pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res, pos.left.max)
                    pos = pos.right
            else:
                if xor >> i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res, pos.max)
        return res


def solveequation(edge, ans, n, m):
    #edge=[[to,dire,id]...]
    x = [0] * m
    used = [False] * n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y != 0:
            return False
    return x

    def dfs(v):
        used[v] = True
        r = ans[v]
        for to, dire, id in edge[v]:
            if used[to]:
                continue
            y = dfs(to)
            if dire == -1:
                x[id] = y
            else:
                x[id] = -y
            r += y
        return r


class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        self.size = n
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        if r == self.size:
            r = self.num

        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self, l, r, x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l < r:
            if l & 1:
                if self.tree[l] <= x and Lmin == -1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r - 1] <= x:
                    Rmin = r - 1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos < self.num:
                if self.tree[2 * pos] <= x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos + 1
            return pos - self.num
        elif Rmin != -1:
            pos = Rmin
            while pos < self.num:
                if self.tree[2 * pos] <= x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos + 1
            return pos - self.num
        else:
            return -1


import sys, random, bisect
from collections import deque, defaultdict
from heapq import heapify, heappop, heappush
from itertools import permutations
from math import gcd, log

input = lambda: sys.stdin.readline().rstrip()
mi = lambda: map(int, input().split())
li = lambda: list(mi())

N, Q = mi()
edge = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = mi()
    edge[a - 1].append(b - 1)
    edge[b - 1].append(a - 1)

parent = [-1 for v in range(N)]
deq = deque([0])
depth = [0 for v in range(N)]
while deq:
    v = deq.popleft()
    for nv in edge[v]:
        if nv != parent[v]:
            depth[nv] = depth[v] + 1
            parent[nv] = v
            deq.append(nv)

for _ in range(Q):
    c, d = mi()
    c, d = c - 1, d - 1
    print("Road" if (depth[c] + depth[d]) & 1 else "Town")
N, Q = map(int, input().split())
edges = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    edges[b].append(a)
    edges[a].append(b)

q = [(0, False)]
colors = [False] * N
visited = set()
while len(q) > 0:
    node = q.pop(0)
    colors[node[0]] = node[1]
    visited.add(node[0])
    for ne in edges[node[0]]:
        if ne in visited:
            continue

        q.append((ne, not node[1]))

for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    print("Town" if colors[c] == colors[d] else "Road")
#!/usr/bin/env python3
import sys
from collections import defaultdict, deque

INF = float('inf')
readline = sys.stdin.buffer.readline
sys.setrecursionlimit(10**7)


def db(*arg):
    print(*arg)


def div_ceil(x, y):
    return -(-x // y)


N, Q = map(int, readline().split())
ad_ls = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, readline().split())
    a, b = a - 1, b - 1
    ad_ls[a].append(b)
    ad_ls[b].append(a)

G = [[] for _ in range(N)]

dist = [0] * N
q = deque()
q.append((0, 0))
done = set([0])
while q:
    now, c = q.popleft()
    for nex in ad_ls[now]:
        if nex in done:
            continue
        dist[nex] = c + 1
        G[now].append(nex)
        done.add(nex)
        q.append((nex, c + 1))

S = []
F = [0] * N
depth = [0] * N
done = set()


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in G[v]:
        if w in done:
            continue
        dfs(w, d + 1)
        S.append(v)
        done.add(w)


dfs(0, 0)

INF = (N, None)

M = 2 * N
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for _ in range(Q):
    c, d = map(int, readline().split())
    lca = query(c - 1, d - 1)
    d = dist[c - 1] + dist[d - 1] - 2 * dist[lca]
    # db('=====')
    # print(d)
    # print('lca', dist[lca])
    print('Town' if d % 2 == 0 else 'Road')
from collections import deque

N, Q = map(int, input().split())
gr = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    gr[a].append(b)
    gr[b].append(a)
s = 0
d = deque()
d.append(s)
log = [0 for i in range(N)]
log[0] = 1
while d:
    e = d.popleft()
    for i in gr[e]:
        if log[i] == 0:
            log[i] = 1
            d.append(i)
            s = i
dis = [0 for i in range(N)]
log = [0 for i in range(N)]
log[s] = 1
d = deque()
d.append(s)
while d:
    e = d.popleft()
    for i in gr[e]:
        if log[i] == 0:
            log[i] = 1
            d.append(i)
            dis[i] = dis[e] + 1
for i in range(Q):
    f, g = map(int, input().split())
    h = abs(dis[f - 1] - dis[g - 1])
    if h % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
G = [[] for i in range(n)]

for i in range(n - 1):
    ind = lambda n: int(n) - 1
    a, b = map(ind, input().split())
    G[a].append(b)
    G[b].append(a)

que = deque()
color = [-1 for _ in range(n)]
color[0] = 0
que.append(0)

while len(que) > 0:
    t = que.pop()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.append(i)

for i in range(q):
    ind = lambda n: int(n) - 1
    a, b = map(ind, input().split())
    print('Town' if color[a] == color[b] else 'Road')
from collections import deque


def D():
    N, Q = map(int, input().split())
    dist = [[] for i in range(N + 1)]
    for i in range(N - 1):
        a, b = map(int, input().split())
        dist[b].append(a)
        dist[a].append(b)
    #スタートsとして、ゴールを1にしたときの、距離（偶数=0,奇数=1)
    que = deque()
    que.append(1)
    vivited = [False] * (N + 1)
    vivited[1] = True
    counter = [0] * (N + 1)
    n = 0

    while que:
        now = que.popleft()
        for to in dist[now]:
            if vivited[to] == False:
                counter[to] = counter[now] + 1
                vivited[to] = True
                que.append(to)
    for i in range(Q):
        c, d = map(int, input().split())
        if (counter[c] + counter[d]) % 2 == 0:
            print('Town')
        else:
            print('Road')


D()
import math
import itertools
import bisect
from heapq import heappush, heappop
from sys import stdin
from collections import deque
from sys import setrecursionlimit
from functools import reduce
from collections import defaultdict

setrecursionlimit(10**7)
input = stdin.readline


def I():
    return int(input())


def IN():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


def LIN():
    return [list(map(int, input().split())) for _ in range(N)]


N, Q = IN()
road = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = IN()
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)

que = deque([])
que.append(0)

cnt = [0] * N
visited = [0] * N

while que:
    before = que.pop()
    if visited[before] == 1:
        continue
    visited[before] = 1

    for visit in road[before]:
        cnt[visit] = 1 - cnt[before]
        que.append(visit)

ans = [0] * Q
for k in range(Q):
    c, d = IN()
    if cnt[c - 1] == cnt[d - 1]:
        ans[k] = "Town"
    else:
        ans[k] = "Road"
print(*ans, sep="\n")
from collections import deque

N, Q = list(map(int, input().split()))
li = [[] for _ in range(N)]
for i in range(N - 1):
    s, t = list(map(int, input().split()))
    li[s - 1].append(t - 1)
    li[t - 1].append(s - 1)

d = deque()
d.append(s)
dist = [-1] * N
dist[s] = 0
while d:
    v = d.popleft()
    for i in li[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)
for i in range(Q):
    s, t = list(map(int, input().split()))
    s -= 1
    t -= 1
    ans = abs(dist[s] - dist[t])
    if ans % 2 == 0:
        print("Town")

    else:
        print("Road")
n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

from collections import defaultdict

g = defaultdict(list)
for a, b in ab:
    g[a] += [b]
    g[b] += [a]


# Euler Tour
def dfs(u, d):
    # first visit
    vis = [-1] * (n + 1)
    # euler tour
    et = []
    que = [(-u, d), (u, d)]

    while len(que) > 0:
        u, d = que.pop()
        if u > 0:
            # 行きがけの処理
            vis[u] = len(et)
            et += [(u, d)]
            for v in g[u]:
                if vis[v] == -1:  # 未探索のみ
                    que += [(-v, d + 1)]  # 帰り
                    que += [(v, d + 1)]  # 行き
        else:
            # 帰りがけの処理
            et += [(u, d)]

    return vis, et


vis, et = dfs(1, 0)


class SegmentTree():
    def __init__(self, a):
        self.INF = float("inf")
        n = len(a)
        p = n.bit_length()
        aug = pow(2, p) - n
        a += [self.INF] * aug
        self.n = len(a)
        self.tree = [self.INF] * (2 * self.n - 1)

        # 葉の値をセット
        for i in range(self.n):
            j = i + self.n - 1
            self.tree[j] = a[i]

        # 葉に近い方から更新していく
        for j in range(self.n - 2, -1, -1):
            self.tree[j] = min(self.tree[j * 2 + 1], self.tree[j * 2 + 2])

    def update(self, i, x):
        # i番目はn-1+i番目
        j = i + self.n - 1
        self.tree[j] = x  # 新しい値
        while (j > 0):
            # 親を辿りながら更新
            j = (j - 1) // 2
            self.tree[j] = min(self.tree[j * 2 + 1], self.tree[j * 2 + 2])

    def rmq(self, a, b):
        k, l, r = 0, 0, self.n
        ans = self.INF
        stack = [(k, l, r)]

        while len(stack):
            k, l, r = stack.pop()
            if r <= a or b <= l:
                pass
            elif a <= l and r <= b:
                ans = min(ans, self.tree[k])
            else:
                stack.append((2 * k + 1, l, (l + r) // 2))
                stack.append((2 * k + 2, (l + r) // 2, r))

        return ans


a = [t for e, t in et]
st = SegmentTree(a)

for c, d in cd:
    vc, vd = vis[c], vis[d]
    dc, dd = a[vc], a[vd]

    #print(c,d,vc,vd,dc,dd)

    if vc > vd:
        tmp = vc
        vc = vd
        vd = tmp

    #continue
    #print(c, d, vc, vd)
    m = st.rmq(vc, vd + 1)

    dist = dc + dd - 2 * m

    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**9)
N, Q = map(int, input().split())
D = [[] for i in range(N)]
G = [[] for i in range(N)]
S = []
F = [0] * N
for i in range(N - 1):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    D[u].append(v)
    D[v].append(u)
#根が決められておらず、Dでとりあえず双方向を記録し、Gで方向を決めている
depth = [-1] * N
import sys

sys.setrecursionlimit(10**9)
from collections import deque

d = deque()
d.append((0, 0))
e = deque()
de = 1
while d:
    now, pre = d.popleft()
    for nex in D[now]:
        if nex != pre:
            G[now].append(nex)
            e.append((nex, now))
    d = e
#print(G)

S = []
F = [0] * N
depth = [0] * N


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in G[v]:
        dfs(w, d + 1)
        S.append(v)


dfs(0, 0)

# 存在しない範囲は深さが他よりも大きくなるようにする
INF = (N, None)

# LCAを計算するクエリの前計算
M = 2 * N
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for q in range(Q):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    a = query(u, v)
    r = depth[u] - depth[a] + depth[v] - depth[a]
    if r % 2 == 0:
        print('Town')
    else:
        print('Road')
# deque
from collections import deque

N, query = [int(_) for _ in input().split()]
G = [[] for i in range(N)]

for i in range(N - 1):
    a, b = [int(_) for _ in input().split()]
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

# 幅優先
dist = [-1] * N
Q = deque()
Q.append(0)
dist[0] = 0
while len(Q) > 0:
    # 4辺チェックしキューへ追加
    i = Q.popleft()
    for j in G[i]:
        if dist[j] == -1 or dist[j] > dist[i] + 1:
            dist[j] = dist[i] + 1
            Q.append(j)

for q in range(query):
    c, d = [int(_) for _ in input().split()]
    if abs(dist[c - 1] - dist[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**7)
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

used = [0] * N
dist = [-1] * N


def dfs(v, p):
    used[v] = 1
    dist[v] = dist[p] + 1
    for w in G[v]:
        if used[w]:
            continue

        dfs(w, v)


dfs(0, 0)  # 最初だけ注意
for i in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2:
        print('Road')
    else:
        print('Town')
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]
root = [[] for _ in range(N + 1)]
for i in range(N - 1):
    root[ab[i][0]].append(ab[i][1])
    root[ab[i][1]].append(ab[i][0])
arrived = [False] * (N + 1)

flag = [-1] * (N + 1)
flag[1] = False
stack = [1]
while stack:
    label = stack.pop(-1)
    for i in root[label]:
        if not arrived[i]:
            arrived[i] = True
            flag[i] = (not flag[label])
            stack.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    if flag[c] == flag[d]:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(500000)
N, Q = map(int, input().split())
A = [-1 for _ in range(N)]
T = [set() for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    T[a - 1].add(b - 1)
    T[b - 1].add(a - 1)
A[0] = 0


def dfs(i):
    for t in T[i]:
        if A[t] == -1:
            A[t] = (A[i] + 1) % 2
            dfs(t)


dfs(0)
for i in range(Q):
    x, y = map(int, input().split())
    if A[x - 1] == A[y - 1]:
        print("Town")
    else:
        print("Road")
def resolve():
    N, Q = map(int, input().split())
    from collections import defaultdict, deque
    path = defaultdict(list)
    for i in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        path[a].append(b)
        path[b].append(a)
    nxt = deque([0])
    depth = [0] * N
    arv = [-1] * N
    arv[0] = 1
    while nxt:
        n = nxt.popleft()
        d = depth[n]
        for i in path[n]:
            if arv[i] == -1:
                arv[i] = 1
                depth[i] = d + 1
                nxt.append(i)

    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        if (depth[c] + depth[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


resolve()
from math import modf, pi, gcd
from heapq import heappop, heappush
from collections import deque

INF = 1 << 60
MOD = 10**9 + 7
# MOD = 998244353


def main():
    n, Q = map(int, input().split())
    path = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = map(int, input().split())
        path[a - 1].append(b - 1)
        path[b - 1].append(a - 1)
    q = deque()
    q.append(0)
    visited = [-1] * n
    visited[0] = 0
    while len(q) > 0:
        x = q.popleft()
        for nx in path[x]:
            if visited[nx] >= 0:
                continue
            visited[nx] = visited[x] + 1
            q.append(nx)
    ret = []
    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1

        tmp = visited[c] + visited[d]
        if tmp % 2 == 0:
            ret.append('Town')
        else:
            ret.append('Road')
    for v in ret:
        print(v)


def dijkstra(s, n, adj):  # (始点, ノード数, 道グラフ)
    dist = [INF] * n
    hq = [(0, s)]  # (distance, node)
    dist[s] = 0
    seen = [False] * n  # ノードが確定済みかどうか
    while hq:
        v = heappop(hq)[1]  # ノードを pop する
        seen[v] = True
        for to, cost in adj[v]:  # ノード v に隣接しているノードに対して
            if seen[to] == False and dist[v] + cost < dist[to]:
                dist[to] = dist[v] + cost
                heappush(hq, (dist[to], to))
    return dist


def warshallFloyd(path):
    n = len(path)
    cost = [[INF] * n for _ in range(n)]
    for i in range(n):
        for j, c in path[i]:
            cost[i][j] = c
        cost[i][i] = 0
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if cost[i][k] != INF and cost[k][j] != INF:
                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])
    return cost


if __name__ == "__main__":
    main()
#D

from collections import deque

N, Q = map(int, input().split())

AB = [list(map(int, input().split())) for l in range(N - 1)]

CD = [list(map(int, input().split())) for l in range(Q)]

edges = [[] for _ in range(N + 1)]
for a, b in AB:
    edges[a].append(b)
    edges[b].append(a)  #根がはっきりしている場合は不要

done = [0] * (N + 1)

dep = [0] * (N + 1)

q = deque()
q.append([1, 0])
# キューが空になるまで繰り返す
while len(q) > 0:
    # キューの末（右端）からnodeを取り出す
    node = q.pop()
    if node is not None:
        n = node[0]
        c = node[1]
        if done[n] == 0:
            done[n] = 1
            dep[n] = c
            for e in edges[n]:
                q.append([e, c + 1])

for cd in CD:
    c = cd[0]
    d = cd[1]
    if abs(dep[c] - dep[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
class Tree:
    def __init__(self, N, index=0):
        """N頂点(index, index+1, ..., N-1+index)の根付き木を生成する.
        """
        self.N = N
        self.index = index
        self.parent = [-1] * (N + index)
        self.__mutable = True

    def vertex_exist(self, x):
        return self.index <= x < self.index + self.N

    def __after_seal_check(self, *vertexes):
        if self.__mutable:
            return False

        for v in vertexes:
            if not self.vertex_exist(v):
                return False
        return True

    def is_mutable(self):
        return self.__mutable

    #設定パート
    def root_set(self, root):
        """頂点xを根に設定する.
        """
        assert self.vertex_exist(root)
        assert self.__mutable

        self.root = root

    def parent_set(self, x, y):
        """頂点xの親をyに設定する.
        """
        assert self.vertex_exist(x)
        assert self.vertex_exist(y)
        assert self.__mutable

        self.parent[x] = y

    def child_set(self, x, y):
        """頂点xの子の一つにyを設定する.
        """
        assert self.vertex_exist(x)
        assert self.vertex_exist(y)
        assert self.__mutable

        self.parent[y] = x

    def seal(self):
        """木の情報を確定させる.
        """
        assert self.__mutable
        assert hasattr(self, "root")

        a = self.index
        b = self.index + self.N
        C = [[] for _ in range(b)]

        p = self.parent
        ve = self.vertex_exist
        for i in range(a, b):
            if i != self.root:
                assert ve(p[i])
                C[p[i]].append(i)

        self.__mutable = False
        self.children = C

    #データを求める.
    def depth_search(self, Mode=True):
        """木の深さを求める.
        """

        assert self.__after_seal_check()

        if hasattr(self, "depth"):
            return self.depth

        from collections import deque
        C = self.children
        D = [-1] * (self.index + self.N)
        E = [[] for _ in range(self.N)]

        Q = deque([self.root])
        D[self.root] = 0
        E[0] = [self.root]

        while Q:
            x = Q.popleft()
            d = D[x]
            for y in C[x]:
                D[y] = d + 1
                E[d + 1].append(y)
                Q.append(y)

        self.depth = D
        self.tower = E

        if Mode:
            return D

    def vertex_depth(self, x):
        """頂点xの深さを求める.
        """
        assert self.__after_seal_check(x)

        if not hasattr(self, "depth"):
            self.depth_search(Mode=False)
        return self.depth[x]

    def __upper_list(self):
        assert self.__after_seal_check()

        if hasattr(self, "upper_list"):
            return

        if not hasattr(self, "depth"):
            self.depth_search(False)

        b = max(self.depth).bit_length()
        X = [[-1] * (self.index + self.N) for _ in range(b)]

        Y = X[0]
        p = self.parent
        rg = range(self.index, self.index + self.N)

        for x in rg:
            if x != self.root:
                Y[x] = p[x]
            else:
                Y[x] = self.root

        for k in range(1, b):
            Y = X[k - 1]
            Z = X[k]

            for x in rg:
                Z[x] = Y[Y[x]]
        self.upper_list = X

    def upper(self, x, k, over=True):
        """頂点xから見てk個親の頂点を求める.

        over:(頂点xの深さ)<kのときにTrueならば根を返し, Falseならばエラーを吐く.
        """

        assert self.__after_seal_check(x)
        assert 0 <= k

        if not hasattr(self, "upper_list"):
            self.__upper_list()

        if self.vertex_depth(x) < k:
            if over:
                return self.root
            else:
                raise ValueError

        i = 0
        while k:
            if k & 1:
                x = self.upper_list[i][x]
            k >>= 1
            i += 1
        return x

    def lowest_common_ancestor(self, x, y):
        """頂点x,yの最小共通先祖(x,yに共通する先祖で最も深いもの)を求める.
        """

        assert self.__after_seal_check(x, y)

        dd = self.vertex_depth(y) - self.vertex_depth(x)
        if dd < 0:
            x, y = y, x
            dd = -dd

        y = self.upper(y, dd)
        if x == self.root:
            return x
        if x == y:
            return x

        d = self.vertex_depth(x)
        b = d.bit_length()

        X = self.upper_list
        for k in range(b - 1, -1, -1):
            px = X[k][x]
            py = X[k][y]
            if px != py:
                x = px
                y = py

        return self.upper(x, 1)

    def __degree_count(self):
        assert self.__after_seal_check()

        if hasattr(self, "deg"):
            return

        self.deg = [0] * (self.index + self.N)
        for v in range(self.index, self.index + self.N):
            d = len(self.children[v]) + 1
            if d != self.root:
                d -= 1
            self.deg[v] = d
        return

    def degree(self, v):
        """頂点vの次数を求める.
        """
        assert self.__after_seal_check(v)

        if not hasattr(self, "deg"):
            self.__degree_count()
        return self.deg[v]

    def diameter(self):
        """木の直径を求める.
        """
        assert self.__after_seal_check()

        from collections import deque

        def bfs(start):
            X = [-1] * (self.index + self.N)
            Q = deque([start])
            X[start] = 0

            pa = self.parent
            ch = self.children
            while Q:
                x = Q.popleft()

                if X[pa[x]] == -1:
                    Q.append(pa[x])
                    X[pa[x]] = X[x] + 1

                for y in ch[x]:
                    if X[y] == -1:
                        Q.append(y)
                        X[y] = X[x] + 1
            y = max(range(self.index, self.index + self.N), key=lambda x: X[x])
            return y, X[y]

        y, _ = bfs(self.root)
        z, d = bfs(y)
        return y, z, d

    def path(self, u, v):
        """頂点u,v間のパスを求める.
        """
        assert self.__after_seal_check(u, v)

        w = self.lowest_common_ancestor(u, v)
        pa = self.parent

        X = [u]
        while u != w:
            u = pa[u]
            X.append(u)

        Y = [v]
        while v != w:
            v = pa[v]
            Y.append(v)
        return X + Y[-2::-1]

    def is_brother(self, u, v):
        """2つの頂点u,vは兄弟 (親が同じ) か?
        """
        assert self.__after_seal_check(u, v)

        if u == self.root or v == self.root:
            return False
        return self.parent[u] == self.parent[v]

    def is_ancestor(self, u, v):
        """頂点uは頂点vの先祖か?
        """
        assert self.__after_seal_check(u, v)

        dd = self.vertex_depth(v) - self.vertex_depth(u)
        if dd < 0:
            return False

        v = self.upper(v, dd)
        return u == v

    def is_descendant(self, u, v):
        """頂点uは頂点vの子孫か?
        """
        assert self.__after_seal_check(u, v)
        return self.is_ancestor(v, u)

    def is_leaf(self, v):
        """頂点vは葉?
        """

        return not bool(self.children[v])

    def distance(self, u, v):
        """2頂点u,v間の距離を求める.
        """
        assert self.__after_seal_check(u, v)

        dep = self.vertex_depth
        return dep(u) + dep(v) - 2 * dep(self.lowest_common_ancestor(u, v))

    def __descendant_count(self):
        assert self.__after_seal_check()
        if hasattr(self, "des_count"):
            return

        if not hasattr(self, "tower"):
            self.depth_search(False)

        self.des_count = [1] * (self.index + self.N)
        pa = self.parent
        for T in self.tower[:0:-1]:
            for x in T:
                self.des_count[pa[x]] += self.des_count[x]
        return

    def descendant_count(self, v):
        """頂点vの子孫の数を求める.
        """
        assert self.__after_seal_check(v)
        self.__descendant_count()
        return self.des_count[v]

    def subtree_size(self, v):
        """頂点vを根とした部分根付き木のサイズを求める.
        """
        return self.descendant_count(v)

    def preorder(self, v):
        """頂点vの行きがけ順を求める.
        """
        assert self.__after_seal_check(v)
        if hasattr(self, "preorder_number"):
            self.preorder_number[v]

        from collections import deque
        Q = deque([self.root])
        T = [-1] * (self.N + self.index)

        p = 1
        while Q:
            x = Q.popleft()
            T[x] = p
            p += 1

            C = self.children[x]
            for y in C:
                Q.append(y)
        self.preorder_number = T
        return T[v]

    def dfs_yielder(self):
        """DFSにおける頂点の出入りをyieldする.

        (v,1): 頂点vに入る
        (v,0): 頂点vを出る
        """
        assert self.__after_seal_check()

        #最初
        yield (self.root, 1)

        v = self.root

        ch = self.children
        pa = self.parent

        R = [-1] * self.index + [
            len(ch[x]) for x in range(self.index, self.index + self.N)
        ]
        S = [0] * (self.index + self.N)

        while True:
            if R[v] == S[v]:  #もし,進めないならば
                yield (v, 0)  #頂点vを出る
                if v == self.root:
                    break
                else:
                    v = pa[v]
            else:  #進める
                w = v
                v = ch[v][S[v]]
                S[w] += 1
                yield (v, 1)

    def top_down(self):
        assert self.__after_seal_check()
        if not hasattr(self, "tower"):
            self.depth_search(False)

        for E in self.tower:
            for v in E:
                yield v

    def bottom_up(self):
        assert self.__after_seal_check()
        if not hasattr(self, "tower"):
            self.depth_search(False)

        for E in self.tower[::-1]:
            for v in E:
                yield v

    def tree_dp(self, merge, unit, f, g, Mode=False):
        """葉から木DPを行う.

        [input]
        calc:可換モノイドを成す2項演算 M x M -> M
        unit:Mの単位元
        f,g: M x V -> M
        Mode: False->根の値のみ, True->全ての値

        [補足]
        頂点 v の子が x,y,z,...のとき, 更新式は
        dp[v]=g(f(x)*f(y)*f(z)*...)
        になる.
        """
        assert self.__after_seal_check()

        data = [unit] * (self.index + self.N)
        ch = self.children

        for x in self.bottom_up():
            for y in ch[x]:
                data[x] = merge(data[x], f(data[y], y))
            data[x] = g(data[x], x)

        if Mode:
            return data
        else:
            return data[self.root]

    def rerooting(self, merge, unit, f, g):
        """全方位木DPを行う.

        [input]
        calc:可換モノイドを成す2項演算 M x M -> M
        unit:Mの単位元
        f,g: M x V -> M
        Mode: False->根の値のみ, True->全ての値

        [補足]
        頂点 v の子が x,y,z,...のとき, 更新式は
        dp[v]=g(f(dp[x],x)*f(dp[y],y)*f(dp[z],z)*...)
        になる.
        """
        assert self.__after_seal_check()

        upper = [unit] * (self.index + self.N)
        lower = [unit] * (self.index + self.N)

        ch = self.children
        pa = self.parent

        #DFSパート
        X = [unit] * (self.N + self.index)
        for v in self.bottom_up():
            for c in ch[v]:
                lower[v] = merge(lower[v], f(X[c], c))
            X[v] = g(lower[v], v)

        #BFSパート
        Y = [unit] * (self.N + self.index)
        for v in self.top_down():
            cc = ch[v]

            #累積マージ
            deg = len(cc)

            L = [unit]
            x = unit
            for c in cc:
                x = merge(x, f(X[c], c))
                L.append(x)

            R = [unit]
            y = unit
            for c in cc[::-1]:
                y = merge(y, f(X[c], c))
                R.append(y)
            R = R[::-1]

            for i in range(deg):
                c = cc[i]
                a = merge(L[i], R[i + 1])
                b = merge(a, f(Y[v], v))
                upper[c] = b
                Y[c] = g(upper[c], c)

        A = [unit] * (self.index + self.N)
        pa = self.parent
        for v in range(self.index, self.index + self.N):
            if v == self.root:
                A[v] = g(X[v], v)
            else:
                A[v] = g(merge(X[v], Y[v]), v)
        return A

    def euler_tour(self):
        """ オイラーツアーに関する計算を行う.
        """

        assert self.__after_seal_check()

        #最初
        X = []
        X_append = X.append  #X: Euler Tour のリスト

        v = self.root

        ch = self.children
        pa = self.parent

        R = [-1] * self.index + [
            len(ch[x]) for x in range(self.index, self.index + self.N)
        ]
        S = [0] * (self.index + self.N)
        while True:
            X_append(v)
            if R[v] == S[v]:  #もし,進めないならば
                if v == self.root:
                    break
                else:
                    v = pa[v]
            else:  #進める
                w = v
                v = ch[v][S[v]]
                S[w] += 1

        self.euler = X
        self.in_time = [-1] * (self.index + self.N)
        self.out_time = [-1] * (self.index + self.N)
        for i in range(len(X)):
            v = X[i]
            if self.in_time[v] == -1:
                self.in_time[v] = self.out_time[v] = i
            else:
                self.out_time[v] = i


#=================================================
def Making_Tree(N, E, root, index=0):
    """木を作る.

    N:頂点数
    E:辺のリスト
    root:根
    """

    from collections import deque
    F = [[] for _ in range(index + N)]
    for u, v in E:
        assert index <= u < index + N
        assert index <= v < index + N
        assert u != v

        F[u].append(v)
        F[v].append(u)

    X = [-1] * (index + N)
    X[root] = root

    C = [[] for _ in range(index + N)]

    Q = deque([root])
    while Q:
        x = Q.popleft()
        for y in F[x]:
            if X[y] == -1:
                X[y] = x
                Q.append(y)
                C[x].append(y)

    T = Tree(N, index)
    T.root_set(root)
    T.parent = X
    T.children = C
    T.seal()
    return T


#==================================================
import sys

input = sys.stdin.readline
write = sys.stdout.write

N, Q = map(int, input().split())
E = []
for _ in range(N - 1):
    a, b = map(int, input().split())
    E.append((a, b))

root = 1
T = Making_Tree(N, E, root, root)

dep = T.depth_search(True)

X = [""] * Q
for q in range(Q):
    c, d = map(int, input().split())
    if (dep[c] + dep[d]) % 2 == 0:
        X[q] = "Town"
    else:
        X[q] = "Road"

write("\n".join(X))
import sys
import collections
import queue

input = sys.stdin.readline


def main():
    N, Q = map(int, input().split())
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)
    que = queue.Queue()
    color = [-1] * N
    color[0] = 0
    que.put(0)
    while not que.empty():
        t = que.get()
        for i in G[t]:
            if color[i] == -1:
                color[i] = 1 - color[t]
                que.put(i)
    for _ in range(Q):
        c, d = map(int, input().split())
        if color[c - 1] == color[d - 1]:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
import sys

sys.setrecursionlimit(10**9)
city, Q = map(int, input().split())
road = [[] for i in range(city)]
flag = [-1] * (city)
for i in range(city - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)
flag[0] = 0


def dfs(x):
    for i in road[x]:
        if flag[i] == -1:
            if flag[x] == 0:
                flag[i] = 1
            elif flag[x] == 1:
                flag[i] = 0
            dfs(i)
    return 0


dfs(0)
Queri = [0] * Q
for i in range(Q):
    Queri[i] = list(map(int, input().split()))
for i in range(Q):
    if flag[Queri[i][0] - 1] == flag[Queri[i][1] - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
G = [[] for i in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
dist = [-1] * n
dist[0] = 0
Q = deque([0])
while Q:
    u = Q.popleft()
    for v in G[u]:
        if dist[v] == -1:
            Q.append(v)
            dist[v] = dist[u] + 1
for _ in range(q):
    c, d = map(int, input().split())
    print("Road" if (dist[c - 1] - dist[d - 1]) % 2 else "Town")
import sys

sys.setrecursionlimit(10**9)

n, q = map(int, input().split())
se = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    se[a - 1].append(b - 1)
    se[b - 1].append(a - 1)

kyori = [10**9] * n
done = [True] * n
done[0] = False


def dfs(t, m):
    global kyori
    kyori[t] = m
    for i in se[t]:
        if done[i]:
            done[i] = False
            dfs(i, m + 1)


dfs(0, 0)

for i in range(q):
    c, d = map(int, input().split())
    if kyori[c - 1] % 2 == kyori[d - 1] % 2:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
a, b = zip(*[map(int, input().split()) for i in range(n - 1)])
c, d = zip(*[map(int, input().split()) for i in range(q)])

E = {i: [] for i in range(n)}
for s, t in zip(a, b):
    s, t = s - 1, t - 1
    E[s].append(t)
    E[t].append(s)
dp = [-1] * n
dp[0] = 0
que = [0]
while que:
    v = que.pop(0)
    for w in E[v]:
        if dp[w] == -1:
            dp[w] = dp[v] + 1
            que.append(w)
for v, w in zip(c, d):
    d = dp[v - 1] + dp[w - 1]
    if d % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque


class Node:
    def __init__(self, index):
        self.index = index
        self.nears = []
        self.sign = False
        self.color = "r"


n, q = map(int, input().split())
links = [list(map(int, input().split())) for _ in range(n - 1)]

nodes = []
for i in range(n + 1):
    nodes.append(Node(i))

for j in range(n - 1):
    edge_start, edge_end = links[j]
    nodes[edge_start].nears.append(edge_end)
    nodes[edge_end].nears.append(edge_start)

queue = deque()
queue.append(nodes[1])

while queue:
    node = queue.popleft()
    nears = node.nears

    for near in nears:
        if nodes[near].sign == False:
            queue.append(nodes[near])
            nodes[near].sign = True
            if node.color == "r":
                nodes[near].color = "b"
            else:
                nodes[near].color = "r"

for k in range(q):
    c, d = map(int, input().split())

    if nodes[c].color == nodes[d].color:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
g = [[] for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    g[b - 1].append(a - 1)
    g[a - 1].append(b - 1)

dist = [-1] * n
dist[0] = 0
queue = deque()
queue.append(0)

while len(queue) != 0:
    v = queue.popleft()
    for i in g[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        queue.append(i)

for i in range(q):
    c, d = map(int, input().split())
    if dist[c - 1] % 2 != dist[d - 1] % 2:
        print("Road")
    else:
        print("Town")
N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
from collections import deque

dist = [-1] * (N)
dist[0] = 0  #start地点を0とする
d = deque()
d.append(0)
while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)
for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] - dist[d - 1]) % 2:
        print('Road')
    else:
        print('Town')
def q4():
    N, Q = [int(x) for x in input().split()]
    ABs = [[int(x) for x in input().split()] for _ in range(N - 1)]
    Qs = [[int(x) for x in input().split()] for _ in range(Q)]
    nodes = {
        i + 1: {
            'index': i + 1,
            'is_searched': False,
            'length': 0,
            'children': [],
            'degree': 0
        }
        for i in range(N)
    }
    for a, b in ABs:
        nodes[a]['children'].append(b)
        nodes[b]['children'].append(a)
        nodes[a]['degree'] = nodes[a]['degree'] + 1
        nodes[b]['degree'] = nodes[b]['degree'] + 1
    for i, node in nodes.items():
        if node['degree'] == 1:
            start_index = node['index']
            break
    answer = 0
    from collections import deque
    d = deque()
    d.append(start_index)
    nodes[start_index]['is_searched'] = True
    nodes[start_index]['length'] = 0
    while d:
        n = d.popleft()
        children = nodes[n]['children']
        for c in children:
            if not nodes[c]['is_searched']:
                d.append(c)
                nodes[c]['is_searched'] = True
                nodes[c]['length'] = nodes[n]['length'] + 1
    for c, d in Qs:
        x = abs(nodes[c]['length'] - nodes[d]['length'])
        if x % 2 == 1:
            answer = 'Road'
        else:
            answer = 'Town'
        print(answer)


q4()
from collections import deque

n, Q = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

dist = [-1] * n
dist[0] = 0
q = deque([0])
while q:
    v = q.popleft()
    for i in g[v]:
        if dist[i] != -1: continue
        dist[i] = dist[v] + 1
        q.append(i)

for _ in range(Q):
    c, d = map(int, input().split())
    if abs(dist[c - 1] - dist[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)
r = [-1] * n
r[0] = 0
queue = deque()
queue.append(0)
while queue:
    x = queue.popleft()
    for y in graph[x]:
        if r[y] == -1:
            r[y] = r[x] ^ 1
            queue.append(y)
for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if r[c] == r[d]:
        print('Town')
    else:
        print('Road')
from collections import defaultdict

graph = defaultdict(list)

n, q = map(int, input().split())

for i in range(1, n + 1):
    graph[i] = []

for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

color = dict()

head = 1
queue = list()
queue.append((head, 1))
color[head] = 1
visited = set()
visited.add(head)

while queue:
    data = queue.pop(0)
    curr_node = data[0]
    curr_color = data[1]

    for node in graph[curr_node]:
        if node not in visited:
            visited.add(node)
            queue.append((node, 1 - curr_color))
            color[node] = 1 - curr_color

for i in range(q):
    a, b = map(int, input().split())

    if color[a] == color[b]:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**9)


def input():
    return sys.stdin.readline()[:-1]


def main():

    N, Q = map(int, input().split())
    G = [list() for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)

    S = []
    F = [0] * N
    depth = [0] * N
    check = [False] * N

    def dfs(v, d):
        F[v] = len(S)
        depth[v] = d
        S.append(v)
        check[v] = True
        for w in G[v]:
            if not check[w]:
                dfs(w, d + 1)
                S.append(v)

    dfs(0, 0)

    INF = (N, None)

    M = 2 * N
    M0 = 2**(M - 1).bit_length()
    data = [INF] * (2 * M0)
    for i, v in enumerate(S):
        data[M0 - 1 + i] = (depth[v], i)
    for i in range(M0 - 2, -1, -1):
        data[i] = min(data[2 * i + 1], data[2 * i + 2])

    def _query(a, b):
        yield INF
        a += M0
        b += M0
        while a < b:
            if b & 1:
                b -= 1
                yield data[b - 1]
            if a & 1:
                yield data[a - 1]
                a += 1
            a >>= 1
            b >>= 1

    def query(u, v):
        fu = F[u]
        fv = F[v]
        if fu > fv:
            fu, fv = fv, fu
        return S[min(_query(fu, fv + 1))[1]]

    for _ in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        lca = query(c, d)
        dist = (depth[lca] - depth[c]) + (depth[lca] - depth[d])
        if dist % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
import heapq
import sys

sys.setrecursionlimit(3000000)

n, q = map(int, input().split())

g = [[] for _ in range(n + 1)]

color = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

for i in range(1, n + 1):
    g[i].sort()


def bfs(start, bef, dim):

    if dim % 2 == 0:
        color[start] = "○"
    else:
        color[start] = "x"
    dim += 1
    for s in g[start]:
        if s != bef:
            bfs(s, start, dim)

    dim -= 1


dim = 1
bfs(1, -1, dim)

for i in range(q):
    c, d = map(int, input().split())
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())

graph = [[] for _ in range(N + 1)]

for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

# ab=[]
cd = []

# for i in range(N-1):
#     ab.append(list(map(int,input().split())))

for i in range(Q):
    cd.append(list(map(int, input().split())))

dist = [-1] * (N + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    # print("v",v)
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i in range(Q):
    if abs(dist[cd[i][0]] - dist[cd[i][1]]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys, collections, math, itertools, re, decimal, statistics

sys.setrecursionlimit(200000)
# n = int(input())
n, q = map(int, input().split())
# li = list(map(int,input().split()))
li = []
for i in range(n - 1):
    li.append(list(map(int, input().split())))
hash = {}
for i in range(n - 1):
    if li[i][0] not in hash: hash[li[i][0]] = [li[i][1]]
    else: hash[li[i][0]].append(li[i][1])
    if li[i][1] not in hash: hash[li[i][1]] = [li[i][0]]
    else: hash[li[i][1]].append(li[i][0])
#print(hash)

# def rec(x,cnt):
#     for y in hash[x]:
#         if seen[y] == -1:
#             seen[y] = cnt
#             rec(y,0 if cnt else 1)
#     return

# rec(1,1)

#print(seen)
cd = []
for i in range(q):
    cd.append(list(map(int, input().split())))

seen = [-1] * (n + 1)

d = [[1, 1]]
while d:
    x = d.pop()
    seen[x[0]] = x[1]
    for y in hash[x[0]]:
        if seen[y] == -1:
            d.append([y, 0 if x[1] else 1])

for c, d in cd:
    print("Town" if seen[c] == seen[d] else "Road")
from collections import deque

N, Q = map(int, input().split())
g = [[] for _ in range(N + 1)]
ans = [[0]] * (N + 1)
for _ in range(N - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)


def bfs(u):
    queue = deque([u])
    d = [None] * (N + 1)
    d[u] = 0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


dist = bfs(1)
for i in range(Q):
    c, d = map(int, input().split())
    ans = abs(dist[c] - dist[d])
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
# -*- coding: utf-8 -*-
'''
文字列取得用関数(str,int併用)
'''


def inputter(is_str=False, split=False):
    import sys
    readline = sys.stdin.readline

    if is_str:
        if split:
            return map(str, readline().rstrip().split())
        else:
            return readline().rstrip()
    else:
        if split:
            return map(int, readline().rstrip().split())
        else:
            return int(readline().rstrip())


'''
二重リストを返す関数
'''


def double_list(input_data):
    return list(list(input_data))


# G[v]: 頂点vに隣接する頂点list
# N: 頂点数
# 引用：https://tjkendev.github.io/procon-library/python/graph/bfs.html
def bfs(N, G, s):
    from collections import deque
    dist = [-1] * N
    que = deque()
    que.append(s)
    dist[s] = 0
    while que:
        v = que.popleft()
        d = dist[v]
        for w in G[v]:
            if dist[w] > -1:
                continue
            dist[w] = d + 1
            que.append(w)
    return dist


# main関数
def main():
    n, q = inputter(0, 1)
    G = [[] for _ in range(n + 1)]
    for i in range(n - 1):
        a, b = inputter(0, 1)
        G[a].append(b)
        G[b].append(a)
    dist = bfs((n + 1), G, 1)
    for i in range(q):
        c, d = inputter(0, 1)
        ans = abs(dist[c] - dist[d])
        if ans % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
def inp(to_int=True):
    if not type(to_int) == bool:
        raise Exception()
    l = input().split()
    return list(map(lambda x: int(x), l)) if to_int else l


def inps(n, to_int=True):
    if not type(n) == int:
        raise Exception()
    return [inp(to_int) for _ in [0] * n]


def main():
    from collections import deque

    n, q = inp()
    to = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = inp()
        a -= 1
        b -= 1
        to[a].append(b)
        to[b].append(a)

    cdl = []
    for _ in range(q):
        c, d = inp()
        c -= 1
        d -= 1
        cdl.append([c, d])

    dist = [-1] * n
    dist[0] = 0

    dq = deque()
    dq.append(0)

    while dq:
        v = dq.popleft()
        for j in to[v]:
            if dist[j] != -1:
                continue

            dist[j] = dist[v] + 1
            dq.append(j)

    for i in range(q):
        c, d = cdl[i]
        if (dist[c] + dist[d]) % 2 == 1:
            print('Road')
        else:
            print('Town')


if __name__ == '__main__':
    main()
from collections import deque

n, q = map(int, input().split())
graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

seen = [False] * n
cnt = [0] * n
que = deque([0])
pre = 0

while que:
    v = que.popleft()
    seen[v] = True
    for u in graph[v]:
        if seen[u] == True: continue
        que.append(u)
        cnt[u] = cnt[v] ^ 1

for _ in range(q):
    c, d = map(int, input().split())
    if cnt[c - 1] != cnt[d - 1]:
        print("Road")
    else:
        print("Town")
#N 個の街と N−1 本の道路なのでループはない。木構造
#根への距離をそれぞれ求めて、和が2で割り切れるかで判断できそう

from collections import defaultdict
from collections import deque

N, Q = map(int, input().split())

connect_nodes = defaultdict(set)

for i in range(N - 1):
    a, b = map(int, input().split())
    connect_nodes[a].add(b)
    connect_nodes[b].add(a)

dist = [-1 for _ in range(N + 1)]  #1からの距離。到達不可なら-1
is_visited = [False for _ in range(N + 1)]  #訪問フラグ

#function 幅優先探索(v)
search_deque = deque()  #Q ← 空のキュー
is_visited[1] = True  #v に訪問済みの印を付ける
search_deque.append(1)  #v を Q に追加
dist[1] = 0

while len(search_deque) != 0:  #while Q が空ではない do
    node = search_deque.popleft()  #    v ← Q から取り出す
    #    v を処理する
    for connect_node in connect_nodes[node]:  #    for each v に接続している頂点 i do
        if is_visited[connect_node] == False:  #        if i が未訪問 then
            is_visited[connect_node] = True  #            iに訪問済みの印を付ける
            search_deque.append(connect_node)  #            i を Q に追加
            dist[connect_node] = dist[
                node] + 1  #(左記は距離が全点間1固定の時。異なる場合は読み込み部分と共に変更すること)

for i in range(Q):
    c, d = map(int, input().split())

    if (dist[c] + dist[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
import networkx as nx

N, Q, *l = map(int, open(0).read().split())
A = l[0:2 * (N - 1):2]
B = l[1:2 * (N - 1):2]
C = l[2 * (N - 1)::2]
D = l[2 * (N - 1) + 1::2]

G = nx.Graph()
G.add_nodes_from(range(1, N + 1))

edges = [(A[i], B[i]) for i in range(len(A))]
G.add_edges_from(edges)  # 一括で追加

length = nx.single_source_shortest_path_length(G, 1)
ans = [0] * Q
for i in range(Q):

    c = C[i]
    d = D[i]
    if (length[c] - length[d]) % 2 == 0:
        ans[i] = "Town"
    else:
        ans[i] = "Road"

print(*ans, sep='\n')
import sys, collections

sys.setrecursionlimit(10**6)
stdin = sys.stdin

ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().strip()
nsa = lambda: list(map(str, stdin.readline().split()))
ntp = lambda: tuple(map(int, stdin.readline().split()))
mod = 10**9 + 7
inf = 10**18

n, q = na()
to = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = na()
    a, b = a - 1, b - 1
    to[a].append(b)
    to[b].append(a)


#! LCAと距離
def EulerTour(to, root=0):
    n = len(to)
    depth = [-1] * n
    depth[root] = 0
    first_visit_index = [-1] * n
    res = []
    stack = collections.deque()
    stack.append((root, 0))
    while stack:
        u, i = stack.pop()
        if i == 0: first_visit_index[u] = len(res)
        res.append(u)
        if i < len(to[u]):
            v = to[u][i]
            stack.append((u, i + 1))
            if depth[v] == -1:
                depth[v] = depth[u] + 1
                stack.append((v, 0))
            else:
                res.pop()
    return res, first_visit_index, depth


class SparseTableMin:
    def __init__(self, aa):
        w = len(aa)
        h = w.bit_length()
        table = [aa] + [[-1] * w for _ in range(h - 1)]
        tablei1 = table[0]
        for i in range(1, h):
            tablei = table[i]
            for j in range(w - (1 << i) + 1):
                rj = j + (1 << (i - 1))
                tablei[j] = min(tablei1[j], tablei1[rj])
            tablei1 = tablei
        self.table = table

    # [l,r)の最小値
    def min(self, l, r):
        i = (r - l).bit_length() - 1
        tablei = self.table[i]
        Lmin = tablei[l]
        Rmin = tablei[r - (1 << i)]
        if Lmin < Rmin: Rmin = Lmin
        return Rmin


et, fi, dep = EulerTour(to)
sp = SparseTableMin([dep[u] for u in et])

for _ in range(q):
    c, d = na()
    c, d = c - 1, d - 1
    A = dep[c] + dep[d] - 2 * dep[sp.min(c, d)]
    if A % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
A = [[] for i in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    A[a].append(b)
    A[b].append(a)

D = [0] * (n + 1)
found = deque()
found.append(1)
vit = [0] * (n + 1)
while (found):
    c = found.popleft()
    if vit[c] == 1:
        continue
    vit[c] = 1
    for x in A[c]:
        if vit[x] == 0:
            found.append(x)
            D[x] = 1 - D[c]

for i in range(q):
    a, b = map(int, input().split())
    if D[a] == D[b]:
        print("Town")
    else:
        print("Road")
import queue

n, q = map(int, input().split())
roads = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    roads[a - 1].append(b)
    roads[b - 1].append(a)

towncolors = [-1] * n
towncolors[0] = 0
que = queue.Queue()
que.put(1)
while not que.empty():
    t = que.get()
    for s in roads[t - 1]:
        if towncolors[s - 1] == -1:
            towncolors[s - 1] = (towncolors[t - 1] + 1) % 2
            que.put(s)

for i in range(q):
    c, d = map(int, input().split())
    if towncolors[c - 1] == towncolors[d - 1]:
        print("Town")
    else:
        print("Road")
import collections

N, Q = map(int, input().split())
edges = collections.defaultdict(list)
for _ in range(N - 1):
    a, b = map(int, input().split())
    edges[a - 1].append(b - 1)
    edges[b - 1].append(a - 1)
targets = [0]
group = [0] * N
group[0] = 1
while targets:
    t = targets.pop()
    for u in edges[t]:
        if group[u] != 0: continue
        group[u] = -group[t]
        targets.append(u)
for _ in range(Q):
    c, d = map(int, input().split())
    if group[c - 1] * group[d - 1] == 1:
        print("Town")
    else:
        print("Road")
import queue

N, Q = [int(x) for x in input().split()]

graph = [[] for i in range(N)]
for i in range(N - 1):
    a, b = [int(x) for x in input().split()]
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

queries = []
for i in range(Q):
    c, d = [int(x) for x in input().split()]
    queries.append([c - 1, d - 1])

que = queue.Queue()
que.put(0)
labels = [0 for x in range(N)]  # 0: ラベルなし, 1: even, -1: odd
labels[0] = 1

while not que.empty():
    current_node = que.get()
    current_label = labels[current_node]

    for next_node in graph[current_node]:
        if labels[next_node] == 0:
            que.put(next_node)
            labels[next_node] = -current_label

for query in queries:
    if labels[query[0]] * labels[query[1]] > 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

from collections import deque


def bfs(p):
    res = []
    used = [False] * (n)
    dq = deque([[p, 0]])
    while dq:
        v, i = dq.popleft()
        if used[v]: continue
        used[v] = True
        res.append([v, i])
        for u in G[v]:
            dq.append([u, i + 1])
    return res


P = bfs(0)
P.sort()

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (P[c][1] + P[d][1]) % 2: print('Road')
    else: print('Town')
from collections import deque

n, q = map(int, input().split())
ab = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    ab[a - 1].append(b - 1)
    ab[b - 1].append(a - 1)
cd = [list(map(int, input().split())) for i in range(q)]

s = set()
qu = deque()
s.add(0)
qu.append(0)
hugo = [0] * n
while qu:
    here = qu.popleft()
    for i in ab[here]:
        if i not in s:
            s.add(i)
            qu.append(i)
            hugo[i] = (hugo[here] + 1) % 2

for i in cd:
    if hugo[i[0] - 1] == hugo[i[1] - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
# print(graph)
dist = [-1] * N
que = deque()

dist[0] = 0
que.append(0)
# print(dist)

while (len(que) != 0):
    v = que.popleft()
    for i in graph[v]:
        # print(i)
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        que.append(i)
# print(dist)
for _ in range(Q):
    c, d = map(int, input().split())
    length = abs(dist[c - 1] - dist[d - 1])
    if length % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())

graph = [[] for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

dist = [-1] * (N)
dist[0] = 0
que = deque()
que.append(0)
while que:
    v = que.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        que.append(i)
for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if (dist[c] + dist[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
#!/usr/bin/env python3
from collections import deque
import sys

# def dfs(start):
#     reach = deque([0])
#     distance = [-1 for _ in range(N)]
#     distance[start] = 0
#     while reach:
#         _from = reach.pop(0)
#         for _to in G[_from]:
#             if not(_to in reach) and distance[_to] == -1:
#                 reach.append(_to)
#                 distance[_to] = distance[_from]+1
#     return(distance)


def main():

    input = sys.stdin.readline
    N, Q = map(int, input().split())
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        x, y = map(int, input().split())
        x, y = x - 1, y - 1
        G[x].append(y)
        G[y].append(x)

    reach = deque([0])
    distance = [-1 for _ in range(N)]
    distance[0] = 0
    while reach:
        _from = reach.pop()
        for _to in G[_from]:
            if not (_to in reach) and distance[_to] == -1:
                reach.append(_to)
                distance[_to] = distance[_from] + 1

    for i in range(Q):
        c, d = map(int, input().split())
        if (distance[c - 1] - distance[d - 1]) % 2:
            print('Road')
        else:
            print('Town')


if __name__ == '__main__':
    main()
R = lambda: map(int,
                input().split())
n, q = R()
g = [None] + [[] for _ in range(n)]
C = [None] * (n + 1)
C[1] = 0
s = [1]
for _ in range(n - 1):
    a, b = R()
    g[b].append(a)
    g[a].append(b)
while s:
    u = s.pop()
    for v in g[u]:
        if C[v] is None:
            s.append(v)
            C[v] = C[u] ^ 1
for _ in range(q):
    c, d = R()
    print('TRoowand'[C[c] ^ C[d]::2])
import sys
import queue

from operator import itemgetter

sys.setrecursionlimit(1000000)


def input():
    return sys.stdin.readline().rstrip()


N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]

path = [[] for _ in range(N + 1)]
for a, b in ab:
    path[a].append(b)
    path[b].append(a)

# dit[i] は 1からiまでの距離
dist = [None] * (N + 1)
dist[1] = 0

q = queue.Queue()
q.put(1)
while not q.empty():
    root = q.get()
    for chil in path[root]:
        if dist[chil] is None:
            dist[chil] = dist[root] + 1
            q.put(chil)

for i in range(Q):
    c, d = list(map(int, input().split()))
    print(["Town", "Road"][(dist[c] + dist[d]) % 2])
R = lambda: map(int,
                input().split())
n, q = R()
g = [None] + [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = R()
    g[b].append(a)
    g[a].append(b)
C = [None] * (n + 1)
C[1] = 0
s = [1]
while s:
    u = s.pop()
    for v in g[u]:
        if C[v] is None:
            s.append(v)
            C[v] = C[u] ^ 1
for _ in range(q):
    c, d = R()
    print('TRoowand'[C[c] ^ C[d]::2])
from collections import deque

n, Q = map(int, input().split())
e = [[] for i in range(n)]
for _ in range(n - 1):
    a, b = [int(x) - 1 for x in input().split()]
    e[a].append(b)
    e[b].append(a)

dis = [-1] * n
dis[0] = 0
q = deque([0])
while q:
    now = q.popleft()
    for nex in e[now]:
        if dis[nex] == -1:
            dis[nex] = dis[now] ^ 1
            q.append(nex)
for _ in range(Q):
    c, d = [int(x) - 1 for x in input().split()]
    if dis[c] == dis[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())

G = {i + 1: [] for i in range(n)}
for _ in range(n - 1):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)

# Make node 1 the root
depth = {}
depth[1] = 0
to_visit = deque([1])
while to_visit:
    node = to_visit.popleft()
    for neighbour in G[node]:
        if neighbour not in depth:
            depth[neighbour] = depth[node] + 1
            to_visit.append(neighbour)

for _ in range(q):
    c, d = map(int, input().split())
    dist = abs(depth[c] - depth[d])
    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python
import sys

sys.setrecursionlimit(10**9)

n, q = map(int, input().split())
c = [0 for _ in range(q)]
d = [0 for _ in range(q)]
to = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    to[a].append(b)
    to[b].append(a)

for i in range(q):
    c[i], d[i] = map(int, input().split())
    c[i] -= 1
    d[i] -= 1

depth = [0 for _ in range(n)]


def dfs(v, d, p=-1):
    depth[v] = d
    for u in to[v]:
        if u != p:
            dfs(u, d + 1, v)


dfs(0, 0)

for i in range(q):
    if abs(depth[c[i]] - depth[d[i]]) % 2 == 1:
        print('Road')
    else:
        print('Town')
import sys

sys.setrecursionlimit(10**6)
stdin = sys.stdin

ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().strip()
nsa = lambda: list(map(str, stdin.readline().split()))
ntp = lambda: tuple(map(int, stdin.readline().split()))
mod = 10**9 + 7
inf = 10**18

n, q = na()
G = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    a, b = na()
    G[a].append(b)
    G[b].append(a)

import collections

que = collections.deque()
que.append(1)
color = [-1] * (n + 1)
color[1] = 0
d = {0: 1, 1: 0}
while que:
    u = que.pop()
    for v in G[u]:
        if color[v] == -1:
            color[v] = d[color[u]]
            que.append(v)

for _ in range(q):
    c, d = na()
    if color[c] == color[d]:
        print('Town')
    else:
        print('Road')
import sys, os

sys.setrecursionlimit(1000000)


def debug(*args, **kwargs):
    if os.getenv('DEBUG'):
        print(*args, **kwargs, file=sys.stderr)


def input():
    return sys.stdin.readline()[:-1]


def int0(s: str) -> int:
    return int(s) - 1


def main(_=0):
    N, Q = map(int, input().split())
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int0, input().split())
        G[a].append(b)
        G[b].append(a)

    INF = 1001001001
    dist = [INF] * N
    dist[0] = 0
    P = [-1] * N

    def dfs(v, p, d):
        P[v] = d
        dist[v] = d
        for u in G[v]:
            if u == p: continue
            dfs(u, v, 1 + d)

    dfs(0, -1, 0)

    # doubling
    k = len(bin(max(dist))[2:])
    dbl = [[-1] * N for _ in range(k + 1)]
    for i in range(N):
        dbl[0][i] = P[i]
    for i in range(k):
        for j in range(N):
            if dbl[i][j] == -1: continue
            dbl[i + 1][j] = dbl[i][dbl[i][j]]

    ## (1) u, v の深さが同じになるまでお互い登っていく
    ## (2) 頂点が同じになる直前まで登っていく
    def lca(u, v):
        ## u のほうを深くする
        if dist[u] <= dist[v]:
            u, v = v, u
        if dist[u] != dist[v]:
            ## 深さの差
            d = dist[u] - dist[v]
            for i in range(k):
                if (d >> i) & 1:
                    u = dbl[i][u]
        if u == v: return u
        for i in range(k, -1, -1):
            if dbl[i][u] != dbl[i][v]:
                u, v = dbl[i][u], dbl[i][v]
        return dbl[0][u]

    # LCA がわかれば一瞬
    for _ in range(Q):
        c, d = map(int0, input().split())
        p = lca(c, d)
        D = 1 + dist[c] + dist[d] - (2 * dist[p])

        if D % 2 == 0:
            print("Road")
        else:
            print("Town")


def as_input(s: str) -> None:
    import io
    global input
    f = io.StringIO(s)
    input = lambda: f.readline().rstrip()
    return None


sample1 = """4 1
1 2
2 3
2 4
1 2
"""
sample2 = """5 2
1 2
2 3
3 4
4 5
1 3
1 5
"""
sample3 = """9 9
2 3
5 6
4 8
8 9
4 5
3 4
1 9
3 7
7 9
2 5
2 6
4 6
2 4
5 8
7 8
3 6
5 6
"""


def test():
    """
    >>> main(as_input(sample1))
    Road
    >>> main(as_input(sample2))
    Town
    Town
    >>> main(as_input(sample3))
    Town
    Road
    Town
    Town
    Town
    Town
    Road
    Road
    Road
    """
    pass


if __name__ == '__main__':
    main()
import sys

input = sys.stdin.readline
from array import array
from collections import deque


def shortest_path_bfs(es: "隣接リスト", start: "始点"):
    INF = 1_000_000_000
    V = len(es)
    d = [INF] * V  # 頂点startからの最短距離
    que = deque()
    que.append(start)
    d[start] = 0
    while que:
        v = que.popleft()
        for e in es[v]:
            if d[e] == INF:
                d[e] = d[v] + 1
                que.append(e)

    return d


n, q = map(int, input().split())
es = [array("i") for _ in range(n)]
for i in range(n - 1):
    start, end = map(int, input().split())
    start -= 1
    end -= 1
    es[start].append(end)
    es[end].append(start)

dist = shortest_path_bfs(es, 0)

res = [""] * q
for i in range(q):
    c, d = map(int, input().split())
    k = dist[c - 1] - dist[d - 1]
    res[i] = "Road" if k % 2 else "Town"

print(*res, sep="\n")
n, q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]
r = [[] for _ in range(n)]
for i, j in ab:
    r[i - 1].append(j - 1)
    r[j - 1].append(i - 1)
a = [0] * n
b = [(0, 0)]
c = [False] * n
c[0] = True
while b:
    i, j = b.pop()
    j += 1
    for k in r[i]:
        if c[k]:
            continue
        a[k] = j
        b.append((k, j))
        c[k] = True
for i, j in cd:
    if a[i - 1] % 2 == a[j - 1] % 2:
        print("Town")
    else:
        print("Road")
def main():
    import queue
    n, q = (int(x) for x in input().split())
    g = [[] for _ in range(n)]
    for i in range(n - 1):
        a, b = (int(x) - 1 for x in input().split())
        g[a].append(b)
        g[b].append(a)
    que = queue.Queue()
    color = [-1] * n
    color[0] = 0
    que.put(0)
    while not que.empty():
        t = que.get()
        for i in g[t]:
            if color[i] == -1:
                color[i] = 1 - color[t]
                que.put(i)
    for i in range(q):
        c, d = (int(x) - 1 for x in input().split())
        print("Town" if color[c] == color[d] else "Road")


if __name__ == '__main__':
    main()
from collections import deque


def bfs(G):
    queue = deque([0])
    P = [-1] * len(G)
    P[0] = 0
    while queue:
        node = queue.popleft()
        for n in G[node]:
            if P[n] != -1:
                continue
            P[n] = (P[node] + 1) % 2
            queue.append(n)
    return P


n, q = list(map(int, input().split()))
G = [set() for _ in range(n)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    G[u - 1].add(v - 1)
    G[v - 1].add(u - 1)
P = bfs(G)

for _ in range(q):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    if (P[u] + P[v]) % 2 == 1:
        print('Road')
    else:
        print('Town')
n, q = [0] * 2
a = []
b = []
c = []
d = []


def format_input(filename=None):
    global n, q
    global a, b, c, d
    if filename == None:
        n, q = list(map(int, input().split()))
        ab = [list(map(int, input().split())) for i in range(n - 1)]
        for i in ab:
            a.append(i[0])
            b.append(i[1])
        cd = [list(map(int, input().split())) for i in range(q)]
        for i in cd:
            c.append(i[0])
            d.append(i[1])

    elif filename == '__random__':
        from random import randint as rng
        n = rng(2, 10**5)
        q = rng(1, 10**5)
        a = [rng(1, n - 1) for i in range(n - 1)]
        b = [rng(a[i], n) for i in range(n - 1)]
        c = [rng(1, n - 1) for i in range(q)]
        d = [rng(c[i], n) for i in range(q)]
        print(n, q)
        [print(a[i], b[i]) for i in range(n - 1)]
        [print(c[i], d[i]) for i in range(q)]


def get_answer():
    answer = []

    road = [[] for i in range(n + 1)]
    for i in range(n - 1):
        road[a[i]].append(b[i])
        road[b[i]].append(a[i])

    depth = [0] * (n + 1)

    stack = []
    for i in road[1]:
        stack.append((i, 1))
    visited = {1}

    while len(stack) > 0:
        next = stack.pop()
        if next[0] in visited:
            continue

        depth[next[0]] = next[1]
        visited.add(next[0])

        for i in road[next[0]]:
            stack.append((i, next[1] + 1))

    for i in range(q):
        if depth[c[i]] % 2 == depth[d[i]] % 2:
            answer.append('Town')
        else:
            answer.append('Road')

    return answer


if __name__ == '__main__':
    format_input()

    ans = get_answer()
    [print(i) for i in ans]
from sys import stdin
import queue

N, Q = map(int, stdin.readline().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, stdin.readline().rstrip().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, stdin.readline().rstrip().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
from queue import Queue

N, Q = map(int, input().split())
rt = [[] for _ in range(N)]
for _ in range(N - 1):
    A, B = map(int, input().split())
    rt[A - 1].append(B - 1)
    rt[B - 1].append(A - 1)
q = Queue()
q.put(0)
d = {0: True}
while not q.empty():
    t = q.get()
    for i in rt[t]:
        if i not in d:
            d[i] = not d[t]
            q.put(i)
for _ in range(Q):
    C, D = map(int, input().split())
    print('Town' if d[C - 1] == d[D - 1] else 'Road')
N, Q = map(int, input().split())
AB = [tuple(map(int, input().split())) for i in range(N - 1)]
CD = [tuple(map(int, input().split())) for i in range(Q)]

from heapq import heappush, heappop

INF = 10**9


def dijkstra(s, n):  # (始点, ノード数, k)
    dist = [INF] * n
    hq = [(0, s)]  # (distance, node)
    dist[s] = 0
    seen = [False] * n  # ノードが確定済みかどうか
    while hq:
        v = heappop(hq)[1]  # ノードを pop する
        seen[v] = True
        for to, cost in adj[v]:  # ノード v に隣接しているノードに対して
            if seen[to] == False and dist[v] + cost < dist[to]:
                dist[to] = dist[v] + cost
                heappush(hq, (dist[to], to))
    return dist


# adj[s]: ノード s に隣接する(ノード, 重み)をリストで持つ
adj = [[] for _ in range(N)]
for A, B in AB:
    adj[A - 1].append((B - 1, 1))
    adj[B - 1].append((A - 1, 1))
result = dijkstra(0, N)

for c, d in CD:
    dist_c = result[c - 1]
    dist_d = result[d - 1]
    ans = dist_c - dist_d
    print("Town" if ans % 2 == 0 else "Road")
from collections import deque

N, Q = map(int, input().split())
l = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    l[a].append(b)
    l[b].append(a)

que = deque([(0, 0)])
visited = [10**18] * N
visited[0] = 0
while que:
    q, c = que.popleft()
    for i in l[q]:
        if visited[i] > c + 1:
            visited[i] = c + 1
            que.append((i, c + 1))

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    ans = 'Town'
    num = visited[c] + visited[d]
    if num % 2 != 0:
        ans = 'Road'
    print(ans)
from sys import setrecursionlimit

setrecursionlimit(10**6)

N, Q, *I = map(int, open(0).read().split())
AB, CD = I[:2 * (N - 1)], I[2 * (N - 1):]

E = [[] for _ in range(N + 1)]
for a, b in zip(*[iter(AB)] * 2):
    E[a].append(b)
    E[b].append(a)

dist = [0] * (N + 1)


def dfs(cur, par):
    d = dist[cur]
    for nxt in E[cur]:
        if nxt != par:
            dist[nxt] = 1 + d
            dfs(nxt, cur)


dfs(1, 0)

for c, d in zip(*[iter(CD)] * 2):
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**7)


def main():
    n, q = map(int, input().split())
    g = [[] for i in range(n)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)
    dist = [-1] * n
    seen = [False] * n
    dist[0] = False

    def dfs(x, last=-1):
        for to in g[x]:
            if to == last:
                continue
            dist[to] = not (dist[x])
            dfs(to, x)

    dfs(0)
    for i in range(q):
        c, d = map(int, input().split())
        c, d = c - 1, d - 1
        if dist[c] != dist[d]:
            print('Road')
        else:
            print('Town')


main()
import sys


def input():
    return sys.stdin.readline().rstrip()


from collections import deque

n, q = map(int, input().split())  # 頂点数と辺数

# グラフ入力受け取り (ここでは無向グラフを想定)
graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * n  # 全頂点を -1 (未訪問) に初期化
pos = deque()  # キュー

# 初期条件 (頂点 0 を始点とする)
dist[0] = 0
pos.append(0)

# 幅優先探索 (キューが空になるまで探索を行う)
while len(pos) > 0:
    v = pos.popleft()  # キューから先頭の頂点を取り出す
    for nv in graph[v]:
        # 既に訪問済みの頂点は探索しない
        if dist[nv] != -1:
            continue
        # 新たな頂点 nv について距離情報を更新してキューに追加する
        dist[nv] = dist[v] + 1
        pos.append(nv)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

from collections import deque

P = [0] * n
dq = deque([0])
while dq:
    v = dq.popleft()
    for u in G[v]:
        if u == 0 or P[u] > 0: continue
        P[u] = P[v] + 1
        dq.append(u)

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (P[c] + P[d]) % 2: print('Road')
    else: print('Town')
import queue

n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)
que = queue.Queue()
cd = [list(map(int, input().split())) for _ in range(q)]

colour = [0] + [-1] * (n - 1)
que.put(0)

while not que.empty():
    t = que.get()
    for i in g[t]:
        if colour[i] == -1:
            colour[i] = 1 - colour[t]
            que.put(i)
for i in range(q):
    if colour[cd[i][0] - 1] == colour[cd[i][1] - 1]:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())

# 各町を頂点として、リストで接続先の頂点を表現するグラフ
table = [[] for i in range(N + 10)]
# 各頂点の色
# 0, 1: 色付き -1:色なし
colors = [-1 for i in range(N + 10)]

# 町番号をインデックスとした接続先の町をリストで格納するテーブルを作成
for i in range(N - 1):
    a, b = map(int, input().split())
    table[a - 1].append(b - 1)
    table[b - 1].append(a - 1)


# bfsで全経路を探索し、2部グラフの各頂点に色をつける
def bfs():
    start = 0
    q = deque()
    q.append(start)
    colors[start] = 1

    while q:
        x = q.popleft()
        for i in table[x]:
            if colors[i] == -1:
                colors[i] = 1 - colors[x]
                q.append(i)


bfs()
#print("colors={}".format(colors))

# クエリを処理する
for i in range(Q):
    c, d = map(int, input().split())
    #print("i={} c={} d={}".format(i,c,d))
    if colors[c - 1] == colors[d - 1]:
        print("Town")
    else:
        print("Road")
import sys
import math
import itertools
from collections import defaultdict, deque, Counter
from copy import deepcopy
from bisect import bisect, bisect_right, bisect_left
from heapq import heapify, heappop, heappush
from operator import itemgetter, attrgetter

sys.setrecursionlimit(10**6)

input = sys.stdin.readline


def RD():
    return input().rstrip()


def F():
    return float(input().rstrip())


def I():
    return int(input().rstrip())


def MI():
    return map(int, input().split())


def MF():
    return map(float, input().split())


def LI():
    return list(map(int, input().split()))


def TI():
    return tuple(map(int, input().split()))


def LF():
    return list(map(float, input().split()))


def Init(H, W, num):
    return [[num for i in range(W)] for j in range(H)]


def TL(mylist):
    return [list(x) for x in zip(*mylist)]  #行と列入れ替え


def RtoL(mylist):
    return [list(reversed(x)) for x in mylist]  #左右反転


def HtoL(mylist):
    return [x for x in list(reversed(mylist))]  #上下反転


def convert_2d(l, colstart, colend, rawstart, rawend):
    return [i[rawstart:rawend] for i in l[colstart:colend]]  #2次元行列から一部を採取


def get_unique_list(seq):
    seen = []
    return [x for x in seq if x not in seen and not seen.append(x)]


def main():
    N, Q = MI()
    G = [[] for i in range(N)]
    max_n = 1000000
    prv = []
    for i in range(N - 1):
        a, b = MI()
        a -= 1
        b -= 1
        G[a].append(b)
        G[b].append(a)

    dist = [-1 for i in range(N)]

    dq = deque()
    dq.append(0)
    dist[0] = 0
    while dq:
        v = dq.pop()
        for nv in G[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                dq.append(nv)

    for i in range(Q):
        c, d = MI()
        c -= 1
        d -= 1
        if c > d:
            swap(c, d)
        if (dist[c] + dist[d]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
from collections import deque, Counter
from collections import defaultdict as dfd
from bisect import bisect, bisect_left
from math import sqrt, gcd, ceil, factorial
from heapq import heapify, heappush, heappop

MOD = 10**9 + 7
inf = float("inf")
ans_ = []


def nin():
    return int(input())


def ninf():
    return int(file.readline())


def st():
    return (input().strip())


def stf():
    return (file.readline().strip())


def read():
    return list(map(int, input().strip().split()))


def readf():
    return list(map(int, file.readline().strip().split()))


def readfl():
    return list(map(float, input().strip().split()))


def readffl():
    return list(map(float, file.readline().strip().split()))


# file = open("input.txt", "r")
def solve():
    #     for _ in range(nin()):
    n, q = read()
    adj = [[] for i in range(n + 1)]
    for i in range(n - 1):
        u, v = read()
        adj[u].append(v)
        adj[v].append(u)

    stk = [[1, 1]]
    vis = [-1] * (n + 1)
    vis[1] = 1
    while stk:
        curr, par = stk.pop()
        for i in adj[curr]:
            if vis[i] == -1:
                stk.append([i, 1 ^ par])
                vis[i] = 1 ^ par

    for i in range(q):
        c, d = read()
        if vis[c] == vis[d]:
            ans_.append("Town")
        else:
            ans_.append("Road")


solve()

for i in ans_:
    print(i)
def func(x):
    for i in range(N - 1):
        if a[i] < x:
            continue
        elif a[i] == x:
            D[b[i]] = 1 - D[a[i]]
        elif a[i] > x:
            return


N, Q = map(int, input().split())
tmp = [list(map(int, input().split())) for _ in range(N - 1)]
a = [i[0] for i in tmp]
b = [i[1] for i in tmp]
tmp = [list(map(int, input().split())) for _ in range(Q)]
c = [i[0] for i in tmp]
d = [i[1] for i in tmp]
l = []
for i in range(N):
    l.append([])
for i in range(N - 1):
    l[a[i] - 1].append(b[i] - 1)
    l[b[i] - 1].append(a[i] - 1)
D = {}
D[0] = 0
q = [0]
while q != []:
    u = q.pop()
    for i in l[u]:
        if i not in D:
            D[i] = D[u] + 1
            q.append(i)
for i in range(Q):
    if (D[c[i] - 1] + D[d[i] - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())

connect = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    connect[a].append(b)
    connect[b].append(a)

stack = [1]
state = [-1 for _ in range(N + 1)]
state[1] = 0
red = [[], []]
color = [-1 for _ in range(N + 1)]
while stack:
    s = stack.pop()
    if state[s] == 0:
        color[s] = 0
    if state[s] == 1:
        color[s] = 1
    for i in connect[s]:
        if state[i] != -1:
            continue
        state[i] = 1 - state[s]
        stack.append(i)
    state[s] = 2

for i in range(Q):
    c, d = map(int, input().split())

    if color[c] == color[d]:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(10**8)


def dfs(now, d):
    for i in g[now]:
        if i not in done:
            done.add(i)
            ds[i] = d + 1
            dfs(i, d + 1)


n, q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

g = [[] for _ in range(n + 1)]
for a, b in ab:
    g[a].append(b)
    g[b].append(a)

ds = [None] * (n + 1)
ds[1] = 0
done = set([1])
dfs(1, 0)

for c, d in cd:
    if (ds[c] + ds[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())  # 頂点数と辺数

# グラフ入力受け取り (ここでは無向グラフを想定)
graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * n  # 全頂点を -1 (未訪問) に初期化
pos = deque()  # キュー

# 初期条件 (頂点 0 を始点とする)
dist[0] = 0
pos.append(0)

# 幅優先探索 (キューが空になるまで探索を行う)
while len(pos) > 0:
    v = pos.popleft()  # キューから先頭の頂点を取り出す
    for nv in graph[v]:
        # 既に訪問済みの頂点は探索しない
        if dist[nv] != -1:
            continue
        # 新たな頂点 nv について距離情報を更新してキューに追加する
        dist[nv] = dist[v] + 1
        pos.append(nv)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    d = dist[c] + dist[d]
    if d % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
graph = [[] for _ in range(N + 1)]

for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
dist = [-1] * (N + 1)

dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

ans = dist[1:]
for j in range(Q):
    c, d = map(int, input().split())
    if abs(ans[c - 1] - ans[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys
from collections import defaultdict

input = lambda: sys.stdin.readline().rstrip()
sys.setrecursionlimit(2000000000)

n, q = map(int, input().split(" "))

graph = defaultdict(lambda: [])
for i in range(n - 1):
    a, b = map(int, input().split(" "))
    graph[a].append(b)
    graph[b].append(a)

costs = [None for i in range(n + 1)]


def f(jibun, oya, jibun_key):
    kids = graph[jibun]
    costs[jibun] = jibun_key

    #kid_id = 0
    #kid_key = jibun_key + 1
    kid_key = not jibun_key
    for kid in kids:
        if kid == oya:
            continue
        f(kid, jibun, kid_key)


def calc_dist(key1, key2):
    len1 = key1
    len2 = key2
    ret = (len1 - len2) % 2
    return ret


#f(1, None, (0,))
#f(1, None, 0)
f(1, None, False)
#print(costs)

for i in range(q):
    c, d = map(int, input().split(" "))
    key_c = costs[c]
    key_d = costs[d]
    dist = calc_dist(key_c, key_d)
    if dist == 0:
        out = "Town"
    else:
        out = "Road"
    print(out)
n, q = map(int, input().split())
g = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    a, b = [int(x) for x in input().split()]
    g[a].append(b)
    g[b].append(a)

from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * (n + 1)  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


dd = bfs(1)
for j in range(q):
    c, d = map(int, input().split())

    if dd[c] % 2 == dd[d] % 2:
        print("Town")
    else:
        print("Road")
from collections import deque

n, Q = map(int, input().split())
dist = [-1] * n
dist[0] = 0
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

q = deque([0])
while q:
    v = q.popleft()
    for i in g[v]:
        if dist[i] != -1: continue
        dist[i] = dist[v] + 1
        q.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    if abs(dist[c - 1] - dist[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import logging
import sys
from inspect import currentframe

sys.setrecursionlimit(10**6)
input = sys.stdin.readline

logging.basicConfig(level=logging.DEBUG)


def dbg(*args):
    id2names = {id(v): k for k, v in currentframe().f_back.f_locals.items()}
    logging.debug(", ".join(
        id2names.get(id(arg), "???") + " = " + repr(arg) for arg in args))


n, q = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)
d = [-1] * n
d[0] = 0


def dfs(v, p=-1):
    for nv in g[v]:
        if nv == p:
            continue
        d[nv] = d[v] + 1
        dfs(nv, v)


dfs(0)
# print(d)
maxi = -1
maxd = -1
for i in range(n):
    if d[i] > maxd:
        maxd = d[i]
        maxi = i
# print(maxi, maxd)
d2 = [-1] * n
d2[maxi] = 0


def dfs2(v, p=-1):
    for nv in g[v]:
        if nv == p:
            continue
        d2[nv] = d2[v] + 1
        dfs2(nv, v)


dfs2(maxi)
# print(d2)
for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    dist = abs(d2[c] - d2[d])
    if dist & 1:
        print("Road")
    else:
        print("Town")
from collections import deque

LI = lambda: list(map(int, input().split()))
LS = lambda: list(map(str, input().split()))
MI = lambda: map(int, input().split())
MS = lambda: map(str, input().split())

N, Q = MI()
Graph = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = MI()
    Graph[a].append(b)
    Graph[b].append(a)

color = [-1] * (N + 1)
color[1] = 0
que = deque()
que.append(1)
while que:
    v = que.popleft()
    for u in Graph[v]:
        if color[u] != -1:
            continue
        color[u] = (color[v] + 1) % 2
        que.append(u)

for _ in range(Q):
    c, d = MI()
    if color[c] == color[d]:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
Road = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    Road[a - 1].append(b - 1)
    Road[b - 1].append(a - 1)

Query = [list(map(int, input().split())) for _ in range(q)]

inf = 10**7

All_cost = []


def bfs(x):
    global cost
    cost = [inf] * n
    dp = [0] * n
    que = deque([x])
    cost[x] = 0
    dp[x] = 1
    while que:
        now = que.popleft()
        curr_cost = cost[now]
        next_cost = curr_cost + 1
        for y in Road[now]:
            if next_cost < cost[y]:
                que.append(y)
                dp[y] = dp[now]
                cost[y] = next_cost
            elif next_cost == cost[y]:
                dp[y] += dp[now]


bfs(0)

for c, d in Query:
    if (cost[c - 1] - cost[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(
    700000)  # if you think this value, change pypy to python3...?


def s_in():
    return input()


def n_in():
    return int(input())


def l_in():
    return list(map(int, input().split()))


class LCA:
    def __init__(self, n, root, edges):
        self.n = n
        self.depth, parents = tree_depth(n, root, edges)
        k = n.bit_length()
        self.double = Doubling(n, k, parents)

    def get_lca(self, u, v):
        dd = self.depth[v] - self.depth[u]
        if dd < 0:
            u, v = v, u
            dd = -dd

        # assert depth[u] <= depth[v]
        for k in range(self.double.max_k + 1):
            if dd & 1:
                v = self.double.double[v][k]
            dd >>= 1

        # assert depth[u] == depth[v]
        if u == v:
            return u

        for k in range(self.double.max_k - 1, -1, -1):
            pu = self.double.double[u][k]
            pv = self.double.double[v][k]
            if pu != pv:
                u = pu
                v = pv

        # assert kprv[0][u] == kprv[0][v]
        return self.double.double[u][0]


def tree_depth(n, root, edges):
    depth = [-1] * n
    parents = [-1] * n
    depth[root] = 0
    parents[root] = root

    stack = [root]

    while len(stack) > 0:
        u = stack.pop()
        for v in edges[u]:
            if not depth[v] == -1: continue
            stack.append(v)
            parents[v] = u
            depth[v] = depth[u] + 1

    return depth, parents


class Doubling:
    def __init__(self, n, k, trans):
        self.n = n
        self.max_k = k
        double = [[-1] * k for _ in range(n)]

        for i in range(n):
            double[i][0] = trans[i]
        for j in range(1, k):
            for i in range(n):
                double[i][j] = double[double[i][j - 1]][j - 1]
        self.double = double

    def forward(self, p, step):
        while step > 0:
            for k in range(0, self.max_k):
                if 2**(k + 1) > step: break
            step -= 2**k
            p = self.double[p][k]
        return p


def _main(n, edges, q):
    lca = LCA(n, 1, edges)
    for c, d in q:
        u = lca.get_lca(c, d)
        d = (lca.depth[c] - lca.depth[u]) + (lca.depth[d] - lca.depth[u])

        if d % 2 == 0:
            print("Town")
        else:
            print("Road")


def main():
    n, qq = l_in()

    edges = [[] for _ in range(n)]
    for i in range(n - 1):
        a, b = l_in()
        edges[a - 1].append(b - 1)
        edges[b - 1].append(a - 1)

    q = [None] * qq

    for i in range(qq):
        a, b = l_in()
        q[i] = (a - 1, b - 1)

    _main(n, edges, q)


if __name__ == "__main__":
    main()
import sys

MAXX = 10**7 + 20
sys.setrecursionlimit(MAXX)
#input = sys.stdin.readline

N, Q = map(int, input().split())
adj = [[] for _ in range(N + 3)]
for i in range(N - 1):
    a, b = map(int, input().split())
    adj[a].append(b)
    adj[b].append(a)
#print(adj)
#label = []
lvl = []
id = [0] * (N + 2)
count = 0


def dfs(v, parent, depth):
    global count
    if depth > N + 10:
        return

    count += 1
    #label.append(v)
    lvl.append(depth)
    if id[v] <= 0:
        id[v] = count
    for u in adj[v]:
        if u == parent: continue
        dfs(u, v, depth + 1)
        #count += 1
        #label.append(v)
        #lvl.append(depth)


dfs(N // 2, 0, 0)
#print(id)
#print(lvl)
ans = []
for _ in range(Q):
    u, v = map(int, input().split())
    ll, rr = id[u] - 1, id[v] - 1  #ノードIDから訪れる順に変換
    dist = lvl[ll] + lvl[rr]  #- 2*lvl[id[lca]-1]
    if dist & 0x01 == 0:
        print('Town')
        #ans.append('Town')
    else:
        print('Road')
        #ans.append('Road')
from collections import deque

N, Q = map(int, input().split())

graph = [[] for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph[a].append(b)
    graph[b].append(a)

dq = deque([])
node = 0
depth = 1
dq.append((node, depth))

dps_list = [-1 for _ in range(N)]
dps_list[node] = 0

while len(dq) != 0:
    node, depth = dq.popleft()
    for child in graph[node]:
        if dps_list[child] == -1:
            dps_list[child] = depth
            dq.append((child, depth + 1))

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    depth_sa = abs(dps_list[c] - dps_list[d])
    if depth_sa % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(200000)

N, Q = map(int, input().split())

depth = [None] * N
canGo = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    canGo[a].append(b)
    canGo[b].append(a)


def iter(s, dep):
    depth[s] = dep
    for n in canGo[s]:
        if depth[n] is None:
            iter(n, dep + 1)


m = 0
s = 0
for i, x in enumerate(canGo):
    if len(x) > m:
        m = len(x)
        s = i
iter(s, 0)
# print(depth)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (depth[c] - depth[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
import math
import bisect
import random
from itertools import permutations, accumulate, combinations, product
import sys
import string
from bisect import bisect_left, bisect_right
from math import factorial, ceil, floor
from operator import mul
from functools import reduce

sys.setrecursionlimit(2147483647)
INF = 10**13


def LI():
    return list(map(int, sys.stdin.buffer.readline().split()))


def I():
    return int(sys.stdin.buffer.readline())


def LS():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()


def S():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8')


def IR(n):
    return [I() for i in range(n)]


def LIR(n):
    return [LI() for i in range(n)]


def SR(n):
    return [S() for i in range(n)]


def LSR(n):
    return [LS() for i in range(n)]


def SRL(n):
    return [list(S()) for i in range(n)]


def MSRL(n):
    return [[int(j) for j in list(S())] for i in range(n)]


mod = 1000000007


class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(int, input().split())
    G[x - 1] += [y - 1]
    G[y - 1] += [x - 1]

lca = LCA(G)
for _ in range(Q):
    c, d = map(int, input().split())
    if (lca.depth[c - 1] + lca.depth[d - 1] -
            2 * lca.depth[lca.get(c - 1, d - 1)]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    G[a].append(b)
    G[b].append(a)

stack = [(0, -1)]
C = [-1] * N
C[0] = 0
while stack:
    u, par = stack.pop()
    color = C[u]
    for v in G[u]:
        if v == par: continue
        stack.append((v, u))
        C[v] = color ^ 1

for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if C[c] == C[d]:
        print('Town')
    else:
        print('Road')
import queue
# tree の depthで算出する方法を試す
# Query は複数飛んでくるので cache しないと間に合わない

N, Q = map(int, input().split())

# Edge は N-1 しかない
abn = [tuple(map(int, input().split())) for _ in range(N - 1)]
cdq = [tuple(map(int, input().split())) for _ in range(Q)]


def show2d(a2d):
    print("===show2d===")
    for i, a1d in enumerate(a2d):
        print(i + 1, a1d)


# It can Not be comlete.-> -root is always lesser than any leaves.-
# ex.) 1-3-2
tree = [set() for _ in range(N)]

for a, b in abn:

    a -= 1
    b -= 1

    # registor parent v
    tree[b].add(a)
    tree[a].add(b)

#if len(  list(filter(lambda a:a==-1,tree))  ) > 0:
#  print(abn)
#  show2d(tree)
#  raise ValueError()

#show2d(tree)
depth = [-1] * N
depth[0] = 0

Q = queue.Queue()
Q.put(0)

while not Q.empty():

    p = Q.get()

    for v in filter(lambda a: depth[a] == -1, tree[p]):
        depth[v] = depth[p] + 1
        Q.put(v)
        #print("d:",depth)

#print(depth)
for c, d in cdq:
    c -= 1
    d -= 1
    t = depth[c] + depth[d]

    print("Road" if t % 2 == 1 else "Town")
from collections import defaultdict
import sys


def input():
    return sys.stdin.readline()[:-1]


class MyGraph:
    def __init__(self):

        # ノードの集合
        self.nodes = set()
        # 各ノードに隣接している(そこからたどり着ける)ノードの集合をまとめた辞書
        self.connections = defaultdict(set)

        # 0:未到達
        # 1:白
        # 2:黒
        self.color = defaultdict(int)

    def add_nodes(self, nodes):
        # 頂点の集合(またはリストなど)を加えます。
        for node in nodes:
            if node not in self.nodes:
                self.nodes.add(node)

    def add_edges(self, edges):
        # 辺を加えます。辺は(from , to )の形のタプルにすること。
        # 例：graph.add_edges([ (1,2) , (1,3) , (2,4) ])
        for f, t in edges:
            # f : from     t : to
            self.connections[f].add(t)
            self.connections[t].add(f)

    def nuriwake(self):
        start_node = 1

        job_stack = [start_node]
        self.color[start_node] = 1

        while job_stack:
            node = job_stack.pop()
            node_c = self.color[node]
            if node_c == 1:
                next_color = 2
            else:
                next_color = 1

            for next_node in self.connections[node]:
                if self.color[next_node] == 0:
                    self.color[next_node] = next_color
                    job_stack.append(next_node)


def main():
    n, q = tuple(map(int, input().split()))
    nodes = list(range(1, n + 1))
    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]

    g = MyGraph()
    g.add_nodes(nodes)
    g.add_edges(edges)
    g.nuriwake()

    ans = []
    for _ in range(q):
        c, d = tuple(map(int, input().split()))
        if g.color[c] == g.color[d]:
            ans.append('Town')
        else:
            ans.append('Road')

    print('\n'.join(ans))


if __name__ == '__main__':
    main()
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
#グラフに入れてる
que = queue.Queue()
color = ["None"] * N
color[0] = 1
que.put(0)
#1を頂点に幅全
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == "None":
            color[i] = -1 * color[t]
            #これで-1か，1かに別れる
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
from heapq import *
import sys
from collections import *
from itertools import *
from decimal import *
import copy
from bisect import *
import math

sys.setrecursionlimit(4100000)


def gcd(a, b):
    if (a % b == 0): return (b)
    return (gcd(b, a % b))


input = lambda: sys.stdin.readline().rstrip()

N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for i in range(N - 1)]
cd = [list(map(int, input().split())) for i in range(Q)]

path = defaultdict(list)
for a, b in ab:
    path[a].append(b)
    path[b].append(a)

dp = [-1 for i in range(N + 1)]
dp[1] = 0

stack = [1]
while stack:
    c = stack.pop()
    count = dp[c]
    for a in path[c]:
        if dp[a] == -1:
            dp[a] = count + 1
            stack.append(a)

#print(dp)
for c, d in cd:
    if dp[c] % 2 == dp[d] % 2:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
node_lst = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    node_lst[a].append(b)
    node_lst[b].append(a)
# print(node_lst)
from collections import deque

dq = deque()
dq.append((0, 0))
depth_lst = [-1 for _ in range(n)]
while (len(dq) > 0):
    node, depth = dq.popleft()
    depth_lst[node] = depth
    for child in node_lst[node]:
        if depth_lst[child] >= 0: continue
        dq.append((child, depth + 1))
# print(depth_lst)
for j in range(q):
    ans = 0
    fr, to = map(int, input().split())
    fr -= 1
    to -= 1
    ans = depth_lst[fr] + depth_lst[to]
    ans %= 2
    print(["Town", "Road"][ans])

# for i in range(q):
#     fr,to=map(int,input().split())
import sys
from collections import deque

sys.setrecursionlimit(10**7)


def I():
    return int(sys.stdin.readline().rstrip())


def MI():
    return map(int, sys.stdin.readline().rstrip().split())


def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


def LI2():
    return list(map(int, sys.stdin.readline().rstrip()))


def S():
    return sys.stdin.readline().rstrip()


def LS():
    return list(sys.stdin.readline().rstrip().split())


def LS2():
    return list(sys.stdin.readline().rstrip())


class LCA():
    def __init__(self, N, Graph, root):
        '''
        N:頂点数,Graph:木の隣接リスト表現,root:根 (0-index)
        '''
        self.N = N
        self.par = [-1] * N
        self.depth = [-1] * N

        deq = deque([root])
        self.depth[root] = 0
        while deq:
            u = deq.pop()
            for v in Graph[u]:
                if self.depth[v] != -1:
                    continue
                self.par[v] = u
                self.depth[v] = self.depth[u] + 1
                deq.appendleft(v)

        self.ancestor = [self.par]
        self.K = (N - 1).bit_length() + 1
        for _ in range(self.K - 1):
            new = [0] * N
            for u in range(N):
                if self.ancestor[-1][u] == -1:
                    new[u] = -1
                else:
                    new[u] = self.ancestor[-1][self.ancestor[-1][u]]
            self.ancestor.append(new)

    def lca(self, u, v):
        depth_diff = self.depth[u] - self.depth[v]
        if depth_diff < 0:
            u, v = v, u
            depth_diff *= -1
        # depth[u] >= depth[v] としてよい

        for k in range(self.K):
            if depth_diff & 1:
                u = self.ancestor[k][u]
            depth_diff >>= 1
        # depth[u] == depth[v] としてよい

        if u == v:
            return u
        for k in range(self.K - 1, -1, -1):
            pu, pv = self.ancestor[k][u], self.ancestor[k][v]
            if pu != pv:
                u, v = pu, pv
        return self.ancestor[0][u]

    def dist(self, u, v):
        return self.depth[u] + self.depth[v] - 2 * self.depth[self.lca(u, v)]


N, Q = MI()
Graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = MI()
    a -= 1
    b -= 1
    Graph[a].append(b)
    Graph[b].append(a)

lca = LCA(N, Graph, 0)
for _ in range(Q):
    c, d = MI()
    c -= 1
    d -= 1
    di = lca.dist(c, d)
    if di % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque


def main():
    n, q = map(int, input().split())

    adj = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        adj[a].append(b)
        adj[b].append(a)

    queue = deque()
    queue.append(0)
    dist = [-1 for _ in range(n)]
    dist[0] = 0

    while queue:
        now_v = queue.popleft()
        for next_v in adj[now_v]:
            if dist[next_v] != -1:
                continue
            dist[next_v] = dist[now_v] + 1
            queue.append(next_v)

    for _ in range(q):
        c, d = map(int, input().split())
        c, d = c - 1, d - 1
        if abs(dist[d] - dist[c]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
N, Q = map(int, input().split())
e = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    e[a].append(b)
    e[b].append(a)

dist = [-1] * N
from collections import deque

v = deque()
v.append(0)
dist[0] = 0
while v:
    x = v.popleft()
    for ix in e[x]:
        if dist[ix] == -1:
            dist[ix] = dist[x] + 1
            v.append(ix)
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**9)

N, Q = map(int, input().split())

G = [list() for i in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)

query = []
for i in range(Q):
    c, d = map(int, input().split())
    query.append((c, d))

height = [-float('inf')] * (N + 1)
height[0] = -1


def dfs(pos, pre):
    height[pos] = height[pre] + 1
    for to in G[pos]:
        if height[to] != -float('inf'):
            continue
        dfs(to, pos)
    pass


dfs(1, 0)  # 1 の高さを０とするため、便宜上、hi\eight[0]= -1
# print(height)

for c, d in query:
    diff1 = height[c]
    diff2 = height[d]
    sum = diff1 + diff2
    if sum % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**9)

N, Q = map(int, input().split())
adjL = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    adjL[a].append(b)
    adjL[b].append(a)
cds = [tuple(map(int, input().split())) for _ in range(Q)]


def bfsTree(vRoot):
    depths[vRoot] = 0
    QQQ = deque([vRoot])
    while QQQ:
        vNow = QQQ.popleft()
        vPar = pars[vNow]
        depth2 = depths[vNow] + 1
        for v2 in adjL[vNow]:
            if v2 == vPar: continue
            pars[v2] = vNow
            depths[v2] = depth2
            QQQ.append(v2)


numV = N  ###
vRoot = 0  ###

pars = [-1] * (numV)
depths = [-1] * (numV)

bfsTree(vRoot)


def getParssLCA(pars):
    numV = len(pars)
    maxD = numV.bit_length() - 1
    parss = [[-1] * (numV) for _ in range(maxD + 1)]
    for v in range(numV):
        parss[0][v] = pars[v]
    for d in range(1, maxD + 1):
        for v in range(numV):
            if parss[d - 1][v] != -1:
                parss[d][v] = parss[d - 1][parss[d - 1][v]]
    return parss, maxD


parss, maxD = getParssLCA(pars)


def getLCA(x, y):
    if depths[x] < depths[y]:
        x, y = y, x
    diff = depths[x] - depths[y]
    for d in range(maxD + 1):
        if (diff >> d) & 1:
            x = parss[d][x]
    if x == y:
        return x
    for d in reversed(range(maxD + 1)):
        if parss[d][x] != parss[d][y]:
            x = parss[d][x]
            y = parss[d][y]
    return parss[0][x]


anss = []
for c, d in cds:
    c, d = c - 1, d - 1
    LCA = getLCA(c, d)
    dist = abs(depths[c] - depths[LCA]) + abs(depths[d] - depths[LCA])
    if dist % 2:
        anss.append('Road')
    else:
        anss.append('Town')

print('\n'.join(anss))
class LowestCommonAncestor:
    """ <O(Nlog(N)), O(1)> """
    __slots__ = ["n", "tour", "depth_list", "id", "sparse_table", "log"]

    def __init__(self, G: "隣接リスト", root: "根"):
        self.n = len(G)
        self.tour = [0] * (2 * self.n - 1)
        self.depth_list = [0] * (2 * self.n - 1)
        self.id = [-1] * self.n
        self.dfs(G, root)
        self._rmq_init(self.depth_list)

    def _rmq_init(self, array):
        n = len(array)
        logn = n.bit_length()
        self.sparse_table = st = [[0] * (n + 1 - (1 << i))
                                  for i in range(logn)]
        st[0] = list(range(n))

        for i in range(logn - 1):
            s = st[i]
            t = st[i + 1]
            width = 1 << i
            for j in range(n + 1 - 2 * width):
                first, second = s[j], s[j + width]
                t[j] = first if array[first] < array[second] else second
        self.log = log = [0] * (n + 1)
        for i in range(2, n + 1):
            log[i] = log[i >> 1] + 1

    def _rmq_query(self, l: int, r: int) -> int:
        """min(array[l:r])を返す．O(1)"""
        b = self.log[r - l]
        s = self.sparse_table[b]
        first, second = s[l], s[r - (1 << b)]
        return first if self.depth_list[first] < self.depth_list[
            second] else second

    def dfs(self, G, root):
        """ 非再帰で深さ優先探索を行う """
        id = self.id
        tour = self.tour
        depth_list = self.depth_list
        v = root
        it = [0] * self.n
        parents = [-1] * self.n
        visit_id = 0
        depth = 0
        while v != -1:
            if id[v] == -1:
                id[v] = visit_id
            tour[visit_id] = v
            depth_list[visit_id] = depth
            visit_id += 1
            g = G[v]
            if it[v] == len(g):
                v = parents[v]
                depth -= 1
                continue
            if g[it[v]] == parents[v]:
                it[v] += 1
                if it[v] == len(g):
                    v = parents[v]
                    depth -= 1
                    continue
                else:
                    child = g[it[v]]
                    parents[child] = v
                    it[v] += 1
                    v = child
                    depth += 1
            else:
                child = g[it[v]]
                parents[child] = v
                it[v] += 1
                v = child
                depth += 1

    def lca(self, u: int, v: int) -> int:
        """ u と v の最小共通祖先を返す """
        l, r = self.id[u], self.id[v]
        if r < l:
            l, r = r, l
        q = self._rmq_query(l, r + 1)
        return self.tour[q]

    def dist(self, u: int, v: int) -> int:
        """ u と v の距離を返す """
        lca = self.lca(u, v)
        depth_u = self.depth_list[self.id[u]]
        depth_v = self.depth_list[self.id[v]]
        depth_lca = self.depth_list[self.id[lca]]
        return depth_u + depth_v - 2 * depth_lca


import sys

input = sys.stdin.readline
from array import array

n, q = map(int, input().split())
es = [array("i") for _ in range(n)]
for i in range(n - 1):
    start, end = map(int, input().split())
    start -= 1
    end -= 1
    es[start].append(end)
    es[end].append(start)

lca = LowestCommonAncestor(es, 0)

res = [""] * q
for i in range(q):
    c, d = map(int, input().split())
    k = lca.dist(c - 1, d - 1)
    if k % 2:
        res[i] = "Road"
    else:
        res[i] = "Town"

print(*res, sep="\n")
# 二部グラフで塗る: 典型のやつ
from collections import deque

n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

color = [-1 for i in range(n)]
color[0] = 1
que = deque([0])
while que:
    v = que.popleft()
    for u in G[v]:
        if color[u] == -1:
            color[u] = 1 - color[v]
            que.append(u)

for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if color[c] == color[d]: print('Town')
    else: print('Road')
from collections import deque


#1.クラスを宣言：
class Node:
    # コンストラクタを宣言
    def __init__(self, index):
        # メソッドを定義
        self.index = index  # Node （頂点） の番号を定義
        self.nears = []  # 隣接 Node のリストを定義
        self.sign = -1  # 未探索の場合は -1 を返す。探索済みの場合、

    def __repr__(self):
        return f'Node index:{self.index} Node nears:{self.nears} Node sign:{self.sign}'


# 入力読み込み
N, Q = map(int, input().split())
links = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]

#2.インスタンス（Node）を生成し、nodes に格納する:
# ノード 0 も生成されるが使用しない。
nodes = []
for i in range(N + 1):
    nodes.append(Node(i))

# この時点で探索済みの node は存在しないため sign メソッドで -1 が返される。
#print([node.sign for node in nodes])

#3.隣接 node を nears メソッドに格納する:
for j in range(N - 1):
    edge_start, edge_end = links[j]
    nodes[edge_start].nears.append(edge_end)
    nodes[edge_end].nears.append(edge_start)  # 有向グラフの場合は消す（無向グラフの場合のみ記述）

# BFS
# 探索対象 node を queue （キュー）に入れる。
queue = deque()
#5-1.本問では node 1 から探索を開始するため queue に node 1 を最初に入れる:
queue.append(nodes[1])

#5-2.queue がなくなるまで探索を続ける:
while queue:
    #5-2-1.queue から node を 1 つ取り出す。取り出したノードについて調べる。
    # 取り出された node は queue から消える。
    node = queue.popleft()  # .pop() にすると DFS になる
    #print(node) # コメントアウトを外すと現在地がわかる。 DFS と BFS で比べてみるとよい
    #5-2-2.取り出された node の隣接 node 達を nears に入れる。
    nears = node.nears
    #5-2-3.隣接 node 達が探索済みか 1 つずつ調べる。
    for near in nears:
        #5-2-4.未探索の隣接 node は queue に追加する。
        # 取り出してきた親 node は道しるべとなるため、子 node の sign メソッドに追加する。
        if nodes[near].sign == -1:
            queue.append(nodes[near])
            nodes[near].sign = node.sign + 1

# 道しるべを表示
for k in range(2, N + 1):
    nodes[k].sign
for i in range(Q):
    if (nodes[CD[i][0]].sign - nodes[CD[i][1]].sign) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(100000)
N, Q = map(int, input().split())
G = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = list(map(int, input().split()))
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)


def tansaku(p):
    for j in G[p]:
        if H[j] == 0:
            H[j] = H[p] + 1
            tansaku(j)


H = [0] * N
tansaku(0)
for l in range(Q):
    c, d = list(map(int, input().split()))
    if abs(H[c - 1] - H[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

N, q = map(int, input().split())
l = [[] for i in range(N)]
#print(l)
for i in range(N - 1):
    a, b = map(int, input().split())
    l[a - 1].append(b - 1)
    l[b - 1].append(a - 1)
#print(l)
s, g = 0, N - 1

dis = [0 for i in range(N)]
conf = [True for i in range(N)]

count = 0
d = deque([(s, 0)])

#while sum(cof)!=0:
while len(d) != 0:

    watch, dist = d.popleft()
    conf[watch] = False

    for i in l[watch]:
        S = dis[i]
        if S == 0 and conf[i]:
            dis[i] = dist + 1
            d.append((i, 1 + dist))

#print(dis)
for i in range(q):
    s, g = map(int, input().split())
    if (dis[s - 1] - dis[g - 1]) % 2 == 0:

        print("Town")
    else:
        print("Road")
import sys
from functools import lru_cache
from collections import defaultdict

sys.setrecursionlimit(500005)


def get_line_int():
    return list(map(int, sys.stdin.readline().strip().split()))


def get_line_float():
    return list(map(float, sys.stdin.readline().strip().split()))


def in1():
    return int(input())


MAXN, MAXQ = 100100, 20

g = defaultdict(list)
tin = defaultdict(int)
tout = defaultdict(int)
d = defaultdict(int)
up = [[0] * MAXQ for _ in range(MAXN)]

timer = 0
root = 0


def visit(pa, u: int):
    global timer
    timer += 1
    d[u] = d[pa] + 1
    tin[u] = timer
    up[u][0] = pa
    for i in range(1, MAXQ):
        up[u][i] = up[up[u][i - 1]][i - 1]

    for v in g[u]:
        if v != pa:
            visit(u, v)

    timer += 1
    tout[u] = timer


def is_ancestor(a, b: int) -> bool:
    return tin[a] <= tin[b] and tout[a] >= tout[b]


def get_lca(a, b: int) -> int:
    if is_ancestor(a, b):
        return a
    elif is_ancestor(b, a):
        return b
    else:
        for i in range(MAXQ - 1, -1, -1):
            if not is_ancestor(up[a][i], b):
                a = up[a][i]

        return up[a][0]


n, q = get_line_int()

for i in range(n - 1):
    u, v = get_line_int()
    g[u - 1].append(v - 1)
    g[v - 1].append(u - 1)

visit(0, 0)

for i in range(q):
    a, b = get_line_int()
    a, b = a - 1, b - 1

    l = get_lca(a, b)
    sz = d[a] + d[b] - 2 * d[l] + 1
    if sz % 2 == 0:
        print("Road")
    else:
        print("Town")
import collections, math
from collections import defaultdict


def I():
    return int(input())


def MI():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


from collections import deque, Counter
from collections import defaultdict
import itertools
import math
import heapq
import math

N, Q = MI()

#つながっている経路
road = [[] for i in range(N)]
for i in range(N - 1):
    a, b = MI()
    a -= 1
    b -= 1
    road[a].append(b)
    road[b].append(a)
"""
道路で出会うのはつながった街にいるとき
街で出会うのは、つながっている街の中継地点にいるとき

cとdの距離を事前に計算できていればよい
"""

#訪問フラグ兼距離
visit = [-1] * N
#BFSを解く
q = deque()
q.append(0)
visit[0] = 0

while q:
    pos = q.pop()
    #つながっている道に確認
    for nx in road[pos]:
        #未訪問なら訪問
        if visit[nx] == -1:
            #距離を追加
            visit[nx] = visit[pos] + 1
            q.append(nx)

#各距離の引き算を計算
ans = []
for i in range(Q):
    c, d = MI()
    c -= 1
    d -= 1
    dist = abs(visit[c] - visit[d])
    if dist % 2 == 0:
        ans.append("Town")
    else:
        ans.append("Road")

for i in ans:
    print(i)
n, q = map(int, input().split())
map_list = [[] for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    map_list[a].append(b)
    map_list[b].append(a)

que = [0]
done = [None] * n
done[0] = 1

for v in que:
    for to in map_list[v]:
        if done[to] is None:
            done[to] = done[v] + 1
            que.append(to)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (done[c] + done[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python3
from itertools import accumulate, chain, combinations, groupby, permutations, product
from collections import deque, Counter
from bisect import bisect_left, bisect_right
from math import gcd, sqrt, sin, cos, tan, degrees, radians, ceil, floor
from fractions import Fraction
from decimal import Decimal
import sys

n, q = map(int, input().split())
g = [[] for _ in range(n)]  # 隣接リスト


#rstripが必要なことも
#input = lambda: sys.stdin.readline().rstrip()
#inputの高速化、基本はいらん、入力が長いときに使用
#from sys import setrecursionlimit
#setrecursionlimit(10**7)
def bfs(u):
    queue = deque([u])
    d = [None] * n  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


MOD = 10**9 + 7
INF = float('inf')


#float型の無限大inf
def resolve():
    #n=int(input())

    for _ in range(n - 1):
        a, b = [int(x) for x in input().split()]
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)
    #C = list(map(int, input().split()))
    #C.sort()
    #d=bfs(1)
    #print(d)
    d = bfs(0)
    for i in range(q):
        c, doo = map(int, input().split())

        if (d[c - 1] - d[doo - 1]) % 2 == 1:
            print("Road")
        else:
            print("Town")


if __name__ == "__main__":
    resolve()
import sys

sys.setrecursionlimit(10**6)

n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

color = [-1] * n


def dfs(v, c=0):
    color[v] = c
    for u in G[v]:
        if color[u] == -1: dfs(u, 1 - c)


dfs(0)

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    print('Road' if color[c] != color[d] else 'Town')
n, q = map(int, input().split())
e = [list() for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    e[a].append(b)
    e[b].append(a)
depth = [0] * n

stack = [(0, -1, 0)]


def dfs(crt, par, d):
    depth[crt] = d
    for nxt in e[crt]:
        if nxt != par:
            stack.append((nxt, crt, d + 1))


while stack:
    dfs(*stack.pop())
for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (depth[c] + depth[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

dist = [0 for _ in range(n)]


def bfs():
    q = deque()
    seen = [False for _ in range(n)]
    q.append([0, 0])
    while len(q) > 0:
        u, d = q.popleft()
        if seen[u]:
            continue
        seen[u] = True
        for v in g[u]:
            if seen[v]:
                continue
            q.append([v, d + 1])
            dist[v] = d + 1


bfs()
for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dist[c] % 2 == dist[d] % 2:
        print('Town')
    else:
        print('Road')
from collections import defaultdict

N, Q = map(int, input().split())
edges = defaultdict(list)
for _ in range(N - 1):
    a, b = map(int, input().split())
    edges[a].append(b)
    edges[b].append(a)
queries = []
for _ in range(Q):
    queries.append(list(map(int, input().split())))

binary_grouping = [None] * (N + 1)

# dfs
stack = [(1, 0)]

while stack:
    node, color = stack.pop()
    if binary_grouping[node] is not None:
        continue
    binary_grouping[node] = color
    for next_node in edges[node]:
        stack.append((next_node, 1 - color))

for c, d in queries:
    if binary_grouping[c] == binary_grouping[d]:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())

graph = [[] for _ in range(N)]
ans = []

for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)


def bfs(u):
    queue = deque([u])
    d = [None] * (N)
    d[u] = 0
    while queue:
        v = queue.popleft()
        for i in graph[v]:
            if d[i] is not None:
                continue
            d[i] = d[v] + 1
            queue.append(i)
    return d


dis, colors = bfs(0), [""] * N
for i in range(N):
    if dis[i] % 2 == 0:
        colors[i] = "red"
    else:
        colors[i] = "blue"

for _ in range(Q):
    c, d = map(int, input().split())
    color1, color2 = colors[c - 1], colors[d - 1]
    if color1 == color2:
        ans.append("Town")
    else:
        ans.append("Road")

print(*ans, sep="\n")
from collections import deque

d = deque()

N, Q = map(int, input().split())
route = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    route[a - 1].append(b - 1)
    route[b - 1].append(a - 1)

# BFS
cost_from_start = [-1] * N
cost_from_start[0] = 0
d.append((0, 0))

while len(d) > 0:
    current_node, cost = d.popleft()
    cost_from_start[current_node] = cost

    for next_node in route[current_node]:
        if cost_from_start[
                next_node] == -1 or cost_from_start[next_node] > cost + 1:
            d.append((next_node, cost + 1))

for i in range(Q):
    c, d = map(int, input().split())
    if abs(cost_from_start[c - 1] - cost_from_start[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.readline
N, Q = map(int, input().split())
e = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    u, v = map(int, input().split())
    e[u].append(v)
    e[v].append(u)

eulbase = pow(10, 6)
lime = [[] for _ in range(N + 1)]
limevis = [0] * (N + 1)


def limitedge():
    global limevis
    global lime
    limevis[1] = 1
    s = [1]
    while len(s):
        x = s.pop()
        for y in e[x]:
            if limevis[y]: continue
            lime[x].append(y)
            limevis[y] = 1
            s.append(y)


euler = []
depth = [0] * (N + 1)
table = [0] * (N + 1)


def eulerdfs():
    global euler
    global depth
    global table
    s = [1]
    while len(s):
        x = s.pop()
        if x >= 0:
            euler.append(depth[x] * eulbase + x)
            for y in lime[x]:
                s.append(~x)
                s.append(y)
                depth[y] = depth[x] + 1
        else:
            euler.append(depth[~x] * eulbase + ~x)


limitedge()
eulerdfs()
for i in range(len(euler) - 1, -1, -1):
    table[euler[i] % eulbase] = i


class SparseTable:
    def calc(self, x, y):
        return min(x, y)

    def __init__(self, n, init_val, ide_ele):
        self.n = n
        k = n.bit_length()
        self.k = k
        self.ide_ele = ide_ele
        self.log_table = [[ide_ele] * n for _ in range(k + 1)]
        for i in range(n):
            self.log_table[0][i] = init_val[i]
        for i in range(k):
            d = 1 << i
            for j in range(n):
                if j + d >= n: break
                self.log_table[i + 1][j] = self.calc(self.log_table[i][j],
                                                     self.log_table[i][j + d])

    def query(self, l, r):
        d = r - l
        if d < 0: return self.ide_ele
        if d == 1: return self.log_table[0][l]
        m = d.bit_length() - 1
        return self.calc(self.log_table[m][l], self.log_table[m][r - (1 << m)])


st = SparseTable(len(euler), euler, N * eulbase)

for _ in range(Q):
    u, v = map(int, input().split())
    if table[u] > table[v]: u, v = v, u
    root = st.query(table[u], table[v]) % eulbase
    d = depth[u] + depth[v] - depth[root] * 2
    if d % 2: print("Road")
    else: print("Town")
R = lambda: map(int, input().split())
n, q = R()
g = [None] + [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = R()
    g[b].append(a)
    g[a].append(b)
C = [None] * (n + 1)
C[1] = 0
s = [1]
while s:
    u = s.pop()
    for v in g[u]:
        if C[v] is None:
            s.append(v)
            C[v] = C[u] ^ 1
for _ in range(q):
    c, d = R()
    print('TRoowand'[C[c] ^ C[d]::2])
from collections import deque
import sys

read = sys.stdin.readline

n, q = map(int, read().split())
path = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, read().split())
    a, b = a - 1, b - 1
    path[a].append(b)
    path[b].append(a)

flag = [-1] * n
flag[0] = 0
que = deque([[0, 0]])
while que:
    x, c = que.popleft()
    for y in path[x]:
        if flag[y] >= 0:
            continue
        flag[y] = (c + 1) % 2
        que.append([y, c + 1])

for _ in range(q):
    s, t = map(int, read().split())
    s, t = s - 1, t - 1
    print('Road' if flag[s] ^ flag[t] else 'Town')
import sys

sys.setrecursionlimit(10**6)
n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

cd = [list(map(int, input().split())) for i in range(q)]
cd = [[x - 1, y - 1] for x, y in cd]
ds = [0] * n


def f(s, p):
    if p == -1: ds[s] = 0
    else: ds[s] = ds[p] + 1
    for u in g[s]:
        if u != p: f(u, s)


f(0, -1)

for c, d in cd:
    if abs(ds[c] - ds[d]) % 2: print("Road")
    else: print("Town")
import sys

input = sys.stdin.readline
from collections import deque

n, q = map(int, input().split())
node = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    node[a].append(b)
    node[b].append(a)
# print(node)

CNT = [-1] * n
CNT[0] = 0
d = deque([0])
while d:
    x = d.popleft()
    for y in node[x]:
        if CNT[y] == -1:
            CNT[y] = 1 - CNT[x]
            d.append(y)

for i in range(q):
    c, d = map(int, input().split())
    print('Town' if CNT[c - 1] == CNT[d - 1] else 'Road')
import sys

input = sys.stdin.readline
N, Q = map(int, input().split())


class DSU:
    def __init__(self, N: int) -> None:
        self.par = list(range(N))
        self.sz = [1] * N

    def find(self, x: int) -> int:
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]

    def unite(self, x: int, y: int) -> bool:
        x, y = self.find(x), self.find(y)
        if x == y:
            return False
        if self.sz[x] < self.sz[y]:
            x, y = y, x
        self.par[y] = x
        self.sz[x] += self.sz[y]
        return True


dsu = DSU(N * 2)

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    dsu.unite(a, b + N)
    dsu.unite(b, a + N)

for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dsu.find(c) == dsu.find(d):
        print("Town")
    else:
        print("Road")
import queue

n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)
que = queue.Queue()
cd = [list(map(int, input().split())) for _ in range(q)]

colour = [0] + [-1] * (n - 1)
que.put(0)

while not que.empty():
    t = que.get()
    for i in g[t]:
        if colour[i] == -1:
            colour[i] = 1 - colour[t]
            que.put(i)
for i in range(q):
    if colour[cd[i][0] - 1] == colour[cd[i][1] - 1]:
        print('Town')
    else:
        print('Road')
import sys

input = sys.stdin.readline
from collections import deque

N, Q = map(int, input().split())
graph = [[] for i in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
CD = []
for i in range(Q):
    a, b = map(int, input().split())
    CD.append([a, b])

visited = [0 for i in range(N + 1)]
G = [[], []]


def bfs(u):
    queue = deque([u])
    d = [None] * N  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in graph[v]:
            if d[i] is None:
                d[i] = d[v] + 1

                queue.append(i)
    return d


Ki = bfs(1)
for i in range(Q):
    c = CD[i][0]
    d = CD[i][1]

    if (Ki[c - 1] + Ki[d - 1]) % 2 == 1:
        print("Road")
    else:
        print("Town")
#!/usr/bin/env python3

from sys import setrecursionlimit, stdin
from typing import Iterable

INF: int = 2**62
MOD: int = 10**9 + 7

setrecursionlimit(10**6)


def inputs(type_=int):
    ins = input().split(' ')
    ins = [x for x in ins if x != '']

    if isinstance(type_, Iterable):
        return [t(x) for t, x in zip(type_, ins)]
    else:
        return list(map(type_, ins))


def input_(type_=int):
    a, = inputs(type_)
    return a


inputi = input_


def inputstr():
    return input_(str)


# b/aの切り上げ
def ceil(b, a):
    return (a + b - 1) // a


def answer(res) -> None:
    print(res)
    exit()


def compute():
    return


from heapq import heappop, heappush


def dijkstra(start: int, n: int, edges, *, inf=INF):
    """
    単一始点最短経路問題を Dijkstra 法で解く
    計算量は O((E+V)log(V))
    Ref: https://mirucacule.hatenablog.com/entry/2020/05/21/124026

    start: 始点のインデックス
    n: ノード数
    edges: {edge_from: {edge_to: cost, ...}, ...} の形式の辞書
    返し値: startからそれぞれの点への最短経路問題を解いたときの回答のリスト
    """
    dists = [inf] * n
    hq = [(0, start)]
    dists[start] = 0
    seen = [False] * n
    while hq:
        v = heappop(hq)[1]
        seen[v] = True
        for to_, cost in edges[v].items():
            if seen[to_] is False and dists[v] + cost < dists[to_]:
                dists[to_] = dists[v] + cost
                heappush(hq, (dists[to_], to_))

    return dists


def main():
    n, q = inputs()
    from collections import defaultdict
    path = defaultdict(set)

    # print(n)
    for _ in range(n - 1):
        a, b = inputs()
        a -= 1
        b -= 1
        path[a].add(b)
        path[b].add(a)

    edges = defaultdict(lambda: defaultdict(int))
    for i in range(n):
        edges[i][i] = 0

    for a in range(n):
        for b in path[a]:
            edges[a][b] = 1
            edges[b][a] = 1

    dists = dijkstra(0, n, edges)

    for _ in range(q):
        c, d = inputs()
        c -= 1
        d -= 1
        d = dists[c] + dists[d]
        if d % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
N, Q = map(int, input().split())
G = dict()
for i in range(N - 1):
    a, b = map(int, input().split())
    if a not in G:
        G[a] = []

    if b not in G:
        G[b] = []

    G[a].append(b)
    G[b].append(a)

color = [-1] * (N + 1)
color[1] = 0
s = [1]
while len(s) > 0:
    v = s.pop()
    for w in G[v]:
        if color[w] != -1:
            continue

        color[w] = 1 - color[v]
        s.append(w)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
import queue

n, q = map(int, input().split())
G = [[] for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * n
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()

    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
def bfs(a_graph: dict, s: int) -> list:
    # Data Structure for graph search
    vertices_num = len(a_graph)  # Number of vertices the graph has
    seen = [False] * vertices_num  # All vertices are not "seen" yet,
    seen[s] = 0  # but only vertex-s (root of tree) is "seen"
    todo = [s]  # Only vertex-s (root of tree) is in "todo"
    depth = 0  # Variable to count depth of tree

    # Continue searching until "todo" becomes empty
    while todo:
        depth += 1
        todo_tmp = []
        # Pull out a vertex from the head of "todo"
        for i in todo:
            # Search all "not-seen" vertices adjacent to vertex-i
            for j in a_graph[i]:
                # Do nothing if vertex-j is already "seen"
                if seen[j]:
                    continue

                # Make vertex-j "seen", and append it into "todo_tmp"
                seen[j] = depth
                todo_tmp.append(j)

        todo = todo_tmp

    return seen


def create_graph(edge_num: int, edge_list: list) -> dict:
    """
    Create a graph expressed with adjacency list
    :dict_key    : int (a vertex)
    :dict_value  : set (consisted of vertices adjacent to key vertex)
    """
    a_graph = {i: set() for i in range(edge_num)}

    for a, b in edge_list:
        a_graph[a - 1].add(b - 1)  # All graphs always need this line
        a_graph[b - 1].add(a - 1)  # Only undirected graph needs this line

    return a_graph


N, Q = map(int, input().split())
LL1 = [list(map(int, input().split())) for _ in range(N - 1)]
LL2 = [list(map(int, input().split())) for _ in range(Q)]

a_graph = create_graph(N, LL1)
a_list = bfs(a_graph, 0)
for c, d in LL2:
    res = 'Town' if (a_list[c - 1] + a_list[d - 1]) % 2 == 0 else 'Road'
    print(res)
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    G[x].append(y)
    G[y].append(x)


def bfs(graph, start):
    from collections import deque
    seen = [False] * len(graph)
    todo = deque()
    color = [0] * len(graph)

    seen[start] = True
    todo.append(start)
    color[start] = 1

    while todo:
        v = todo.popleft()
        for w in graph[v]:
            if seen[w]: continue
            seen[w] = True
            todo.append(w)
            color[w] = color[v] * (-1)

    return color


color = bfs(G, 0)

for q in range(Q):
    c, d = map(lambda n: int(n) - 1, input().split())
    print("Town" if color[c] == color[d] else "Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
import sys
import collections

input = sys.stdin.readline


def main():
    n, q = map(int, input().strip().split())
    G = collections.defaultdict(list)
    for _ in range(n - 1):
        a, b = map(int, input().strip().split())
        a -= 1
        b -= 1
        G[a].append(b)
        G[b].append(a)
    D = {}
    Q = collections.deque()
    Q.append((0, 0))
    while Q:
        x, d = Q.popleft()
        if x in D:
            continue
        D[x] = d
        for y in G[x]:
            Q.append((y, d + 1))

    for query in range(q):
        a, b = map(int, input().strip().split())
        a -= 1
        b -= 1
        dist_a, dist_b = D[a], D[b]
        # print('distances', dist_a, dist_b)
        if (dist_a + dist_b) % 2 == 0:
            print('Town')
        else:
            print('Road')


main()
import sys

sys.setrecursionlimit(10**5)
INFTY = sys.maxsize
from collections import deque


def i_input():
    return int(input())


def m_input():
    return map(int, input().split())


def l_input():
    return list(map(int, input().split()))


DEBUG = False


def printd(*args):
    if DEBUG:
        print(*args)


def readinput():
    n, q = m_input()
    nList = []
    for _ in range(n):
        nList.append([])
    for _ in range(n - 1):
        a, b = m_input()
        a -= 1
        b -= 1
        nList[a].append(b)
        nList[b].append(a)
    queries = []
    for _ in range(q):
        c, d = m_input()
        queries.append((c, d))
    return n, q, nList, queries


def bfs(u, nList):
    n = len(nList)
    depth = [INFTY] * n
    visited = [False] * n
    queue = deque()
    queue.append(u)
    depth[u] = 0
    visited[u] = True
    while len(queue) > 0:
        u = queue.popleft()
        for v in nList[u]:
            if not visited[v]:
                queue.append(v)
                depth[v] = depth[u] + 1
                visited[v] = True
    return depth


def main(n, q, nList, queries):
    depth = bfs(0, nList)
    ans = []
    for c, d in queries:
        c -= 1
        d -= 1
        if abs(depth[c] - depth[d]) % 2 == 0:
            ans.append('Town')
        else:
            ans.append('Road')
    return ans


def printans(ans):
    for a in ans:
        print(a)


if __name__ == '__main__':
    n, q, nList, queries = readinput()
    ans = main(n, q, nList, queries)
    printans(ans)
from collections import deque

n, m = map(int, input().split())
lis = [[] for i in range(n)]
lis.append([])

for i in range(n - 1):
    a, b = map(int, input().split())  #aとbが辺で結ばれている
    a -= 1
    b -= 1
    lis[a].append(b)
    lis[b].append(a)

dis = [-1 for i in range(n)]
dis[0] = 0
que = deque([0])

while que:
    q = que.popleft()
    for node in lis[q]:
        if dis[node] != -1:
            continue
        dis[node] = (dis[q] + 1) % 2
        que.append(node)

for _ in range(m):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dis[c] == dis[d]:
        print("Town")
    else:
        print("Road")
import queue

#BFSで街を色分け
N, Q = map(int, input().split())
a = [[] for i in range(N + 1)]

for i in range(N - 1):
    st, ed = map(int, input().split())
    a[st].append(ed)
    a[ed].append(st)

que = queue.Queue()
color = [-1] * (N + 1)
color[1] = 0
que.put(1)

while not que.empty():
    now = que.get()
    for i in a[now]:
        if color[i] == -1:
            color[i] = 1 - color[now]
            que.put(i)

for i in range(Q):
    st, ed = map(int, input().split())
    if color[st] == color[ed]:
        print("Town")
    else:
        print("Road")N, Q = map(int, input().split())

AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]

from collections import deque
import sys

sys.setrecursionlimit(100000000)

con = [deque() for _ in range(N)]
G = [deque() for _ in range(N)]
for a, b in AB:
    a, b = a - 1, b - 1
    con[a].append(b)
    con[b].append(a)

q = deque([0])
flag = [False] * N
while len(q) != 0:
    x = q.pop()
    if flag[x]:
        continue
    else:
        flag[x] = True
        for i in con[x]:
            if flag[i]:
                continue
            else:
                G[x].append(i)
                q.append(i)

# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)

# Euler Tour の構築
S = deque([])
F = [0] * N
depth = [0] * N
flag = [False] * N


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    flag[v] = True
    for w in G[v]:
        if flag[w]:
            continue
        dfs(w, d + 1)
        S.append(v)


dfs(0, 0)

# 存在しない範囲は深さが他よりも大きくなるようにする
INF = (N, None)

# LCAを計算するクエリの前計算
M = 2 * N
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


# LCAの計算 (外から呼び出す関数)
def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for c, d in CD:
    c, d = c - 1, d - 1
    x = depth[c] + depth[d] - 2 * query(c, d)
    if x % 2 == 0:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())
AB = [[*map(lambda x: int(x) - 1, input().split())] for _ in range(n - 1)]
CD = [[*map(lambda x: int(x) - 1, input().split())] for _ in range(q)]
# print(n,q)
# print(AB)
# print(CD)

G = [[] for _ in range(n)]
for a, b in AB:
    G[a].append(b)
    G[b].append(a)

# for i in range(n):
#     print(i,G[i])

from collections import deque


def bfs(p):
    res = []
    used = [False] * (n)
    dq = deque()
    i = 0
    dq.append([p, i])
    while dq:
        v, i = dq.popleft()
        if used[v]: continue
        used[v] = True
        res.append([v, i])
        for u in G[v]:
            dq.append([u, i + 1])
    return res


P = bfs(0)
P.sort()
# print(f'P {P}')

for c, d in CD:
    if (P[c][1] + P[d][1]) % 2:
        print('Road')
    else:
        print('Town')
import sys

sys.setrecursionlimit(100000)

n, q = map(int, input().split())
g = [[] for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)


def dfs(v, depth):
    if temp[v]:
        return
    temp[v] = True
    depth += 1
    #print(depth)
    dep[v] = depth
    for vv in g[v]:
        dfs(vv, depth)


temp = [False] * n
dep = [0] * n
dfs(0, 0)

#print(dep)
ans = []
for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if abs(dep[d] - dep[c]) % 2 == 0:
        print('Town')
    else:
        print('Road')
N, Q = list(map(int, input().split()))
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = list(map(lambda x: int(x) - 1, input().split()))
    G[a].append(b)
    G[b].append(a)

D = [None] * N
d = 0
to = {0}
while to:
    next_to = set()
    for v in to:
        D[v] = d
        for u in G[v]:
            if D[u] == None:
                next_to.add(u)
    to = next_to
    d += 1

for _ in range(Q):
    c, d = list(map(lambda x: int(x) - 1, input().split()))
    if (D[c] - D[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque


def hukasa(graph, n):
    dist = [-1] * (n + 1)
    dist[0], dist[1] = 0, 0
    d = deque()
    d.append(1)
    while d:
        v = d.popleft()
        for i in graph[v]:
            if dist[i] != -1:
                continue
            dist[i] = dist[v] + 1
            d.append(i)
    return dist


N, Q = map(int, input().split())
graph = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
dist = hukasa(graph, N)
for _ in range(Q):
    c, d = map(int, input().split())
    if (dist[d] - dist[c]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from sys import stdin

input = stdin.readline

N, Q = map(int, input().split())
edges = [list(map(int, input().split())) for i in range(N - 1)]
xy = [list(map(int, input().split())) for i in range(Q)]


def BFS(K, edges, N):
    roots = [[] for i in range(N)]
    for a, b in edges:
        roots[a - 1] += [(b - 1, 1)]
        roots[b - 1] += [(a - 1, 1)]
    dist = [-1] * N
    stack = []
    stack.append(K)
    dist[K] = 0
    while stack:
        label = stack.pop(-1)
        for i, c in roots[label]:
            if dist[i] == -1:
                dist[i] = dist[label] + 1
                stack += [i]
    return dist


distance = BFS(1, edges, N)
for i in range(Q):
    print(['Town',
           'Road'][(distance[xy[i][0] - 1] + distance[xy[i][1] - 1]) % 2])
N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]
cd = [list(map(int, input().split())) for _ in range(Q)]

G = [[] for _ in range(N)]
for a, b in ab:
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1 for _ in range(N)]
#"dist[0] = 0

from collections import deque

Qu = deque()
Qu.append(0)

while len(Qu) > 0:
    i = Qu.popleft()

    for j in G[i]:
        if dist[j] == -1:
            dist[j] = dist[i] + 1
            Qu.append(j)
for c, d in cd:
    c -= 1
    d -= 1
    diff = dist[c] - dist[d]
    if diff % 2 != 0:
        print('Road')
    else:
        print('Town')
# BFS, breadth first search, 幅優先探索
from collections import defaultdict, deque

N, Q = map(int, input().split())
# 隣接リストはdefaultdictで管理すると楽
G = defaultdict(lambda: [])

for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

INF = 10**18
dist = [INF] * N
parent = [-1] * N  # 親ノード
q = deque()

dist[0] = 0
q.append(0)
while q:
    now = q.popleft()  # now: 探索起点
    for to in G[now]:  # to: 隣接リストの接続先
        if dist[to] != INF:  # toをすでに探索していたらINFではない。
            continue
        dist[to] = dist[now] + 1  # 距離の更新
        parent[to] = now
        q.append(to)

out = []
for i in range(Q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if abs(dist[a] - dist[b]) % 2 == 1:
        out.append("Road")
    else:
        out.append("Town")
print(*out, sep="\n")
from heapq import heappush, heappop

INF = 10**9


def dijkstra(s, n, adj):
    dist = [INF] * n
    hq = [(0, s)]
    dist[s] = 0
    seen = [False] * n
    while hq:
        v = heappop(hq)[1]
        seen[v] = True
        for to, cost in adj[v]:
            if seen[to] == False and dist[v] + cost < dist[to]:
                dist[to] = dist[v] + cost
                heappush(hq, (dist[to], to))
    return dist


n, q = map(int, input().split())
adj = [[] for _ in range(n)]
for i in range(n - 1):
    ai, bi = map(int, input().split())
    adj[ai - 1].append((bi - 1, 1))
    adj[bi - 1].append((ai - 1, 1))

dist = dijkstra(0, n, adj)

for i in range(q):
    ci, di = map(int, input().split())
    if (dist[ci - 1] + dist[di - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
def main():
    N, Q = map(int, input().split())
    from collections import defaultdict
    d = defaultdict(list)
    for _ in range(N - 1):
        a, b = map(int, input().split())
        d[a].append(b)
        d[b].append(a)
    ans = [0] * (1 + N)

    from collections import deque
    q = deque([1])
    visited = [False] * (1 + N)
    while q:
        t = q.popleft()
        visited[t] = True
        for nxt in d[t]:
            if visited[nxt]:
                continue
            q.append(nxt)
            ans[nxt] = 1 if ans[t] == 0 else 0

    for _ in range(Q):
        c, d = map(int, input().split())
        if ans[c] == ans[d]:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
from heapq import *

n, q = map(int, input().split())
INF = 10**9 + 7

G = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)


def dijkstra_heap(siten):
    """
    1-indexed
    疎グラフの時に有効　O(E log(V))
    :return:
    """
    dist = [INF] * (n + 1)
    dist[siten] = 0
    que = []
    heappush(que, (dist[siten], siten))
    while len(que):
        d, v = heappop(que)
        if d > dist[v]:
            continue
        for e in G[v]:
            if dist[e] > dist[v] + 1:
                dist[e] = dist[v] + 1
                heappush(que, (dist[e], e))
    return dist


dist = dijkstra_heap(1)  #1-indexedのlist
for i in range(q):
    c, d = map(int, input().split())
    tmp = dist[c] - dist[d]
    if tmp % 2 == 0:
        print("Town")
    else:
        print("Road")
from heapq import heappush, heappop

INF = 10**9


def dijkstra(s, n):
    dist = [INF] * n
    hq = [(0, s)]
    dist[s] = 0
    seen = [False] * n
    while hq:
        v = heappop(hq)[1]
        seen[v] = True
        for to, cost in A[v]:
            if seen[to] == False and dist[v] + cost < dist[to]:
                dist[to] = dist[v] + cost
                heappush(hq, (dist[to], to))
    return dist


N, Q = map(int, input().split())

A = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    A[a - 1].append((b - 1, 1))
    A[b - 1].append((a - 1, 1))

d = dijkstra(0, N)

for i in range(Q):
    a, b = map(int, input().split())
    if abs(d[a - 1] - d[b - 1]) % 2 == 1:
        print("Road")
    else:
        print("Town")
from collections import deque

N, Q = map(int, input().split())
matrix = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    matrix[a - 1].append(b - 1)
    matrix[b - 1].append(a - 1)
    matrix[i].append(i)

visited = [0 for _ in range(N)]
visited[0] = 1
d = deque([0])
cost = 1
cost_matrix = [1e9 for _ in range(N)]
cost_matrix[0] = 0
while d:
    for _ in range(len(d)):
        place = d.popleft()
        for i in matrix[place]:
            if not visited[i]:
                visited[i] = 1
                d.append(i)
                cost_matrix[i] = cost
    cost += 1
for _ in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (cost_matrix[c] + cost_matrix[d]) % 2 == 1:
        print('Road')
    else:
        print('Town')
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())

edges = [list() for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edges[a].append(b)
    edges[b].append(a)
# print(edges)

depth = 0
queue = deque([[0, -1, 0]])
dist = [0] * n

while queue:
    node, parent, depth = queue.popleft()
    dist[node] = depth

    for child in edges[node]:
        if child != parent:
            queue.append([child, node, depth + 1])
# print(dist)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import defaultdict, deque
# input: a_1 a_2がそれぞれ無向につがなっている
# 1 2
# 1 4
# 2 3
# 3 4
# このinputでは、1と２のノードが繋がっていて、1と４のノードが繋がっているetc..


def solve():
    N, Q = map(int, input().split())
    G = defaultdict(list)
    for i in range(N - 1):
        a, b = map(int, input().split())
        G[a].append(b)
        G[b].append(a)
    # print(G)
    # print(c, d)
    dist = [-1] * (N + 1)
    que = deque()

    dist[1] = 0
    que.append(1)
    while not len(que) == 0:
        v = que.popleft()

        for nv in G[v]:
            if not dist[nv] == -1: continue
            dist[nv] = dist[v] + 1
            que.append(nv)

    for _ in range(Q):
        c, d = map(int, input().split())
        result = "Town" if (dist[d] - dist[c]) % 2 == 0 else "Road"
        print(result)


if __name__ == '__main__':
    solve()
#!/usr/bin/env python3
import sys

sys.setrecursionlimit(10**7)
import bisect
import heapq
import itertools
import math
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from math import gcd
from functools import reduce
from operator import add, itemgetter, mul, xor
from heapq import heappush, heappop


def cmb(n, r, mod):
    bunshi = 1
    bunbo = 1
    for i in range(r):
        bunbo = bunbo * (i + 1) % mod
        bunshi = bunshi * (n - i) % mod
    return (bunshi * pow(bunbo, mod - 2, mod)) % mod


def I():
    return int(input())


def LI():
    return list(map(int, input().split()))


def MI():
    return map(int, input().split())


def LLI(n):
    return [list(map(int, input().split())) for _ in range(n)]


def LL(n):
    return [list(input()) for i in range(n)]


def combinations_count(n, r):
    r = min(r, n - r)
    numer = reduce(mul, range(n, n - r, -1), 1)
    denom = reduce(mul, range(1, r + 1), 1)
    return numer // denom


#bisect.bisect_left(list,key)はlistのなかでkey未満の数字がいくつあるかを返す
#つまりlist[i] < x となる i の個数
#bisect.bisect_right(list, key)はlistのなかでkey以下の数字がいくつあるかを返す
#つまりlist[i] <= x となる i の個数
#これを応用することで
#len(list) - bisect.bisect_left(list,key)はlistのなかでkey以上の数字がいくつあるかを返す
#len(list) - bisect.bisect_right(list,key)はlistのなかでkeyより大きい数字がいくつあるかを返す
#これらを使うときはあらかじめlistをソートしておくこと！

n, q = MI()
G = [[] for _ in range(n + 1)]
for i in range(n - 1):
    a, b = MI()
    G[a].append(b)
    G[b].append(a)
depth = [-1 for _ in range(n + 1)]


#depth[v]は頂点vの深さ
def dfs(graph, v, p=-1, d=0):
    depth[v] = d
    for next_v in graph[v]:
        if next_v == p:
            continue
        dfs(graph, next_v, v, d + 1)


dfs(G, 1)
for i in range(q):
    c, d = MI()
    size_c = depth[c]
    size_d = depth[d]
    if (size_c - size_d) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(100000)

N, Q = map(int, input().split())

graph = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1] += [b - 1]
    graph[b - 1] += [a - 1]

color = [0] * N


def dfs(n, d):
    if d % 2 == 0:
        color[n] = 2
    else:
        color[n] = 1

    for g in graph[n]:
        if color[g] == 0:
            dfs(g, d + 1)


dfs(0, 0)

for i in range(Q):
    c, d = map(int, input().split())

    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
R = lambda: map(int, input().split())
n, q = R()
g = [None] + [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = R()
    g[b].append(a)
    g[a].append(b)
C = [None] * (n + 1)
C[1] = 0
s = [1]
while s:
    u = s.pop()
    for v in g[u]:
        if C[v] is None:
            s.append(v)
            C[v] = C[u] ^ 1
for _ in range(q):
    c, d = R()
    print('TRoowand'[(C[c] ^ C[d]) & 1::2])
import heapq

N, Q = map(int, input().split())
road = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)

distance = [0] * N
que = [(0, 0)]
heapq.heapify(que)

arrived = {}
while que:
    now = heapq.heappop(que)
    distance[now[1]] = now[0]
    arrived[now[1]] = 1
    for town in road[now[1]]:
        if town not in arrived:
            heapq.heappush(que, (now[0] + 1, town))

for _ in range(Q):
    c, d = map(int, input().split())
    if (distance[c - 1] - distance[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
import math
import bisect
import random
from itertools import permutations, accumulate, combinations, product
import sys
import string
from bisect import bisect_left, bisect_right
from math import factorial, ceil, floor
from operator import mul
from functools import reduce

sys.setrecursionlimit(2147483647)
INF = 10**13


def LI():
    return list(map(int, sys.stdin.buffer.readline().split()))


def I():
    return int(sys.stdin.buffer.readline())


def LS():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()


def S():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8')


def IR(n):
    return [I() for i in range(n)]


def LIR(n):
    return [LI() for i in range(n)]


def SR(n):
    return [S() for i in range(n)]


def LSR(n):
    return [LS() for i in range(n)]


def SRL(n):
    return [list(S()) for i in range(n)]


def MSRL(n):
    return [[int(j) for j in list(S())] for i in range(n)]


mod = 1000000007


class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(int, input().split())
    G[x - 1] += [y - 1]
    G[y - 1] += [x - 1]

lca = LCA(G)
for _ in range(Q):
    c, d = map(int, input().split())
    common = lca.get(c - 1, d - 1)
    if (lca.depth[c - 1] + lca.depth[d - 1] - 2 * lca.depth[common]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
k = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    k[a - 1].append(b - 1)
    k[b - 1].append(a - 1)
from collections import deque

x = [-1] * n
x[0] = 0
d = deque()
d.append(0)
visit = [1] * n
visit[0] = 0
while d:
    g = d.popleft()
    for i in k[g]:
        if visit[i]:
            d.append(i)
            visit[i] = 0
            if x[g] == 0:
                x[i] = 1
            elif x[g] == 1:
                x[i] = 0
for i in range(q):
    c, d = map(int, input().split())
    if x[c - 1] == x[d - 1]:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

dist = [-1] * N
que = deque([0])
dist[0] = 0

while que:
    v = que.popleft()
    d = dist[v]
    for w in G[v]:
        if dist[w] > -1:
            continue
        dist[w] = d + 1
        que.append(w)

q = [] * Q
for i in range(Q):
    c, d = map(int, input().split())
    q.append([c - 1, d - 1])

for i in range(Q):
    if abs(dist[q[i][1]] - dist[q[i][0]]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(100000)

N, Q = map(int, input().split())

bridges = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    bridges[a - 1].append(b - 1)
    bridges[b - 1].append(a - 1)
a = [-1] * N
a[0] = 0


def bfs(c):
    for i in bridges[c]:
        if a[i] == -1:
            a[i] = 0 if a[c] else 1
            bfs(i)


bfs(0)

for i in range(Q):
    x, y = map(int, input().split())
    print('Road' if a[x - 1] != a[y - 1] else 'Town')
import sys
import math
import itertools
import collections
from typing import AnyStr

stdin = sys.stdin
ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().rstrip()  # ignore trailing spaces

n, q = na()
root = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = na()
    root[a - 1].append(b - 1)
    root[b - 1].append(a - 1)

color = [-1] * n
color[0] = 0
que = collections.deque()
que.append(0)
while que:
    t = que.popleft()
    for nxt in root[t]:
        if color[nxt] < 0:
            color[nxt] = (color[t] + 1) % 2
            que.append(nxt)

r = []
for _ in range(q):
    c, d = na()
    if color[c - 1] == color[d - 1]:
        r.append("Town")
    else:
        r.append("Road")

for i in range(q):
    print(r[i])
import math
import itertools
import bisect
import heapq
from sys import stdin
from collections import deque
from sys import setrecursionlimit
from functools import reduce
from collections import defaultdict

setrecursionlimit(10**7)
input = stdin.readline


def I():
    return int(input())


def IN():
    return map(int, input().split())


def LI():
    return list(map(int, input().split()))


def LIN():
    return [list(map(int, input().split())) for _ in range(N)]


N, Q = IN()
m = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = IN()
    a -= 1
    b -= 1
    m[a].append(b)
    m[b].append(a)

p = [-1] * N
p[0] = 0
que = deque()
que.append(0)
while que:
    j = que.popleft()

    for k in m[j]:
        if p[k] == -1:
            p[k] = 1 - p[j]
            que.append(k)
for j in range(Q):
    c, d = IN()
    if p[c - 1] == p[d - 1]:
        print("Town")
    else:
        print("Road")
def dfs(cur, prev):
    global depth, parent
    depth[cur] = depth[prev] + 1
    parent[cur][0] = prev
    for next_ in tree[cur]:
        if next_ != prev:
            dfs(next_, cur)


def addEdge(u, v):
    global tree
    tree[u].append(v)
    tree[v].append(u)


def precompute(n):
    for i in range(1, level):
        for node in range(1, n + 1):
            if parent[node][i - 1] != -1:
                parent[node][i] = parent[parent[node][i - 1]][i - 1]


def lca(u, v):
    if depth[v] < depth[u]:
        u, v = v, u

    diff = depth[v] - depth[u]

    for i in range(level):
        if ((diff >> i) & 1):
            v = parent[v][i]

    if u == v:
        return u

    for i in range(level - 1, -1, -1):
        if (parent[u][i] != parent[v][i]):
            u = parent[u][i]
            v = parent[v][i]

    return parent[u][0]


import sys

sys.setrecursionlimit(200002)

MAXN = 200002
level = 1

tree = [[] for _ in range(MAXN)]
depth = [0 for _ in range(MAXN)]
parent = [[-1 for _ in range(level)] for _ in range(MAXN)]

n, q = map(int, input().split())
for _ in range(n - 1):
    a, b = map(int, input().split())
    addEdge(a, b)

depth[0] = 0
dfs(1, 0)

precompute(n)

for i in range(q):
    c, d = map(int, input().split())
    if (depth[c] + depth[d] - 2 * lca(c, d)) % 2 != 0:
        print("Road")
    else:
        print("Town")
from collections import deque

N, Q = map(int, input().split())
INF = float('INF')
edge = [[] for n in range(N)]
for n in range(N - 1):
    a, b = map(int, input().split())
    #print(a,b)
    edge[a - 1] += [b - 1]
    edge[b - 1] += [a - 1]
#for e in edge:
#    print(e)

townColor = [-1 for n in range(N)]
townColor[0] = 0
#print(townColor)
d = deque([0])
while d:
    mypos = d.popleft()
    for i in edge[mypos]:
        if townColor[i] == -1:
            d.append(i)
            townColor[i] = townColor[mypos] + 1
#print(townColor)
for q in range(Q):
    c, d = map(int, input().split())
    if townColor[c - 1] % 2 == townColor[d - 1] % 2:
        print('Town')
    else:
        print('Road')
from collections import defaultdict
import sys

sys.setrecursionlimit(10**9)
n, q = map(int, (input().split()))
graph = defaultdict(list)
for _ in range(n - 1):
    ai, bi = map(int, input().split())
    graph[ai].append(bi)
    graph[bi].append(ai)
vis = [0] * (n + 1)
dp = [0] * (n + 1)


def dfs(node, val):
    vis[node] = 1
    for child in graph[node]:
        if vis[child] == 0:
            dfs(child, val + 1)
    dp[node] = val


dfs(1, 0)
for _ in range(q):
    ci, di = map(int, input().split())
    if (dp[di] - dp[ci]) % 2: print("Road")
    else: print("Town")
from collections import deque

N, Q = map(int, input().split())
city = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    city[a].append(b)
    city[b].append(a)
n_city = [-1] * (N + 1)
q = deque([])
q.append(1)
n_city[1] = 0
while q:
    x = q.pop()
    p = n_city[x]
    for i in city[x]:
        if n_city[i] != -1:
            continue
        q.append(i)
        n_city[i] = p ^ 1
for i in range(Q):
    c, d = map(int, input().split())
    if n_city[c] == n_city[d]:
        print("Town")
    else:
        print("Road")
# モジュールのインポート
import sys

sys.setrecursionlimit(1000000)

# 標準入力を取得
N, Q = list(map(int, input().split()))
g = {i: [] for i in range(1, N + 1)}
for _ in range(N - 1):
    a, b = list(map(int, input().split()))
    g[a].append(b)
    g[b].append(a)
q = []
for _ in range(Q):
    c, d = list(map(int, input().split()))
    q.append((c, d))

# 求解処理
t = {i: -1 for i in range(1, N + 1)}


def dfs(g: dict, t: dict, depth: int, node: int) -> None:
    if t[node] != -1:
        return
    t[node] = depth
    for child in g[node]:
        dfs(g, t, depth + 1, child)


dfs(g, t, 0, 1)

for c, d in q:
    if abs(t[c] - t[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())

AB_2d = [[] for _ in range(N)]
for _ in range(N - 1):
    A, B = map(int, input().split())
    AB_2d[A - 1].append(B - 1)
    AB_2d[B - 1].append(A - 1)

Q_2d = [list(map(int, input().split())) for _ in range(Q)]

que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in AB_2d[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for q in Q_2d:
    if color[q[0] - 1] == color[q[1] - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, Q = map(int, input().split())
l = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    l[a].append(b)
    l[b].append(a)
vis = [-1] * n
vis[0] = 0
q = deque([[0, 0]])
while q:
    node, cnt = q.popleft()
    for nd in l[node]:
        if vis[nd] == -1:
            vis[nd] = (cnt + 1) & 1
            q.append([nd, cnt + 1])
for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if vis[c] ^ vis[d]:
        print("Road")
    else:
        print("Town")
import queue

INF = 1000000000

N, Q = map(int, input().split())
g = [[] for _ in range(N)]

for i in range(N - 1):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    g[x].append(y)
    g[y].append(x)

q = queue.Queue()
dist = [INF] * N
dist[0] = 0
q.put(0)
while (not q.empty()):
    v = q.get()
    for u in g[v]:
        if (dist[u] != INF):
            continue
        dist[u] = dist[v] + 1
        q.put(u)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] == dist[d]):
        print("Town")
        continue

    print("Road" if abs(dist[c] - dist[d]) % 2 == 1 else "Town")
import sys


def read():
    return sys.stdin.readline().rstrip()


def main():
    n, q = map(int, read().split())
    al = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = [int(i) - 1 for i in read().split()]
        al[a].append(b)
        al[b].append(a)
    todo = [(0, 0)]
    seen = [False] * n
    color = [0] * n
    while todo:
        v, p = todo.pop()
        if seen[v]:
            continue
        seen[v] = True
        color[v] = p
        for u in al[v]:
            todo.append((u, 1 - p))
    for _ in range(q):
        c, d = [int(i) - 1 for i in read().split()]
        print("Town" if color[c] == color[d] else "Road")


if __name__ == '__main__':
    main()
from collections import deque


def main():
    N, Q = map(int, input().split())
    g = [[] for _ in range(N)]

    for _ in range(N - 1):
        A, B = map(int, input().split())
        A -= 1
        B -= 1
        g[A].append(B)
        g[B].append(A)

    q = deque()
    q.append(0)
    dist = [-1] * N
    dist[0] = 0

    while q:
        now = q.popleft()

        for nxt in g[now]:
            if dist[nxt] == -1:
                dist[nxt] = dist[now] + 1
                q.append(nxt)

    for _ in range(Q):
        C, D = map(int, input().split())
        C -= 1
        D -= 1

        if (dist[C] + dist[D]) % 2 == 0:
            print("Town")
        else:
            print("Road")


main()
import heapq
import sys

sys.setrecursionlimit(3000000)

n, q = map(int, input().split())

g = [[] for _ in range(n + 1)]

color = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

for i in range(1, n + 1):
    g[i].sort()


def bfs(start, bef, dim):

    if dim % 2 == 0:
        color[start] = "○"
    else:
        color[start] = "x"
    dim += 1
    for s in g[start]:
        if s != bef:
            bfs(s, start, dim)

    dim -= 1


dim = 1
bfs(1, -1, dim)

for i in range(q):
    c, d = map(int, input().split())
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
import queue

n, q = map(int, input().split())

g = [[] for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

que = queue.Queue()

color = [-1] * n
color[0] = 0

que.put(0)

while not que.empty():
    t = que.get()
    for i in g[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(q):
    c, d = map(int, input().split())
    if color[c - 1] + color[d - 1] != 1:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
adj = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)
c = [0] * q
d = [0] * q
for i in range(q):
    c[i], d[i] = map(int, input().split())
    c[i] -= 1
    d[i] -= 1

from collections import deque

que = deque()
que.append(0)
seen = [-1] * (n)
seen[0] = 0
par = [0] * (n)
child = [[] for _ in range(n)]
seq = []
while que:
    v = que.popleft()
    seq.append(v)
    for u in adj[v]:
        if seen[u] == -1:
            seen[u] = seen[v] + 1
            par[u] = v
            child[v].append(u)
            que.append(u)

for i in range(q):
    ans = seen[c[i]] - seen[d[i]]
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

from heapq import heappush, heappop


class dijkstra:
    # 初期化(ノード数)
    def __init__(self, n):
        # ノード数
        self.num = n
        # エッジ情報の格納先　edge[start]=[(end,cost),(end,cost),・・・]
        self.edge = [[] for _ in range(n)]

    # エッジの追加(0index)
    def edge_add(self, start, end, cost):
        self.edge[start].append((end, cost))

    # スタート地点からそれぞれの点への最短距離を計算
    # O((ノード数+エッジ数)log(ノード数)
    def to_end(self, start):
        # 到達不能距離
        inf = 10**15
        # スタートからの距離
        dist = [inf] * self.num
        # 固定されているかどうか
        fixed = [False] * self.num
        # スタート地点からスタート地点への距離は0
        dist[start] = 0
        # スタート地点をキューに入れる
        hq = [(0, start)]
        while hq:
            # now_cost=今いる場所に書いてるコスト、now_place=今いる場所
            now_cost, now_place = heappop(hq)
            # すでに終わっていれば
            if fixed[now_place] == True:
                continue
            # 今いる場所のコストを固定
            fixed[now_place] = True
            # 今いる場所から行ける場所を順に回る
            for to_place, to_cost in self.edge[now_place]:
                # 固定されていなくて、よりコストが低いなら
                if fixed[to_place] == False and now_cost + to_cost < dist[
                        to_place]:
                    # コストを書き換え
                    dist[to_place] = now_cost + to_cost
                    # キューに入れる
                    heappush(hq, (dist[to_place], to_place))
        return dist


dij = dijkstra(n)
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1

    dij.edge_add(a, b, 1)
    dij.edge_add(b, a, 1)

dist = dij.to_end(0)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if dist[c] % 2 == dist[d] % 2:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
g = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)
#幅優先探索
color = [-1 for i in range(N)]
color[0] = 0
q = deque([])
q.append(0)
while q:
    e = q.pop()
    for i in g[e]:
        if color[i] == -1:
            color[i] = 1 - color[e]
            q.append(i)
#print(color)
for i in range(Q):
    c, d = map(int, input().split())
    print("Road") if color[c - 1] != color[d - 1] else print("Town")
import sys

input = sys.stdin.readline

from collections import deque


def bfs(start):
    queue = deque([start])
    sign = [-1] * (n)  # 最短経路長 / 最短経路 到達可能 False
    sign[start] = 0  # 最短経路長 自分との距離は0(1往復を考えるときは消す) / 最短経路 到達可能 sign[start] = 1
    while queue:
        node = queue.popleft()  # .pop()ならdfs
        for near in nears[node]:
            if sign[near] == -1:  # 最短経路長 / 最短経路 到達可能 False
                sign[near] = sign[
                    node] + 1  # 最短経路長 / 最短経路 sign[near] = node / 到達可能 sign[near] = 1
                queue.append(near)
    return sign


n, q = [int(x) for x in input().split()]  # nは頂点の数、mは辺の数
nears = [[] for _ in range(n)]  # 隣接リスト

for _ in range(n - 1):
    a, b = [int(x) for x in input().split()]
    nears[a - 1].append(b - 1)
    nears[b - 1].append(a - 1)  # 有向グラフの場合は消す

d = bfs(0)
d = [0 if i % 2 == 0 else 1 for i in d]
#print(d)

for _ in range(q):
    x, y = list(map(int, input().split()))
    if abs(d[x - 1] - d[y - 1]) == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**8)
N, Q = map(int, input().split())
roads = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    roads[a].append(b)
    roads[b].append(a)

dist = [-1] * N
dist[0] = 0


def count_dist(i):
    for j in roads[i]:
        if dist[j] == -1:
            dist[j] = dist[i] + 1
            count_dist(j)
    return


count_dist(0)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (dist[c] + dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
graphs = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a = a - 1
    b = b - 1
    graphs[a].append(b)
    graphs[b].append(a)
dist = [-1] * (n)
dist[0] = 0  #頂点0を親とする深さ優先探索

d = deque()
d.append(0)

while d:
    v = d.popleft()
    for i in graphs[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)
for j in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if (abs((dist[c] - dist[d])) % 2 == 0):
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
edge = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)
# print("edge:",edge)
from collections import deque

que = deque()
depth = [-1 for i in range(n)]
# depth[0]=0
que.append((0, 0))
# print("que:",que,"depth:",depth)
while len(que) > 0:

    node, dep = que.pop()
    depth[node] = dep
    # print("q:",q)
    # tmp=0
    # print("Q:",q)
    # t=edge(q)
    # print(t)
    # tmp=0
    for child in edge[node]:
        if depth[child] < 0:
            que.append((child, dep + 1))
            # print("child:",child,"dep:",dep+1)
        else:
            continue

for j in range(q):
    ans = 0
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    ans += depth[a] + depth[b]
    ans %= 2
    print(["Town", "Road"][ans])
i1 = lambda: input()
i2 = lambda: int(input())
i3 = lambda: map(int, input().split())
i4 = lambda n: [list(map(int, input().split()) for _ in range(n))]

import sys

sys.setrecursionlimit(1000000)

N, Q = i3()

INF = float('infinity')

G = [[] for _ in range(N + 1)]
for i in range(N - 1):
    s, t = i3()
    G[s].append(t)
    G[t].append(s)

# N=4
# Q=1
# G=[[], [2], [1,3,4], [2], [2]]
# S=[[1,2]]

V = [0] * (N + 1)


def dfs(i, count):
    if V[i] != 0: return
    V[i] = count
    for p in G[i]:
        dfs(p, count + 1)
    return


R = 1
dfs(R, 0)
S = [list(map(int, input().split())) for _ in range(Q)]

for i in range(Q):
    c, d = S[i]
    if (V[c] + V[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import defaultdict as dd

N, Q = map(int, input().split())
Es = dd(dict)
for _ in range(N - 1):
    a, b = map(int, input().split())
    Es[a - 1][b - 1] = Es[b - 1][a - 1] = 1

q = [[0, 0]]
Xs = [None] * N
while q:
    node, x = q.pop()
    Xs[node] = x
    nx = (x + 1) % 2
    for to in Es[node].keys():
        if Xs[to] is not None: continue
        q.append([to, nx])

for _ in range(Q):
    c, d = map(int, input().split())
    if Xs[c - 1] == Xs[d - 1]:
        print('Town')
    else:
        print('Road')
from collections import deque


def main():
    N, Q = map(int, input().split())
    path_dat = [list(map(int, input().split())) for _ in range(N - 1)]
    queries = [list(map(int, input().split())) for _ in range(Q)]

    paths = [[] for _ in range(N)]
    for a, b in path_dat:
        a -= 1
        b -= 1
        paths[a].append(b)
        paths[b].append(a)

    dist = [-1] * N
    dist[0] = 0
    queue = deque([0])
    while queue:
        now = queue.popleft()
        for nxt in paths[now]:
            if dist[nxt] != -1:
                continue
            dist[nxt] = dist[now] + 1
            queue.append(nxt)

    for c, d in queries:
        c -= 1
        d -= 1
        tmp = dist[c] + dist[d]
        if tmp % 2 == 0:
            print('Town')
        else:
            print('Road')


main()
# = int(input())
n, q = map(int, input().split())
# = list(map(int,input().split()))
# = [list(map(int,input().split())) for _ in range(N)]

connection_array = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    connection_array[a].append(b)
    connection_array[b].append(a)

zero_one = [0 for _ in range(n)]

now_node = [0]
zero_one[0] = 1
now_number = 1

while len(now_node) != 0:
    improve_node_array = []
    for node_ in now_node:
        for candidate_node in connection_array[node_]:
            if zero_one[candidate_node] == 0:
                improve_node_array.append(candidate_node)
    now_number *= -1
    for node_ in improve_node_array:
        zero_one[node_] = now_number

    now_node = improve_node_array

for _ in range(q):
    c, d = map(int, input().split())
    if zero_one[c - 1] == zero_one[d - 1]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    g[a].append(b)
    g[b].append(a)
cd = [list(map(int, input().split())) for _ in range(q)]
from collections import deque


def bfs():
    q = deque()
    dist = [-1] * n
    q.append(0)
    dist[0] = 0
    while q:
        v = q.popleft()
        for v1 in g[v]:
            if dist[v1] == -1:
                dist[v1] = dist[v] + 1
                q.append(v1)
    return dist


dist = bfs()
for c, d in cd:
    if (dist[c - 1] - dist[d - 1]) % 2 == 1:
        print('Road')
    else:
        print('Town')
from collections import deque

n, q = map(int, input().split())
g = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

li = [0] * n
li[0] = 1
to = deque([0])

lis = [0] * n

while len(to):
    v = to.pop()
    for i in g[v]:
        if li[i]: continue
        li[i] = 1
        lis[i] ^= lis[v] ^ 1
        to.append(i)

ans = []
for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if lis[c] == lis[d]: ans.append("Town")
    else: ans.append("Road")

[print(i) for i in ans]
from collections import defaultdict, deque
from heapq import heappop, heappush
import math
import sys
import itertools
import bisect
#sys.setrecursionlimit(10**9)
#import numpy as np
import decimal

INF = float('inf')


class UnionFind():
    def __init__(self, n):
        # classのお気持ち
        self.n = n
        #0~n-1の要素がありすべての要素の親は-1
        self.parents = [-1] * n

    def find(self, x):
        #xがどこにいるかを探している
        #親だったら自分を子だったら親を返す
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        #要素xとyを結合する
        #xとyの親を探す
        x = self.find(x)
        y = self.find(y)
        if x == y:
            #親が同じだったらそのまま
            return
        if self.parents[x] > self.parents[y]:
            x, y = y, x
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        #xが含まれるunionのサイズ
        return -self.parents[self.find(x)]

    def same(self, x, y):
        #xとyが同じunionであるかの判定
        return self.find(x) == self.find(y)

    def members(self, x):
        #xが含まれるunionのメンバー
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        #親の集合
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        #unionの数
        return len(self.roots())

    def all_group_members(self):
        group_members = defaultdict(list)
        for member in range(self.n):
            group_members[self.find(member)].append(member)
        return group_members

    def __str__(self):
        return '\n'.join(f'{r}: {m}'
                         for r, m in self.all_group_members().items())


def comb(n, r, mod):
    if r < 0 or n < r:
        return 0
    N = n
    fact = [1, 1]
    factinv = [1, 1]
    inv = [0, 1]
    for i in range(2, N + 1):
        fact.append((fact[-1] * i) % mod)
        inv.append((-inv[mod % i] * (mod // i)) % mod)
        factinv.append((factinv[-1] * inv[-1]) % mod)
    r = min(r, n - r)
    return fact[n] * factinv[r] * factinv[n - r] % mod


def is_prime(n):
    #nが素数であるかの判定
    if n == 1:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % k == 0:
            return False
    return True


def primes(n):
    #nまでの素数列挙
    #リストのその番目が1だったら素数(0から)
    nums = [0, 1] * (n // 2 + 1)
    if n % 2 == 0:
        nums.pop()
    nums[1] = 0
    nums[2] = 1
    for p in range(3, int(n**0.5) + 1, 2):
        if nums[p]:
            for q in range(p**2, n + 1, 2 * p):
                nums[q] = 0
    return nums


def soinsu(n):
    ans = []
    num = n
    for i in range(2, int(-(-n**0.5 // 1)) + 1):
        if num % i == 0:
            coun = 0
            while num % i == 0:
                coun += 1
                num //= i
            ans.append([i, coun])
    if num != 1:
        ans.append([num, 1])
    if ans == []:
        ans.append([n, 1])
    return ans


def arr_pow(A, p, mod):
    res = np.eye(A.shape[0], dtype=np.int64)
    while p:
        if p & 1:
            res = np.dot(res, A) % mod
        A = np.dot(A, A) % mod
        p >>= 1
    return res


def dijk(n, road, start):
    #(町の数,道路のリスト,出発地点)
    dist = [INF for _ in range(n + 1)]
    dist[start] = 0
    visit = [False for _ in range(n + 1)]
    hq = [(0, start)]  #(距離,場所)
    while hq:
        h = heappop(hq)
        dis = h[0]
        pla = h[1]
        if visit[pla]:
            continue
        visit[pla] = True
        for q in road[pla]:
            num = q[0]
            cost = q[1]
            if visit[num] == False:
                if dist[num] > dist[pla] + cost:
                    dist[num] = dist[pla] + cost
                    heappush(hq, (dist[pla] + cost, num))
    return dist


def arr_arr(A, B, mod):
    I, J, K = len(A), len(B[0]), len(B)
    c = [[0] * J for _ in range(I)]
    for i in range(I):
        for j in range(J):
            for k in range(K):
                c[i][j] += A[i][k] * B[k][j]
            c[i][j] %= mod
    return c


def arr_pow(x, n, mod):
    #行列の累乗
    #x^n
    y = [[0] * len(x) for _ in range(len(x))]
    for i in range(len(x)):
        y[i][i] = 1
    while n > 0:
        if n & 1:
            y = arr_arr(x, y, mod)
        x = arr_arr(x, x, mod)
        n >>= 1
    return y


def w_f(N, road):
    #ワ―シャルフロイド法
    #(街の数、道路のリスト)
    dist = [[INF for _ in range(N)] for _ in range(N)]
    for i in range(N):
        dist[i][i] = 0
    for i in range(N):
        for k in road[i + 1]:
            dist[i][k[0] - 1] = min(k[1], dist[i][k[0] - 1])
    for k in range(N):
        for i in range(N):
            for j in range(N):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    return dist


# ord('a') = 97 ord('z') = 122 ord('A') = 65 ord('Z') = 90

################################
#　　　目　　　　　　次　　　　　 #
################################

# class UnionFind
# find(x) xの親を返す(親だったら自分)
# union(x,y) xとyを結合する
# size(x) xが含まれるunionのサイズ
# same(x,y) xとyが同じかの判定
# members(x) xが含まれるunionのメンバー
# roots() 親の集合
# group_count() unionの数
# all_group_members　辞書型でunion全体を返す
#comb(n,r,mod) nCr (mod)
#is_prime(n) nが素数かの判定
#primes(n) nまでの整数列挙
#soinsu(n) nを素因数分解
#arr_pow(A, p, mod) 行列累乗
#dijk(n,road,start) ダイクストラn個の街road道のリストstart開始位置
#arr_arr(A,B,mod) 行列A*B
#w_f(N,road) ワ―シャルフロイド法

#################################
# ここからコードが始まったりする #
#################################

N, Q = map(int, input().split())
road = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    road[a].append(b)
    road[b].append(a)
dist = [-1 for _ in range(N + 1)]
visit = [False for _ in range(N + 1)]
dist[1] = 1
d = deque([1])
while d:
    q = d.popleft()
    visit[q] = True
    p = dist[q]
    for num in road[q]:
        if visit[num]:
            continue
        dist[num] = (p + 1) % 2
        d.append(num)
for _ in range(Q):
    c, d = map(int, input().split())
    if dist[c] == dist[d]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())
G = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

query = []
for i in range(q):
    query.append(list(map(int, input().split())))

from collections import deque


#引数はリストと開始点
def bfs(graph, first):
    que = deque()
    dist[first] = 0
    que.append(first)

    while que:
        v = que[0]
        que.popleft()

        for i in graph[v]:
            if (dist[i] != -1):
                continue

            dist[i] = dist[v] + 1
            que.append(i)
    return dist


dist = [-1] * n
bfs(G, 0)
for i in query:
    if (dist[i[0] - 1] + dist[i[1] - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
arrAB = [list(map(int, input().split())) for i in range(N - 1)]
arrCD = [list(map(int, input().split())) for i in range(Q)]

grp = [[] for i in range(N)]
for a, b in arrAB:
    grp[a - 1].append(b - 1)
    grp[b - 1].append(a - 1)

que = deque([])
dist = [-1] * N
dist[0] = 0
que.append(0)

while len(que) > 0:
    v = que.popleft()
    for next_v in grp[v]:
        if dist[next_v] != -1:
            continue

        dist[next_v] = dist[v] + 1
        que.append(next_v)

for c, d in arrCD:
    l1 = dist[c - 1]
    l2 = dist[d - 1]
    if (l1 + l2) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import Counter, defaultdict, deque
from heapq import heappop, heappush, heapify
from bisect import bisect_left, bisect_right
import sys, math, itertools, pprint, fractions

sys.setrecursionlimit(10**8)
mod = 10**9 + 7
INF = float('inf')


def inp():
    return int(sys.stdin.readline())


def inpl():
    return list(map(int, sys.stdin.readline().split()))


def inpl_1():
    return list(map(lambda x: int(x) - 1, sys.stdin.readline().split()))


def err(x):
    print(x)
    exit()


LV = 20


def construct(prv):
    kprv = [prv]
    S = prv
    for k in range(20):
        T = [-1] * n
        for i in range(n):
            if S[i] == -1:
                continue
            T[i] = S[S[i]]
        kprv.append(T)
        S = T
    return kprv


def lca(u, v, kprv, depth):
    dd = depth[v] - depth[u]
    if dd < 0:
        u, v = v, u
        dd = -dd

    # assert depth[u] <= depth[v]
    for k in range(LV + 1):
        if dd & 1:
            v = kprv[k][v]
        dd >>= 1

    # assert depth[u] == depth[v]
    if u == v:
        return u

    for k in range(LV - 1, -1, -1):
        pu = kprv[k][u]
        pv = kprv[k][v]
        if pu != pv:
            u = pu
            v = pv

    # assert kprv[0][u] == kprv[0][v]
    return kprv[0][u]


n, Q = inpl()
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = inpl_1()
    g[a].append(b)
    g[b].append(a)
pa = [-1] * n
dist = [0] * n
seen = [0] * n
seen[0] = 1
q = deque([0])
while q:
    u = q.popleft()
    for v in g[u]:
        if seen[v]: continue
        pa[v] = u
        dist[v] = dist[u] + 1
        q.append(v)
        seen[v] = 1

# pa[v] ->vの親ノード
#kprv[k][v] -> vから2^k回上に遡った時の頂点
kprv = construct(pa)
#dist[v] -> ルートからの深さ
#l -> a,bのLCA
for _ in range(Q):
    a, b = inpl_1()
    l = lca(a, b, kprv, dist)
    ln = dist[a] - dist[l] + dist[b] - dist[l]
    print('Town' if ln % 2 == 0 else 'Road')
n, q = map(int, input().split())
g = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

from collections import deque


def bfs(u):
    que = deque([u])
    l = [None] * n
    l[u] = 0
    while que:
        v = que.popleft()
        for i in g[v]:
            if l[i] is None:
                l[i] = l[v] + 1
                que.append(i)
    return l


l = bfs(0)
for i in range(n):
    l[i] %= 2

for i in range(q):
    c, d = map(int, input().split())
    if l[c - 1] == l[d - 1]:
        print("Town")
    else:
        print("Road")
import queue

n, Q = map(int, input().split())
ab = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    ab[a - 1].append(b - 1)
    ab[b - 1].append(a - 1)

points = [-1] * n
points[0] = 0

q = queue.Queue()
q.put(0)
while not q.empty():
    p = q.get()
    for i in ab[p]:
        if points[i] == -1:
            points[i] = points[p] + 1
            q.put(i)


def ans():
    c, d = map(int, input().split())
    c_depth = points[c - 1]
    d_depth = points[d - 1]
    if abs(c_depth - d_depth) % 2 == 0:
        print('Town')
    else:
        print('Road')


for _ in range(Q):
    ans()
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * N  #-1でなければ到達済み
color[0] = 0
que.put(0)

while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
# N개의 정점과 N-1개의 간선 & 한 지점에서 다른 지점으로 가는 경로가 반드시 존재 => 트리
from collections import deque
from sys import stdin

input = stdin.readline


def bfs(adj, vst, blackwhite):
    q = deque([(1, 1)])
    vst[1] = True
    blackwhite[1] = 1

    while q:
        curr, dist = q.popleft()
        for nxt in adj[curr]:
            if not vst[nxt]:
                q.append((nxt, dist + 1))
                vst[nxt] = True
                blackwhite[nxt] = (dist + 1) % 2


# c에서 d가 같은 색(검정, 하양) 이면 타운, 아니면 로드
N, Q = map(int, input().rstrip().split())
adj = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().rstrip().split())
    adj[a].append(b)
    adj[b].append(a)
BlackWithe = [None] * (N + 1)
visited = [False] * (N + 1)

bfs(adj, visited, BlackWithe)

queries = [tuple(map(int, input().rstrip().split())) for _ in range(Q)]
for query in queries:
    a, b = query[0], query[1]
    if BlackWithe[a] == BlackWithe[b]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())

edges = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    edges[a - 1].append(b - 1)
    edges[b - 1].append(a - 1)

# DFS
root = 0
heights = [-1] * n
heights[root] = 0
todo = [root]
while todo:
    a = todo.pop()
    for b in edges[a]:
        if heights[b] == -1:
            heights[b] = heights[a] + 1
            todo.append(b)

ans = ['Town'] * q
for i in range(q):
    c, d = map(int, input().split())
    if heights[c - 1] + heights[d - 1] & 1:
        ans[i] = 'Road'
print(*ans, sep='\n')
#!/usr/bin/env python3
import itertools
import sys

sys.setrecursionlimit(10**7)  #再帰回数の上限変更
import collections
from collections import deque
import copy
import bisect

inf = int(1e9)

n, q = map(int, input().split())

road = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)

C = []
D = []
for i in range(q):
    c, d = map(int, input().split())
    C.append(c - 1)
    D.append(d - 1)

Dist = [inf for _ in range(n)]


def bfs():
    que = deque()
    que.append(0)
    Dist[0] = 0

    while len(que) != 0:
        p = que.popleft()
        for i in road[p]:
            if Dist[i] == inf:
                que.append(i)
                Dist[i] = Dist[p] + 1
    return


bfs()

for i in range(q):
    tmp = (Dist[C[i]] - Dist[D[i]]) % 2
    if tmp == 1:
        print("Road")
    else:
        print("Town")
import sys
import math
from collections import deque

sys.setrecursionlimit(10**6)
INF = float('inf')


def solve():
    n, q = map(int, input().split())

    graph = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        graph[a].append(b)
        graph[b].append(a)

    visited = [False] * n

    logn = int(math.log(n, 2)) + 1
    pa = [[None for _ in range(n)] for _ in range(logn + 1)]
    depth = [None for _ in range(n)]

    def build():
        que = deque()
        que.append(0)
        depth[0] = 0
        c = [[] for _ in range(n)]
        while que:
            cur = que.popleft()
            visited[cur] = True

            for child in graph[cur]:
                if visited[child]:
                    continue
                depth[child] = depth[cur] + 1
                que.append(child)
                c[cur].append(child)

        for i in range(n):
            for child in c[i]:
                pa[0][child] = i
        for i in range(logn):
            for j in range(n):
                if pa[i][j] != None:
                    pa[i + 1][j] = pa[i][pa[i][j]]

    def query(u, v):
        def move(src, dst):
            return src, dst

        while depth[u] != depth[v]:
            if depth[v] < depth[u]:
                u, v = v, u
            d = depth[v] - depth[u]
            for k in range(logn):
                if d & 1:
                    move(v, pa[k][v])
                    v = pa[k][v]
                d = d >> 1
        for nk in range(logn):
            k = logn - nk - 1
            if pa[k][u] != pa[k][v]:
                move(u, pa[k][u])
                u = pa[k][u]
                move(v, pa[k][v])
                v = pa[k][v]
        if u == v:
            res = u
        else:
            move(u, pa[0][u])
            res = pa[0][u]

        return res

    depth[0] = 0
    build()

    ans = []
    for i in range(q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        parent = query(c, d)
        if (depth[c] - depth[parent] + depth[d] - depth[parent]) % 2 == 0:
            ans.append('Town')
        else:
            ans.append('Road')

    print(*ans, sep='\n')


if __name__ == '__main__':
    solve()
from collections import defaultdict


class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        group_members = defaultdict(list)
        for member in range(self.n):
            group_members[self.find(member)].append(member)
        return group_members

    def __str__(self):
        return '\n'.join(f'{r}: {m}'
                         for r, m in self.all_group_members().items())


n, q = map(int, input().split())
elist = [[] for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    elist[a - 1].append(b - 1)
    elist[b - 1].append(a - 1)
haji = 0
for i in range(n):
    if len(elist[i]) == 1:
        haji = i
        break
fukasa = [0 for i in range(n)]
import heapq

node_heap = []
heapq.heappush(node_heap, [haji])
done = [True] * n
while node_heap:
    tmp = heapq.heappop(node_heap)
    cur_node = tmp[0]

    for e in elist[cur_node]:
        if done[e]:
            fukasa[e] = fukasa[cur_node] + 1
            heapq.heappush(node_heap, [e])
    done[cur_node] = False
#print(fukasa)

for i in range(q):
    c, d = map(int, input().split())
    if (fukasa[c - 1] - fukasa[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**9)

N, Q = map(int, input().split())
adjL = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    adjL[a].append(b)
    adjL[b].append(a)
cds = [tuple(map(int, input().split())) for _ in range(Q)]


def bfsTree(vRoot):
    depths[vRoot] = 0
    QQQ = deque([vRoot])
    while QQQ:
        vNow = QQQ.popleft()
        vPar = pars[vNow]
        depth2 = depths[vNow] + 1
        for v2 in adjL[vNow]:
            if v2 == vPar: continue
            pars[v2] = vNow
            depths[v2] = depth2
            QQQ.append(v2)


numV = N  ###
vRoot = 0  ###

pars = [-1] * (numV)
depths = [-1] * (numV)

bfsTree(vRoot)


def getParssLCA(pars):
    numV = len(pars)
    maxD = numV.bit_length() - 1
    parss = [[-1] * (numV) for _ in range(maxD + 1)]
    for v in range(numV):
        parss[0][v] = pars[v]
    for d in range(1, maxD + 1):
        for v in range(numV):
            if parss[d - 1][v] != -1:
                parss[d][v] = parss[d - 1][parss[d - 1][v]]
    return parss, maxD


parss, maxD = getParssLCA(pars)


def getLCA(x, y):
    if depths[x] < depths[y]:
        x, y = y, x
    diff = depths[x] - depths[y]
    for d in range(maxD + 1):
        if (diff >> d) & 1:
            x = parss[d][x]
    if x == y:
        return x
    for d in reversed(range(maxD + 1)):
        if parss[d][x] != parss[d][y]:
            x = parss[d][x]
            y = parss[d][y]
    return parss[0][x]


anss = []
for c, d in cds:
    c, d = c - 1, d - 1
    LCA = getLCA(c, d)
    dist = abs(depths[c] - depths[LCA]) + abs(depths[d] - depths[LCA])
    if dist % 2:
        anss.append('Road')
    else:
        anss.append('Town')

print('\n'.join(anss))
from collections import deque

n, q = map(int, input().split())

g = []
for _ in range(n):
    g.append([])

for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)

dist = []
for _ in range(n):
    dist.append(-1)
Q = deque()
Q.append(0)
dist[0] = 0
while len(Q) > 0:
    i = Q.popleft()
    for j in g[i]:
        if dist[j] == -1:
            dist[j] = dist[i] + 1
            Q.append(j)
#print(saitan)
for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (abs(dist[c] - dist[d])) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**9)

n, q = map(int, input().split())

if n == 2:
    for i in range(q):
        print("Road")
    sys.exit()

road = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    road[a].append(b)
    road[b].append(a)
INF = float("inf")

le = [[] for _ in range(n + 1)]
seen = 1

start = 0
for i in range(1, n - 1):
    if len(road[i]) == 1:
        start = i
        break
le[start].append(1)


def dfs(cur, l):
    global seen
    if seen == n:
        return
    tind = 0
    tl = INF
    for t in road[cur]:
        if len(le[t]) == 0:
            tind = t
            seen += 1
            break
        elif max(le[t]) < tl:
            tl = max(le[t])
            tind = t
    le[tind].append(l + 1)
    dfs(tind, l + 1)


dfs(start, 1)

for i in range(q):
    x, y = map(int, input().split())
    ans = min(abs(max(le[x]) - min(le[y])), abs(max(le[y]) - min(le[x])))
    if ans % 2 == 1:
        print("Road")
    else:
        print("Town")
from random import randrange
import sys
from scipy.sparse.csgraph import dijkstra
from scipy.sparse import csr_matrix


def resolve(input):
    N, Q = map(int, input().split())
    ab = [list(map(int, input().split())) for _ in range(N - 1)]
    cd = [list(map(int, input().split())) for _ in range(Q)]

    g = csr_matrix(
        ([1] * (N - 1), ([x[0] - 1 for x in ab], [x[1] - 1 for x in ab])),
        shape=(N, N))
    r = dijkstra(g, directed=False, indices=0)

    for c, d in cd:
        c -= 1
        d -= 1
        if abs(r[c] - r[d]) % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    stdin = sys.stdin.readline

    resolve(stdin)
import networkx as nx

N, Q, *l = map(int, open(0).read().split())
A = l[0:2 * (N - 1):2]
B = l[1:2 * (N - 1):2]
C = l[2 * (N - 1)::2]
D = l[2 * (N - 1) + 1::2]

G = nx.Graph()
G.add_nodes_from(range(1, N + 1))

edges = [(A[i], B[i]) for i in range(len(A))]
G.add_edges_from(edges)  # 一括で追加

length = nx.single_source_shortest_path_length(G, 1)

for i in range(Q):

    c = C[i]
    d = D[i]
    if (length[c] - length[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

from collections import deque


def bfs(p):
    res = []
    used = [False] * (n)
    dq = deque()
    dq.append([p, 0])
    while dq:
        v, i = dq.popleft()
        if used[v]: continue
        used[v] = True
        res.append([v, i])
        for u in G[v]:
            dq.append([u, i + 1])
    return res


P = bfs(0)
P.sort()

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (P[c][1] + P[d][1]) % 2: print('Road')
    else: print('Town')
import sys

input = sys.stdin.readline
n, q = map(int, input().split())
l = [list(map(int, input().split())) for i in range(n - 1)]
l2 = [list(map(int, input().split())) for i in range(q)]

connection = [[] for i in range(n)]
for i in range(n - 1):
    connection[l[i][0] - 1].append(l[i][1] - 1)
    connection[l[i][1] - 1].append(l[i][0] - 1)


def bfs(v):
    distance = [-1] * n
    distance[v] = 0
    next = connection[v]
    next2 = set()
    visited = [-1] * n
    visited[v] = 1
    visitct = 1
    ct = 0
    while len(next) != 0 and visitct != n:
        ct += 1
        for i in range(len(next)):
            if visited[next[i]] == -1:
                distance[next[i]] = ct
                visited[next[i]] = 1
                visitct += 1
                for j in range(len(connection[next[i]])):
                    if visited[connection[next[i]][j]] == -1:
                        next2.add(connection[next[i]][j])
        next = list(next2)
        next2 = set()
    return distance


B = bfs(0)

par = [-1] * n
chi = [[] for i in range(n)]
root = 0

for i in range(n - 1):
    if B[l[i][0] - 1] < B[l[i][1] - 1]:
        par[l[i][1] - 1] = l[i][0] - 1
        chi[l[i][0] - 1].append(l[i][1] - 1)
    else:
        par[l[i][0] - 1] = l[i][1] - 1
        chi[l[i][1] - 1].append(l[i][0] - 1)


def eulerTour(par, chi):
    tank = [root]
    eulerTour = []
    left = [0] * n
    right = [-1] * n
    depth = [-1] * n
    eulerNum = -1
    de = -1

    while tank:
        q = tank.pop()
        if q >= 0:
            eulerNum += 1
            eulerTour.append(q)
            left[q] = eulerNum
            right[q] = eulerNum
            tank.append(~q)
            de += 1
            depth[q] = de
            for ch in chi[q]:
                tank.append(ch)
        else:
            de -= 1
            if ~q != root:
                eulerTour.append(par[~q])
                eulerNum += 1
                right[par[~q]] = eulerNum

    return eulerTour, depth, left, right


S = eulerTour(par, chi)[0]
depth = eulerTour(par, chi)[1]
F = eulerTour(par, chi)[2]

INF = (n, None)

M = 2 * n
M0 = 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


def LCA(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for i in range(q):
    x = depth[l2[i][0] - 1] + depth[l2[i][1] - 1] - 2 * depth[LCA(
        l2[i][0] - 1, l2[i][1] - 1)]
    if x % 2 == 1:
        print('Road')
    else:
        print('Town')
import sys

sys.setrecursionlimit(10**6)
N, Q = map(int, input().split())
adj = [[] for _ in range(N)]
nodes = [-1 for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    adj[a - 1].append(b - 1)
    adj[b - 1].append(a - 1)


def dfs(v, flag):
    global nodes
    nodes[v] = flag
    flag ^= 1
    for to in adj[v]:
        if nodes[to] == -1:
            dfs(to, flag)


dfs(0, 0)

for _ in range(Q):
    c, d = map(int, input().split())
    if (nodes[c - 1] + nodes[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**9)
n, q = map(int, input().split())
ablist = [list(map(int, input().split())) for i in range(n - 1)]
cdlist = [list(map(int, input().split())) for i in range(q)]

graph = [list() for i in range(n)]
for a, b in ablist:
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

edge_i = 0
for i, t in enumerate(graph):
    if len(t) == 1:
        edge_i = i
        break

distl = [-1] * n


def dist(n, d):
    distl[n] = d
    for t in graph[n]:
        if distl[t] != -1:
            continue
        dist(t, d + 1)


dist(edge_i, 0)

for c, d in cdlist:
    if abs(distl[c - 1] - distl[d - 1]) % 2 == 0:
        print("Town")
    else:
        print('Road')
import sys


#input()
def I():
    return sys.stdin.readline().rstrip()


#list(input())
def SI():
    return list(sys.stdin.readline().rstrip())


#int(input())
def II():
    return int(sys.stdin.readline().rstrip())


#map(int,input().split())
def MI():
    return map(int, sys.stdin.readline().rstrip().split())


#map(str, input().split())
def MS():
    return map(str, sys.stdin.readline().rstrip().split())


#list(map(int,input().split()))
def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


#行列
def LLI(rows_number):
    return [LI() for _ in range(rows_number)]


from heapq import heappop, heappush

n, Q = MI()
graph = [[] for _ in range(n)]
oe = [0] * n

for i in range(n - 1):
    a, b = MI()
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)


def dijkstra(s, g):  # 始点・隣接グラフ
    INF = 10**18
    check = [False] * n
    dist = [INF] * n
    dist[s] = 0
    q = [(0, s)]  # 距離・ノード
    while q:
        node = heappop(q)[1]  # 今いる所までの距離・そのノード
        if check[node]: continue
        check[node] = True
        for i in g[node]:  # これから行く所までの距離・そのノード
            if check[i]: continue
            if dist[i] <= dist[node] + 1: continue
            dist[i] = dist[node] + 1
            heappush(q, [dist[i], i])
    return dist


d = dijkstra(0, graph)
for i in range(n):
    if d[i] % 2 == 1:
        oe[i] = 1

for i in range(Q):
    c, d = MI()
    if oe[c - 1] == oe[d - 1]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    G[x].append(y)
    G[y].append(x)


def bfs(graph, start):
    from collections import deque
    seen = [False] * len(graph)
    todo = deque()
    color = [0] * len(graph)

    seen[start] = True
    todo.append(start)
    color[start] = 1

    while todo:
        v = todo.popleft()
        for w in graph[v]:
            if seen[w]: continue
            seen[w] = True
            todo.append(w)
            color[w] = color[v] * (-1)

    return color


color = bfs(G, 0)

for q in range(Q):
    c, d = map(lambda n: int(n) - 1, input().split())
    print("Town" if color[c] == color[d] else "Road")
n, q = map(int, input().split())
link = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = list(map(int, input().split()))
    link[a - 1].append(b - 1)
    link[b - 1].append(a - 1)
cd = [list(map(int, input().split())) for i in range(q)]

from collections import deque

visited = [-1] * n
visited[0] = True

from collections import deque

Q = deque()
Q.append(0)

while Q:
    now = Q.popleft()
    for nxt in link[now]:
        if visited[nxt] != -1:
            continue
        visited[nxt] = not visited[now]
        Q.append(nxt)

for c, d in cd:
    if visited[c - 1] == visited[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())

w = [[] for i in range(n + 1)]
r = [-1 for i in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    w[a].append(b)
    w[b].append(a)
for i in range(1, n + 1):
    if len(w[i]) == 1:
        s = i
        break
r[s] = 0
d = deque()
d.append(s)

while d:
    t0 = d.popleft()

    r0 = r[t0] + 1
    for t in w[t0]:
        if r[t] == -1:
            d.append(t)
            r[t] = r0
for i in range(q):
    a, b = map(int, input().split())
    if (r[a] - r[b]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
edges = [[] for i in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    edges[a].append(b)
    edges[b].append(a)
data = []
for i in range(Q):
    x = list(map(int, input().split()))
    data.append(x)
inf = float("inf")


def search(edge):
    dist = [inf] * (N + 1)
    dist[1] = 0
    m = deque()
    for i in edge[1]:
        m.append(i)
        dist[i] = 1
    while len(m):
        a = m.popleft()
        for i in edge[a]:
            if dist[i] == inf:
                if dist[a] == 1:
                    dist[i] = 0
                else:
                    dist[i] = 1
                m.append(i)
    return dist


D = search(edges)
for i in range(Q):
    c, d = data[i][0], data[i][1]
    c1 = D[c]
    d1 = D[d]
    if c1 == d1:
        print("Town")
    else:
        print("Road")
class segtree:
    """
    Segment tree
    Store value as object type and optional function for binary operarion
    get function return a value by binary operarion result
    update function update tree's a value

    Attributes
    ----------
    n : int
        Number of elements
    identity element_func : func
        identity_element for initialization
        if operator is * and identiry element is e, e * A = A and A * e = A
    binary_operation_func : func
        function for binary operation x and y
        function must have associative law
        if operator is *, (A * B) * C = A * (B * C)

    Methods
    -------
    update(i, x)
        update tree[i] value to x
    get(a, b)
        get value from [a, b)
        include a but not include b, return a merged value
    """
    def __init__(self, n: int, identity_element_func, binary_operation_func):
        """
        Constructer(Initialize parameter in this class)

        Parameters
        ----------
        n : int
            Number of elements
        identity_element_func : func
            identity element for initialization
            if operator is * and identiry element is e, e * A = A and A * e = A
        binary_operation_func : func
            function for binary operation x and y
            function must have associative law
            if operator is *, (A * B) * C = A * (B * C)
        """
        self.n = n
        self.identity = identity_element_func
        self.binary = binary_operation_func
        n2 = 1  # n2はnより大きい2の冪数
        while n2 < n:
            n2 <<= 1
        self.n2 = n2
        self.tree = [identity_element_func() for _ in range(n2 << 1)]

    def update(self, index: int, x: int):
        """
        Update segment-tree's a value and update segment-tree's tree

        Parameters
        ----------
        index : int
            index of update value
        x : int
            new value
        """
        index += self.n2
        self.tree[index] = self.binary(self.tree[index], x)
        while index > 1:
            # (index ^ 1) はiと1の排他的論理和(XOR)
            x = self.binary(x, self.tree[index ^ 1])
            index >>= 1  # 右ビットシフトで親ノードのインデックスへ移動
            self.tree[index] = self.binary(self.tree[index], x)

    def get(self, a: int, b: int) -> int:
        """
        Get a specific value by result of binary operation from interval [a, b)

        Parameters
        ----------
        a, b : int
            index of interval
            this is hald open interval, this interval include a but not b
        """
        result = self.identity()
        q = [(1, 0, self.n2)]
        while q:
            k, left, right = q.pop()
            if a <= left and right <= b:
                result = self.binary(result, self.tree[k])
                continue
            m = (left + right) // 2
            k <<= 1
            if a < m and left < b:
                q.append((k, left, m))
            if a < right and left < m:
                q.append((k + 1, m, right))
        return result


N, Q = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(lambda n: int(n) - 1, input().split())
    edge[x].append(y)
    edge[y].append(x)  # 有向グラフならこの行は消す!!

first_seen_cnt = [-1] * N
dists_from_root = [-1] * N
eular_tour = segtree(N * 2, lambda: 0, min)
cnt = 0

queue = [(0, 0)]
while queue:
    now, depth = queue.pop()
    if dists_from_root[now] != -1:
        continue
    dists_from_root[now] = depth

    cnt += 1
    first_seen_cnt[now] = cnt
    eular_tour.update(cnt, depth)
    for n_node in edge[now]:
        if dists_from_root[n_node] != -1:
            continue
        queue.append((n_node, depth + 1))

for _ in range(Q):
    c, d = map(lambda n: int(n) - 1, input().split())
    a, b = sorted([first_seen_cnt[c], first_seen_cnt[d]])
    lca = eular_tour.get(a, b)
    dist = dists_from_root[c] + dists_from_root[d] - 2 * dists_from_root[lca]
    if dist % 2:
        print("Road")
    else:
        print("Town")
N, Q = list(map(int, input().split()))
graph = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = list(map(int, input().split()))
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
visited = [-1 for _ in range(N)]
score = 0
visited[a] = score
queue = [a]
while queue:
    tmp = queue.pop()
    nexts = graph[tmp]
    score = (visited[tmp] + 1) % 2
    for item in nexts:
        if visited[item] == -1:
            queue.append(item)
            visited[item] = score
for _ in range(Q):
    c, d = list(map(int, input().split()))
    c, d = c - 1, d - 1
    if visited[c] == visited[d]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())

G = [None] + [[] for _ in range(N)]
C = [None] * (N + 1)
C[1] = 1

for _ in range(N - 1):
    a, b = map(int, input().split())
    G[b].append(a)
    G[a].append(b)

s = [1]

while s:
    u = s.pop()
    for v in G[u]:
        if C[v] is None:
            s.append(v)
            C[v] = C[u] ^ 1

for _ in range(Q):
    c, d = map(int, input().split())
    print('Road' if C[c] ^ C[d] else 'Town')
import queue

go = list(map(int, input().split()))
colors = [-1] * go[0]

l = [[] for _ in range(go[0])]

for i in range(go[0] - 1):
    x = list(map(int, input().split()))
    l[x[0] - 1].append(x[1] - 1)
    l[x[1] - 1].append(x[0] - 1)

que = queue.Queue()
colors[0] = 0
que.put(0)

while not que.empty():
    t = que.get()
    for i in l[t]:
        if colors[i] == -1:
            colors[i] = 1 - colors[t]
            que.put(i)

for i in range(int(go[1])):
    start, end = list(map(int, input().split()))
    if colors[start - 1] == colors[end - 1]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
path = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)
seen = [False] * N
dist = [0] * N
nxt = [0]
depth = 1
while len(nxt) > 0:
    v = nxt.pop()
    for u in path[v]:
        if not seen[u]:
            dist[u] = dist[v] + 1
            nxt.append(u)
    seen[v] = True
cd = [list(map(int, input().split())) for i in range(Q)]
for q in cd:
    if (dist[q[0] - 1] + dist[q[1] - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from heapq import heappush, heappop

INF = 10**9


def dijkstra(s, n):  # (始点, ノード数)
    dist = [INF] * n
    hq = [(0, s)]  # (distance, node)
    dist[s] = 0
    seen = [False] * n  # ノードが確定済みかどうか
    while hq:
        v = heappop(hq)[1]  # ノードを pop する
        seen[v] = True
        for to, cost in adj[v]:  # ノード v に隣接しているノードに対して
            if seen[to] == False and dist[v] + cost < dist[to]:
                dist[to] = dist[v] + cost
                heappush(hq, (dist[to], to))
    return dist


# ノード数, エッジ数, 始点ノード
n, m = map(int, input().split())
# adj[s]: ノード s に隣接する(ノード, 重み)をリストで持つ
adj = [[] for _ in range(n)]
for i in range(n - 1):
    s, t = map(int, input().split())
    s, t = s - 1, t - 1
    adj[s].append((t, 1))
    adj[t].append((s, 1))

dis = dijkstra(0, n)
for _ in range(m):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    dif = dis[c] - dis[d]
    if dif % 2 == 0:
        print('Town')
    else:
        print('Road')
def dfs(u):
    s = []
    s.append(u)
    while s:
        u = s.pop()
        visited[u] = 1
        for v in adj[u]:
            if not visited[v]:
                d[v] = d[u] + 1
                s.append(v)


N, Q = map(int, input().split())
adj = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    adj[a].append(b)
    adj[b].append(a)

d = [-1] * N
visited = [0] * N
d[0] = 0
dfs(0)

for i in range(Q):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    if (d[x] + d[y]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())

G = [[] for i in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()

color = [-1] * N
color[0] = 0
que.put(0)

while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
def get_pass(road, start, end):
    count = 0
    now = [start]
    passed = {start: 0}
    while (1):
        count += 1
        next_now = []
        for i in now:
            next_towns = road[i]
            for next_town in next_towns:
                if next_town in passed:
                    pass
                if (next_town == end):
                    return (count)
                else:
                    passed[next_town] = 0
                    next_now.append(next_town)
        now = next_now


def get_all_pass(road, n):
    count = 0
    start = 1
    now = [start]
    road_count = [0] * (n + 1)
    passed = {start: 0}
    while (len(passed) < n):
        count += 1
        next_now = []
        for i in now:
            next_towns = road[i]
            for next_town in next_towns:
                if next_town in passed:
                    pass
                else:
                    passed[next_town] = 0
                    next_now.append(next_town)
                    road_count[next_town] = count
        now = next_now
    return (road_count)


n, q = map(int, input().split())
road = {}

for i in range(n - 1):
    a, b = map(int, input().split())
    if (not a in road):
        road[a] = [b]
    else:
        road[a].append(b)
    if (not b in road):
        road[b] = [a]
    else:
        road[b].append(a)

road_count = get_all_pass(road, n)
#print(get_all_pass(road, n))
for i in range(q):
    c, d = map(int, input().split())
    #if(get_pass(road, c, d) % 2 == 0):
    if ((road_count[c] - road_count[d]) % 2 == 0):
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(N - 1)]

G = [[] for _ in range(N)]

for i in range(N - 1):
    ai, bi = map(int, ab[i])
    G[ai - 1].append(bi - 1)
    G[bi - 1].append(ai - 1)

color = [0] * N
color[0] = -1

d = deque()
d.append(0)

while d:
    v = d.popleft()
    for i in G[v]:
        if color[i] != 0:
            continue
        color[i] = -color[v]
        d.append(i)

for j in range(Q):
    cj, dj = map(int, input().split())
    if color[cj - 1] == color[dj - 1]:
        print('Town')
    else:
        print('Road')
import sys
from itertools import islice
from collections import deque


def solve(in_):
    N, Q = map(int, next(in_).split())
    _graph = [[] for _ in range(N)]
    _edges = tuple(
        tuple(map(int, line.split())) for line in islice(in_, N - 1))
    for a, b in _edges:
        a -= 1
        b -= 1
        _graph[a].append(b)
        _graph[b].append(a)
    C = [-1] * N
    C[0] = 0
    q = deque([0])
    while q:
        cur = q.popleft()
        for d in _graph[cur]:
            if C[d] == -1:
                C[d] = 1 - C[cur]
                q.append(d)

    queries = tuple(tuple(map(int, line.split())) for line in islice(in_, Q))

    ans = []
    for c, d in queries:
        c -= 1
        d -= 1

        if (C[c] + C[d]) % 2:
            ans.append('Road')
        else:
            ans.append('Town')
    return ans


def main():
    answer = solve(sys.stdin.buffer)
    print('\n'.join(answer))


if __name__ == '__main__':
    main()
from collections import deque

n, q = map(int, input().split())
cl, dl = [], []

graph = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
for _ in range(q):
    tc, td = map(int, input().split())
    cl.append(tc)
    dl.append(td)

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

ans = dist[1:]

for i, j in zip(cl, dl):
    if abs(ans[i - 1] - ans[j - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10**9)
input = sys.stdin.readline


class UnionFindTree:
    __all__ = ['root', 'merge', 'same', 'size']

    def __init__(self, maxsize=10**6):
        assert (maxsize > 0)
        self._n = maxsize
        self._parent_or_size = [-1] * maxsize

    def root(self, a):
        assert (0 <= a < self._n)
        pos = a
        children = []
        while self._parent_or_size[pos] >= 0:
            children.append(pos)
            pos = self._parent_or_size[pos]
        else:
            root_pos = pos
        for child_pos in children:
            self._parent_or_size[child_pos] = root_pos
        return root_pos

    def merge(self, a, b):
        assert (0 <= a < self._n)
        assert (0 <= b < self._n)
        root_a = self.root(a)
        root_b = self.root(b)
        if root_a == root_b:
            return True
        else:
            if -self._parent_or_size[root_a] > -self._parent_or_size[root_b]:
                root_a, root_b = root_b, root_a
            self._parent_or_size[root_b] += self._parent_or_size[root_a]
            self._parent_or_size[root_a] = root_b
            return False

    def same(self, a, b):
        assert (0 <= a < self._n)
        assert (0 <= b < self._n)
        root_a = self.root(a)
        root_b = self.root(b)
        return root_a == root_b

    def size(self, a):
        assert (0 <= a < self._n)
        root_a = self.root(a)
        return -self._parent_or_size[root_a]


n, q = map(int, input().strip().split())
e = [[] for _ in range(n)]
for _ in range(n - 1):
    aa, bb = map(int, input().strip().split())
    e[aa - 1].append(bb - 1)
    e[bb - 1].append(aa - 1)

#print("e", e)

ut = UnionFindTree(maxsize=n)
depth = [-1] * n
from collections import deque

depth[0] = 0
que = deque([])
for x in e[0]:
    depth[x] = 1
    ut.merge(0, x)
    que.append(x)

while len(que) > 0:
    p = que.pop()
    for x in e[p]:
        if ut.same(0, x):
            continue
        depth[x] = depth[p] + 1
        ut.merge(0, x)
        que.append(x)

#print(depth)

for _ in range(q):
    c, d = map(int, input().strip().split())
    if abs(depth[c - 1] - depth[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

#Data Input
N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
C = [-1] * N
C[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if C[i] == -1:
            C[i] = 1 - C[t]
            que.put(i)

for i in range(Q):
    x, y = map(int, input().split())
    if (C[x - 1] - C[y - 1]) % 2 == 1:
        print('Road')
    else:
        print('Town')
import collections

D = collections.defaultdict(list)

N, Q = map(int, input().split())
for i in range(N - 1):
    a, b = map(int, input().split())
    D[a].append(b)
    D[b].append(a)

edge = []
for i in range(Q):
    c, d = map(int, input().split())
    edge.append([c, d])

#前処理
dist = [-1] * (N + 1)
dist[0] = 0
dist[1] = 0

queue = collections.deque()
queue.append(1)

while queue:
    v = queue.popleft()
    for i in D[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        queue.append(i)

for i in range(Q):
    takahashi = edge[i][0]
    aoki = edge[i][1]

    if (dist[takahashi] - dist[aoki]) % 2 == 0:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python3
N, Q = map(int, input().split())
AB = [tuple(map(lambda x: int(x) - 1, input().split())) for _ in range(N - 1)]
CD = [tuple(map(lambda x: int(x) - 1, input().split())) for _ in range(Q)]

from collections import deque

G = [[] for _ in range(N)]
for a, b in AB:
    G[a].append(b)
    G[b].append(a)

start = 0
dist = [-1] * N
Q = deque()
Q.append(start)
dist[start] = 0
while Q:
    i = Q.popleft()
    for j in G[i]:
        if dist[j] == -1:
            dist[j] = dist[i] + 1
            Q.append(j)

for c, d in CD:
    if abs(dist[c] - dist[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")

# D = [[-1]*N for _ in range(N)]

# for start in range(N):
#     dist = [-1]*N
#     Q = deque()
#     Q.append(start)
#     dist[start] = 0
#     while Q:
#         i = Q.popleft()
#         for j in G[i]:
#             if dist[j] == -1:
#                 dist[j] = dist[i] + 1
#                 Q.append(j)
#     for j in range(N):
#         D[start][j] = dist[j]

# for c, d in CD:
#     if D[c][d] % 2 == 0:
#         print("Town")
#     else:
#         print("Road")
import collections

n, q = map(int, input().split())
tree = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    tree[a - 1].append(b - 1)
    tree[b - 1].append(a - 1)
colors = [0] * n
colors[0] = 1
stack = collections.deque([0])
while stack:
    tmp = stack.pop()
    tmp_color = colors[tmp]
    for i in tree[tmp]:
        if colors[i] == 0:
            colors[i] = tmp_color * -1
            stack.append(i)

for i in range(q):
    c, d = map(int, input().split())
    if colors[c - 1] == colors[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = list(map(int, input().split()))
graph = [[] * n for i in range(n)]
for i in range(n - 1):
    ai, bi = list(map(int, input().split()))
    graph[ai - 1].append(bi - 1)
    graph[bi - 1].append(ai - 1)

INF = float("inf")
dist = [INF for i in range(n)]
dist[0] = 0
seen = [False] * n
que = deque([(0, 0)])
while que:
    node, d = que.popleft()
    if seen[node]:
        continue
    seen[node] = True
    for ne in graph[node]:
        dist[ne] = d + 1
        que.append((ne, d + 1))

for qi in range(q):
    ci, di = list(map(int, input().split()))
    if (dist[ci - 1] + dist[di - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
ab = [map(int, input().split()) for _ in range(N - 1)]
a, b = [list(i) for i in zip(*ab)]

G = [[] for _ in range(N)]
for i in range(N - 1):
    G[a[i] - 1].append(b[i])
    G[b[i] - 1].append(a[i])

start = 1
q = deque()
inf = 10**9
board = [0] * N
w_tmp = -1

q.append(start)
board[start - 1] = 1
while q:
    w = q.popleft()
    for num in G[w - 1]:
        if board[num - 1] != 0:
            continue
        if board[w - 1] == 1:
            board[num - 1] = 2
        if board[w - 1] == 2:
            board[num - 1] = 1
        q.append(num)
    w_tmp = w

for _ in range(Q):
    start, end = map(int, input().split())
    if board[start - 1] == board[end - 1]:
        print('Town')
    else:
        print('Road')
from heapq import heappush, heappop

n, q = map(int, input().split())

graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)


def dijkstra(s, g):  # 始点、隣接グラフ
    INF = 10**18
    check = [False] * n
    dist = [INF] * n
    dist[s] = 0
    q = [(0, s)]  # 距離・ノード
    while q:
        node = heappop(q)[1]
        if check[node]: continue
        check[node] = True
        for i in g[node]:
            if check[i]: continue
            if dist[i] <= dist[node] + 1: continue
            dist[i] = dist[node] + 1
            heappush(q, [dist[i], i])
    return dist


dis = dijkstra(0, graph)
for i in range(n):
    dis[i] %= 2

for _ in range(q):
    c, d = map(int, input().split())
    if dis[c - 1] == dis[d - 1]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = (int(x) for x in input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = (int(x) for x in input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

color = [-1] * N
color[0] = 0
todo = queue.Queue()
todo.put(0)
while not todo.empty():
    v = todo.get()
    for i in G[v]:
        if color[i] == -1:
            color[i] = 1 - color[v]
            todo.put(i)

for _ in range(Q):
    c, d = (int(x) for x in input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python3
def BFS(q1, q2, edges, N):
    roots = [[] for _ in range(N)]
    for a, b in edges:
        roots[a - 1] += [(b - 1, 1)]
        roots[b - 1] += [(a - 1, 1)]
    dist = [-1] * N
    stack = []
    stack.append(q1)
    dist[q1] = 0
    while stack:
        label = stack.pop(-1)
        for i, c in roots[label]:
            if dist[i] == -1:
                dist[i] = dist[label] + c
                stack += [i]
                if i == q2:
                    return dist[q2]


# Generated by 2.5.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    n, Q = map(int, input().split())
    edges = [[] for _ in range(n)]
    for i in range(n - 1):
        x, y = map(int, input().split())
        edges[x - 1].append(y - 1)
        edges[y - 1].append(x - 1)
    D = [-1] * n
    q = [0]
    D[0] = 0
    while q:
        u = q.pop()
        for v in edges[u]:
            if D[v] >= 0: continue
            D[v] = D[u] + 1
            q.append(v)

    for i in range(Q):
        q1, q2 = map(int, input().split())
        ans = D[q1 - 1] + D[q2 - 1]
        if ans % 2 == 0:
            print("Town")
        else:
            print("Road")
    return


if __name__ == '__main__':
    main()
from collections import deque

N, QE = map(int, input().split())

#頂点iからつながる辺のリストGの定義
G = []
for _ in range(N):
    G.append([])

for i in range(N - 1):
    ai, bi = map(int, input().split())
    #indexを０始まりに直す
    ai -= 1
    bi -= 1
    G[ai].append(bi)
    G[bi].append(ai)

color = []

for _ in range(N):
    color.append(-1)

color[0] = 0
Q = deque()
Q.append(0)

ans = []

while len(Q) > 0:

    i = Q.popleft()

    for j in G[i]:
        if color[j] == -1:
            color[j] = 1 - color[i]
            Q.append(j)

for i in range(QE):
    ci, di = map(int, input().split())
    ci -= 1
    di -= 1
    if color[ci] == color[di]:
        ans.append("Town")
    else:
        ans.append("Road")

for i in ans:
    print(i)
n, q = map(int, input().split())
ab = [input() for i in range(n - 1)]
que = [input() for i in range(q)]
to = [[] for i in range(n)]
for i in range(len(ab)):
    a, b = map(int, ab[i].split())
    to[a - 1].append(b - 1)
    to[b - 1].append(a - 1)
for i in range(len(que)):
    c, d = map(int, que[i].split())
    que[i] = [c - 1, d - 1]

pari = [0 for i in range(n)]

import queue

qu = queue.Queue()
qu.put(0)
pari[0] = 1
while not qu.empty():
    t = qu.get()
    for i in to[t]:
        if pari[i] != 0:
            continue
        pari[i] = pari[t] % 2 + 1
        qu.put(i)

for i in que:
    if (pari[i[0]] - pari[i[1]]) % 2:
        print("Road")
    else:
        print("Town")
N, Q = map(int, input().split())
L = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    L[a].append(b)
    L[b].append(a)
#print(L)
from collections import deque

q = deque([0])
visited = [False] * N
visited[0] = True
dist = [0] * N
while q:
    r = q.popleft()
    #print(r,q)
    for to in L[r]:
        if visited[to]:
            continue
        visited[to] = True
        dist[to] = dist[r] + 1
        q.append(to)
#print(dist)
for i in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    w1 = dist[c]
    w2 = dist[d]
    #print(w,c,d)
    if (w1 + w2) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]
import sys

sys.setrecursionlimit(10**9)

from collections import defaultdict

g = defaultdict(list)
for a, b in ab:
    g[a] += [b]
    g[b] += [a]

cs = [-1] * (n + 1)


def dfs(u, c):
    que = [(u, c)]

    while len(que) > 0:
        u, c = que.pop()
        if cs[u] == -1:
            cs[u] = c
            for v in g[u]:
                que += [(v, 1 - c)]


dfs(1, 0)

for c, d in cd:
    if cs[c] == cs[d]:
        print("Town")
    else:
        print("Road")
from collections import deque
import copy

n, q = map(int, input().split())
road = []
dist2 = []
for i in range(n):
    road.append([])
    dist2.append(-1)
for i in range(n - 1):
    a, b = map(int, input().split())
    road[a - 1].append(b - 1)
    road[b - 1].append(a - 1)
Q = deque()
Q.append(0)
while len(Q) > 0:
    i = Q.popleft()
    for j in road[i]:
        if dist2[j] == -1:
            dist2[j] = dist2[i] + 1
            Q.append(j)
for i, d in enumerate(dist2):
    if d % 2 == 0:
        dist2[i] = 1
    else:
        dist2[i] = 2
for i in range(q):
    c, d = map(int, input().split())
    if dist2[c - 1] == dist2[d - 1]:
        print('Town')
    else:
        print('Road')
from sys import stdin

read = stdin.readline
(N, Q) = map(int, read().split())
AB = [list(map(lambda i: int(i) - 1, read().split())) for j in range(N - 1)]
CD = [list(map(lambda i: int(i) - 1, read().split())) for j in range(Q)]

nbr = [set() for i in range(N)]
for (a, b) in AB:
    nbr[a].add(b), nbr[b].add(a)

dtc = [None for i in range(N)]
q = [(0, 0)]
used = set()
while len(q) != 0:
    (i, d) = q.pop()
    used.add(i)
    dtc[i] = d
    for j in nbr[i]:
        if j in used:
            continue
        q.append((j, d + 1))

for (c, d) in CD:
    print("Town" if dtc[c] % 2 == dtc[d] % 2 else "Road")
import sys

sys.setrecursionlimit(10**6)


def dfs(v, pre, d):
    for nv in G[v]:
        if nv == pre: continue
        depth[nv] = d + 1
        dfs(nv, v, d + 1)


N, Q = map(int, input().split())
G = [[] for i in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

depth = [-1] * (N)  # 根（root）からの距離
depth[0] = 0  # rootの初期値を0とする。
# グラフに根からの距離と2**k上の点を記録。
dfs(0, -1, 0)

for q in range(Q):
    ci, di = map(int, input().split())
    ci -= 1
    di -= 1
    ans = 0
    if abs(depth[ci] - depth[di]) % 2 == 0:
        print('Town')
    else:
        print('Road')
class RmQWithSparseTable:
    """
    RmQ特化型クラス sparse_tableを用いている 空間計算量は大きいことに注意
    計算量 構築O(NlogN) クエリO(1)
    https://tookunn.hatenablog.com/entry/2016/07/13/211148 <--基本的にはこの実装
    https://ikatakos.com/pot/programming_algorithm/data_structure/sparse_table
    https://www.topcoder.com/thrive/articles/Range%20Minimum%20Query%20and%20Lowest%20Common%20Ancestor
    """
    def __init__(self, array, is_for_return_index=True):
        N = len(array)
        logN = N.bit_length()
        log_table = [0] * (N + 1)
        for i in range(2, N + 1):
            log_table[i] = log_table[i >> 1] + 1
        sparse_table = [[0] * (N)
                        for i in range(log_table[N] + 1)]  # 参考文献とは順序を変えた
        sparse_table[0] = list(range(N)) if is_for_return_index else array
        if is_for_return_index:
            for k in range(1, logN):
                for i in range(N):
                    if i + (1 << k) > N:
                        break
                    first = sparse_table[k - 1][i]
                    second = sparse_table[k - 1][i + (1 << (k - 1))]
                    sparse_table[k][i] = first if array[first] <\
                        array[second] else second
        else:  # この方針ではindexの保持も値の保持も本質的には同じ
            for k in range(1, logN):
                for i in range(N):
                    if i + (1 << k) > N:
                        break
                    sparse_table[k][i] = min(
                        sparse_table[k - 1][i],
                        sparse_table[k - 1][i + (1 << (k - 1))])
        self.array = array
        self.log_table = log_table
        self.sparse_table = sparse_table
        self.mode = is_for_return_index

    def query(self, l, r):
        """
        array[l:r]の最小を返す 半開区間、0-indexed
        仕組み ざっくり言えば、クエリの区間に応じてアクセスする節の大きさを決める感じ
        stk[l],stk[r-(1<<k)]でそれぞれ1<<k個の区間の最小値が分かるので、
        全体の区間の最小値はそのいずれか 冪等性(A•A==A)を満たすならば、他にも応用可
        """
        d = r - l
        k = self.log_table[d]
        stk = self.sparse_table[k]
        if self.mode:
            return stk[l] if self.array[stk[l]] < self.array[stk[r-(1 << k)]]\
                else stk[r-(1 << k)]
        else:
            return min(stk[l], stk[r - (1 << k)])


class LCA(RmQWithSparseTable):
    def __init__(self, adj):
        self.adj = adj
        self.vs, self.depth, self.id = self.euler_tour(self.adj, start_node=0)
        super().__init__(self.depth, is_for_return_index=True)

    def euler_tour(self, adj: list, start_node: int = 0):
        """
        根からDFSをし、その順に番号を付けていく 蟻本p.294の非再帰版 自作につき壊れに注意
        """
        MAX_V = len(adj)
        vs = [0] * (2 * MAX_V - 1)  # DFSでの訪問順
        depth = [0] * (2 * MAX_V - 1)  # 根からの深さ
        id = [0] * MAX_V  # 各頂点がvsにはじめて登場するインデックス
        k = -1  # 何番目の訪問であるか
        d = -1  # 現時点での深さ
        visited = [False] * MAX_V
        stack = [start_node]
        while stack:
            from_node = stack.pop()
            if from_node >= 0:  # 行き
                visited[from_node] = True
                d += 1  # dやkの扱いを蟻本と変えているのは非再帰だから
                k += 1  # euler_tourを辺の往復で考えると理由が分かりやすい
                id[from_node] = k
                vs[k] = from_node
                depth[k] = d
                for to_node in adj[from_node]:
                    if visited[to_node]:
                        continue
                    stack.append(~from_node)  # これも辺の往復で考えるとよい
                    stack.append(to_node)  # 通常のdfsと仕様が異なるので注意
            else:  # 帰り
                d -= 1
                k += 1
                vs[k] = ~from_node
                depth[k] = d
        return vs, depth, id

    def lca(self, u, v):  # 計算量 O(1)
        return self.vs[super().query(min(self.id[u], self.id[v]),
                                     max(self.id[u], self.id[v]) + 1)]

    def dist(self, u, v):  # 計算量 O(1)
        return self.depth[self.id[u]]+self.depth[self.id[v]]\
            - 2*self.depth[self.id[self.lca(u, v)]]


# 以上LCA用コード


def main():
    import sys
    input = sys.stdin.readline
    N, Q = map(int, input().split())
    adj = [[] for _ in range(N)]
    for _ in range(N - 1):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        adj[x].append(y)
        adj[y].append(x)

    lca = LCA(adj)

    for q in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        dist = lca.dist(c, d)
        if dist % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
def dfs(cur, prev):
    global depth, parent
    depth[cur] = depth[prev] + 1
    parent[cur][0] = prev
    for next_ in tree[cur]:
        if next_ != prev:
            dfs(next_, cur)


def addEdge(u, v):
    global tree
    tree[u].append(v)
    tree[v].append(u)


def precompute(n):
    for i in range(1, level):
        for node in range(1, n + 1):
            if parent[node][i - 1] != -1:
                parent[node][i] = parent[parent[node][i - 1]][i - 1]


def lca(u, v):
    if depth[v] < depth[u]:
        u, v = v, u

    diff = depth[v] - depth[u]

    for i in range(level):
        if ((diff >> i) & 1):
            v = parent[v][i]

    if u == v:
        return u

    for i in range(level - 1, -1, -1):
        if (parent[u][i] != parent[v][i]):
            u = parent[u][i]
            v = parent[v][i]

    return parent[u][0]


import sys

sys.setrecursionlimit(200002)

MAXN = 200002
level = 1

tree = [[] for _ in range(MAXN)]
depth = [0 for _ in range(MAXN)]
parent = [[-1 for _ in range(level)] for _ in range(MAXN)]

n, q = map(int, input().split())
for _ in range(n - 1):
    a, b = map(int, input().split())
    addEdge(a, b)

depth[0] = 0
dfs(1, 0)

for i in range(q):
    c, d = map(int, input().split())
    if (depth[c] + depth[d]) % 2 != 0:
        print("Road")
    else:
        print("Town")
def main():
    from collections import deque, defaultdict
    n, query = map(int, input().split())
    tree = defaultdict(list)
    q = deque([1])
    vis = [0] * (n + 1)

    for _ in range(n - 1):
        a, b = map(int, input().split())
        tree[a].append(b)
        tree[b].append(a)

    dist = [float('inf')] * (n + 1)
    dist[1] = 0
    while q:
        length = len(q)
        s = set()
        for _ in range(length):
            node = q.popleft()
            vis[node] = 1
            for son in tree[node]:
                dist[son] = min(dist[son], dist[node] + 1)
                if vis[son] == 0:
                    q.append(son)

    for _ in range(query):
        c, d = map(int, input().split())
        res = 'Road'
        if dist[c] % 2 == dist[d] % 2:
            res = 'Town'
        print(res)

    return


main()import sys  #追加

sys.setrecursionlimit(100000000)  #追加


class Node:
    def __init__(self, id, len_to_root):
        self.id = id
        self.len_to_root = len_to_root


def main():
    N, Q = map(int, input().split())

    routes = [set() for _ in range(N)]

    for i in range(N - 1):
        a, b = map(lambda x: int(x) - 1, input().split())
        routes[a].add(b)
        routes[b].add(a)

    node_hash = [None] * N

    def generate_tree(node, parent_id):
        id = node.id
        next_len = node.len_to_root + 1

        for dst in routes[id]:
            if dst == parent_id:
                continue

            child = Node(dst, next_len)
            node_hash[dst] = child

            generate_tree(child, id)

    root = Node(0, 0)
    node_hash[0] = root
    generate_tree(root, -1)

    for _ in range(Q):
        c, d = map(lambda x: int(x) - 1, input().split())

        node_c = node_hash[c]
        node_d = node_hash[d]

        c_len = node_c.len_to_root
        d_len = node_d.len_to_root

        print("Town" if (c_len - d_len) % 2 == 0 else "Road")


main()
from collections import deque


class LcaDoubling:
    """
    links[v] = { (u, w), (u, w), ... }  (u:隣接頂点, w:辺の重み)
    というグラフ情報から、ダブリングによるLCAを構築。
    任意の2頂点のLCAおよび距離を取得できるようにする
    """
    def __init__(self, n, links, root=0):
        self.depths = [-1] * n
        self.distances = [-1] * n
        prev_ancestors = self._init_dfs(n, links, root)
        self.ancestors = [prev_ancestors]
        max_depth = max(self.depths)
        d = 1
        while d < max_depth:
            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]
            self.ancestors.append(next_ancestors)
            d <<= 1
            prev_ancestors = next_ancestors

    def _init_dfs(self, n, links, root):
        q = [(root, -1, 0, 0)]
        direct_ancestors = [-1] * (n + 1
                                   )  # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1
        while q:
            v, p, dep, dist = q.pop()
            direct_ancestors[v] = p
            self.depths[v] = dep
            self.distances[v] = dist
            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)
        return direct_ancestors

    def get_lca(self, u, v):
        du, dv = self.depths[u], self.depths[v]
        if du > dv:
            u, v = v, u
            du, dv = dv, du
        tu = u
        tv = self.upstream(v, dv - du)
        if u == tv:
            return u
        for k in range(du.bit_length() - 1, -1, -1):
            mu = self.ancestors[k][tu]
            mv = self.ancestors[k][tv]
            if mu != mv:
                tu = mu
                tv = mv
        lca = self.ancestors[0][tu]
        assert lca == self.ancestors[0][tv]
        return lca

    def get_distance(self, u, v):
        lca = self.get_lca(u, v)
        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]

    def upstream(self, v, k):
        i = 0
        while k:
            if k & 1:
                v = self.ancestors[i][v]
            k >>= 1
            i += 1
        return v


n, Q = map(int, input().split())
g = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append([b, 1])
    g[b].append([a, 1])

lcad = LcaDoubling(n, g)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if lcad.get_distance(c, d) % 2:
        print("Road")
    else:
        print("Town")
from collections import deque


def getdist(start):
    q = deque()
    q.append(start)
    dist[start] = 0

    while len(q) > 0:
        curr = q.popleft()
        for to in g[curr]:
            if dist[to] == 10**9:
                dist[to] = dist[curr] + 1
                q.append(to)


n, q = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

dist = [10**9 for _ in range(n)]
getdist(0)

for _ in range(q):
    c, d = map(int, input().split())
    if abs(dist[c - 1] - dist[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque

N, Q = map(int, input().split())
G = [[] for _ in range(N)]

for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

q = deque()
q.append(0)
color = [-1] * N
color[0] = 0

while len(q) > 0:
    t = q.popleft()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 ^ color[t]
            q.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

from collections import defaultdict

g = defaultdict(list)
for a, b in ab:
    g[a] += [b]
    g[b] += [a]


# Euler Tour
def dfs(u, d):
    # first visit
    vis = [-1] * (n + 1)
    # euler tour
    et = []
    stack = [(u, d)]

    while len(stack):
        u, d = stack.pop()
        if u > 0:
            # 行きがけの処理
            vis[u] = len(et)
            et += [(u, d)]
            for v in g[u]:
                if vis[v] == -1:  # 未探索のみ
                    stack.append((-v, d + 1))  # 帰り
                    stack.append((v, d + 1))  # 行き
        else:
            # 帰りがけの処理
            et += [(u, d)]

    return vis, et


F, ET = dfs(1, 0)
A = [et[1] for et in ET]


def init_min(init_min_val):
    #set_val
    for i in range(n):
        seg_min[i + num_min - 1] = init_min_val[i]
    #built
    for i in range(num_min - 2, -1, -1):
        seg_min[i] = min(seg_min[2 * i + 1], seg_min[2 * i + 2])


def query_min(p, q):
    if q <= p:
        return ide_ele_min
    p += num_min - 1
    q += num_min - 2
    res = ide_ele_min
    while q - p > 1:
        if p & 1 == 0:
            res = min(res, seg_min[p])
        if q & 1 == 1:
            res = min(res, seg_min[q])
            q -= 1
        p = p // 2
        q = (q - 1) // 2
    if p == q:
        res = min(res, seg_min[p])
    else:
        res = min(min(res, seg_min[p]), seg_min[q])
    return res


n = len(A)
ide_ele_min = 10**5 + 1

#num_min:n以上の最小の2のべき乗
num_min = 2**(n - 1).bit_length()
seg_min = [ide_ele_min] * 2 * num_min

#init
init_min(A)

for c, d in cd:
    pc, pd = F[c], F[d]

    dc, dd = A[pc], A[pd]
    #print(c, d)
    #print(F[c], F[d])
    #print(ET[pc], ET[pd])
    #print()
    #continue
    m = query_min(pc, pd)

    #print(c,d,pc,pd,dc,dd,m)

    dist = dc + dd - 2 * m
    #print(dist)
    #print(ET[pc:pd+1])

    if dist % 2 == 0:
        print(  #dist, 
            "Town")
    else:
        print(  #dist, 
            "Road")
    #print()
N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    G[u].append(v)
    G[v].append(u)
D = [-1] * N
D[0] = 0
q = [0]
for u in q:
    for v in G[u]:
        if D[v] >= 0:
            continue
        D[v] = D[u] ^ 1
        q.append(v)
for _ in range(Q):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    if D[u] == D[v]:
        print("Town")
    else:
        print("Road")
# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)
#
# - construct
# prv[u] = v: 頂点uの一つ上の祖先頂点v
# - lca
# kprv[k][u] = v: 頂点uの2^k個上の祖先頂点v
# depth[u]: 頂点uの深さ (根頂点は0)
import sys

sys.setrecursionlimit(500000)
N, Q = map(int, input().split())
G = [[] for _ in range(N + 1)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

# N: 頂点数
# G[v]: 頂点vの子頂点 (親頂点は含まない)

# Euler Tour の構築
S = []
F = [0] * 200000
depth = [0] * 200000


def dfs(v, d):
    F[v] = len(S)
    depth[v] = d
    S.append(v)
    for w in G[v]:
        if depth[w] == 0:
            dfs(w, d + 1)
        S.append(v)


dfs(0, 0)

# 存在しない範囲は深さが他よりも大きくなるようにする
INF = (N, None)

# LCAを計算するクエリの前計算
M = 2 * N
M0 = 2 * 2**(M - 1).bit_length()
data = [INF] * (2 * M0)
for i, v in enumerate(S):
    data[M0 - 1 + i] = (depth[v], i)
for i in range(M0 - 2, -1, -1):
    data[i] = min(data[2 * i + 1], data[2 * i + 2])


# LCAの計算 (generatorで最小値を求める)
def _query(a, b):
    yield INF
    a += M0
    b += M0
    while a < b:
        if b & 1:
            b -= 1
            yield data[b - 1]
        if a & 1:
            yield data[a - 1]
            a += 1
        a >>= 1
        b >>= 1


# LCAの計算 (外から呼び出す関数)
def query(u, v):
    fu = F[u]
    fv = F[v]
    if fu > fv:
        fu, fv = fv, fu
    return S[min(_query(fu, fv + 1))[1]]


for i in range(Q):
    c, d = map(int, input().split())
    e = query(c - 1, d - 1)
    if (depth[c - 1] + depth[d - 1] - 2 * depth[e]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue
############################
n, q = map(int, input().split())
#無向グラフ。隣接リストを使用
graph = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
##########################
que = queue.Queue()
#街へは確実に移動できるので、街1からのコストをカウントする
color = [-1] * n
#偶奇がわかればよいので、コストが偶数なら０，奇数なら1とする
#１→１は移動ゼロなので、偶数
color[0] = 0
#キューに0を入れる
que.put(0)
#キューが空になるまで実施
while not que.empty():
    #ターゲットを取り出す
    t = que.get()
    #街tからいける場所を確認していく
    for i in graph[t]:
        #未確認の場合
        if color[i] == -1:
            #深く潜るので、起点と偶奇が変わる
            color[i] = 1 - color[t]
            #潜った先をキューに追加
            que.put(i)
###########
#アウトプット
for i in range(q):
    c, d = map(int, input().split())
    #cとdの偶奇が同じなら、どこかの街で合流
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
import heapq
import sys

sys.setrecursionlimit(3000000)

n, q = map(int, input().split())

g = [[] for _ in range(n + 1)]

color = ["x"] * (n + 1)

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

# for i in range(1,n+1):
#     g[i].sort()


def bfs(start, bef, dim):

    if dim % 2 == 0:
        color[start] = "○"
    else:
        color[start] = "x"
    dim += 1
    for s in g[start]:
        if s != bef:
            bfs(s, start, dim)

    dim -= 1


dim = 1
bfs(1, -1, dim)

for i in range(q):
    c, d = map(int, input().split())
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
n, q = list(map(int, input().split()))
ab = [list(map(int, input().split())) for _ in range(n - 1)]
cd = [list(map(int, input().split())) for _ in range(q)]

from collections import defaultdict

g = defaultdict(list)
for a, b in ab:
    g[a] += [b]
    g[b] += [a]


# Euler Tour
def dfs(u, d):
    # first visit
    vis = [-1] * (n + 1)
    # euler tour
    et = []
    que = [(-u, d), (u, d)]

    while len(que) > 0:
        u, d = que.pop()
        if u > 0:
            # 行きがけの処理
            vis[u] = len(et)
            et += [(u, d)]
            for v in g[u]:
                if vis[v] == -1:  # 未探索のみ
                    que += [(-v, d + 1)]  # 帰り
                    que += [(v, d + 1)]  # 行き
        else:
            # 帰りがけの処理
            et += [(u, d)]

    return vis, et


vis, et = dfs(1, 0)


class SegmentTree():
    def __init__(self, a):
        self.INF = float("inf")
        p = len(a).bit_length()
        self.n = pow(2, p)
        self.tree = [self.INF] * (2 * self.n - 1)

        # 葉の値をセット
        for i in range(len(a)):
            j = i + self.n - 1
            self.tree[j] = a[i]
        for i in range(len(a), n):
            j = i + self.n - 1
            self.tree[j] = self.INF

        # 葉に近い方から更新していく
        for j in range(self.n - 2, -1, -1):
            self.tree[j] = min(self.tree[j * 2 + 1], self.tree[j * 2 + 2])

    def update(self, i, x):
        # i番目はn-1+i番目
        j = i + self.n - 1
        self.tree[j] = x  # 新しい値
        while (j > 0):
            # 親を辿りながら更新
            j = (j - 1) // 2
            self.tree[j] = min(self.tree[j * 2 + 1], self.tree[j * 2 + 2])

    def rmq(self, a, b):
        k, l, r = 0, 0, self.n
        ans = self.INF
        stack = [(k, l, r)]

        while len(stack):
            k, l, r = stack.pop()
            if r <= a or b <= l:
                pass
            elif a <= l and r <= b:
                ans = min(ans, self.tree[k])
            else:
                stack.append((2 * k + 1, l, (l + r) // 2))
                stack.append((2 * k + 2, (l + r) // 2, r))

        return ans


a = [t for e, t in et]
st = SegmentTree(a)

for c, d in cd:
    vc, vd = vis[c], vis[d]
    dc, dd = a[vc], a[vd]

    #print(c,d,vc,vd,dc,dd)

    if vc > vd:
        tmp = vc
        vc = vd
        vd = tmp

    #continue
    #print(c, d, vc, vd)
    m = st.rmq(vc, vd + 1)

    dist = dc + dd - 2 * m

    if dist % 2 == 0:
        print("Town")
    else:
        print("Road")
def Is():
    return input()


def Iss():
    return input().split()


def Ii():
    return int(input())


def Iis():
    return map(int, input().split())


def Iil():
    return list(map(int, input().split()))


def Ixy(N):
    return [list(map(int, input().split())) for l in range(N)]


def Ixyind(N):
    xy = [map(int, input().split()) for _ in range(N)]
    return [list(i) for i in zip(*xy)]


def Imixind(N):
    list = []
    for i in range(N):
        a, b = input().split()
        list.append([int(a), b])
    return list


#####################################################################
import sys

sys.setrecursionlimit(100000)


def main():
    # N = Ii()
    # S = Is()
    N, Q = Iis()

    # l = Iil()
    # X,Y = Ixyind(N)
    # XY = Ixy(N)

    class Node:
        def __init__(self):
            self.parents = []
            self.children = []
            self.depth = None

    def cal_depth(node_id, d=0):
        Tree[node_id].depth = d
        for child in Tree[node_id].children:
            if Tree[child].depth == None:
                cal_depth(child, d + 1)
        for parent in Tree[node_id].parents:
            if Tree[parent].depth == None:
                cal_depth(parent, d - 1)

    Tree = [Node() for _ in range(N)]

    for i in range(N - 1):
        #id, 子供の数k, c_0~c_k
        tree_info = list(map(int, input().split()))
        node_id = tree_info[0] - 1
        k = 1

        if k > 0:
            children = tree_info[1] - 1
            Tree[node_id].children.append(children)
            Tree[node_id].type = "internal node"
        else:
            Tree[node_id].type = "leaf"

        for child in Tree[node_id].children:
            Tree[child].parents.append(node_id)

    #search_root
    root_id = [i for i, t in enumerate(Tree) if t.parents == []][0]
    Tree[root_id].type = "root"
    cal_depth(root_id)

    # answer_output
    # for i, t in enumerate(Tree):
    #     print("node {}: parents = {}, depth = {}, {}".format(i, t.parents, t.depth, t.children))
    for _ in range(Q):
        c, d = Iis()
        c -= 1
        d -= 1
        if Tree[c].depth % 2 == Tree[d].depth % 2:
            print("Town")
        else:
            print("Road")


main()
N, Q = map(int, input().split())
length = [-1] * (N + 1)
length[1] = 0

links = [set() for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    links[a].add(b)
    links[b].add(a)

from collections import deque

q = deque()
for x in links[1]:
    q.append([1, x])

while q:
    tmp = q.popleft()
    for x in links[tmp[1]]:
        if x != tmp[0]:
            q.append([tmp[1], x])
        else:
            length[tmp[1]] = length[tmp[0]] + 1

for i in range(Q):
    c, d = map(int, input().split())
    if (length[c] - length[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
# -*- coding: utf-8 -*-


class TreeDistance:
    def __init__(self, vertex_count, graph) -> None:
        self.dist = [0 for _ in range(vertex_count)]
        self._graph = graph
        self._visited = [False for _ in range(vertex_count)]

    def calc(self, start_vertex=0):
        self._bfs(start_vertex)

        return self.dist

    def _bfs(self, vertex):
        from collections import deque

        d = deque()
        d.append(vertex)
        self._visited[vertex] = True

        while d:
            di = d.popleft()

            for to in self._graph[di]:
                if self._visited[to]:
                    continue

                self._visited[to] = True
                self.dist[to] = self.dist[di] + 1
                d.append(to)


def main():
    from collections import deque
    import sys

    input = sys.stdin.readline

    n, q = map(int, input().split())
    graph = [[] for _ in range(n)]

    for _ in range(n - 1):
        ai, bi = map(int, input().split())
        ai -= 1
        bi -= 1

        graph[ai].append(bi)
        graph[bi].append(ai)

    td = TreeDistance(n, graph)
    dist = td.calc(0)

    for i in range(q):
        ci, di = map(int, input().split())
        ci -= 1
        di -= 1

        if abs(dist[ci] - dist[di]) % 2 == 1:
            print("Road")
        else:
            print("Town")


if __name__ == "__main__":
    main()
import sys
from random import randint

sys.setrecursionlimit(10**7)
input = sys.stdin.readline


def getlist(type):
    return list(map(type, input().rstrip().split()))


def calc(G, crr, pre, arr):
    for nxt in G[crr]:
        if nxt == pre:
            continue
        arr[nxt] = (arr[crr] + 1) % 2
        calc(G, nxt, crr, arr)
    return


def main():
    n, q = getlist(int)
    G = [set() for _ in range(n)]
    for _ in range(n - 1):
        a, b = getlist(int)
        a, b = a - 1, b - 1
        G[a].add(b)
        G[b].add(a)
    arr = [0 for _ in range(n)]
    calc(G, randint(0, n - 1), -1, arr)
    ans = []
    for _ in range(q):
        a, b = getlist(int)
        a, b = a - 1, b - 1
        ans.append((arr[a] ^ arr[b]) == 0)
    for f in ans:
        if f:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    main()
from bisect import bisect_right

inpl = lambda: list(map(int, input().split()))
output = ['Town', 'Road']
N, Q = inpl()
edges = [set() for _ in range(N)]
for _ in range(N - 1):
    a, b = inpl()
    a -= 1
    b -= 1
    edges[a].add(b)
    edges[b].add(a)
cd = []
c2q = [set() for _ in range(N)]
for q in range(Q):
    c, d = inpl()
    c -= 1
    d -= 1
    cd.append((c, d))
    c2q[c].add(q)
    c2q[d].add(q)

FORWARD, BACK = 0, 1
pool = [(FORWARD, 0)]  # s, x
parent = [-1] * N
depth = [-1] * N
route = [-1] * Q
history = []
in_order = [-1] * N
cur = -1
while pool:
    s, x = pool.pop()
    if s == FORWARD:
        depth[x] = len(history)
        cur += 1
        history.append(cur)
        in_order[x] = cur
        for q in c2q[x]:
            c, d = cd[q]
            y = d if x == c else c
            prev = in_order[y]
            if prev < 0:
                continue
            else:
                p = bisect_right(history, prev) - 1
                route[q] = depth[x] + depth[y] - 2 * p

        pool.append((BACK, x))
        for y in edges[x]:
            if y == parent[x]:
                continue
            else:
                parent[y] = x
                pool.append((FORWARD, y))
    else:
        history.pop()

for q in range(Q):
    print(output[route[q] % 2])
# for q in range(Q):
#     print(route[q])
import heapq


def dijkstra(st):
    dst[st] = 0
    hq = [(0, st)]
    while hq:
        c, v = heapq.heappop(hq)
        if c > dst[v]: continue
        for nc, nv in G[v]:
            if c + nc >= dst[nv]: continue
            dst[nv] = c + nc
            heapq.heappush(hq, (c + nc, nv))


n, q = map(int, input().split())
G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    G[a].append((1, b))
    G[b].append((1, a))

dst = [float('inf')] * n
dijkstra(0)

for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if abs(dst[c] - dst[d]) % 2 == 0: print('Town')
    else: print('Road')
def euler_tour(s):
    stack = [~s, s]
    t, d = 0, 0
    depth, first_visit, last_visit, tour = [0] * N, [0] * N, [0] * N, []
    parent, seen = [None] * N, [False] * N
    parent[s] = -1
    depth[s] = 0
    seen[s] = True

    while stack:
        u = stack.pop()
        if u >= 0:
            t += 1
            first_visit[u] = t
            tour.append(u)
            for v in G[u]:
                if seen[v]:
                    continue
                else:
                    seen[v] = True
                depth[v] = depth[u] + 1
                parent[v] = u
                stack.append(~v)
                stack.append(v)
        else:
            t += 1
            last_visit[u] = t
            tour.append(~u)
    return depth, first_visit, last_visit, tour


N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    A, B = map(int, input().split())
    A, B = A - 1, B - 1
    G[A].append(B)
    G[B].append(A)

depth, first_visit, last_visit, tour = euler_tour(0)
for i in range(Q):
    C, D = map(int, input().split())
    C, D = C - 1, D - 1
    if (depth[C] - depth[D]) % 2 == 0:
        print("Town")
    else:
        print("Road")class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]  # 隣接リストG[u][i] := 頂点uのi個目の隣接辺
        self._E = 0  # 辺の数
        self._V = V  # 頂点の数

    def E(self):
        return self._E

    def V(self):
        return self._V

    def add(self, _from, _to):
        self.G[_from].append(self.Edge(_to, 1))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []  # プライオリティキュー（ヒープ木）
        d = [float("INF")] * self._V
        d[s] = 0
        heapq.heappush(que, (0, s))  # 始点の(最短距離, 頂点番号)をヒープに追加する
        while len(que) != 0:
            cost, v = heapq.heappop(que)
            # キューに格納されている最短経路の候補がdの距離よりも大きければ、他の経路で最短経路が存在するので、処理をスキップ
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                # 頂点vに隣接する各頂点に関して、頂点vを経由した場合の距離を計算し、今までの距離(d)よりも小さければ更新する
                e = self.G[v][i]  # vのi個目の隣接辺e
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost  # dの更新
                    heapq.heappush(
                        que,
                        (d[e.to], e.to))  # キューに新たな最短経路の候補(最短距離, 頂点番号)の情報をpush
        return d


N, Q = map(int, input().split())
djk = Dijkstra(N)
for i in range(N - 1):
    u, v = map(int, input().split())
    djk.add(u - 1, v - 1)
    djk.add(v - 1, u - 1)
d1 = djk.shortest_path(0)
for i in range(Q):
    c, d = map(int, input().split())
    if (d1[c - 1] + d1[d - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import sys

sys.setrecursionlimit(10000000)


def dfs(a):
    for i in load[a]:
        if length[i] != -1:
            continue
        else:
            length[i] = length[a] + 1
            dfs(i)
    return


n, q = map(int, input().split())
length = [-1 for i in range(n + 1)]
length[1] = 0
load = [[] for i in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    load[a].append(b)
    load[b].append(a)
dfs(1)
for i in range(q):
    c, d = map(int, input().split())
    if (length[c] - length[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
n, qc = map(int, input().split())
edge = [[] for _ in range(n)]
for i in range(n - 1):
    x, y = map(int, input().split())
    edge[x - 1].append(y - 1)
    edge[y - 1].append(x - 1)
q, dist = [0], [-1] * n
dist[0] = 0
while q:
    node = q.pop()
    for e in edge[node]:
        if dist[e] == -1:
            dist[e] = dist[node] + 1
            q.append(e)
for _ in range(qc):
    c, d = map(int, input().split())
    if dist[c - 1] % 2 == dist[d - 1] % 2:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
edges = [list(map(int, input().split())) for i in range(N - 1)]
xy = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(Q)]


def BFS(K, edges, N):
    roots = [[] for i in range(N)]
    for a, b in edges:
        roots[a - 1] += [(b - 1, 1)]
        roots[b - 1] += [(a - 1, 1)]
    dist = [-1] * N
    stack = []
    stack.append(K)
    dist[K] = 0
    while stack:
        label = stack.pop(-1)
        for i, c in roots[label]:
            if dist[i] == -1:
                dist[i] = dist[label] + c
                stack += [i]
    return dist


distance = BFS(0, edges, N)

result = []
for a, b in xy:
    tar = distance[a] + distance[b]
    if tar % 2 == 0:
        result.append('Town')
    else:
        result.append('Road')
print(*result, sep='\n')
class BinaryLiftingLCA:
    '''
    参考: https://tjkendev.github.io/procon-library/python/graph/lca-doubling.html
    '''
    def __init__(self, N):
        self.N = N
        self.G = [[] for _ in range(N)]

    def add_edge(self, a, b):
        self.G[a].append(b)
        self.G[b].append(a)

    def from_graph(self, G):
        self.G = G

    def build(self, root=0):
        self.root = root
        self._bfs(root)
        self.maxdepth = max(self.d).bit_length()
        self.table = [self.prev]
        tmp1 = self.prev[:]
        for i in range(self.maxdepth):
            tmp2 = [0] * self.N
            for j in range(self.N):
                if tmp1[j] == -1: continue
                tmp2[j] = tmp1[tmp1[j]]
            self.table.append(tmp2)
            tmp1 = tmp2

    def lca(self, u, v):
        dd = self.d[v] - self.d[u]
        if dd < 0:
            u, v = v, u
            dd = -dd
        for k in range(self.maxdepth + 1):
            if dd & 1: v = self.table[k][v]
            dd >>= 1
        if u == v: return u
        for i in range(self.maxdepth - 1, -1, -1):
            pu = self.table[i][u]
            pv = self.table[i][v]
            if pu != pv:
                u = pu
                v = pv
        return self.table[self.root][u]

    def _bfs(self, s):
        from collections import deque
        seen = [0] * self.N
        self.d = [0] * self.N
        self.prev = [-1] * self.N
        todo = deque()
        seen[s] = 1
        todo.append(s)
        while len(todo):
            a = todo.popleft()
            for b in self.G[a]:
                if seen[b] == 0:
                    seen[b] = 1
                    todo.append(b)
                    self.d[b] += self.d[a] + 1
                    self.prev[b] = a


N, Q = map(int, input().split())
lca = BinaryLiftingLCA(N)
for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    lca.add_edge(a, b)

lca.build()
for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    w = lca.lca(c, d)
    dist = lca.d[c] + lca.d[d] - lca.d[w] * 2
    if dist % 2: print("Road")
    else: print("Town")
n, q = map(int, input().split())
peer = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    peer[a].append(b)
    peer[b].append(a)
st = [0 for _ in range(n)]
seen = [0 for _ in range(n)]
seen[0] = 1
now = [0]
cnt = 0
while now:
    cnt += 1
    last = now
    now = []
    for x in last:
        for y in peer[x]:
            if seen[y] == 0:
                seen[y] = 1
                st[y] = cnt
                now.append(y)
#print(st)
for _ in range(q):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    if (st[a] + st[b]) % 2:
        print('Road')
    else:
        print('Town')
from collections import defaultdict, deque

N, Q = map(int, input().split())
info = defaultdict(list)
for _ in range(N - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    info[a].append(b)
    info[b].append(a)
dist = [-1] * N
dist[0] = 0
que = deque([(0, 0)])
while que:
    d, c = que.popleft()
    for to in info[c]:
        if dist[to] != -1:
            continue
        dist[to] = d + 1
        que.append((d + 1, to))

for _ in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    ans = "Town" if dist[c] % 2 == dist[d] % 2 else "Road"
    print(ans)
import sys, re
from math import ceil, floor, sqrt, pi, factorial, gcd
from copy import deepcopy
from collections import Counter, deque
from heapq import heapify, heappop, heappush
from itertools import accumulate, product, combinations, combinations_with_replacement
from bisect import bisect, bisect_left, bisect_right
from functools import reduce
from decimal import Decimal, getcontext


def i_input():
    return int(input())


def i_map():
    return map(int, input().split())


def i_list():
    return list(i_map())


def i_row(N):
    return [i_input() for _ in range(N)]


def i_row_list(N):
    return [i_list() for _ in range(N)]


def s_input():
    return input()


def s_map():
    return input().split()


def s_list():
    return list(s_map())


def s_row(N):
    return [s_input for _ in range(N)]


def s_row_str(N):
    return [s_list() for _ in range(N)]


def s_row_list(N):
    return [list(s_input()) for _ in range(N)]


def lcm(a, b):
    return a * b // gcd(a, b)


sys.setrecursionlimit(10**6)
INF = float('inf')
MOD = 10**9 + 7
num_list = []
str_list = []


def dfs(i, graph, dist, depth):
    depth += 1
    for j in graph[i]:
        if dist[j] == 0:
            dist[j] = depth
            dfs(j, graph, dist, depth)


def main():
    n, q = i_map()
    graph = [[] for _ in range(n)]

    for _ in range(n - 1):
        a, b = i_map()
        graph[a - 1].append(b - 1)
        graph[b - 1].append(a - 1)

    query = i_row_list(q)
    dist = [0] * n

    dfs(0, graph, dist, 0)

    for a, b in query:
        if (dist[a - 1] + dist[b - 1]) % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
N, Q = map(int, input().split())
root = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    root[a - 1].append(b - 1)
    root[b - 1].append(a - 1)
ischecked = [-1] * N
q = [0]
ischecked[0] = 0
while q:
    now = q.pop()
    dist = (ischecked[now] + 1) % 2
    for nex in root[now]:
        if ischecked[nex] >= 0:
            continue
        ischecked[nex] = dist
        q.append(nex)
for _ in range(Q):
    c, d = map(int, input().split())
    if ischecked[c - 1] == ischecked[d - 1]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())

G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    elif color[c - 1] != color[d - 1]:
        print("Road")
from collections import deque

n, q = map(int, input().split())
G = [[] for i in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
dist = [-1] * n
dist[0] = 0
Q = deque([0])
while Q:
    u = Q.popleft()
    for v in G[u]:
        if dist[v] == -1:
            Q.append(v)
            dist[v] = dist[u] + 1
for _ in range(q):
    c, d = map(int, input().split())
    print("Road" if (dist[c - 1] - dist[d - 1]) % 2 else "Town")
import queue

n, q = map(int, input().split())
g = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)
l = queue.Queue()
eo = [-1] * n
eo[0] = 0
l.put(0)
while l.empty() == False:
    t = l.get()
    for i in g[t]:
        if eo[i] == -1:
            eo[i] = 1 - eo[t]
            l.put(i)
for i in range(q):
    a, b = map(int, input().split())
    if eo[a - 1] == eo[b - 1]:
        print("Town")
    else:
        print("Road")
import sys

input = sys.stdin.buffer.readline


class LcaDoubling:
    """
    links[v] = { (u, w), (u, w), ... }  (u:隣接頂点, w:辺の重み) #set
    というグラフ情報から、ダブリングによるLCAを構築。
    任意の2頂点のLCAおよび距離を取得できるようにする
    """
    def __init__(self, n, links, root=0):  #根を指定する。
        self.depths = [-1] * n
        self.distances = [-1] * n
        prev_ancestors = self._init_dfs(n, links, root)
        self.ancestors = [prev_ancestors]
        max_depth = max(self.depths)
        d = 1
        while d < max_depth:
            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]
            self.ancestors.append(next_ancestors)
            d <<= 1
            prev_ancestors = next_ancestors

    def _init_dfs(self, n, links, root):
        q = [(root, -1, 0, 0)]
        direct_ancestors = [-1] * (n + 1
                                   )  # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1
        while q:
            v, p, dep, dist = q.pop()
            direct_ancestors[v] = p
            self.depths[v] = dep
            self.distances[v] = dist
            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)
        return direct_ancestors

    def get_lca(self, u, v):
        du, dv = self.depths[u], self.depths[v]
        if du > dv:
            u, v = v, u
            du, dv = dv, du
        tu = u
        tv = self.upstream(v, dv - du)
        if u == tv:
            return u
        for k in range(du.bit_length() - 1, -1, -1):
            mu = self.ancestors[k][tu]
            mv = self.ancestors[k][tv]
            if mu != mv:
                tu = mu
                tv = mv
        lca = self.ancestors[0][tu]
        assert lca == self.ancestors[0][tv]
        return lca

    def get_distance(self, u, v):
        lca = self.get_lca(u, v)
        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]

    def upstream(self, v, k):  #vからk個上？
        i = 0
        while k:
            if k & 1:
                v = self.ancestors[i][v]
            k >>= 1
            i += 1
        return v


def main():
    N, Q = map(int, input().split())
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        G[a].append((b, 1))
        G[b].append((a, 1))

    lcad = LcaDoubling(N, G)

    for i in range(Q):
        c, d = map(int, input().split())
        c -= 1
        d -= 1
        dis = lcad.get_distance(c, d)
        if dis % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(int, input().split())
    G[x - 1] += [y - 1]
    G[y - 1] += [x - 1]

lca = LCA(G)
for _ in range(Q):
    c, d = map(int, input().split())
    common = lca.get(c - 1, d - 1)
    #頂点 a , b a,b を結ぶパスは、 c = l c a ( a , b ) c=lca(a,b) として、 a a から c c までは木を遡上し、
    # c c から b b まで下ることとなる。 根から各頂点への距離 d i s t [ v ] depth[v] を記録しておけば、
    # 簡単な計算で2点間距離を求めることができる。
    # depth[a]+depth[b]−2depth[c] 「 a a から根まで遡上し、根から b b まで下る、という経路の内、根～ c c の往復分が無駄である」と考えるとよい。
    if (lca.depth[c - 1] + lca.depth[d - 1] - 2 * lca.depth[common]) % 2 == 0:
        print("Town")
    else:
        print("Road")
(N, _), *r = [map(int, s.split()) for s in open(0)]
G = [[] for _ in range(N + 1)]
for a, b in r[:N - 1]:
    G[a] += b,
    G[b] += a,
V = [1] * N + [0]
q = [N]
while q:
    i = q.pop()
    for j in G[i]:
        if V[j] > 0:
            V[j] = ~V[i]
            q += j,
for c, d in r[N - 1:]:
    print('RTooawdn'[V[c] == V[d]::2])
N, Q = map(int, input().split())
AB = [[int(item) for item in input().split()] for _ in range(N - 1)]
# print(AB)
AB.sort(key=lambda x: (x[0], x[1]))
Next_Dict = {n: [] for n in range(1, N + 1)}
for ab in AB:
    Next_Dict[ab[0]].append(ab[1])
    Next_Dict[ab[1]].append(ab[0])

# print(Next_Dict)
min_list = [N for _ in range(N + 1)]
min_list[1] = 0

import queue

q = queue.Queue()

q.put(1)

tuuka = [False for _ in range(0, N + 1)]
while not q.empty():
    item = q.get()
    if tuuka[item]:
        continue
    tuuka[item] = True
    # print("item", item)
    d = min_list[item]
    # print("d", d)
    for next in Next_Dict[item]:
        q.put(next)
        min_list[next] = min(d + 1, min_list[next])
    # print("min_list", min_list)

# print(min_list)

CD = [[int(item) for item in input().split()] for _ in range(Q)]

for cd in CD:
    c, d = cd
    print('Town' if (min_list[c] + min_list[d]) % 2 == 0 else 'Road')
class Node:
    def __init__(self, i):
        self.id = i
        self.adj_list = list()
        self.color = -1


class Graph:
    def __init__(self, size):
        self.node_num = size + 1
        self.node_list = [Node(i) for i in range(self.node_num)]

    def add_edge(self, a, b):
        a_node = self.node_list[a]
        b_node = self.node_list[b]
        a_node.adj_list.append(b_node)
        b_node.adj_list.append(a_node)

    def node(self, idx):
        return self.node_list[idx]

    def coloring(self):
        v_node = self.node_list[1]
        c = 0
        v_node.color = c
        queue = list()
        queue.append(v_node)
        while len(queue) > 0:
            c = (c + 1) % 2
            queue2 = list()
            for v_node in queue:
                for u_node in v_node.adj_list:
                    if u_node.color == -1:
                        u_node.color = c
                        queue2.append(u_node)
            queue = queue2

    def shortest_path(self, a, b):
        a_node = self.node_list[a]
        b_node = self.node_list[b]
        if a_node.color == b_node.color:
            return 0
        else:
            return 1


n, q = map(int, input().split())

G = Graph(n)
for _ in range(n - 1):
    a, b = map(int, input().split())
    G.add_edge(a, b)
G.coloring()
for _ in range(q):
    c, d = map(int, input().split())
    if G.shortest_path(c, d):
        print('Road')
    else:
        print('Town')
import heapq
import sys

sys.setrecursionlimit(3000000)

n, q = map(int, input().split())

g = [[] for _ in range(n + 1)]

color = ["x"] * (n + 1)

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

# for i in range(1,n+1):
#     g[i].sort()


def bfs(start, bef, dim):

    if dim % 2 == 0:
        color[start] = "○"
    else:
        color[start] = "x"
    dim += 1
    for s in g[start]:
        if s != bef:
            bfs(s, start, dim)

    dim -= 1


dim = 1
bfs(1, -1, dim)

for i in range(q):
    c, d = map(int, input().split())
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())

edges = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    edges[a].append(b)
    edges[b].append(a)

CNT = [-1] * n
CNT[0] = 0

DQ = deque([0])

while DQ:
    x = DQ.popleft()
    for y in edges[x]:
        if CNT[y] >= 0:
            continue
        CNT[y] = CNT[x] + 1
        DQ.append(y)
# print(CNT)

for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if (CNT[c] - CNT[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())

tree = [[] for _ in range(N)]
ans = []

for _ in range(N - 1):
    a, b = map(int, input().split())
    tree[a - 1].append(b - 1)
    tree[b - 1].append(a - 1)


def bfs(u):
    queue = deque([u])
    d = [None] * (N)
    d[u] = 0
    while queue:
        v = queue.popleft()
        for i in tree[v]:
            if d[i] is not None:
                continue
            d[i] = d[v] + 1
            queue.append(i)
    return d


dis = bfs(0)

for _ in range(Q):
    c, d = map(int, input().split())
    if (dis[c - 1] + dis[d - 1]) % 2 == 0:
        ans.append("Town")
    else:
        ans.append("Road")

print(*ans, sep="\n")
import sys
from collections import deque


def input():
    return sys.stdin.readline().strip()


def I():
    return int(input())


def LI():
    return list(map(int, input().split()))


def IR(n):
    return [I() for i in range(n)]


def LIR(n):
    return [LI() for i in range(n)]


def SR(n):
    return [S() for i in range(n)]


def S():
    return input()


def LS():
    return input().split()


INF = float('inf')


class Graph:
    def __init__(self, n, is_directed=False):
        """
        :param n: 頂点数
        :param is_directed: 有向グラフ(True)か無向グラフか(False)
        """
        self.graph = [[] for _ in range(n)]
        self.is_directed = is_directed

    def add_edge(self, u, v):
        """頂点uから頂点vに辺を作る
        無向グラフの場合、uからvの方向の辺のみを記録する
        """
        self.graph[u].append(v)
        if not self.is_directed:
            self.graph[v].append(u)

    def bfs(self, start):
        """幅優先探索を行い始点から各頂点までの距離の配列を返す
        """
        distances = [INF] * len(self.graph)
        queue = deque([start])
        distances[start] = 0
        # ans = [0] * len(self.graph)

        while queue:
            now = queue.popleft()
            for to in self.graph[now]:
                if distances[to] != INF:
                    continue
                queue.append(to)
                distances[to] = distances[now] + 1
        return distances

    def dfs(self, start):
        """深さ優先探索を行い始点から各頂点までの距離の配列を返す
        """
        distances = [INF] * len(self.graph)
        queue = deque([start])
        distances[start] = 0

        while queue:
            now = queue.pop()
            for to in self.graph[now]:
                if distances[to] != INF:
                    continue
                queue.append(to)
                # 前の頂点からこの頂点に対する道標を建てる
                distances[to] = distances[now] + 1
        return distances


n, q = LI()
g = Graph(n)
for _ in range(n - 1):
    a, b = LI()
    a -= 1
    b -= 1
    g.add_edge(a, b)

ques = []
for _ in range(q):
    c, d = LI()
    c -= 1
    d -= 1
    ques.append([c, d])

dist = g.dfs(0)

for (c, d) in ques:
    m = abs(dist[c] - dist[d]) % 2
    print('Road' if m == 1 else 'Town')
from collections import deque

n, m = map(int, input().split())
graph = [list() for _ in range(n)]

for _ in range(n - 1):
    u, k = [int(x) for x in input().split()]  # uは頂点番号、kは隣接頂点の個数
    u, k = u - 1, k - 1
    graph[u].append(k)
    graph[k].append(u)  # 無向グラフ

dist = [-1] * n  #距離
dist[0] = 0  #startは0

q = deque()
q.append(0)  #startは0
while q:  #qが空になるまで
    v = q.popleft()
    for x in graph[v]:
        if dist[x] != -1:  #更新
            continue
        dist[x] = 1 - dist[v]
        q.append(x)

for i in range(m):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    if dist[c] != dist[d]:
        print("Road")
    else:
        print("Town")
import sys
from collections import deque

readline = sys.stdin.readline
readall = sys.stdin.read
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))
prl = lambda x: print(*x, sep='\n')
string = 'abcdefghijklmnopqrstuvwxyz'


def bfs(s, W):
    n = len(W)
    color = [-1] * len(W)
    que = deque([s])
    color[s] = 0
    while que:
        v = que.popleft()
        for w in W[v]:
            if color[w] > -1:
                continue
            color[w] = abs(color[v] - 1)
            que.append(w)
    return color


n, q = nl()
W = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = nl()
    W[a - 1].append(b - 1)
    W[b - 1].append(a - 1)

color = bfs(0, W)
for _ in range(q):
    c, d = nl()
    if color[c - 1] == color[d - 1]:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())

path = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    path[a - 1].append(b - 1)
    path[b - 1].append(a - 1)
l = [0] * N
for i in range(N):
    if len(path[i]) == 1:
        s = i
        break

flag = -1
l[s] = flag
stack = [s]
unused = [1] * N
unused[s] = 0
while len(stack):
    flag *= -1
    new_stack = []
    for p in stack:
        for np in path[p]:
            if unused[np]:
                unused[np] = 0
                l[np] = flag
                new_stack.append(np)
    stack = new_stack[:]

for i in range(Q):
    c, d = map(int, input().split())
    if l[c - 1] == l[d - 1]:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
graph = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
C, D = [0] * Q, [0] * Q
for i in range(Q):
    C[i], D[i] = map(int, input().split())

from collections import deque

d = deque([1])
depth = [-1] * (N + 1)
depth[1] = 0

while d:
    v = d.popleft()
    for i in graph[v]:
        if depth[i] != -1:
            continue
        else:
            depth[i] = (depth[v] + 1) % 2
            d.append(i)

for i in range(Q):
    if depth[C[i]] == depth[D[i]]:
        print('Town')
    else:
        print('Road')
from collections import defaultdict, deque

distances = {}


def depth(edges, n):
    visited = [0] * (n + 1)
    distance = [0] * (n + 1)

    # queue to do BFS.
    Q = deque()
    distance[1] = 0

    Q.append(1)
    visited[1] = True
    while Q:
        x = Q.popleft()

        for i in edges[x]:
            if visited[i]:
                continue

            distance[i] = distance[x] + 1
            Q.append(i)
            visited[i] = 1
    return distance


n, q = map(int, input().split())
graph = defaultdict(list)
for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

depths = depth(graph, n)

for _ in range(q):
    c, d = map(int, input().split())
    dist = depths[c] - depths[d]
    if dist % 2 == 1:
        print('Road')
    else:
        print('Town')
from collections import deque

n, q = map(int, input().split())
graph = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

dp = [0] * n

que = deque()
que.append([0, 1])
ch = [False] * n
while (que):
    t = que.popleft()
    x = t[0]
    cnt = t[1]
    for i in graph[x]:
        if (ch[i]):
            continue
        else:
            if (cnt % 2):
                dp[i] = 1
            ch[i] = True
            que.append([i, cnt + 1])

ans = [0] * q
for i in range(q):
    c, d = map(int, input().split())
    if (dp[c - 1] == dp[d - 1]):
        ans[i] = 1

for i in range(q):
    if (ans[i]):
        print("Town")
    else:
        print("Road")
#N 個の街と N−1 本の道路なのでループはない。木構造
#根への距離をそれぞれ求めて、和が2で割り切れるかで判断できそう

from collections import defaultdict
from collections import deque

N, Q = map(int, input().split())

connect_nodes = defaultdict(set)

for i in range(N - 1):
    a, b = map(int, input().split())
    connect_nodes[a].add(b)
    connect_nodes[b].add(a)

dist = [-1 for _ in range(N + 1)]  #1からの距離。到達不可なら-1
is_visited = [False for _ in range(N + 1)]  #訪問フラグ

#function 幅優先探索(v)
search_deque = deque()  #Q ← 空のキュー
is_visited[1] = True  #v に訪問済みの印を付ける
search_deque.append(1)  #v を Q に追加
dist[1] = 0

while len(search_deque) != 0:  #while Q が空ではない do
    node = search_deque.popleft()  #    v ← Q から取り出す
    #    v を処理する
    for connect_node in connect_nodes[node]:  #    for each v に接続している頂点 i do
        if is_visited[connect_node] == False:  #        if i が未訪問 then
            is_visited[connect_node] = True  #            iに訪問済みの印を付ける
            search_deque.append(connect_node)  #            i を Q に追加
            dist[connect_node] = dist[
                node] + 1  #(左記は距離が全点間1固定の時。異なる場合は読み込み部分と共に変更すること)

for i in range(Q):
    c, d = map(int, input().split())

    if (dist[c] + dist[d]) % 2 == 1:
        print("Road")
    else:
        print("Town")
from collections import defaultdict, Counter, deque

N, Q = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

A = [0 for _ in range(N)]

st = 0
for i in range(N):
    if len(G[i]) == 1:
        st = i
        break

d = deque([st])
al = set([st])
turn = 0
while d:
    #print(d)
    turn += 1
    for _ in range(len(d)):
        q = d.popleft()
        for i in range(len(G[q])):
            nex = G[q][i]
            if nex in al:
                continue
            d.append(nex)
            al.add(nex)
            A[nex] = turn

for _ in range(Q):
    c, d = map(int, input().split())
    ans = abs(A[d - 1] - A[c - 1])
    if ans % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque


def func():
    N, Q = map(int, input().split())
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)

    que = deque()
    que.append((0, 0, -1))
    tmp = -1
    dist = [0] * N
    while que:
        v = que.popleft()
        for x in G[v[0]]:
            if x == v[2]:
                continue
            dist[x] = v[1] + 1
            que.append((x, v[1] + 1, v[0]))
    # print(dist)
    for _ in range(Q):
        c, d = map(int, input().split())
        if abs(dist[c - 1] - dist[d - 1]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    func()
from collections import deque

N, Q = map(int, input().split())
D = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1

    D[a].append(b)
    D[b].append(a)

dist = [-1] * N
que = deque()
dist[0] = 0
que.append(0)

while que:
    v = que.popleft()

    for i in D[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        que.append(i)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    if (dist[c] + dist[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
input = lambda: sys.stdin.readline().rstrip()
import bisect, string, math, time, functools, random, fractions
from bisect import *
from heapq import heappush, heappop, heapify
from collections import deque, defaultdict, Counter
from itertools import permutations, combinations, groupby

rep = range
R = range


def I():
    return int(input())


def LI():
    return [int(i) for i in input().split()]


def LI_():
    return [int(i) - 1 for i in input().split()]


def AI():
    return map(int, open(0).read().split())


def S_():
    return input()


def IS():
    return input().split()


def LS():
    return [i for i in input().split()]


def NI(n):
    return [int(input()) for i in range(n)]


def NI_(n):
    return [int(input()) - 1 for i in range(n)]


def NLI(n):
    return [[int(i) for i in input().split()] for i in range(n)]


def NLI_(n):
    return [[int(i) - 1 for i in input().split()] for i in range(n)]


def StoLI():
    return [ord(i) - 97 for i in input()]


def ItoS(n):
    return chr(n + 97)


def LtoS(ls):
    return ''.join([chr(i + 97) for i in ls])


def RLI(n=8, a=1, b=10):
    return [random.randint(a, b) for i in range(n)]


def RI(a=1, b=10):
    return random.randint(a, b)


def INP():
    N = 10
    n = random.randint(1, N)
    a = RLI(n, 0, n - 1)
    return n, a


def Rtest(T):
    case, err = 0, 0
    for i in range(T):
        inp = INP()
        a1 = naive(*inp)
        a2 = solve(*inp)
        if a1 != a2:
            print(inp)
            print('naive', a1)
            print('solve', a2)
            err += 1
        case += 1
    print('Tested', case, 'case with', err, 'errors')


def GI(V, E, ls=None, Directed=False, index=1):
    org_inp = []
    g = [[] for i in range(V)]
    FromStdin = True if ls == None else False
    for i in range(E):
        if FromStdin:
            inp = LI()
            org_inp.append(inp)
        else:
            inp = ls[i]
        if len(inp) == 2:
            a, b = inp
            c = 1
        else:
            a, b, c = inp
        if index == 1:
            a -= 1
            b -= 1
        aa = (a, c)
        bb = (b, c)
        g[a].append(bb)
        if not Directed: g[b].append(aa)
    return g, org_inp


def GGI(h,
        w,
        search=None,
        replacement_of_found='.',
        mp_def={
            '#': 1,
            '.': 0
        },
        boundary=1):
    #h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1) # sample usage
    mp = [boundary] * (w + 2)
    found = {}
    for i in R(h):
        s = input()
        for char in search:
            if char in s:
                found[char] = ((i + 1) * (w + 2) + s.index(char) + 1)
                mp_def[char] = mp_def[replacement_of_found]
        mp += [boundary] + [mp_def[j] for j in s] + [boundary]
    mp += [boundary] * (w + 2)
    return h + 2, w + 2, mp, found


def TI(n):
    return GI(n, n - 1)


def accum(ls):
    rt = [0]
    for i in ls:
        rt += [rt[-1] + i]
    return rt


def bit_combination(n, base=2):
    rt = []
    for tb in R(base**n):
        s = [tb // (base**bt) % base for bt in R(n)]
        rt += [s]
    return rt


def gcd(x, y):
    if y == 0: return x
    if x % y == 0: return y
    while x % y != 0:
        x, y = y, x % y
    return y


def YN(x):
    print(['NO', 'YES'][x])


def Yn(x):
    print('YNeos'[not x::2])


def show(*inp, end='\n'):
    if show_flg: print(*inp, end=end)


def showf(inp, length=3, end='\n'):
    if show_flg:
        print([' ' * (length - len(str(i))) + str(i) for i in inp], end=end)


mo = 10**9 + 7
#mo=998244353
inf = float('inf')
FourNb = [(-1, 0), (1, 0), (0, 1), (0, -1)]
EightNb = [(-1, 0), (1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1),
           (-1, 1)]
compas = dict(zip('WENS', FourNb))
cursol = dict(zip('LRUD', FourNb))
alp = [chr(ord('a') + i) for i in range(26)]


#sys.setrecursionlimit(10**7)
def gcj(c, x):
    print("Case #{0}:".format(c + 1), x)


show_flg = False
show_flg = True

# Verified by
# https://atcoder.jp/contests/abc014/tasks/abc014_4
# https://atcoder.jp/contests/abc133/tasks/abc133_f

# import SparseTable
# initialize
# Tree() => n; (a,b);*(n-1)
# Tree(n) => (a,b);*(n-1)
# Tree(init=False); Tree.stdin(); => n; (a,b);*(n-1)
# Tree(init=False); Tree.listin(ls,index=0); => (a,b);*(n-1)


class Tree:
    def __init__(self, inp_size=None, ls=None, init=True, index=1):
        self.LCA_init_stat = False
        self.ETtable = []
        if init:
            if ls == None:
                self.stdin(inp_size, index=index)
            else:
                self.node_size = len(ls) + 1
                self.edges, _ = GI(self.node_size,
                                   self.node_size - 1,
                                   ls,
                                   index=index)
        return

    def stdin(self, inp_size=None, index=1):
        if inp_size == None:
            self.node_size = int(input())
        else:
            self.node_size = inp_size
        self.edges, _ = GI(self.node_size, self.node_size - 1, index=index)
        return

    def listin(self, ls, index=0):
        self.node_size = len(ls) + 1
        self.edges, _ = GI(self.node_size, self.node_size - 1, ls, index=index)
        return

    def dfs(self, x, func=lambda pr, prv, nx, dist: prv + dist, root_v=0):
        q = deque([x])
        v = [None] * self.node_size
        v[x] = root_v
        while q:
            c = q.pop()
            for nb, d in self.edges[c]:
                if v[nb] == None:
                    q.append(nb)
                    v[nb] = func(c, v[c], nb, d)
        return v

    def bfs(self, x, func=lambda pr, prv, nx, dist: prv + dist, root_v=0):
        q = deque([x])
        v = [None] * self.node_size
        v[x] = root_v
        while q:
            c = q.popleft()
            for nb, d in self.edges[c]:
                if v[nb] == None:
                    q.append(nb)
                    v[nb] = func(c, v[c], nb, d)
        return v

    def parent(self, x):
        return self.dfs(0, func=lambda pr, prv, nx, dist: pr, root_v=-1)

    def topological_sort(self, x):  # return topological sort of the tree
        tps = []
        q = deque([x])
        v = [None] * self.node_size
        v[x] = 0
        while q:
            c = q.popleft()
            tps.append(c)
            for nb, d in self.edges[c]:
                if v[nb] == None:
                    q.append(nb)
                    v[nb] = 0
        return tps

    def EulerTour(self, x):
        q = deque()
        q.append(x)
        self.depth = [None] * self.node_size
        self.depth[x] = 0
        self.ETtable = []
        self.ETdepth = []
        self.ETin = [-1] * self.node_size
        self.ETout = [-1] * self.node_size
        cnt = 0
        while q:
            c = q.pop()
            if c < 0:
                ce = ~c
            else:
                ce = c
                for nb, d in self.edges[ce]:
                    if self.depth[nb] == None:
                        q.append(~ce)
                        q.append(nb)
                        self.depth[nb] = self.depth[ce] + 1
            self.ETtable.append(ce)
            self.ETdepth.append(self.depth[ce])
            if self.ETin[ce] == -1:
                self.ETin[ce] = cnt
            else:
                self.ETout[ce] = cnt
            cnt += 1
        return

    def doubling_LCA(self, root, x, y):
        if self.LCA_init_stat == False:
            self.depth = [None] * self.node_size
            self.depth = self.bfs(0, func=lambda pr, prv, nxt, dist: prv + 1)
            self.par = self.bfs(0, func=lambda pr, prv, nxt, dist: pr)
            self.db = [self.par]
            for i in range(self.node_size.bit_length()):
                #show(self.db)
                self.db += [[
                    self.db[-1][self.db[-1][i]] for i in range(self.node_size)
                ]]
            self.LCA_init_stat = True
        dx = self.depth[x]
        dy = self.depth[y]
        if dx > dy:
            dx, dy = dy, dx
        c = self.node_size.bit_length()
        while c > 0:
            if dx + c <= dy:
                x = self.db[c][x]
                dx += 1 << c
            c >>= 1

        if x == y:
            return x

        c = self.node_size.bit_length()
        while c > 0:
            if self.db[c][x] != self.db[c][y]:
                x = self.db[c][x]
                y = self.db[c][y]
            c >>= 1

        return self.par[x]

    def LCA_init(self, root):
        self.EulerTour(root)
        self.st = SparseTable(self.ETdepth, init_func=min, init_idl=inf)
        #self.st=SegTree(self.node_size*2-1,self.ETdepth,function=min,ide=inf)
        self.LCA_init_stat = True
        return

    def LCA(self, root, x, y):
        if self.LCA_init_stat == False:
            self.LCA_init(root)
        xin, xout = self.ETin[x], self.ETout[x]
        yin, yout = self.ETin[y], self.ETout[y]
        a = min(xin, yin)
        b = max(xout, yout, xin, yin)
        id_of_min_dep_in_et = self.st.query_id(a, b + 1)
        return self.ETtable[id_of_min_dep_in_et]

    def __str__(self):
        return str(self.edges)

    def show(self):
        if all([all([d == 1 for nd, d in e]) for e in self.edges]):
            print([[nd for nd, d in e] for e in self.edges])
        else:
            print(self)

    def dfs_tour(self, x, root_dep=0):
        q = deque([x])
        dep = [None] * self.node_size
        dep[x] = root_dep
        dfs_tr = [x]
        while q:
            c = q.pop()
            for nb, d in self.edges[c]:
                if dep[nb] == None:
                    q.append(nb)
                    dep[nb] = dep[c] + 1
                    dfs_tr += nb,
        return dep, dfs_tr


ans = 0
P = math.pi

n, q = LI()
tr = Tree(n)
v = tr.bfs(0)
for i in range(q):
    c, d = LI_()
    if (v[c] - v[d]) % 2 == 0:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())
roads = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    roads[a].append(b)
    roads[b].append(a)

color = ['', 'black'] + ['?'] * (n - 1)
queue = [1]
while len(queue) != 0:
    x = queue.pop(0)
    for i in roads[x]:
        if color[i] != '?':
            continue
        if color[x] == 'black':
            color[i] = 'white'
            queue.append(i)
        else:
            color[i] = 'black'
            queue.append(i)

for _ in range(q):
    c, d = map(int, input().split())
    if color[c] == color[d]:
        print("Town")
    else:
        print("Road")
from collections import deque


def main():
    N, Q = map(int, input().split())
    graph = [[] for _ in range(N + 1)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)
    depth_vec = [-1] * (N + 1)
    queue = deque()
    queue.append((1, 0))
    while len(queue) > 0:
        node, depth = queue.pop()
        depth_vec[node] = depth
        for child in graph[node]:
            if depth_vec[child] >= 0:
                continue
            queue.append((child, depth + 1))
    for query in range(Q):
        c, d = map(int, input().split())
        if (depth_vec[c] + depth_vec[d]) % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
import sys
from collections import defaultdict, deque
from itertools import permutations, combinations
from math import factorial, ceil, floor
from decimal import Decimal


def i_input():
    return int(input())


def map_str():
    return input().split()


def map_int():
    return map(int, input().split())


def lmap_int():
    return list(map(int, input().split()))


def lmap_str():
    return list(map(input().split()))

# mod = 10**9 + 7


# g: 二次元配列(あるノードがどのノードと隣接しているかを示す)
# q: キュー
def bfs(g, q, dist):
    while q:
        # キューの先頭が現在地
        current = q.popleft()
        # 隣接する各ノードについて
        for node in g[current]:
            if dist[node] != 0: continue
            dist[node] = dist[current] + 1
            q.append(node)
    return dist


def main():
    sys.setrecursionlimit(3 * 10**5)
    n, r = map_int()
    g = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b = map_int()
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)
    q = deque([0])
    dist = [0] * n
    dist[0] = 1
    dist = bfs(g, q, dist)

    for _ in range(r):
        c, d = map_int()
        if dist[c - 1] == dist[d - 1]:
            if c - 1 in g[d - 1]:
                print("Road")
                continue
        if (dist[c - 1] - dist[d - 1]) % 2 == 0:
            print("Town")
        else:
            print("Road")


if __name__ == '__main__':
    main()
import queue

n, q = map(int, input().split())
G = [[] for i in range(n)]

for i in range(n - 1):
    ind = lambda n: int(n) - 1
    a, b = map(ind, input().split())
    G[a].append(b)
    G[b].append(a)

que = queue.Queue()
color = [-1 for _ in range(n)]
color[0] = 0
que.put(0)

while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(q):
    ind = lambda n: int(n) - 1
    a, b = map(ind, input().split())
    print('Town' if color[a] == color[b] else 'Road')
from collections import deque

n, q = map(int, input().split())

graph = [[] for _ in range(n + 1)]

for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

CD = []
for i in range(q):
    e, f = map(int, input().split())
    CD.append([e, f])

dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0

d = deque()
d.append(1)

while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)

for i, j in CD:
    x = dist[i] + dist[j]
    if x % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())
graph = [[] for _ in range(n + 1)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
dist = [-1] * (n + 1)
dist[0] = 0
dist[1] = 0
d = deque()
d.append(1)
while d:
    v = d.popleft()
    for i in graph[v]:
        if dist[i] != -1:
            continue
        dist[i] = dist[v] + 1
        d.append(i)
for i in range(n + 1):
    dist[i] = dist[i] % 2
for i in range(q):
    c, d = map(int, input().split())
    if dist[c] == dist[d]:
        print('Town')
    else:
        print('Road')
n, q = map(int, input().split())

from collections import deque

graph = []
visited = []

for i in range(n):
    tmp = []
    graph.append(tmp)

for i in range(n - 1):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    graph[u].append(v)
    graph[v].append(u)

#print(graph)


def BFS(s, g):
    dist = [-1] * n

    Q = deque()
    Q.append(s)
    dist[s] = 0

    while len(Q) > 0:
        #キューの先頭の頂点を取り出してiとする
        i = Q.popleft()
        #頂点iに隣接する頂点を順番に見る
        #見ている頂点をiとする
        for j in graph[i]:
            #jが未訪問だったとき、jへの最短距離を更新して、キューの末尾に追加する
            if dist[j] == -1:
                dist[j] = dist[i] + 1
                Q.append(j)
            #print(dist,Q)

    #print(dist)
    return dist


x = BFS(0, n)

#print(x)

for i in range(q):
    s, g = map(int, input().split())
    s -= 1
    g -= 1
    if (x[s] + x[g]) % 2 == 0:
        print('Town')
    else:
        print('Road')
R = lambda: map(int,
                input().split())
n, q = R()
g = [None] + [[] for _ in range(n)]
C = [None] * (n + 1)
C[1] = 0
s = [1]
for _ in range(n - 1):
    a, b = R()
    g[b].append(a)
    g[a].append(b)
while s:
    u = s.pop()
    for v in g[u]:
        if C[v] is None:
            s.append(v)
            C[v] = C[u] ^ 1
for _ in range(q):
    c, d = R()
    print('TRoowand'[C[c] ^ C[d]::2])
from collections import deque

n, q = map(int, input().split())
R = [list(map(int, input().split())) for _ in range(n - 1)]
Q = [list(map(int, input().split())) for _ in range(q)]
near = [[] for _ in range(n + 1)]
for r in R:
    near[r[0]].append(r[1])
    near[r[1]].append(r[0])

queue = deque()
city = [-1 for _ in range(n + 1)]
city[1] = 0
queue.append(1)

while len(queue) > 0:
    i = queue.popleft()
    for c in near[i]:
        if city[c] != -1:
            continue
        else:
            city[c] = 1 - city[i]
            queue.append(c)

for query in Q:
    if city[query[0]] == city[query[1]]:
        print("Town")
    else:
        print("Road")
import math
from collections import deque, Counter
from itertools import product, combinations, permutations

n, q = map(int, input().split())
p = [list(map(int, input().split())) for _ in range(n - 1)]
q = [list(map(int, input().split())) for _ in range(q)]

x = [[] for _ in range(n)]

for i in range(n - 1):
    a, b = p[i][0], p[i][1]
    a -= 1
    b -= 1
    x[a].append(b)
    x[b].append(a)

dist = [-1] * n
G = deque()
root = 0
dist[root] = 0
G.append(root)
while (G):
    v = G.popleft()
    for next in x[v]:
        if dist[next] != -1:
            continue
        else:
            dist[next] = dist[v] + 1
            G.append(next)

for query in q:
    if (dist[query[1] - 1] - dist[query[0] - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

graph = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a, b = a - 1, b - 1
    graph[a].append(b)
    graph[b].append(a)


class LCA_doubling:
    def __init__(self, n, graph, start):
        self.n = n
        self.graph = graph
        self.start = start

        # graph and n is necessary
        def dfs(start):
            par = [-1] * n
            depth = [-1] * n
            euler = []
            stack = []
            stack.append(start)
            depth[start] = 0
            while stack:
                v = stack.pop()
                euler.append(v)
                d = depth[v]
                for u in graph[v]:
                    if par[v] == u:
                        continue
                    par[u] = v
                    depth[u] = d + 1
                    stack.append(u)
            return par, depth

        self.par, self.depth = dfs(self.start)
        self.num = self.n.bit_length() + 1
        self.doubling = [[-1] * (self.num) for _ in range(n)]

        for i in range(n):
            self.doubling[i][0] = self.par[i]

        for d in range(self.num - 1):
            nd = d + 1
            for i in range(n):
                if self.doubling[i][d] == -1:
                    self.doubling[i][nd] = -1
                else:
                    self.doubling[i][nd] = self.doubling[self.doubling[i]
                                                         [d]][d]

    def query(self, a, b):
        def soroeru(a, b):
            if self.depth[a] == self.depth[b]:
                return a, b
            elif self.depth[a] < self.depth[b]:
                a, b = b, a
            delta = self.depth[a] - self.depth[b]
            assert delta > 0
            now = a
            for i in range(self.num):
                if (delta >> i) & 1:
                    now = self.doubling[now][i]
            assert self.depth[now] == self.depth[b]
            return now, b

        a, b = soroeru(a, b)
        if a == b:
            return a
        for i in range(self.num)[::-1]:
            if self.doubling[a][i] != self.doubling[b][i]:
                a = self.doubling[a][i]
                b = self.doubling[b][i]
        return self.doubling[a][0]


LCA = LCA_doubling(n, graph, 0)
for _ in range(q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    cc = LCA.query(c, d)
    dist = LCA.depth[d] + LCA.depth[c] - 2 * LCA.depth[cc]
    if dist % 2:
        print("Road")
    else:
        print("Town")
import math
import copy
from collections import deque
# from typing import Collection, List, OrderedDict
# from union_find import UnionFind
import sys

# https://techblog.nhn-techorus.com/archives/15289 より 中央値の高速算出アルゴリズム


def partition(lst, pivot):
    """Modifired partition algorithm in section 7.1"""
    pivot_idx = None
    for idx, value in enumerate(lst):
        if value == pivot:
            pivot_idx = idx
    if pivot_idx is None:
        raise Exception
    lst[pivot_idx], lst[-1] = lst[-1], lst[pivot_idx]
    pivot = lst[-1]
    i = -1
    for j, val in enumerate(lst[:-1]):
        if val <= pivot:
            i += 1
            lst[i], lst[j] = lst[j], lst[i]
    lst[i + 1], lst[-1] = lst[-1], lst[i + 1]
    return i + 1


def select(lst, i):
    """Selection in linear time"""
    if len(lst) == 1:
        return lst[0]
    split_lists = [lst[i * 5:(i + 1) * 5] for i in range((len(lst) + 4) // 5)]
    split_list_medians = [
        sorted(split_list)[(len(split_list) - 1) // 2]
        for split_list in split_lists
    ]
    x = select(split_list_medians, (len(split_list_medians) - 1) // 2)
    k = partition(lst, x)
    if i == k:
        return x
    elif i < k:
        return select(lst[:k], i)
    else:
        return select(lst[k + 1:], i - (k + 1))


def median_linear(lst):
    """Calculate median by selection algorithm"""
    return select(lst, (len(lst) - 1) // 2)


# nCrを求める https://qiita.com/Ma_AtoP/items/b9070518ff6e207e64a8
def comb(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


# https://qiita.com/keisuke-ota/items/6c1b4846b82f548b5dec より
class Node:
    def __init__(self, index):
        self.index = index
        self.nears = []
        self.sign = -1  # 未探索の場合は -1 を返す。探索済みの場合、

    def __repr__(self):
        return f'Node index:{self.index} nears:{self.nears} sign:{self.sign}'


# 緩和
def chmin(a, b):
    if a > b:
        a = b  # 参照渡し
        return True
    else:
        return False


# 距離を返す


def bfs(nodes, start):

    # BGS
    queue = deque()
    # 本問では node start から探索を開始するため queue に node[start]  を最初に入れる
    nodes[start].sign = 0  # スタートの距離を0とする
    queue.append(nodes[start])

    # queue がなくなるまで探索を続ける
    while queue:
        # queue から node を 1 つ取り出す。取り出したノードについて調べる。
        # 取り出された node は queue から消える。
        node = queue.popleft()  # .pop() にすると DFS になる
        # 取り出された node の隣接 node 達を nears に入れる。
        nears = node.nears

        # 隣接 node 達が探索済みか 1 つずつ調べる。
        for near in nears:
            # 未探索の隣接 node は queue に追加する。
            # 取り出してきた親 node は道しるべとなるため、子 node の sign メソッドに追加する。
            if nodes[near].sign == -1:
                queue.append(nodes[near])
                nodes[near].sign = node.sign + 1  # ノードの隣は距離を1個増やす

    return


def main():
    # N = int(input())
    N, Q = map(int, input().split())

    links = [list(map(int, input().split())) for _ in range(N - 1)]
    que = [list(map(int, input().split())) for _ in range(Q)]

    # print(que)

    nodes = []
    # 町
    for i in range(N + 1):
        nodes.append(Node(i))

    # 道
    for j in range(N - 1):
        edge_start, edge_end = links[j]
        nodes[edge_start].nears.append(edge_end)
        nodes[edge_end].nears.append(edge_start)  # 有向グラフの場合は消す

    bfs(nodes, 1)

    for q in que:
        # print(q)
        start, end = q
        if abs(nodes[start].sign - nodes[end].sign) % 2:
            # 距離差が奇数のときは路上、偶数のときは町
            print("Road")
        else:
            print("Town")

            # G = [-1] * M
            # B = [-1] * M
            # C = [-1] * M

            # for m in range(M):
            #     A[m], B[m], C[m] = map(int, input().split())
            #     G[m] = []
            #     G[m].append(Edge(B[m], C[m]))

            # # A = list(map(int, input().split()))
            # # B = list(map(int, input().split()))
            # # C = list(map(int, input().split()))

            # print(G)
            # print(dijkstra(A[0], B[0], N, G))


if __name__ == "__main__":
    main()
from collections import deque

n, q = map(int, input().split())
connect = [[] for _ in range(n + 1)]
counter = [0] * (n + 1)
visited = [False] * (n + 1)
visited[1] = True
que = deque()
que.append(1)
for _ in range(n - 1):
    a, b = map(int, input().split())
    connect[a].append(b)
    connect[b].append(a)

while que:
    now = que.popleft()
    for i in connect[now]:
        if visited[i] == False:
            counter[i] += counter[now] + 1
            visited[i] = True
            que.append(i)

ans = []
for _ in range(q):
    s, t = map(int, input().split())
    if counter[s] % 2 == counter[t] % 2:
        ans.append('Town')
    else:
        ans.append('Road')
for i in ans:
    print(i)
#import sys
#import numpy as np
import math
#from fractions import Fraction
import itertools
from collections import deque
from collections import Counter
import heapq
from fractions import gcd
#input=sys.stdin.readline
#import bisect

n, q = map(int, input().split())
v = tuple(
    tuple(map(lambda x: int(x) - 1,
              input().split())) for _ in range(n - 1))

node = [[] for _ in range(n)]

for pair in v:
    node[pair[0]].append(pair[1])
    node[pair[1]].append(pair[0])
d = deque()
check = [-1] * n
check[0] = 0
for i in node[0]:
    d.append(i)
    check[i] = 1

while True:
    if not d:
        break
    t = d.pop()
    dist = check[t]
    for i in node[t]:
        if check[i] != -1:
            continue
        d.append(i)
        check[i] = dist + 1
for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if (check[c] + check[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

color = [-1] * N
color[0] = 0
que = queue.Queue()
que.put(0)

while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
from collections import deque

graph = [deque() for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
dist = [-1 for _ in range(N)]
dist[0] = 0
L = deque()
L.append([0, 0])
while L:
    i, s = L.popleft()
    for j in range(len(graph[i])):
        if dist[graph[i][j]] == -1:
            dist[graph[i][j]] = s + 1
            L.append([graph[i][j], s + 1])

for i in range(Q):
    c, d = map(int, input().split())
    if (dist[c - 1] + dist[d - 1]) % 2 == 0:
        print('Town')
    else:
        print('Road')
from collections import deque
import sys

sys.setrecursionlimit(500000)
#入力が
#頂点数　辺数
#辺iの始点　終点 for i in range(辺数)
#だったとして
n, q = map(int, input().split())
g = [[] for i in range(n)]  #g[i]はグラフの頂点iに隣接する頂点（有向）
for i in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

seen = [False] * n  #seen[i]は頂点iが検知済みか
todo = deque()  #todoは検知したが訪問済みでない頂点のリスト
parity = [-1] * n


#ここからDFS
def dfs(s):
    seen[s] = True
    todo.append(s)
    #処理とか
    while todo:
        v = todo.pop()
        for i in g[v]:
            if seen[i] == True:
                continue
            parity[i] = (parity[v] + 1) % 2
            dfs(i)


parity[0] = 0
dfs(0)

for j in range(q):
    c, d = map(int, input().split())
    if parity[c - 1] == parity[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import defaultdict
from collections import deque

n, q = map(int, input().split())
ab = defaultdict(list)
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    ab[a].append(b)
    ab[b].append(a)

visited = [False] * n
visited[0] = True
color = [0] * n
col = 0
que = {0}
while que:
    col = 1 - col
    nq = set()
    for x in que:
        for y in ab[x]:
            if visited[y]:
                continue
            color[y] = col
            visited[y] = True
            nq.add(y)
    que = nq

cc = [0] * q
dd = [0] * q
for i in range(q):
    cc[i], dd[i] = map(int, input().split())
for c, d in zip(cc, dd):
    c -= 1
    d -= 1
    if color[c] == color[d]:
        print('Town')
    else:
        print('Road')from sys import stdin
from collections import deque

n, Q = map(int, input().split())
edge = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, stdin.readline().split())
    a, b = a - 1, b - 1
    edge[a].append(b)
    edge[b].append(a)
colors = [-1] * n
colors[0] = 0
q = deque([0])

while q:
    v = q.popleft()
    for e in edge[v]:
        if colors[e] == -1:
            colors[e] = 1 - colors[v]
            q.append(e)
for _ in range(Q):
    c, d = map(int, stdin.readline().split())
    s = colors[c - 1]
    t = colors[d - 1]

    if s == t:
        print('Town')
    else:
        print('Road')
def dfs(cur, prev):
    global depth, parent
    depth[cur] = depth[prev] + 1
    parent[cur][0] = prev
    for next_ in tree[cur]:
        if next_ != prev:
            dfs(next_, cur)


def addEdge(u, v):
    global tree
    tree[u].append(v)
    tree[v].append(u)


def precompute(n):
    for i in range(1, level):
        for node in range(1, n + 1):
            if parent[node][i - 1] != -1:
                parent[node][i] = parent[parent[node][i - 1]][i - 1]


def lca(u, v):
    if depth[v] < depth[u]:
        u, v = v, u

    diff = depth[v] - depth[u]

    for i in range(level):
        if ((diff >> i) & 1):
            v = parent[v][i]

    if u == v:
        return u

    for i in range(level - 1, -1, -1):
        if (parent[u][i] != parent[v][i]):
            u = parent[u][i]
            v = parent[v][i]

    return parent[u][0]


import sys

sys.setrecursionlimit(200002)

MAXN = 200002
level = 1

tree = [[] for _ in range(MAXN)]
depth = [0 for _ in range(MAXN)]
parent = [[-1 for _ in range(level)] for _ in range(MAXN)]

n, q = map(int, input().split())
for _ in range(n - 1):
    a, b = map(int, input().split())
    addEdge(a, b)

depth[0] = 0
dfs(1, 0)

for i in range(q):
    c, d = map(int, input().split())
    if (depth[c] + depth[d] - 2 * lca(c, d)) % 2 != 0:
        print("Road")
    else:
        print("Town")
# u, vの共通の親
# ダブリング p[i][v] = vの2^i個 親
# LevelAncestor(頂点vのh個親)
# LCA(Lowest common ansector)

from collections import deque


class lca():
    def __init__(self, n):
        self.n = n
        self.root = None
        self.edges = [[] for _ in range(n)]
        self.lv = n.bit_length()
        self.p = [[None] * n for _ in range(self.lv)]
        self.depth = [None] * n

    def set_root(self, root):
        self.root = root

    def add_edge(self, fm, to):
        self.edges[fm].append(to)

    def construct(self):
        # 深さと親の設定
        q = deque()
        q.append((self.root, 0))
        self.depth[self.root] = 0
        self.p[0][self.root] = 0
        while len(q) > 0:
            cur, dep = q.popleft()
            for nxt in self.edges[cur]:
                if self.p[0][nxt] != None: continue
                q.append((nxt, dep + 1))
                self.depth[nxt] = dep + 1
                self.p[0][nxt] = cur
        # ダブリング
        for i in range(1, self.lv):
            for v in range(self.n):
                self.p[i][v] = self.p[i - 1][self.p[i - 1][v]]

    def la(self, x, h):
        for i in range(self.lv)[::-1]:
            if h >= 1 << i:
                x = self.p[i][x]
                h -= 1 << i
        return x

    def lca(self, u, v):
        # u,vの高さを合わせる
        if self.depth[u] < self.depth[v]: u, v = v, u
        u = self.la(u, self.depth[u] - self.depth[v])
        if u == v: return u
        # u, vのギリギリ合わない高さまで昇る
        for i in range(self.lv)[::-1]:
            if self.p[i][u] != self.p[i][v]:
                u = self.p[i][u]
                v = self.p[i][v]
        return self.p[0][u]

    def dist(self, u, v):
        lca = self.lca(u, v)
        return self.depth[u] + self.depth[v] - 2 * self.depth[lca]


n, q = map(int, input().split())

l = lca(n)
l.set_root(0)
for i in range(n - 1):
    a, b = map(int, input().split())
    l.add_edge(a - 1, b - 1)
    l.add_edge(b - 1, a - 1)
l.construct()

for i in range(q):
    x, y = map(int, input().split())
    d = l.dist(x - 1, y - 1)
    if d % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys

sys.setrecursionlimit(10000000)


class LowestCommonAncedtor:
    def __init__(self, G, root):
        self.n = len(G)
        self.tour = [0] * (2 * self.n - 1)
        self.depth_list = [0] * (2 * self.n - 1)
        self.id = [0] * self.n
        self.visit_id = 0
        self.dfs(G, root, -1, 0)
        self._rmq_init(self.depth_list)

    def _rmq_init(self, arr):
        n = len(arr)
        self.N0 = 1 << (n - 1).bit_length()
        self.dat = [self.n] * (self.N0 - 1) + arr + [self.n
                                                     ] * (self.N0 - n + 1)
        self.index = [0] * (self.N0 - 1) + list(
            range(n)) + [0] * (self.N0 - n + 1)
        dat = self.dat
        index = self.index
        for i in range(self.N0 - 2, -1, -1):
            if dat[2 * i + 1] > dat[2 * i + 2]:
                dat[i] = dat[2 * i + 2]
                index[i] = index[2 * i + 2]
            else:
                dat[i] = dat[2 * i + 1]
                index[i] = index[2 * i + 1]

    def _rmq_query(self, l, r):
        """最小値となるindexを返す"""
        l += self.N0
        r += self.N0
        s = self.n
        dat = self.dat
        index = self.index
        while l < r:
            if r & 1:
                r -= 1
                if s > dat[r - 1]:
                    s = dat[r - 1]
                    res = index[r - 1]
            if l & 1:
                if s > dat[l - 1]:
                    s = dat[l - 1]
                    res = index[l - 1]
                l += 1
            l >>= 1
            r >>= 1
        return res

    def dfs(self, G, vertex, parent, depth):
        self.id[vertex] = self.visit_id
        self.tour[self.visit_id] = vertex
        self.depth_list[self.visit_id] = depth
        self.visit_id += 1
        for element in G[vertex]:
            if element != parent:
                self.dfs(G, element, vertex, depth + 1)
                self.tour[self.visit_id] = vertex
                self.depth_list[self.visit_id] = depth
                self.visit_id += 1

    def get(self, u, v):
        l, r = self.id[u], self.id[v]
        if r < l:
            l, r = r, l
        q = self._rmq_query(l, r + 1)
        return self.tour[q]

    def dist(self, u, v):
        """点u,点vの距離"""
        lca = self.get(u, v)
        depth_u = self.depth_list[self.id[u]]
        depth_v = self.depth_list[self.id[v]]
        depth_lca = self.depth_list[self.id[lca]]
        return depth_u + depth_v - 2 * depth_lca


#問.任意の2頂点の距離
n, q = map(int, input().split())
e = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    e[a].append(b)
    e[b].append(a)

lca = LowestCommonAncedtor(e, 0)
for _ in range(q):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    if lca.dist(u, v) % 2 == 1:
        print("Road")
    else:
        print("Town")
import sys

input = sys.stdin.readline

n, q = map(int, input().split())
g = [[] for _ in range(n)]  # 隣接リスト

for _ in range(n - 1):
    a, b = [int(x) for x in input().split()]
    g[a - 1].append(b - 1)
    g[b - 1].append(a - 1)

from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * n  # uからの距離の初期化
    d[u] = 0  # 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


# 0からの各頂点の距離
# d = bfs(0)
# print(d)

ans = []
D_o = bfs(0)
for i in range(len(D_o)):
    if D_o[i] % 2 == 0:
        D_o[i] = 2
    else:
        D_o[i] = 1

for i in range(q):
    c, d = map(int, input().split())
    if D_o[c - 1] % 2 == 0:
        if D_o[d - 1] == 2:
            ans.append('Town')
        else:
            ans.append('Road')
    else:
        if D_o[d - 1] == 2:
            ans.append('Road')
        else:
            ans.append('Town')

for i in range(q):
    print(ans[i])
from collections import deque
#入力が1-indxなのでリスト番号も1-indに
#1-indなのでfor文の範囲も変わってることに注意

n, q = map(int, input().split())
graph = [[] for _ in range(n + 1)]

for i in range(1, n):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dist = [-1] * (n + 1)
dist[1] = 0
dist[0] = 0
#-1が未訪問

d = deque()
d.append(1)  #頂点1を訪問

while d:
    #print(d)
    v = d.popleft()  #要素の左端を削除して取得
    for i in graph[v]:
        if dist[i] != -1:  #訪問済みであれば
            continue
        dist[i] = dist[v] + 1  #未訪問ならdistを計算 今いる場所の隣なので+1
        d.append(i)  #今回新しく見つけた頂点を追加
    #print(d)

#for i in range(1,n+1):
#    print(i,dist[i])

for i in range(q):
    c, d = map(int, input().split())
    judge = dist[d] + dist[c]
    #print(dist[c],dist[d])
    #本来の距離ではない
    #絶対的な距離はLCAを考慮する必要あり

    if judge % 2 == 0:
        print('Town')
    else:
        print('Road')
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**6)


def main():
    n, q = map(int, input().split())
    g = [[] for i in range(n)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        g[a - 1].append(b - 1)
        g[b - 1].append(a - 1)
    dist = [-1] * n
    seen = [False] * n
    dist[0] = 0

    def dfs(i):
        if seen[i]: return
        seen[i] = True
        for j in g[i]:
            dist[j] = (dist[i] + 1) % 2
            dfs(j)

    dfs(0)
    for i in range(q):
        c, d = map(int, input().split())
        c, d = c - 1, d - 1
        if dist[c] != dist[d]:
            print('Road')
        else:
            print('Town')


main()
from collections import deque

N, Q = map(int, input().split())
tree = [[] for _ in range(N + 1)]
for i in range(N - 1):
    a, b = map(int, input().split())
    tree[a].append(b)
    tree[b].append(a)
cd = []
for j in range(Q):
    c, d = map(int, input().split())
    cd.append([c, d])
que = deque()
bi = [False] * (N + 1)
que.append(1)
while que:
    cp = que.popleft()
    for k in tree[cp]:
        if bi[k] == False:
            bi[k] = not bi[cp]
            que.append(k)
for c, d in cd:
    print('Town' if bi[c] == bi[d] else 'Road')
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)
for t in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
import sys


#input()
def I():
    return sys.stdin.readline().rstrip()


#list(input())
def SI():
    return list(sys.stdin.readline().rstrip())


#int(input())
def II():
    return int(sys.stdin.readline().rstrip())


#map(int,input().split())
def MI():
    return map(int, sys.stdin.readline().rstrip().split())


#map(str, input().split())
def MS():
    return map(str, sys.stdin.readline().rstrip().split())


#list(map(int,input().split()))
def LI():
    return list(map(int, sys.stdin.readline().rstrip().split()))


#行列
def LLI(rows_number):
    return [LI() for _ in range(rows_number)]


from heapq import heappop, heappush

n, Q = MI()
graph = [[] for _ in range(n)]
oe = [0] * n

for i in range(n - 1):
    a, b = MI()
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)


def dijkstra(s, g):  # 始点・隣接グラフ
    INF = 10**18
    check = [False] * n
    dist = [INF] * n
    dist[s] = 0
    q = [(0, s)]  # 距離・ノード
    while q:
        node = heappop(q)[1]  # 今いる所までの距離・そのノード
        if check[node]: continue
        check[node] = True
        for i in g[node]:  # これから行く所までの距離・そのノード
            if check[i]: continue
            if dist[i] <= dist[node] + 1: continue
            dist[i] = dist[node] + 1
            heappush(q, [dist[i], i])
    return dist


d = dijkstra(0, graph)
for i in range(n):
    if d[i] % 2 == 1:
        oe[i] = 1

for i in range(Q):
    c, d = MI()
    if oe[c - 1] == oe[d - 1]:
        print("Town")
    else:
        print("Road")
n, q = map(int, input().split())

G = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    G[a].append(b)
    G[b].append(a)

from collections import deque

P = [0] * n
dq = deque([0])
while dq:
    v = dq.popleft()
    for u in G[v]:
        if P[u] > 0: continue
        P[u] = P[v] + 1
        dq.append(u)

for _ in range(q):
    c, d = map(lambda x: int(x) - 1, input().split())
    if (P[c] + P[d]) % 2: print('Road')
    else: print('Town')
import queue

N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)

while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            color[i] = 1 - color[t]
            que.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
import math
import bisect
import random
from itertools import permutations, accumulate, combinations, product
import sys
import string
from bisect import bisect_left, bisect_right
from math import factorial, ceil, floor
from operator import mul
from functools import reduce

sys.setrecursionlimit(2147483647)
INF = 10**13


def LI():
    return list(map(int, sys.stdin.buffer.readline().split()))


def I():
    return int(sys.stdin.buffer.readline())


def LS():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()


def S():
    return sys.stdin.buffer.readline().rstrip().decode('utf-8')


def IR(n):
    return [I() for i in range(n)]


def LIR(n):
    return [LI() for i in range(n)]


def SR(n):
    return [S() for i in range(n)]


def LSR(n):
    return [LS() for i in range(n)]


def SRL(n):
    return [list(S()) for i in range(n)]


def MSRL(n):
    return [[int(j) for j in list(S())] for i in range(n)]


mod = 1000000007


class LCA(object):
    def __init__(self, G, root=0):
        self.G = G
        self.root = root
        self.n = len(G)
        self.logn = (self.n - 1).bit_length()
        self.depth = [-1 if i != root else 0 for i in range(self.n)]
        self.parent = [[-1] * self.n for _ in range(self.logn)]
        self.dfs()
        self.doubling()

    def dfs(self):
        que = [self.root]
        while que:
            u = que.pop()
            for v in self.G[u]:
                if self.depth[v] == -1:
                    self.depth[v] = self.depth[u] + 1
                    self.parent[0][v] = u
                    que += [v]

    def doubling(self):
        for i in range(1, self.logn):
            for v in range(self.n):
                if self.parent[i - 1][v] != -1:
                    self.parent[i][v] = self.parent[i - 1][self.parent[i -
                                                                       1][v]]

    def get(self, u, v):
        if self.depth[v] < self.depth[u]:
            u, v = v, u
        du = self.depth[u]
        dv = self.depth[v]

        for i in range(self.logn):  # depthの差分だけuを遡らせる
            if (dv - du) >> i & 1:
                v = self.parent[i][v]
        if u == v: return u  # 高さ揃えた時点で一致してたら終わり

        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索
            pu, pv = self.parent[i][u], self.parent[i][v]
            if pu != pv:
                u, v = pu, pv
        return self.parent[0][u]


N, Q = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(N - 1):
    x, y = map(int, input().split())
    G[x - 1] += [y - 1]
    G[y - 1] += [x - 1]

lca = LCA(G)
for _ in range(Q):
    c, d = map(int, input().split())
    if (lca.depth[c - 1] + lca.depth[d - 1] -
            2 * lca.depth[lca.get(c - 1, d - 1)] + 1) % 2 == 0:
        print("Road")
    else:
        print("Town")
N, Q = map(int, input().split())

G = [[] for n in range(N)]
for n in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    G[a].append(b)
    G[b].append(a)

import collections

que = collections.deque([(0, 0)])

vis = dict()

while que:
    i, cnt = que.pop()
    vis[i] = cnt
    if cnt == 1:
        cnt = 0
    else:
        cnt = 1
    for j in G[i]:
        if j in vis:
            continue
        que.append((j, cnt))

for q in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    #print("d", vis[c], vis[d])
    if (vis[c] + vis[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
import queue
import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd
from itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left
from heapq import heappush, heappop
from functools import reduce


def input():
    return sys.stdin.readline().strip()


def INT():
    return int(input())


def MAP():
    return map(int, input().split())


def LIST():
    return list(map(int, input().split()))


def ZIP(n):
    return zip(*(MAP() for _ in range(n)))


sys.setrecursionlimit(10**9)
INF = float('inf')
mod = 10**9 + 7
YES = 'YES'
NO = 'NO'


class Node:
    def __init__(self, n):
        self.n = n
        self.children = []

    def add_child(self, child):
        self.children = self.children + [child]


def get_find():
    visited = set()

    def find(cnt: int, dist: Node, n: Node):
        cur_c = INF
        for c in n.children:
            if c in visited:
                continue
            visited.add(c)
            if c.n == dist.n:
                return cnt
            else:
                c = find(cnt + 1, dist, c)
                cur_c = min(cur_c, c)

        return cur_c

    return find


def resolve():
    N, Q = MAP()
    G = [[] for _ in range(N)]
    for i in range(N - 1):
        a, b = map(int, input().split())
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)

    color = [-1] * N
    color[0] = 0
    que = queue.Queue()
    que.put(0)
    while not que.empty():
        t = que.get()
        for g in G[t]:
            if color[g] == -1:
                color[g] = 1 - color[t]
                que.put(g)

    for _ in range(Q):
        i, j = MAP()
        if color[i - 1] == color[j - 1]:
            print("Town")
        else:
            print("Road")


if __name__ == "__main__":
    resolve()
from collections import deque

n, q = map(int, input().split())
L = [[] for i in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    L[a].append(b)
    L[b].append(a)

inf = 10**7
dist = [inf] * n

dq = deque()
dq.append(0)
dist[0] = 0
while dq:
    p = dq.popleft()
    for np in L[p]:
        if dist[np] == inf:
            dist[np] = dist[p] + 1
            dq.append(np)

for i in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    l = dist[c] + dist[d] - 2
    if l % 2 == 0:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
tmp = [list(map(int, input().split())) for _ in range(N - 1)]
a = [i[0] for i in tmp]
b = [i[1] for i in tmp]
tmp = [list(map(int, input().split())) for _ in range(Q)]
c = [i[0] for i in tmp]
d = [i[1] for i in tmp]
l = []
for i in range(N):
    l.append([])
for i in range(N - 1):
    l[a[i] - 1].append(b[i] - 1)
    l[b[i] - 1].append(a[i] - 1)
D = {}
D[0] = 0
q = [0]
while q != []:
    u = q.pop()
    for i in l[u]:
        if i not in D:
            D[i] = D[u] + 1
            q.append(i)
for i in range(Q):
    if (D[c[i] - 1] + D[d[i] - 1]) % 2 == 0:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
D = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    D[a].append(b)
    D[b].append(a)

INF = N + 10

Solve = [INF] * N
Solve[0] = 0

from collections import deque

d = deque([])
d.append(0)
while len(d) > 0:
    now = d.popleft()
    for to in D[now]:
        if Solve[to] == INF:
            Solve[to] = (Solve[now] + 1) % 2
            d.append(to)

for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1

    s = (Solve[c] - Solve[d]) % 2
    if s == 0:
        print("Town")
    else:
        print("Road")
from collections import deque


def bfs():
    seen = [False] * n
    q = deque()
    q.append([0, 0])
    d_list = [0] * n
    while q:
        now, dist = q.popleft()
        if seen[now]:
            continue
        seen[now] = True
        d_list[now] = dist
        for node in edge[now]:
            q.append([node, dist + 1])
    return d_list


n, q = map(int, input().split())
edge = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    edge[a].append(b)
    edge[b].append(a)

d_list = bfs()

for _ in range(q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if abs(d_list[c] - d_list[d]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q, *abcd = map(int, open(0).read().split())
ab = abcd[:n * 2 - 2]
cd = abcd[n * 2 - 2:]
g = [[] for i in range(n + 1)]
for i in range(0, len(ab), 2):
    a = ab[i]
    b = ab[i + 1]
    g[a].append(b)
    g[b].append(a)

q = deque([(1, 0)])
dists = [-1] * (n + 1)
while q:
    v, n = q.popleft()
    dists[v] = n
    n += 1
    for x in g[v]:
        if dists[x] != -1: continue
        q.append((x, n))

for i in range(0, len(cd), 2):
    c = cd[i]
    d = cd[i + 1]
    if dists[c] % 2 == dists[d] % 2:
        print('Town')
    else:
        print('Road')
from sys import stdin

n, q = map(int, input().split())
edge = [[] for _ in range(n)]

for _ in range(n - 1):
    a, b = map(int, stdin.readline().split())
    a, b = a - 1, b - 1
    edge[a].append(b)
    edge[b].append(a)
colors = [0] * n


def is_bipartite():
    stack = [(0, 1)]  # (頂点、色)のタプルをスタックする。最初は(頂点0, 黒(1))
    while stack:
        v, color = stack.pop()
        colors[v] = color
        for to in edge[v]:
            if colors[to] == color:
                return False
            if colors[to] == 0:
                stack.append((to, -color))
    return True


is_bipartite()

for _ in range(q):
    c, d = map(int, stdin.readline().split())
    s = colors[c - 1]
    t = colors[d - 1]

    if s == t:
        print('Town')
    else:
        print('Road')
import sys

N, Q = map(int, input().split())  # nは頂点の数、mは辺の数
g = [[] for _ in range(N)]  # 隣接リスト

for _ in range(N - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)
from collections import deque


def bfs(u):
    queue = deque([u])
    d = [None] * N  # uからの距離の初期化
    d[u] = 0  #oad") 自分との距離は0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
    return d


T = bfs(0)
for i in range(N):
    if T[i] % 2 == 0:
        T[i] = 1
    else:
        T[i] = 0
#print(T)
for i in range(Q):
    c, d = map(int, input().split())
    c -= 1
    d -= 1
    if T[d] % 2 == T[c] % 2:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
AB = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    AB[a - 1].append(b - 1)
    AB[b - 1].append(a - 1)

CD = []
for i in range(Q):
    c, d = map(int, input().split())
    c, d = c - 1, d - 1
    CD.append([c, d])
OE = [0 for _ in range(N)]
vi = [0 for _ in range(N)]

que = deque([0])

while que:
    query = que.pop()
    for dst in AB[query]:
        if vi[dst] == 0:
            vi[dst] = 1
            OE[dst] = 1 - OE[query]
            que.append(dst)
    #print(OE)

for c, d in CD:
    if OE[c] == OE[d]:
        print("Town")
    else:
        print("Road")
N, Q = map(int, input().split())
L = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(lambda x: int(x) - 1, input().split())
    L[a].append(b)
    L[b].append(a)

dp = [-1 for _ in range(N)]
dp[0] == 0
que = [0]

for i in que:
    for j in L[i]:
        if dp[j] == -1:
            que.append(j)
            dp[j] = abs(dp[i] - 1)

for _ in range(Q):
    c, d = map(lambda x: int(x) - 1, input().split())
    tmp = dp[c] + dp[d]
    print('Road' if tmp % 2 else 'Town')
from collections import deque

N, Q = map(int, input().split())
graph = [[] for _ in range(N)]

for _ in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

q = deque()
color = [-1 for _ in range(N)]
color[0] = 0
q.append(0)

while len(q) > 0:
    node = q.popleft()
    for node2 in graph[node]:
        if color[node2] < 0:
            color[node2] = (color[node] + 1) % 2
            q.append(node2)

for _ in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print('Town')
    else:
        print('Road')
N, Q = map(int, input().split())
neighbors = [[] for _ in range(N)]
for _ in range(N - 1):
    a, b = map(int, input().split())
    neighbors[a - 1].append(b - 1)
    neighbors[b - 1].append(a - 1)
queries = []
for _ in range(Q):
    c, d = map(int, input().split())
    queries.append((c - 1, d - 1))

from collections import deque

# root: #0
# find depths
depths = [-1] * N
parents = [[-1] * N]  # [k of 2^k][i]
q = deque()
q.append((0, 0, -1))
while len(q):
    i, d, parent = q.popleft()  # BFS
    depths[i] = d
    parents[0][i] = parent
    for j in neighbors[i]:
        if parent == j:
            continue
        q.append((j, d + 1, i))
u = i  # one of the deepest
maxdepth = d

# doubling
logmaxdepth = 1
while (1 << logmaxdepth) <= maxdepth:
    logmaxdepth += 1
for k in range(logmaxdepth - 1):
    parents.append([-1] * N)
    for i in range(N):
        parents[k + 1][i] = parents[k][parents[k][i]]


def find_lca(u, v):
    if depths[u] < depths[v]:
        u, v = v, u  # ensure depths[u] >= depths[v]
    for k in range(logmaxdepth):
        if 1 & (depths[u] - depths[v]) >> k:
            u = parents[k][u]
    if u == v:
        return u
    for k in range(logmaxdepth - 1, -1, -1):
        if parents[k][u] != parents[k][v]:
            u = parents[k][u]
            v = parents[k][v]
    return parents[0][u]


def find_dist(u, v):
    return depths[u] + depths[v] - 2 * depths[find_lca(u, v)]


for c, d in queries:
    print("Road" if find_dist(c, d) % 2 else "Town")
import heapq as hq
import math

N, Q = [int(_) for _ in input().split(' ')]


def dijkstra(G, s):
    n = len(G)
    visited = [False] * n
    weights = [math.inf] * n
    path = [None] * n
    queue = []
    weights[s] = 0
    hq.heappush(queue, (0, s))
    while len(queue) > 0:
        g, u = hq.heappop(queue)
        visited[u] = True
        for v, w in G[u]:
            if not visited[v]:
                f = g + w
                if f < weights[v]:
                    weights[v] = f
                    path[v] = u
                    hq.heappush(queue, (f, v))
    return path, weights


G = []
for i in range(N):
    G.append([])
for i in range(N - 1):
    a, b = [int(_) for _ in input().split(' ')]
    G[a - 1].append((b - 1, 1))
    G[b - 1].append((a - 1, 1))

alls = dijkstra(G, 0)[1]

for i in range(Q):
    k, v = [int(_) for _ in input().split(' ')]
    print("Road" if (alls[k - 1] - alls[v - 1]) % 2 else "Town")
# -*- coding: utf-8 -*-
'''
文字列取得用関数(str,int併用)
'''


def inputter(is_str=False, split=False, is_list=False, loop_times=0):
    import sys
    readline = sys.stdin.readline

    return_data_list = []
    loop_cnt = loop_times
    if loop_times == 0:
        loop_cnt = 1

    for _ in range(loop_cnt):
        data = readline().rstrip()
        data_split = data.split()

        if not (split) and len(data_split) > 1:
            split = True

        if not (is_str):
            try:
                int(data_split[0])
            except:
                is_str = True

        if is_str:
            if split:
                if is_list:
                    return_data = list(list(map(str, data_split)))
                else:
                    return_data = map(str, data_split)
            else:
                if is_list:
                    return_data = list(data)
                else:
                    return_data = data
        else:
            if split:
                if is_list:
                    return_data = list(list(map(int, data_split)))
                else:
                    return_data = map(int, data_split)
            else:
                if is_list:
                    return_data = list(list(int(data)))
                else:
                    return_data = int(data)
        if loop_times != 0:
            return_data_list.append(return_data)

    if loop_times == 0:
        return return_data
    else:
        return return_data_list


# G[v]: 頂点vに隣接する頂点list
# N: 頂点数
# 引用：https://tjkendev.github.io/procon-library/python/graph/bfs.html
def bfs(N, G, s):
    from collections import deque
    dist = [-1] * N
    que = deque()
    que.append(s)
    dist[s] = 0
    while que:
        v = que.popleft()
        d = dist[v]
        for w in G[v]:
            if dist[w] > -1:
                continue
            dist[w] = d + 1
            que.append(w)
    return dist


# main関数
def main():
    n, q = inputter()
    G = [[] for _ in range(n + 1)]
    for _ in range(n - 1):
        a, b = inputter()
        G[a].append(b)
        G[b].append(a)
    dist = bfs((n + 1), G, 1)
    for _ in range(q):
        c, d = inputter()
        ans = abs(dist[c] - dist[d])
        if ans % 2 == 0:
            print('Town')
        else:
            print('Road')


if __name__ == '__main__':
    main()
N, Q = map(int, input().split())

Graph = [[] for _ in range(N + 1)]

sumc = 0

for i in range(N - 1):
    a, b = map(int, input().split())
    Graph[a].append(b)
    Graph[b].append(a)
# print(Graph)

from collections import deque


def dfs(Graph, N, s, t):
    todo_stack = deque()
    done_list = [0] * N
    todo_stack.append(s)
    dist = [0] * N  # sからの距離

    while todo_stack:
        # スタックからチェック対象を取り出す
        now = todo_stack.pop()
        # 接続ノードごとに未確認の場合、距離を計算、確認済、todoに追加
        for node in Graph[now]:
            if done_list[node] == 0:
                dist[node] = dist[now] + 1
                done_list[node] = 1
                todo_stack.append(node)
    # return(dist[t])

    # 1からの距離で偶数ノードと奇数ノードを分ける。
    node_gk = [0] * N
    for i in range(N):
        node_gk[i] = dist[i] % 2

    return (node_gk)


node_gk = dfs(Graph, N + 1, 1, N)
# print(node_gk)

for i in range(Q):
    c, d = map(int, input().split())
    if node_gk[c] == node_gk[d]:
        print("Town")
    else:
        print("Road")
from collections import deque

N, Q = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]
CD = [list(map(int, input().split())) for _ in range(Q)]
G = [[] for _ in range(N)]
dp = [-1] * N

for ab in AB:
    a, b = ab
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

Q = deque()
Q.append(0)
dp[0] = 0
while Q:
    q = Q.pop()
    for g in G[q]:
        if dp[g] == -1:
            dp[g] ^= dp[q]
            Q.append(g)

for cd in CD:
    c, d = cd
    if dp[c - 1] == dp[d - 1]:
        print("Town")
    else:
        print("Road")
import collections

n, q = map(int, input().split())

g = []
for _ in range(n + 1):
    g.append([])

for i in range(n - 1):
    a, b = map(int, input().split())
    g[a].append(b)
    g[b].append(a)

visited = [False] * (n + 1)
visited[1] = True

queue = collections.deque([1])
dist = [0] * (n + 1)

while queue:
    flag = False
    que = queue.popleft()

    for k in g[que]:
        if visited[k]:
            continue
        else:
            visited[k] = True
            dist[k] += dist[que] + 1
            queue.append(k)

    if flag:
        break

for j in range(q):
    c, d = map(int, input().split())

    if (dist[d] - dist[c]) % 2 == 0:
        print("Town")
    else:
        print("Road")
from collections import deque

n, q = map(int, input().split())

branch = [[] for i in range(n)]

for i in range(n - 1):
    a, b = map(int, input().split())
    branch[a - 1].append(b - 1)
    branch[b - 1].append(a - 1)

queue = deque()
check = [False] * n
ans = [0] * n

for i in range(n):
    if not check[i]:
        check[i] = True
        queue.appendleft(i)

    while len(queue) != 0:
        v = queue.pop()

        for i in branch[v]:
            if not check[i]:
                check[i] = True
                queue.appendleft(i)

            ans[i] = 1 if ans[v] == 0 else 0

for i in range(q):
    c, d = map(int, input().split())
    if ans[c - 1] == ans[d - 1]:
        print('Town')
    else:
        print('Road')
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)
#グラフに入れてる
que = queue.Queue()
color = [-1] * N
color[0] = 0
que.put(0)
#1を頂点に幅全
while not que.empty():
    t = que.get()
    for i in G[t]:
        if color[i] == -1:
            #-1なら未探索
            color[i] = 1 - color[t]
            #これで0か，1かに別れる
            que.put(i)
for i in range(Q):
    a, b = map(int, input().split())
    if color[a - 1] == color[b - 1]:
        print("Town")
    else:
        print("Road")
import queue

N, Q = map(int, input().split())
G = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    G[a - 1].append(b - 1)
    G[b - 1].append(a - 1)

que = queue.Queue()
que.put(0)
dist = [-1] * N
dist[0] = 0

while not que.empty():
    s = que.get()
    for i in G[s]:
        if dist[i] == -1:
            dist[i] = dist[s] + 1
            que.put(i)

for i in range(Q):
    c, d = map(int, input().split())
    if dist[c - 1] % 2 == dist[d - 1] % 2:
        print("Town")
    else:
        print("Road")
from heapq import heappush, heappop

INF = 10**9


# O(E log V)
def dijkstra(s, n, g):  # (始点, ノード数, グラフ情報) g: [[(to, cost), ...], ...]
    d = [INF] * n
    d[s] = 0
    hq = [(0, s)]
    while hq:
        p = heappop(hq)
        v = p[1]
        if d[v] < p[0]:
            continue
        for to, cost in g[v]:
            if d[to] > d[v] + cost:
                d[to] = d[v] + cost
                heappush(hq, (d[to], to))
    return d


n, q = map(int, input().split())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    g[a - 1].append((b - 1, 1))
    g[b - 1].append((a - 1, 1))

dij = dijkstra(0, n, g)
for i in range(q):
    c, d = map(int, input().split())
    if (dij[c - 1] + dij[d - 1]) & 1:
        print('Road')
    else:
        print('Town')
import sys


def dfs(prev, now, visited, flag):
    visited[now] = True
    for nxt in G[now]:
        if nxt == prev or visited[nxt]:
            continue
        res[nxt] = not flag
        dfs(now, nxt, visited, not flag)


sys.setrecursionlimit(10**6)

n, q = map(int, input().split())
a, b = zip(*[tuple(map(int, input().split())) for _ in range(n - 1)])
c, d = zip(*[tuple(map(int, input().split())) for _ in range(q)])

# 距離の偶奇が重要？
# 2色？に分ける

G = [[] for _ in range(n)]
for i in range(n - 1):
    G[a[i] - 1].append(b[i] - 1)
    G[b[i] - 1].append(a[i] - 1)

visited = [False] * n
res = [False] * n
dfs(0, 0, visited, False)
for i in range(q):
    if res[c[i] - 1] ^ res[d[i] - 1]:
        print("Road")
    else:
        print("Town")
import sys
from heapq import *
import numpy as np
import numba
from numba import njit, b1, i1, i4, i8, f8

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines


def from_read(dtype=np.int64):
    return np.fromstring(read().decode(), dtype=dtype, sep=' ')


def from_readline(dtype=np.int64):
    return np.fromstring(readline().decode(), dtype=dtype, sep=' ')


def to_undirected(G, add_index=False):
    N = len(G)
    if add_index:
        G = np.append(G, np.arange(N).reshape(N, 1), axis=1)
    G = np.vstack((G, G))
    G[N:, 0] = G[:N, 1]
    G[N:, 1] = G[:N, 0]
    key = G[:, 0] << 32 | G[:, 1]
    idx = np.argsort(key, kind='mergesort')
    return G[idx]


@njit
def tree_bfs(N, G, root=1):
    idx = np.searchsorted(G[:, 0], np.arange(N + 2))
    que, l, r = np.empty(N, np.int64), 0, 0
    parent = np.zeros(N + 1, np.int64)
    depth = np.zeros(N + 1, np.int64)
    que[r], r = root, r + 1
    depth[root] = 1
    for _ in range(N):
        v, l = que[l], l + 1
        for w in G[idx[v]:idx[v + 1], 1]:
            if parent[v] == w:
                continue
            parent[w] = v
            depth[w] = depth[v] + 1
            que[r], r = w, r + 1
    order = que
    return parent, order, depth


@njit((i8, i8, i8[:, :], i8[:, :]), cache=True)
def main(N, Q, G, CD):
    parent, order, depth = tree_bfs(N, G)
    for q in range(Q):
        c, d = CD[q]
        if (depth[c] + depth[d]) % 2 == 0:
            print('Town')
        else:
            print('Road')


N, Q = from_readline()
nums = from_read().reshape(N + Q - 1, 2)
G = to_undirected(nums[:N - 1])
CD = nums[N - 1:]

main(N, Q, G, CD)
from heapq import heappop, heappush

N, Q = map(int, input().split())
graph = [[] for i in range(N)]
for i in range(N - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)
color = [-1] * N
color[0] = 0
q = [0]
while q:
    now = heappop(q)
    for to in graph[now]:
        if color[to] == -1:
            color[to] = 1 - color[now]
            heappush(q, to)
#print(color)
for i in range(Q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")
#!/usr/bin/env python3.8
import sys
import math
from itertools import accumulate  #累積和list(accumulate(A))
from itertools import permutations
import bisect  #二分探索　bisect.bisect(A,5)
from copy import deepcopy
# import numpy as np
from collections import deque
from collections import defaultdict
from collections import Counter
from fractions import Fraction
from decimal import Decimal
from heapq import heappush, heappop

import cmath  #cmath.rect

sys.setrecursionlimit(500 * 500)

# print(' '.join(map(str, E)))


def IN():
    return int(input())


def MAP():
    return map(int, input().split())


def LIST():
    return list(map(int, input().split()))


def LINE(N):
    return [list(map(int, input().split())) for _ in range(N)]


def KOSI(N):
    return [input().split() for _ in range(N)]


def Gy(gy_x, gy_mod):
    return pow(gy_x, gy_mod - 2, gy_mod)


def p_yes(judge):
    print("Yes" if judge else "No")


# MOD = 998244353
MOD = 10**9 + 7
MOD2 = 998244353

INF = 10**30 + 7
# ==================== #


def comb(n, k):
    return math.factorial(n) // (math.factorial(n - k) * math.factorial(k))


def su(x, check):
    global ans
    if check[x] == 1:
        return 0
    check[x] = 1
    ans += 1
    for lx in L[x]:
        su(lx, check)
    return 0


def root(h, w):
    if uni[h][w] == [h, w]:
        return [h, w]
    else:
        uni[h][w] = root(uni[h][w][0], uni[h][w][1])
        return uni[h][w]


def U(h, w):
    ch = [[-1, 0], [1, 0], [0, 1], [0, -1]]
    cnt = 0
    for c in ch:
        nh = h + c[0]
        nw = w + c[1]
        if 0 <= nh < H and 0 <= nw < W and ca[nh][nw] == 1:
            if cnt == 0:
                uni[h][w] = root(nh, nw)
            else:
                uni[uni[h][w][0]][uni[h][w][1]] = root(nh, nw)
                uni[h][w] = root(nh, nw)
            cnt += 1
    if cnt == 0:
        uni[h][w] = [h, w]


def dijkstra(s, n):  # (始点, ノード数)
    dist = [INF] * n
    hq = [(0, s)]  # (distance, node)
    dist[s] = 0
    seen = [False] * n  # ノードが確定済みかどうか
    while hq:
        now = heappop(hq)[1]  # ノードを pop する
        seen[now] = True
        for to, cost in v[now]:  # ノード now に隣接しているノードに対して
            if seen[to] == False and dist[now] + cost < dist[to]:
                dist[to] = dist[now] + cost
                heappush(hq, (dist[to], to))
    return dist


# ==================== #
N, Q = MAP()
v = [[] for _ in range(N)]
for i in range(N - 1):
    a, b = MAP()
    a -= 1
    b -= 1
    v[a].append([b, 1])
    v[b].append([a, 1])
D = dijkstra(0, N)
ans = []
for i in range(Q):
    c, d = MAP()
    c -= 1
    d -= 1
    if (D[c] - D[d]) % 2 == 0:
        ans.append("Town")
    else:
        ans.append("Road")
for A in ans:
    print(A)
n, q = map(int, input().split())

graph = [[] for _ in range(n)]
for i in range(n - 1):
    a, b = map(int, input().split())
    graph[a - 1].append(b - 1)
    graph[b - 1].append(a - 1)

#0 or 1
color = [-1 for _ in range(n)]
color[0] = 0

#bfs
from collections import deque

queue = deque()
queue.append(0)
while queue:
    v = queue.popleft()
    for nei in graph[v]:
        if color[nei] == -1:
            color[nei] = 1 - color[v]
            queue.append(nei)

for _ in range(q):
    c, d = map(int, input().split())
    if color[c - 1] == color[d - 1]:
        print("Town")
    else:
        print("Road")

